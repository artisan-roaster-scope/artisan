#

# ABOUT
# This program shows how to plot the temperature and its rate of change from a
# Fuji PID or a thermocouple meter.

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later version. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import time as libtime
startup_time = libtime.process_time()

from artisanlib import __version__
from artisanlib import __revision__
from artisanlib import __build__

from artisanlib import __release_sponsor_name__
from artisanlib import __release_sponsor_domain__
from artisanlib import __release_sponsor_url__

## Profiling: use @profile annotations
#import cProfile
#import io
#import pstats
#def profile(func):
#    def wrapper(*args, **kwargs):
#        pr = cProfile.Profile()
#        pr.enable()
#        retval = func(*args, **kwargs)
#        pr.disable()
#        s = io.StringIO()
#        sortby = pstats.SortKey.CUMULATIVE  # 'cumulative'
#        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
#        ps.print_stats()
#        print(s.getvalue())
#        return retval
#    return wrapper

import os
import sys  # @UnusedImport
import ast
import platform
import math
import datetime
import warnings
import numpy
import threading
import multiprocessing
import re
import gc
import io
import functools
import dateutil.parser
from bisect import bisect_right

# links CTR-C signals to the system default (ignore)
import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

import logging.config
from yaml import safe_load as yaml_load
from typing import Optional, List  #for Python >= 3.9: can remove 'List' since type hints can now use the generic 'list'
try:
    from typing import Final
except ImportError:
    # for Python 3.7:
    from typing_extensions import Final

from functools import reduce as freduce

## MONKEY PATCH BEGIN: importlib.metadata fix for macOS builds with py2app that fails to set proper metadata for prettytable >0.7.2 and thus fail
## on import with importlib.metadata.PackageNotFoundError: prettytable on __version__ = importlib_metadata.version(__name__)
try:
    import importlib.metadata as importlib_metadata # @UnresolvedImport
    def md_version(pkg_name):
        if pkg_name == 'prettytable':
            return '2.1.0'
        return importlib_metadata.version(pkg_name)
    importlib_metadata.version = md_version
except Exception: # pylint: disable=broad-except
    pass
## MONKEY PATCH END:

try: # activate support for hiDPI screens on Windows
    if str(platform.system()).startswith('Windows'):
        os.environ['QT_AUTO_SCREEN_SCALE_FACTOR'] = '1'
        os.environ['QT_ENABLE_HIGHDPI_SCALING'] = '1'
except Exception: # pylint: disable=broad-except
    pass

# write logtrace to Console on OS X:
#try:
#..
#except Exception as e: # pylint: disable=broad-except
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))

QtWebEngineSupport = False # set to True if the QtWebEngine was successfully imported

try:
    #pylint: disable-next = E, W, R, C
    from PyQt6.QtWidgets import (QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog, QGraphicsDropShadowEffect, # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error
                             QInputDialog, QGroupBox, QLineEdit, # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, QVBoxLayout, QHBoxLayout, QPushButton, # @Reimport @UnresolvedImport @UnusedImport
                             QLCDNumber, QSpinBox, QComboBox, # @Reimport @UnresolvedImport @UnusedImport
                             QAbstractSlider, QSlider, # @Reimport @UnresolvedImport @UnusedImport
                             QColorDialog, QFrame, QSplitter, QScrollArea, QProgressDialog, # @Reimport @UnresolvedImport @UnusedImport
                             QStyleFactory, QMenu, QLayout) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtGui import (QPageLayout, QAction, QImage, QImageReader, QWindow, # @Reimport @UnresolvedImport @UnusedImport
                                QKeySequence, # @Reimport @UnresolvedImport @UnusedImport
                                QPixmap,QColor,QDesktopServices,QIcon, # @Reimport @UnresolvedImport @UnusedImport
                                QRegularExpressionValidator,QDoubleValidator, QPainter, QCursor, QFont) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtPrintSupport import (QPrinter,QPrintDialog) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtCore import (QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, pyqtSignal, pyqtSlot, pyqtProperty, QSize, # @Reimport @UnresolvedImport @UnusedImport
                              qVersion, QTime, QTimer, QFile, QIODevice, QTextStream, QSettings, # @Reimport @UnresolvedImport @UnusedImport
                              QRegularExpression, QDate, QUrl, QUrlQuery, QDir, Qt, QEvent, QDateTime, QObject, QThread, QSemaphore, qInstallMessageHandler) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtNetwork import QLocalSocket # @Reimport @UnresolvedImport @UnusedImport
    #QtWebEngineWidgets must be imported before a QCoreApplication instance is created
    try:
        from PyQt6.QtWebEngineWidgets import QWebEngineView # @Reimport @UnresolvedImport @UnusedImport  # pylint: disable=import-error,no-name-in-module
        QtWebEngineSupport = True
    except Exception: # pylint: disable=broad-except
        # on the RPi platform there is no native package PyQt-WebEngine nor PyQt6-WebEngine for Raspebarry 32bit
        pass
    from PyQt6 import sip # @Reimport @UnresolvedImport @UnusedImport
except Exception:
    #pylint: disable = E, W, R, C
    from PyQt5.QtWidgets import (QAction, QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog, QGraphicsDropShadowEffect,  # @Reimport @UnresolvedImport @UnusedImport
                             QInputDialog, QGroupBox, QLineEdit, # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, QVBoxLayout, QHBoxLayout, QPushButton, # @Reimport @UnresolvedImport @UnusedImport
                             QLCDNumber, QSpinBox, QComboBox, # @Reimport @UnresolvedImport @UnusedImport
                             QAbstractSlider, QSlider, QStackedWidget, # @Reimport @UnresolvedImport @UnusedImport
                             QColorDialog, QFrame, QSplitter, QScrollArea, QProgressDialog, # @Reimport @UnresolvedImport @UnusedImport
                             QStyleFactory, QMenu, QLayout) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtGui import (QPageLayout, QImage, QImageReader, QWindow,  # @Reimport @UnresolvedImport @UnusedImport
                                QKeySequence, # @Reimport @UnresolvedImport @UnusedImport
                                QPixmap,QColor,QDesktopServices,QIcon, # @Reimport @UnresolvedImport @UnusedImport
                                QRegularExpressionValidator,QDoubleValidator, QPainter, QCursor, QFont) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtPrintSupport import (QPrinter,QPrintDialog) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtCore import (QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, pyqtSignal, pyqtSlot, pyqtProperty, QSize, # @Reimport @UnresolvedImport @UnusedImport
                              qVersion, QTime, QTimer, QFile, QIODevice, QTextStream, QSettings,  # @Reimport @UnresolvedImport @UnusedImport
                              QRegularExpression, QDate, QUrl, QUrlQuery, QDir, Qt, QPoint, QEvent, QDateTime, QObject, QThread, QSemaphore, qInstallMessageHandler) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtNetwork import QLocalSocket # @Reimport @UnresolvedImport @UnusedImport
    #QtWebEngineWidgets must be imported before a QCoreApplication instance is created
    try:
        from PyQt5.QtWebEngineWidgets import QWebEngineView # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error,no-name-in-module
        QtWebEngineSupport = True
    except Exception: # pylint: disable=broad-except
        # on the RPi platform there is no native package PyQt-WebEngine nor PyQt6-WebEngine for Raspebarry 32bit
        pass
    try:
        from PyQt5 import sip # @Reimport @UnresolvedImport @UnusedImport
    except Exception: # pylint: disable=broad-except
        import sip # @Reimport @UnresolvedImport @UnusedImport



from artisanlib.suppress_errors import suppress_stdout_stderr

with suppress_stdout_stderr():
    import matplotlib as mpl
    from matplotlib import cm
    import matplotlib.colors as mcolors
try:
    mpl_version = [int(i) for i in mpl.__version__.split('.')]
except Exception: # pylint: disable=broad-except
    mpl_version = [7,7,7] # a trunk version

if mpl_version[0] > 2 and mpl_version[1] > 2:
    if mpl_version[1] > 3:
        from matplotlib.backends.qt_compat import _devicePixelRatioF, _setDevicePixelRatio # @UnresolvedImport @UnusedImport
    else:
        from matplotlib.backends.qt_compat import _devicePixelRatioF, _setDevicePixelRatioF # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error,no-name-in-module
    from matplotlib.backend_bases import _Mode as MPL_Mode  # @UnresolvedImport


# on OS X / PyQt5 one needs to
#   export DYLD_FRAMEWORK_PATH=~/Qt5.5.0/5.5/clang_64/lib/
# (see Mac OS X specific notes in the PyQt5 documentation)
#print(QImageReader.supportedImageFormats())
#print(QLibraryInfo.path(QLibraryInfo.LibraryLocation.PluginsPath))

svgsupport = next((x for x in QImageReader.supportedImageFormats() if x == b'svg'),None)

mpl.use('Qt5Agg')

from matplotlib.figure import Figure
from matplotlib import rcParams, patches, transforms, ticker
import matplotlib.patheffects as PathEffects

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas  # @Reimport
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar # @Reimport
from matplotlib.backend_bases import LocationEvent as mplLocationevent

from matplotlib.backends.qt_editor import figureoptions
import matplotlib.backends.qt_editor._formlayout as formlayout

from matplotlib.patches import Polygon
from matplotlib.transforms import Bbox


# fix socket.inet_pton on Windows (used by pymodbus TCP/UDP)
try:
    if str(platform.system()).startswith('Windows'):
        import win_inet_pton # @UnresolvedImport @UnusedImport # pylint: disable=import-error,unused-import
except Exception: # pylint: disable=broad-except
    pass



import artisanlib.arabic_reshaper
from artisanlib.util import (appFrozen, stringp, uchr, decodeLocal, encodeLocal, s2a, fill_gaps,
        deltaLabelPrefix, deltaLabelUTF8, deltaLabelBigPrefix, deltaLabelMathPrefix, stringfromseconds, stringtoseconds,
        fromFtoC, fromCtoF, RoRfromFtoC, RoRfromCtoF, convertRoR, convertTemp, path2url, toInt, toString, toList, toFloat,
        toBool, toStringList, toMap, removeAll, application_name, application_viewer_name, application_organization_name,
        application_organization_domain, getDataDirectory, getAppPath, getResourcePath, getDirectory, debugLogLevelToggle,
        debugLogLevelActive, setDebugLogLevel, abbrevString, createGradient, natsort, toGrey, toDim, setDeviceDebugLogLevel)

from artisanlib.qtsingleapplication import QtSingleApplication
from artisanlib.filters import LiveMedian


from Phidget22.VoltageRange import VoltageRange

try:
    # spanning a second multiprocessing instance (Hottop server) on macOS falils to import the YAPI interface
    from yoctopuce.yocto_api import YAPI
except Exception: # pylint: disable=broad-except
    pass

platf = str(platform.system())


#######################################################################################
#################### Main Application  ################################################
#######################################################################################

appGuid = '9068bd2fa8e54945a6be1f1a0a589e92'
viewerAppGuid = '9068bd2fa8e54945a6be1f1a0a589e93'

class Artisan(QtSingleApplication):
    def __init__(self, args):
        super().__init__(appGuid,viewerAppGuid,args)

        self.sentToBackground = None # set to timestamp on putting app to background without any open dialog
        self.plus_sync_cache_expiration = 1*60 # how long a plus sync is valid in seconds

        if multiprocessing.current_process().name == 'MainProcess' and self.isRunning():
            self.artisanviewerMode = True
            if self.isRunningViewer(): sys.exit(0) # there is already one ArtisanViewer running, we terminate
        else:
            self.artisanviewerMode = False
        self.messageReceived.connect(self.receiveMessage)
        self.focusChanged.connect(self.appRaised)

    @pyqtSlot('QWidget*','QWidget*')
    def appRaised(self,oldFocusWidget,newFocusWidget):
        try:
            if aw is not None and not sip.isdeleted(aw): # sip not supported on older PyQt versions (eg. RPi)
                if oldFocusWidget is None and newFocusWidget is not None and aw is not None and aw.centralWidget() == newFocusWidget and self.sentToBackground is not None:
                    #focus gained
                    try:
                        if aw.plus_account is not None and aw.qmc.roastUUID is not None and aw.curFile is not None and \
                                libtime.time() - self.sentToBackground > self.plus_sync_cache_expiration:
                            plus.sync.getUpdate(aw.qmc.roastUUID,aw.curFile)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    self.sentToBackground = None

                elif oldFocusWidget is not None and newFocusWidget is None and aw is not None and aw.centralWidget() == oldFocusWidget:
                    # focus released
                    self.sentToBackground = libtime.time() # keep the timestamp on sending the app with the main window to background
                else: # on raising another dialog/widget was open, reset timer
                    self.sentToBackground = None
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # takes a QUrl and interprets it as follows
    # artisan://roast/<UUID>         : loads profile from path associated with the given roast <UUID>
    # artisan://template/<UUID>      : loads background profile from path associated with the given roast <UUID>
    # artisan://profile?url=<url>    : loads proflie from given URL
    # file://<path>                  : loads file from path
    #                                  if query is "background" Artisan is not raised to the foreground
    #                                  if query is "template" and the file has an .alog extension, the profile is loaded as background profile
    def open_url(self, url):
        _log.debug('open_url(%s)', url)
        if not aw.qmc.flagon and not aw.qmc.designerflag and not aw.qmc.wheelflag and aw.qmc.flavorchart_plot is None: # only if not yet monitoring
            if url.scheme() == 'artisan' and url.authority() in ['roast','template']:
                # we try to resolve this one into a file URL and recurse
                roast_UUID = url.toString(QUrl.UrlFormattingOption.RemoveScheme | QUrl.UrlFormattingOption.RemoveAuthority | QUrl.UrlFormattingOption.RemoveQuery | QUrl.UrlFormattingOption.RemoveFragment | QUrl.UrlFormattingOption.StripTrailingSlash)[1:]
                if aw.qmc.roastUUID is None or aw.qmc.roastUUID != roast_UUID:
                    # not yet open, lets try to find the path to that roastUUID and open it
                    profile_path = plus.register.getPath(roast_UUID)
                    if profile_path:
                        aw.sendmessage(QApplication.translate('Message','URL open profile: {0}').format(profile_path))
                        file_url = QUrl.fromLocalFile(profile_path)
                        if url.authority() == 'template':
                            file_url.setQuery('template')
                        self.open_url(file_url)
            elif url.scheme() == 'artisan' and url.authority() == 'profile' and url.hasQuery():
                try:
                    query = QUrlQuery(url.query())
                    if query.hasQueryItem('url'):
                        import requests
                        query_url = QUrl(requests.utils.unquote(query.queryItemValue('url')))
                        if bool(aw.comparator):
                            QTimer.singleShot(5,lambda: aw.comparator.addProfileFromURL(aw.artisanURLextractor,query_url))
                        else:
                            QTimer.singleShot(5,lambda: aw.importExternalURL(aw.artisanURLextractor,url=query_url))
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            elif url.scheme() == 'file':
                aw.sendmessage(QApplication.translate('Message','URL open profile: {0}').format(url.toDisplayString()))
                url_query = None
                if url.hasQuery():
                    url_query = url.query()
                if url_query is None or url_query != 'background':
                    # by default we raise Artisan to the foreground
                    QTimer.singleShot(20,self.activateWindow)
                url.setQuery(None) # remove any query to get a valid file path
                url.setFragment(None) # remove also any potential fragment
                filename = url.toString(QUrl.UrlFormattingOption.PreferLocalFile)
                qfile = QFileInfo(filename)
                file_suffix = qfile.suffix()
                if file_suffix == 'alog':
                    if bool(aw.comparator):
                        # add Artisan profile to the comparator selection
                        QTimer.singleShot(20,lambda : aw.comparator.addProfiles([filename]))
                    else:
                        # load Artisan profile on double-click on *.alog file
                        if url_query is not None and url_query == 'template':
                            aw.loadBackgroundSignal.emit(filename)
                        else:
                            QTimer.singleShot(20,lambda : aw.loadFile(filename))
                elif file_suffix == 'alrm':
                    # load Artisan alarms on double-click on *.alrm file
                    QTimer.singleShot(20,lambda : aw.loadAlarms(filename))
                elif file_suffix == 'apal':
                    # load Artisan palettes on double-click on *.apal file
                    QTimer.singleShot(20,lambda : aw.getPalettes(filename,aw.buttonpalette))

        elif platf == 'Windows' and not self.artisanviewerMode:
            msg = url.toString()  #here we don't want a local file, preserve the windows file:///
            self.sendMessage2ArtisanInstance(msg,self._viewer_id)

    @pyqtSlot(str)
    def receiveMessage(self,msg):
        url = QUrl()
        url.setUrl(msg)
        self.open_url(url)

    # to send message to main Artisan instance: id = appGuid
    # to send message to viewer:                id = viewerAppGuid
    def sendMessage2ArtisanInstance(self,message,instance_id):
        if platf == 'Windows':
            try:
                if instance_id == self._viewer_id:
                    res = self._sendMessage2ArtisanInstance(message,self._viewer_id)
                elif instance_id == self._id:
                    res = self._sendMessage2ArtisanInstance(message,self._id)
                if not res:
                    # get the path of the artisan.exe file
                    if getattr(sys, 'frozen', False):
                        application_path = getattr(sys, '_MEIPASS', os.path.dirname(sys.executable))
                        application_path += '\\artisan.exe'
                    # or the artisan py file if running from source
                    else:
                        application_path = sys.argv[0]
                    application_path = re.sub(r'\\',r'/',application_path)
                    # must start viewer without an argv else it thinks it was started from a link and sends back to artisan
                    os.startfile(application_path)  # @UndefinedVariable # pylint: disable=maybe-no-member
                    QTimer.singleShot(3000,lambda : self._sendMessage2ArtisanInstance(message,instance_id))
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        else:
            self._sendMessage2ArtisanInstance(message,instance_id)

    def _sendMessage2ArtisanInstance(self,message,instance_id):
        try:
            self._outSocket = QLocalSocket()
            self._outSocket.connectToServer(instance_id)
            self._isRunning = self._outSocket.waitForConnected(-1)
            if self.isRunning():
                self._outStream = QTextStream(self._outSocket)
#                self._outStream.setCodec('UTF-8')
                return self.sendMessage(message)
            return False
        except Exception as e:
            _log.exception(e)
            return False
        finally:
            self._outSocket = None
            self._outStream = None

    def event(self, event):
        file_open = QEvent.Type.FileOpen
        if event.type() == file_open:
            try:
                url = event.url()
                # files cannot be opend while
                # - sampling
                # - in Designer mode
                # - in Wheel graph mode
                # - while editing the cup profile
                can_open_mode = not aw.qmc.flagon and not aw.qmc.designerflag and not aw.qmc.wheelflag and aw.qmc.flavorchart_plot is None
                if can_open_mode and bool(aw.comparator):
                    # while in comparator mode with the events file already open we rather send it to another instance
                    filename = url.toString(QUrl.UrlFormattingOption.PreferLocalFile)
                    can_open_mode = not any(p.filepath == filename for p in aw.comparator.profiles)
                if can_open_mode:
                    self.open_url(url)
                else:
                    message = url.toString()
                    # we send open file in the other instance if running
                    if self.artisanviewerMode:
                        # this is the Viewer, but we cannot open the file, send an open request to the main app if it is running
                        self.sendMessage2ArtisanInstance(message,self._id)
                    else:
                        # try to open the file in Viewer if it is running
                        self.sendMessage2ArtisanInstance(message,self._viewer_id)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            return 1
        return super().event(event)

# configure multiprocessing
if sys.platform.startswith('darwin'):
    try:
        # start method can only be set once!
        if False and 'forkserver' in multiprocessing.get_all_start_methods(): # pylint: disable=condition-evals-to-constant
            # signed app with forkserver option fails with a MemoryError
            multiprocessing.set_start_method('forkserver') # only available on Python3 on Unix, currently (Python 3.8) not supported by frozen executables generated with pyinstaller
        elif 'fork' in multiprocessing.get_all_start_methods():
            multiprocessing.set_start_method('fork') # default on Python3.7 for macOS (and on Unix also under Python3.8), but considered unsafe,
            # not available on Windows, on Python3.8 we have to explicitly set this
            # https://bugs.python.org/issue33725
            # this is the only option that works (Hottop communication & WebLCDs) in signed macOS apps
#        if "spawn" in multiprocessing.get_all_start_methods():
#            multiprocessing.set_start_method('spawn') # default on Python3.8 for macOS (always default on Windows)
#            # this breaks on starting WebLCDs in macOS (and linux) builds with py2app, pyinstaller
#            # https://bugs.python.org/issue32146
#            # https://github.com/pyinstaller/pyinstaller/issues/4865
    except Exception: # pylint: disable=broad-except
        pass

app_args = sys.argv
if sys.platform.startswith('linux'):
    # avoid a GTK bug in Ubuntu Unity
    app_args = app_args + ['-style','Fusion']
#if platf == 'Windows':
#    # highDPI support must be set before creating the Application instance
#    try:
#        # activate scaling for hiDPI screen support on Windows
#        QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)
#        QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
#    except Exception as e: # pylint: disable=broad-except
#        pass
app = Artisan(app_args)

# On the first run if there are legacy settings under "YourQuest" but no new settings under "artisan-scope" then the legacy settings
# will be copied to the new settings location. Once settings exist under "artisan-scope" the legacy settings under "YourQuest" will
# no longer be read or saved.  At start-up, versions of Artisan before to v2.0 will no longer share settings with versions v2.0 and after.
# Settings can be shared among all versions of Artisan by explicitly saving and loading them using Help>Save/Load Settings.
try:
    app.setApplicationName(application_name)                                #needed by QSettings() to store windows geometry in operating system

    app.setOrganizationName('YourQuest')                                    #needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain('p.code.google.com')                          #needed by QSettings() to store windows geometry in operating system
    legacysettings = QSettings()
    app.setOrganizationName(application_organization_name)                  #needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain(application_organization_domain)              #needed by QSettings() to store windows geometry in operating system
    newsettings = QSettings()

    settingsRelocated = False
    # copy settings from legacy to new if newsettings do not exist, legacysettings do exist, and were not previously copied
    if not newsettings.contains('Mode') and legacysettings.contains('Mode') and not legacysettings.value('_settingsCopied') == 1:
        settingsRelocated = True
        # copy Artisan settings
        for key in legacysettings.allKeys():
            newsettings.setValue(key,legacysettings.value(key))
        legacysettings.setValue('_settingsCopied', 1)  # prevents copying again in the future, this key not cleared by a Factory Reset

        # copy ArtisanViewer settings
        app.setApplicationName(application_viewer_name)                         #needed by QSettings() to store windows geometry in operating system

        app.setOrganizationName('YourQuest')                                    #needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain('p.code.google.com')                          #needed by QSettings() to store windows geometry in operating system
        legacysettings = QSettings()
        app.setOrganizationName(application_organization_name)                  #needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain(application_organization_domain)              #needed by QSettings() to store windows geometry in operating system
        newsettings = QSettings()
        for key in legacysettings.allKeys():
            newsettings.setValue(key,legacysettings.value(key))
    del legacysettings   #free up memory?
    del newsettings      #free up memory?
except Exception: # pylint: disable=broad-except
    pass

app.setApplicationName(application_name)                                #needed by QSettings() to store windows geometry in operating system
app.setOrganizationName(application_organization_name)                  #needed by QSettings() to store windows geometry in operating system
app.setOrganizationDomain(application_organization_domain)              #needed by QSettings() to store windows geometry in operating system

# replace revision string with git hash when running from source
if not appFrozen() and __revision__ == '0':
    try:
        from subprocess import run as subprocessrun
        uncommittedChanges = subprocessrun(['git','status', '--porcelain=v1'], capture_output=True, check=True).stdout  #number of uncommitted changes
        if len(uncommittedChanges) > 0:
            uc = '+'
        else:
            uc = ''
        git_hash = subprocessrun(['git', 'rev-parse', 'HEAD'], capture_output=True, check=True).stdout.decode('ascii').strip()[:7]  #git hash
        __revision__ = f'{git_hash}{uc}'
    except Exception: # pylint: disable=broad-except
        pass

# configure logging
try:
    with open(os.path.join(getResourcePath(),'logging.yaml'), encoding='utf-8') as logging_conf:
        conf = yaml_load(logging_conf)
        try:
            # set log file to Artisan data directory
            if app.artisanviewerMode:
                conf['handlers']['file']['filename'] = os.path.join(getDataDirectory(),'artisanViewer.log')
            else:
                conf['handlers']['file']['filename'] = os.path.join(getDataDirectory(),'artisan.log')
        except Exception: # pylint: disable=broad-except
            pass
        logging.config.dictConfig(conf)
except Exception: # pylint: disable=broad-except
    pass

_log: Final = logging.getLogger(__name__)
_log.info(
    '%s v%s (%s, %s)',
    ('ArtisanViewer' if app.artisanviewerMode else 'Artisan'),
    str(__version__),
    str(__revision__),
    str(__build__),
)


if platf == 'Windows':
    app.setWindowIcon(QIcon(os.path.join(getAppPath(),'artisan.png')))
#    try:
#        # activate scaling for hiDPI screen support on Windows
#        app.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)
#        if hasattr(QStyleFactory, 'AA_UseHighDpiPixmaps'):
#            app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
#    except Exception as e: # pylint: disable=broad-except
#        pass

# platform dependent imports:
if sys.platform.startswith('darwin'):
    # control app napping on OS X >= 10.9
    import appnope  # @UnresolvedImport # pylint: disable=import-error
    # import module to detect if OS X dark mode is active or not
    import darkdetect # @UnresolvedImport # pylint: disable=import-error

#def __dependencies_for_freezing():
#    # pylint: disable=import-error,no-name-in-module,unused-import
#    from scipy.sparse.csgraph import _validation # @UnresolvedImport @UnusedImport
#    from scipy.special import _ufuncs_cxx # @UnresolvedImport @UnusedImport
#    from scipy import integrate # @UnresolvedImport @UnusedImport
#    from scipy import interpolate # @UnresolvedImport @UnusedImport
##    from scipy.optimize import curve_fit # @UnresolvedImport @UnusedImport
#    # to make bbfreeze on Linux and py2exe on Win/Py3 happy with scipy > 0.17.0
#    import scipy.linalg.cython_blas # @UnresolvedImport @UnusedImport
#    import scipy.linalg.cython_lapack # @UnresolvedImport @UnusedImport
#    import scipy.special.cython_special # @UnresolvedImport @UnusedImport
#
#    import appdirs # @UnresolvedImport @UnusedImport
#    import packaging # @UnresolvedImport @UnusedImport
#    import packaging.version # @UnresolvedImport @UnusedImport
#    import packaging.specifiers # @UnresolvedImport @UnusedImport
#    import packaging.markers # @UnresolvedImport @UnusedImport
#    import packaging.requirements # @UnresolvedImport @UnusedImport
#
#    import PyQt5.QtSvg  # @UnusedImport
#    import PyQt5.QtXml  # @UnusedImport
#    import PyQt5.QtDBus # needed for QT5 builds  # @UnusedImport
#    import PyQt5.QtPrintSupport # needed for by platform plugin libqcocoa  # @UnusedImport
#
#    # for gevent bundling
#    from gevent import signal as gevent_signal, core, resolver_thread, resolver_ares, socket, threadpool, thread, threading as gevent_threading, select, subprocess as gevent_subprocess, pywsgi, server, hub # @UnusedImport @Reimport
#
#del __dependencies_for_freezing

from artisanlib.s7port import s7port
from artisanlib.wsport import wsport
from artisanlib.modbusport import modbusport
from artisanlib.phidgets import PhidgetManager
from artisanlib.slider_style import artisan_slider_style
from artisanlib.event_button_style import artisan_event_button_style
from artisanlib.simulator import Simulator
from artisanlib.dialogs import ArtisanMessageBox, HelpDlg, ArtisanInputDialog, ArtisanComboBoxDialog
from artisanlib.large_lcds import (LargeMainLCDs, LargeDeltaLCDs, LargePIDLCDs, LargeExtraLCDs, LargePhasesLCDs, LargeScaleLCDs)
from artisanlib.logs import (serialLogDlg, errorDlg, messageDlg)
from artisanlib.comm import serialport, colorport, scaleport
from artisanlib.pid_dialogs import (PXRpidDlgControl, PXG4pidDlgControl,
    PID_DlgControl, DTApidDlgControl)
from artisanlib.pid_control import FujiPID, PIDcontrol, DtaPID
from artisanlib.widgets import (MyQLCDNumber, MajorEventPushButton,
    AnimatedMajorEventPushButton, MinorEventPushButton, AuxEventPushButton, ClickableLCDFrame)

from artisanlib import pid
from artisanlib.time import ArtisanTime
from artisanlib.notifications import Notification, NotificationManager, NotificationType


# import artisan.plus module
import plus.config
import plus.util
import plus.sync
import plus.queue
import plus.controller
import plus.register
import plus.notifications
import plus.blend

#######################################################################################
#################### Ambient Data Collection  #########################################
#######################################################################################

class AmbientWorker(QObject): # pylint: disable=too-few-public-methods
    finished = pyqtSignal()

    def run(self):
        libtime.sleep(2.5) # wait a moment after ON until all other devices are attached
        try:
            aw.qmc.getAmbientData()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        finally:
            self.finished.emit()

#######################################################################################
#################### GRAPH DRAWING WINDOW  ############################################
#######################################################################################

class tphasescanvas(FigureCanvas):

    __slots__ = [ 'dpi_offset', 'barheight', 'm', 'g', 'data', 'fig', 'ax' ]

    def __init__(self, dpi):
        self.dpi_offset = -30 # set the dpi to 30% less than the user selected dpi
        # values that define the bars and spacing
        self.barheight =  0.88  # height of each bar within the norm row height of 1
        self.m = 10             # width of batch number field and drop time field
        self.g = 2              # width of the gap between batch number field and drop time field and the actual phase percentage bars
        # set data
        self.data = None  # the phases data per profile
        # the canvas
        self.fig = Figure(figsize=(1, 1), frameon=False, dpi=dpi+self.dpi_offset)
#        self.fig.set_constrained_layout(True)
        # as alternative to the experimental constrained_layout we could use tight_layout as for them main canvas:
        self.tight_layout_params: Final = {'pad':.3,'h_pad':0.0,'w_pad':0.0} # slightly less space for axis labels
        self.fig.set_tight_layout(self.tight_layout_params)
        #
        super().__init__(self.fig)
        self.ax = None
        self.clear_phases()

    def clear_phases(self):
        if self.ax is None:
            self.ax = self.fig.add_subplot(111, frameon=False)
        self.ax.clear()
        self.ax.axis('off')
        self.ax.grid(False)
        self.ax.set_xlim(0,100 + 2*self.m + 2*self.g)

    def setdpi(self,dpi,moveWindow=True):
        if aw and self.fig:
            dpi = (dpi + self.dpi_offset) * aw.devicePixelRatio()
            self.fig.set_dpi(dpi)
            if moveWindow:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()
                    self.fig.canvas.update()
                FigureCanvas.updateGeometry(self)  #@UndefinedVariable
            aw.scroll.setMaximumHeight(self.sizeHint().height())

    # data is expected to be a None or a list of tuples of the form
    #   (label, total_time, (phase1_time, phase2_time, phase3_time), active, color)
    # each time value in the tripple is in seconds and can be 0 if corresponding phase is missing
    # active is of type bool indicating the state of the corresponding profile
    # aligned is of type bool indicating that the profile is aligned to the current selected alignment target
    # color is a regular color string like '#00b950'
    def set_phases(self, data):
        self.data = data

    # updates the phases graphs data and redraws its canvas
    # side condition: only profile data of visible profiles are contained in data
    def update_phases(self, data):
        self.set_phases(data)
        self.redraw_phases()

    def redraw_phases(self):
        if aw is None:
            return
        # clear canvas
        self.clear_phases()
        if self.data and len(self.data):
            aw.scroll.setVisible(True)
            # set canvas background color
            background_color = aw.qmc.palette['background']
            self.setStyleSheet(f'background-color: {background_color}')
            # maximum total roast time of all given profiles
            max_total_time = max(p[1] for p in self.data)
            # set font
            if aw:
                prop = aw.mpl_fontproperties
            else:
                prop = mpl.font_manager.FontProperties().copy()
            prop.set_family(mpl.rcParams['font.family'])
            prop.set_size('medium')

            digits = (1 if aw.qmc.LCDdecimalplaces else 0)
            # dimmed phases bar colors
            rect1dim = toDim(aw.qmc.palette['rect1'])
            rect2dim = toDim(aw.qmc.palette['rect2'])
            rect3dim = toDim(aw.qmc.palette['rect3'])
            # i counts the number of rows drawn to get the geometry right
            i = 0
            # add bars
            for p in self.data:
                label, total_time, phases_times, active, aligned, color = p
                if not (active and aligned):
                    color = toGrey(color)
                rects = None
                if all(phases_times):
                    # all phases defined
                    if int(round(total_time)) == int(round(sum(phases_times))):
                        phases_percentages = [(phase_time/total_time) * 100. for phase_time in phases_times]
                        extended_phases_percentages = [self.m,self.g] + phases_percentages + [self.g,self.m*total_time/max_total_time]
                        widths = numpy.array(extended_phases_percentages)
                        starts = widths.cumsum() - widths
                        if active:
                            labels = [f"{str(round(percent,digits)).rstrip('0').rstrip('.')}%  {stringfromseconds(tx,leadingzero=False)}" if percent>20 else (f"{str(round(percent,digits)).rstrip('0').rstrip('.')}%" if percent>10 else '')
                                    for (percent,tx) in zip(phases_percentages, phases_times)]
                        else:
                            labels = ['']*3
                        labels = [label, ''] + labels + ['', stringfromseconds(total_time,leadingzero=False)]
                        # draw the bars
                        if active:
                            patch_colors = color, background_color, aw.qmc.palette['rect1'], aw.qmc.palette['rect2'], aw.qmc.palette['rect3'], background_color, color
                        else:
                            patch_colors = color, background_color, rect1dim, rect2dim, rect3dim, background_color, color
                        rects = self.ax.barh(i, widths, left=starts, height=self.barheight, color=patch_colors)
                    else:
                        _log.error('redraw_phases(): inconsistent phases data in %s (total: %s, sum(phases): %s)', label, total_time, sum(phases_times))
                    # else something is inconsistent in this data and we skip this entry
                elif phases_times[0] and not phases_times[1] and not phases_times[2]:
                    # only Drying Phase is defined
                    phase1_percentage = (phases_times[0]/total_time) * 100.
                    phases_percentages = [phase1_percentage, 100-phase1_percentage]
                    extended_phases_percentages = [self.m,self.g] + phases_percentages + [self.g,self.m*total_time/max_total_time]
                    widths = numpy.array(extended_phases_percentages)
                    starts = widths.cumsum() - widths
                    if active:
                        label1 = f"{str(round(phase1_percentage,digits)).rstrip('0').rstrip('.')}%  {stringfromseconds(phases_times[0],leadingzero=False)}" if phase1_percentage>20 else (f"{str(round(phase1_percentage,digits)).rstrip('0').rstrip('.')}%" if phase1_percentage>10 else '')
                    else:
                        label1 = ''
                    labels = [label, '', label1, '', #QApplication.translate('Message', 'Profile missing FCs event'),
                        '', stringfromseconds(total_time,leadingzero=False)]
                    # draw the bars
                    if active:
                        patch_colors = [color, background_color, aw.qmc.palette['rect1'], background_color, background_color, color]
                    else:
                        patch_colors = [color, background_color, rect1dim, background_color, background_color, color]
                    rects = self.ax.barh(i, widths, left=starts, height=self.barheight, color=patch_colors)
                elif not phases_times[0] and not phases_times[1] and phases_times[2]:
                    # only Finishing Phase is defined
                    phase3_percentage = (phases_times[2]/total_time) * 100.
                    phases_percentages = [100-phase3_percentage, phase3_percentage]
                    extended_phases_percentages = [self.m,self.g] + phases_percentages + [self.g,self.m*total_time/max_total_time]
                    widths = numpy.array(extended_phases_percentages)
                    starts = widths.cumsum() - widths
                    if active:
                        label3 = f"{str(round(phase3_percentage,digits)).rstrip('0').rstrip('.')}%  {stringfromseconds(phases_times[2],leadingzero=False)}" if phase3_percentage>20 else (f"{str(round(phase3_percentage,digits)).rstrip('0').rstrip('.')}%" if phase3_percentage>10 else '')
                    else:
                        label3 = ''
                    labels = [label, '', '', # QApplication.translate('Message', 'Profile missing DRY event'),
                        label3, '', stringfromseconds(total_time,leadingzero=False)]
                    # draw the bars
                    if active:
                        patch_colors = [color, background_color, background_color, aw.qmc.palette['rect3'], background_color, color]
                    else:
                        patch_colors = [color, background_color, background_color, rect3dim, background_color, color]
                    rects = self.ax.barh(i, widths, left=starts, height=self.barheight, color=patch_colors)
                # draw the row
                if rects is not None:
                    # draw the labels
                    tboxes = self.ax.bar_label(rects, label_type='center', labels=labels, fontproperties=prop)
                    # set the colors to ensure good contrast
                    if active:
                        text_colors = ['white' if aw.QColorBrightness(QColor(c)) < 128 else 'black' for c in patch_colors]
                    else:
                        text_colors = ['gainsboro' if aw.QColorBrightness(QColor(c)) < 128 else 'dimgrey' for c in patch_colors]
                    for j in range(len(tboxes)):
                        tboxes[j].set_color(text_colors[j])
                    # we set the sketch params for elements of the graph
                    if aw.qmc.graphstyle:
                        for c in rects.get_children():
                            c.set_sketch_params(scale=1, length=700, randomness=12)
                    # we increase the row counter
                    i += 1

            # set the graph axis limits
            x,_ = self.fig.get_size_inches()
            self.fig.set_size_inches(x, (i-1)*0.35 + 0.445, forward=True)
            self.ax.set_ylim([-0.5, i-0.5]) # 0 to number of entries but shifted by one half to get rid of borders

#            # add legend
#            phases_names = [QApplication.translate('Button','Drying Phase'), QApplication.translate('Button','Maillard Phase'),
#                      QApplication.translate('Button','Finishing Phase')]
#            phases_colors = aw.qmc.palette['rect1'], aw.qmc.palette['rect2'], aw.qmc.palette['rect3']
#            import matplotlib.patches as mpatches
#            handles = [mpatches.Patch(color=color, label=name) for (name, color) in zip(phases_names,phases_colors)]
#            legend_labelcolor = 'white' if aw.QColorBrightness(QColor(background_color)) < 120 else 'black'
#            self.ax.legend(ncol=len(phases_names),handles=handles, bbox_to_anchor=(0,-0.01,1,0),
#                  loc='upper center', fontsize='small', shadow=False, frameon=False, fancybox=False, labelcolor=legend_labelcolor)

            self.fig.canvas.draw_idle()
            aw.scroll.setMaximumHeight(self.sizeHint().height())
        else:
            # if no profiles are given we set the canvas height to 0
            QSettings().setValue('MainSplitter',aw.splitter.saveState())
            self.ax.set_ylim([0, 0])
            #self.fig.set_size_inches(0,0, forward=True) # this one crashes numpy on Windows and seems not needed
            aw.scroll.setMaximumHeight(0)
            aw.scroll.setVisible(False)


# NOTE: to have pylint to verify proper __slot__ definitions one has to remove the super class FigureCanvas here temporarily
#   as this does not has __slot__ definitions and thus __dict__ is contained which suppresses the warnings
class tgraphcanvas(FigureCanvas):
    updategraphicsSignal = pyqtSignal()
    updateLargeLCDsTimeSignal = pyqtSignal(str)
    updateLargeLCDsReadingsSignal = pyqtSignal(str,str)
    updateLargeLCDsSignal = pyqtSignal(str,str,str)
    setTimerLargeLCDcolorSignal = pyqtSignal(str,str)
    showAlarmPopupSignal = pyqtSignal(str,int)
    fileDirtySignal = pyqtSignal()
    fileCleanSignal = pyqtSignal()
    markChargeSignal = pyqtSignal(int)
    markDRYSignal = pyqtSignal()
    markFCsSignal = pyqtSignal()
    markFCeSignal = pyqtSignal()
    markSCsSignal = pyqtSignal()
    markSCeSignal = pyqtSignal()
    markDropSignal = pyqtSignal()
    markCoolSignal = pyqtSignal()
    toggleMonitorSignal = pyqtSignal()
    toggleRecorderSignal = pyqtSignal()
    processAlarmSignal = pyqtSignal(int, bool, int, str)
    alarmsetSignal = pyqtSignal(int)
    moveBackgroundSignal = pyqtSignal(str, int)
    eventRecordSignal = pyqtSignal(int)
    showCurveSignal = pyqtSignal(str, bool)
    showExtraCurveSignal = pyqtSignal(int, str, bool)
    showEventsSignal = pyqtSignal(int, bool)
    showBackgroundEventsSignal = pyqtSignal(bool)

    umlaute_dict : Final = {
       uchr(228): 'ae',  # U+00E4   \xc3\xa4
       uchr(246): 'oe',  # U+00F6   \xc3\xb6
       uchr(252): 'ue',  # U+00FC   \xc3\xbc
       uchr(196): 'Ae',  # U+00C4   \xc3\x84
       uchr(214): 'Oe',  # U+00D6   \xc3\x96
       uchr(220): 'Ue',  # U+00DC   \xc3\x9c
       uchr(223): 'ss',  # U+00DF   \xc3\x9f
    }

    __slots__ = [ 'locale_str', 'alpha', 'palette', 'palette1', 'EvalueColor_default', 'EvalueTextColor_default', 'artisanflavordefaultlabels', 'customflavorlabels',
        'SCAAflavordefaultlabels', 'SCAflavordefaultlabels', 'CQIflavordefaultlabels', 'SweetMariasflavordefaultlabels', 'Cflavordefaultlabels', 'Eflavordefaultlabels', 'coffeegeekflavordefaultlabels',
        'Intelligentsiaflavordefaultlabels', 'IstitutoInternazionaleAssaggiatoriCaffe', 'WorldCoffeeRoastingChampionship', 'ax1', 'ax2', 'ambiWorker', 'ambiThread', 'afterTP',
        'decay_weights', 'temp_decay_weights', 'flavorlabels', 'flavors', 'flavorstartangle', 'flavoraspect', 'flavorchart_plotf', 'flavorchart_angles', 'flavorchart_plot',
        'flavorchart_fill', 'flavorchart_labels', 'flavorchart_total', 'mode', 'mode_tempsliders', 'errorlog', 'default_delay', 'delay', 'min_delay', 'extra_event_sampling_delay',
        'phases_fahrenheit_defaults', 'phases_celsius_defaults', 'phases', 'phasesbuttonflag', 'phasesfromBackgroundflag', 'watermarksflag', 'step100temp', 'phasesLCDflag',
        'phasesLCDmode', 'phasesLCDmode_l', 'phasesLCDmode_all', 'statisticsflags', 'statisticsmode', 'AUCbegin', 'AUCbase', 'AUCbaseFlag', 'AUCtarget', 'AUCbackground',
        'AUCtargetFlag', 'AUCguideFlag', 'AUClcdFlag', 'AUCLCDmode', 'AUCvalue', 'AUCsinceFCs', 'AUCguideTime', 'AUCshowFlag', 'statisticstimes', 'device', 'device_logging',
        'device_log_file_name', 'device_log_file', 'phidget_dataRatesStrings', 'phidget_dataRatesValues', 'phidget1048_types', 'phidget1048_async', 'phidget1048_changeTriggers',
        'phidget1048_changeTriggersValues', 'phidget1048_changeTriggersStrings', 'phidget1048_dataRate', 'phidget1045_async', 'phidget1045_changeTrigger', 'phidget1045_changeTriggersValues',
        'phidget1045_changeTriggersStrings', 'phidget1045_emissivity', 'phidget1045_dataRate', 'phidget1200_async', 'phidget1200_formula', 'phidget1200_formulaValues', 'phidget1200_wire',
        'phidget1200_wireValues', 'phidget1200_changeTrigger', 'phidget1200_changeTriggersValues', 'phidget1200_changeTriggersStrings', 'phidget1200_dataRate',
        'phidget1200_dataRatesStrings', 'phidget1200_dataRatesValues', 'phidget1200_2_async', 'phidget1200_2_formula', 'phidget1200_2_wire', 'phidget1200_2_changeTrigger',
        'phidget1200_2_dataRate', 'phidget1046_async', 'phidget1046_gain', 'phidget1046_gainValues', 'phidget1046_formula', 'phidget1046_formulaValues', 'phidget1046_dataRate',
        'phidgetRemoteFlag', 'phidgetRemoteOnlyFlag', 'phidgetServerID', 'phidgetPassword', 'phidgetPort', 'phidgetServerAdded', 'phidgetServiceDiscoveryStarted',
        'phidgetManager', 'probatManager', 'yoctoRemoteFlag', 'yoctoServerID', 'YOCTOchanUnit', 'YOCTOchan1Unit', 'YOCTOchan2Unit', 'YOCTO_emissivity', 'YOCTO_async',
        'YOCTO_dataRate', 'YOCTO_dataRatesStrings', 'YOCTO_dataRatesValues', 'phidget1018valueFactor', 'phidget1018_async', 'phidget1018_ratio', 'phidget1018_dataRates',
        'phidget1018_changeTriggers', 'phidget1018_changeTriggersValues', 'phidget1018_changeTriggersStrings', 'phidgetVCP100x_voltageRanges', 'phidgetVCP100x_voltageRangeValues',
        'phidgetVCP100x_voltageRangeStrings', 'phidgetDAQ1400_powerSupplyStrings', 'phidgetDAQ1400_powerSupply', 'phidgetDAQ1400_inputModeStrings', 'phidgetDAQ1400_inputMode',
        'devices', 'phidgetDevices', 'nonSerialDevices', 'nonTempDevices', 'extradevices', 'extratimex', 'extradevicecolor1', 'extradevicecolor2', 'extratemp1',
        'extratemp2', 'extrastemp1', 'extrastemp2', 'extractimex1', 'extractimex2', 'extractemp1', 'extractemp2', 'extratemp1lines', 'extratemp2lines',
        'extraname1', 'extraname2', 'extramathexpression1', 'extramathexpression2', 'extralinestyles1', 'extralinestyles2', 'extradrawstyles1', 'extradrawstyles2',
        'extralinewidths1', 'extralinewidths2', 'extramarkers1', 'extramarkers2', 'extramarkersizes1', 'extramarkersizes2', 'devicetablecolumnwidths', 'extraNoneTempHint1',
        'extraNoneTempHint2', 'plotcurves', 'plotcurvecolor', 'overlapList', 'tight_layout_params', 'fig', 'ax', 'delta_ax', 'legendloc', 'legendloc_pos', 'onclick_cid',
        'oncpick_cid', 'ondraw_cid', 'rateofchange1', 'rateofchange2', 'flagon', 'flagstart', 'flagKeepON', 'flagOpenCompleted', 'flagsampling', 'flagsamplingthreadrunning',
        'manuallogETflag', 'zoom_follow', 'alignEvent', 'compareAlignEvent', 'compareEvents', 'compareET', 'compareBT', 'compareDeltaET', 'compareDeltaBT', 'compareMainEvents', 'compareBBP', 'compareRoast',
        'replayType', 'replayedBackgroundEvents', 'beepedBackgroundEvents', 'roastpropertiesflag', 'roastpropertiesAutoOpenFlag', 'roastpropertiesAutoOpenDropFlag',
        'title', 'title_show_always', 'ambientTemp', 'ambientTempSource', 'ambient_temperature_device', 'ambient_pressure', 'ambient_pressure_device', 'ambient_humidity',
        'ambient_humidity_device', 'elevation', 'temperaturedevicefunctionlist', 'humiditydevicefunctionlist', 'pressuredevicefunctionlist', 'moisture_greens', 'moisture_roasted',
        'greens_temp', 'beansize', 'beansize_min', 'beansize_max', 'whole_color', 'ground_color', 'color_systems', 'color_system_idx', 'heavyFC_flag', 'lowFC_flag', 'lightCut_flag',
        'darkCut_flag', 'drops_flag', 'oily_flag', 'uneven_flag', 'tipping_flag', 'scorching_flag', 'divots_flag', 'timex',
        'temp1', 'temp2', 'delta1', 'delta2', 'stemp1', 'stemp2', 'tstemp1', 'tstemp2', 'ctimex1', 'ctimex2', 'ctemp1', 'ctemp2', 'unfiltereddelta1', 'unfiltereddelta2',  'unfiltereddelta1_pure', 'unfiltereddelta2_pure',
        'on_timex', 'on_temp1', 'on_temp2', 'on_ctimex1', 'on_ctimex2', 'on_ctemp1', 'on_ctemp2','on_tstemp1', 'on_tstemp2', 'on_unfiltereddelta1',
        'on_unfiltereddelta2', 'on_delta1', 'on_delta2', 'on_extratemp1', 'on_extratemp2', 'on_extratimex', 'on_extractimex1', 'on_extractemp1', 'on_extractimex2', 'on_extractemp2',
        'timeindex', 'ETfunction', 'BTfunction', 'DeltaETfunction', 'DeltaBTfunction', 'safesaveflag', 'pid', 'background', 'backgroundprofile', 'backgroundprofile_moved_x', 'backgroundprofile_moved_y', 'backgroundDetails',
        'backgroundeventsflag', 'backgroundpath', 'backgroundUUID', 'backgroundUUID', 'backgroundShowFullflag', 'titleB', 'roastbatchnrB', 'roastbatchprefixB',
        'roastbatchposB', 'temp1B', 'temp2B', 'temp1BX', 'temp2BX', 'timeB', 'temp1Bdelta', 'temp2Bdelta',
        'stemp1B', 'stemp2B', 'stemp1BX', 'stemp2BX', 'extraname1B', 'extraname2B', 'extratimexB', 'xtcurveidx', 'ytcurveidx', 'delta1B', 'delta2B', 'timeindexB',
        'TP_time_B_loaded', 'backgroundEvents', 'backgroundEtypes', 'backgroundEvalues', 'backgroundEStrings', 'backgroundalpha', 'backgroundmetcolor',
        'backgroundbtcolor', 'backgroundxtcolor', 'backgroundytcolor', 'backgrounddeltaetcolor', 'backgrounddeltabtcolor', 'backmoveflag', 'detectBackgroundEventTime',
        'backgroundReproduce', 'backgroundReproduceBeep', 'backgroundPlaybackEvents', 'backgroundPlaybackDROP', 'Betypes', 'backgroundFlavors', 'flavorbackgroundflag',
        'E1backgroundtimex', 'E2backgroundtimex', 'E3backgroundtimex', 'E4backgroundtimex', 'E1backgroundvalues', 'E2backgroundvalues', 'E3backgroundvalues',
        'E4backgroundvalues', 'l_backgroundeventtype1dots', 'l_backgroundeventtype2dots', 'l_backgroundeventtype3dots', 'l_backgroundeventtype4dots',
        'DeltaETBflag', 'DeltaBTBflag', 'clearBgbeforeprofileload', 'hideBgafterprofileload', 'heating_types', 'operator', 'organization', 'roastertype', 'roastersize', 'roasterheating', 'drumspeed',
        'organization_setup', 'operator_setup', 'roastertype_setup', 'roastersize_setup', 'roasterheating_setup', 'drumspeed_setup', 'last_batchsize', 'machinesetup_energy_ratings',
        'machinesetup', 'roastingnotes', 'cuppingnotes', 'roastdate', 'roastepoch', 'lastroastepoch', 'batchcounter', 'batchsequence', 'batchprefix', 'neverUpdateBatchCounter',
        'roastbatchnr', 'roastbatchprefix', 'roastbatchpos', 'roasttzoffset', 'roastUUID', 'plus_default_store', 'plus_store', 'plus_store_label', 'plus_coffee',
        'plus_coffee_label', 'plus_blend_spec', 'plus_blend_spec_labels', 'plus_blend_label', 'plus_custom_blend', 'plus_sync_record_hash', 'plus_file_last_modified', 'beans', 'projectFlag', 'curveVisibilityCache', 'ETcurve', 'BTcurve',
        'ETlcd', 'BTlcd', 'swaplcds', 'LCDdecimalplaces', 'foregroundShowFullflag', 'DeltaETflag', 'DeltaBTflag', 'DeltaETlcdflag', 'DeltaBTlcdflag',
        'swapdeltalcds', 'PIDbuttonflag', 'Controlbuttonflag', 'deltaETfilter', 'deltaBTfilter', 'curvefilter', 'deltaETspan', 'deltaBTspan',
        'deltaETsamples', 'deltaBTsamples', 'profile_sampling_interval', 'background_profile_sampling_interval', 'profile_meter', 'optimalSmoothing', 'polyfitRoRcalc',
        'patheffects', 'graphstyle', 'graphfont', 'buttonvisibility', 'buttonactions', 'buttonactionstrings', 'extrabuttonactions', 'extrabuttonactionstrings',
        'xextrabuttonactions', 'xextrabuttonactionstrings', 'chargeTimerFlag', 'autoChargeFlag', 'autoDropFlag', 'autoChargeIdx', 'autoDropIdx', 'markTPflag', 'autoTPIdx',
        'autoDRYflag', 'autoFCsFlag', 'autoCHARGEenabled', 'autoDRYenabled', 'autoFCsenabled', 'autoDROPenabled', 'autoDryIdx', 'autoFCsIdx', 'projectionconstant',
        'projectionmode', 'transMappingMode', 'weight', 'volume_units', 'volume', 'density', 'density_roasted', 'volumeCalcUnit', 'volumeCalcWeightInStr',
        'volumeCalcWeightOutStr', 'container_names', 'container_weights', 'container_idx', 'specialevents', 'etypes', 'etypesdefault', 'specialeventstype',
        'specialeventsStrings', 'specialeventsvalue', 'eventsGraphflag', 'clampEvents', 'renderEventsDescr', 'eventslabelschars', 'eventsshowflag',
        'annotationsflag', 'showeventsonbt', 'showEtypes', 'E1timex', 'E2timex', 'E3timex', 'E4timex', 'E1values', 'E2values', 'E3values', 'E4values',
        'EvalueColor', 'EvalueTextColor', 'EvalueMarker', 'EvalueMarkerSize', 'Evaluelinethickness', 'Evaluealpha', 'eventpositionbars', 'specialeventannotations',
        'specialeventannovisibilities', 'specialeventplaybackaid', 'specialeventplayback', 'overlappct', 'linestyle_default', 'drawstyle_default', 'linewidth_default', 'back_linewidth_default', 'delta_linewidth_default',
        'back_delta_linewidth_default', 'extra_linewidth_default', 'marker_default', 'markersize_default', 'BTlinestyle', 'BTdrawstyle', 'BTlinewidth', 'BTmarker',
        'BTmarkersize', 'ETlinestyle', 'ETdrawstyle', 'ETlinewidth', 'ETmarker', 'ETmarkersize', 'BTdeltalinestyle', 'BTdeltadrawstyle', 'BTdeltalinewidth',
        'BTdeltamarker', 'BTdeltamarkersize', 'ETdeltalinestyle', 'ETdeltadrawstyle', 'ETdeltalinewidth', 'ETdeltamarker', 'ETdeltamarkersize', 'BTbacklinestyle',
        'BTbackdrawstyle', 'BTbacklinewidth', 'BTbackmarker', 'BTbackmarkersize', 'ETbacklinestyle', 'ETbackdrawstyle', 'ETbacklinewidth', 'ETbackmarker',
        'ETbackmarkersize', 'XTbacklinestyle', 'XTbackdrawstyle', 'XTbacklinewidth', 'XTbackmarker', 'XTbackmarkersize', 'YTbacklinestyle', 'YTbackdrawstyle',
        'YTbacklinewidth', 'YTbackmarker', 'YTbackmarkersize', 'BTBdeltalinestyle', 'BTBdeltadrawstyle', 'BTBdeltalinewidth', 'BTBdeltamarker', 'BTBdeltamarkersize',
        'ETBdeltalinestyle', 'ETBdeltadrawstyle', 'ETBdeltalinewidth', 'ETBdeltamarker', 'ETBdeltamarkersize', 'BTBdeltalinestyle', 'BTBdeltadrawstyle',
        'BTBdeltalinewidth', 'BTBdeltamarker', 'BTBdeltamarkersize', 'ETBdeltalinestyle', 'ETBdeltadrawstyle', 'ETBdeltalinewidth', 'ETBdeltamarker',
        'ETBdeltamarkersize', 'alarmsetlabel', 'alarmflag', 'alarmguard', 'alarmnegguard', 'alarmtime', 'alarmoffset', 'alarmtime2menuidx', 'menuidx2alarmtime',
        'alarmcond', 'alarmstate', 'alarmsource', 'alarmtemperature', 'alarmaction', 'alarmbeep', 'alarmstrings', 'alarmtablecolumnwidths', 'silent_alarms',
        'alarmsets_count', 'alarmsets', 'loadalarmsfromprofile', 'loadalarmsfrombackground', 'alarmsfile', 'temporaryalarmflag', 'TPalarmtimeindex',
        'rsfile', 'temporary_error', 'temporarymovepositiveslider', 'temporarymovenegativeslider',
        'temporayslider_force_move', 'quantifiedEvent', 'loadaxisfromprofile', 'startofx_default', 'endofx_default', 'xgrid_default', 'ylimit_F_default',
        'ylimit_min_F_default', 'ygrid_F_default', 'zlimit_F_default', 'zlimit_min_F_default', 'zgrid_F_default', 'ylimit_C_default', 'ylimit_min_C_default',
        'ygrid_C_default', 'zlimit_C_default', 'zlimit_min_C_default', 'zgrid_C_default', 'temp_grid', 'time_grid', 'zlimit_max', 'zlimit_min_max',
        'ylimit_max', 'ylimit_min_max', 'ylimit', 'ylimit_min', 'zlimit', 'zlimit_min', 'RoRlimitFlag', 'RoRlimit', 'RoRlimitm', 'maxRoRlimit',
        'endofx', 'startofx', 'resetmaxtime', 'chargemintime', 'fixmaxtime', 'locktimex', 'autotimex', 'autotimexMode', 'autodeltaxET', 'autodeltaxBT', 'locktimex_start',
        'locktimex_end', 'xgrid', 'ygrid', 'zgrid', 'gridstyles', 'gridlinestyle', 'gridthickness', 'gridalpha', 'xrotation',
        'statisticsheight', 'statisticsupper', 'statisticslower', 'autosaveflag', 'autosaveprefix', 'autosavepath', 'autosavealsopath',
        'autosaveaddtorecentfilesflag', 'autosaveimage', 'autosaveimageformat', 'autoasaveimageformat_types', 'ystep_down', 'ystep_up', 'backgroundETcurve', 'backgroundBTcurve',
        'l_temp1', 'l_temp2', 'l_delta1', 'l_delta2', 'l_back1', 'l_back2', 'l_back3', 'l_back4', 'l_delta1B', 'l_delta2B', 'l_BTprojection', 'l_DeltaETprojection', 'l_DeltaBTprojection',
        'l_ETprojection', 'l_AUCguide', 'l_horizontalcrossline', 'l_verticalcrossline', 'l_timeline', 'legend', 'l_eventtype1dots', 'l_eventtype2dots',
        'l_eventtype3dots', 'l_eventtype4dots', 'l_eteventannos', 'l_bteventannos', 'l_eventtype1annos', 'l_eventtype2annos', 'l_eventtype3annos',
        'l_eventtype4annos', 'l_annotations', 'l_background_annotations', 'l_annotations_dict', 'l_annotations_pos_dict', 'l_event_flags_dict',
        'l_event_flags_pos_dict', 'ai', 'timeclock', 'threadserver', 'designerflag', 'designerconnections', 'mousepress', 'indexpoint',
        'workingline', 'eventtimecopy', 'specialeventsStringscopy', 'specialeventsvaluecopy', 'specialeventstypecopy', 'currentx', 'currenty',
        'designertimeinit', 'BTsplinedegree', 'ETsplinedegree', 'reproducedesigner', 'designertemp1init', 'designertemp2init',
        'filterDropOut_replaceRoR_period', 'filterDropOut_spikeRoR_period', 'filterDropOut_tmin_C_default', 'filterDropOut_tmax_C_default',
        'filterDropOut_tmin_F_default', 'filterDropOut_tmax_F_default', 'filterDropOut_spikeRoR_dRoR_limit_C_default', 'filterDropOut_spikeRoR_dRoR_limit_F_default',
        'filterDropOuts', 'filterDropOut_tmin', 'filterDropOut_tmax', 'filterDropOut_spikeRoR_dRoR_limit', 'minmaxLimits',
        'dropSpikes', 'dropDuplicates', 'dropDuplicatesLimit', 'liveMedianRoRfilter', 'interpolatemax', 'swapETBT', 'wheelflag', 'wheelnames', 'segmentlengths', 'segmentsalpha',
        'wheellabelparent', 'wheelcolor', 'wradii', 'startangle', 'projection', 'wheeltextsize', 'wheelcolorpattern', 'wheeledge',
        'wheellinewidth', 'wheellinecolor', 'wheeltextcolor', 'wheelconnections', 'wheelx', 'wheelz', 'wheellocationx', 'wheellocationz',
        'wheelaspect', 'samplingSemaphore', 'profileDataSemaphore', 'messagesemaphore', 'errorsemaphore', 'serialsemaphore', 'seriallogsemaphore',
        'eventactionsemaphore', 'updateBackgroundSemaphore', 'alarmSemaphore', 'rampSoakSemaphore', 'crossmarker', 'crossmouseid', 'onreleaseid',
        'analyzer_connect_id', 'extra309T3', 'extra309T4', 'extra309TX', 'hottop_ET', 'hottop_BT', 'hottop_HEATER', 'hottop_MAIN_FAN', 'hottop_TX',
        'R1_DT', 'R1_BT', 'R1_BT_ROR', 'R1_EXIT_TEMP', 'R1_HEATER', 'R1_FAN', 'R1_DRUM', 'R1_VOLTAGE', 'R1_TX', 'R1_STATE', 'R1_FAN_RPM', 'R1_STATE_STR',
        'extraArduinoT1', 'extraArduinoT2', 'extraArduinoT3', 'extraArduinoT4', 'extraArduinoT5', 'extraArduinoT6', 'program_t3', 'program_t4', 'program_t5', 'program_t6',
        'program_t7', 'program_t8', 'program_t9', 'program_t10', 'dutycycle', 'dutycycleTX', 'currentpidsv', 'linecount', 'deltalinecount',
        'ax_background', 'block_update', 'fmt_data_RoR', 'fmt_data_curve', 'running_LCDs', 'plotterstack', 'plotterequationresults', 'plottermessage', 'alarm_popup_timout',
        'RTtemp1', 'RTtemp2', 'RTextratemp1', 'RTextratemp2', 'RTextratx', 'idx_met', 'showmet', 'met_annotate', 'met_timex_temp1_delta',
        'extendevents', 'statssummary', 'showtimeguide', 'statsmaxchrperline', 'energyunits', 'powerunits', 'sourcenames', 'loadlabels_setup',
        'loadratings_setup', 'ratingunits_setup', 'sourcetypes_setup', 'load_etypes_setup', 'presssure_percents_setup', 'loadevent_zeropcts_setup',
        'loadevent_hundpcts_setup', 'preheatDuration_setup', 'preheatenergies_setup', 'betweenbatchDuration_setup', 'betweenbatchenergies_setup',
        'coolingDuration_setup', 'coolingenergies_setup', 'betweenbatch_after_preheat_setup', 'electricEnergyMix_setup', 'energyresultunit_setup',
        'kind_list', 'loadlabels', 'loadratings', 'ratingunits', 'sourcetypes', 'load_etypes', 'presssure_percents', 'loadevent_zeropcts',
        'loadevent_hundpcts', 'preheatDuration', 'preheatenergies', 'betweenbatchDuration', 'betweenbatchenergies', 'coolingDuration', 'coolingenergies',
        'betweenbatch_after_preheat', 'electricEnergyMix', 'baseX', 'baseY', 'base_horizontalcrossline', 'base_verticalcrossline',
        'base_messagevisible', 'colorDifferenceThreshold', 'handles', 'labels', 'legend_lines', 'eventmessage', 'backgroundeventmessage',
        'eventmessagetimer', 'resizeredrawing', 'logoimg', 'analysisresultsloc_default', 'analysisresultsloc', 'analysispickflag', 'analysisresultsstr',
        'analysisstartchoice', 'analysisoffset', 'curvefitstartchoice', 'curvefitoffset', 'segmentresultsloc_default', 'segmentresultsloc',
        'segmentpickflag', 'segmentdeltathreshold', 'segmentsamplesthreshold', 'stats_summary_rect', 'title_text', 'title_artist', 'title_width',
        'background_title_width', 'xlabel_text', 'xlabel_artist', 'xlabel_width', 'lazyredraw_on_resize_timer', 'mathdictionary_base',
        'ambient_pressure_sampled', 'ambient_humidity_sampled', 'ambientTemp_sampled', 'backgroundmovespeed', 'chargeTimerPeriod', 'flavors_default_value',
        'fmt_data_ON', 'l_subtitle', 'projectDeltaFlag', 'weight_units']


    def __init__(self, parent, dpi, *, locale):

        #default palette of colors
        self.locale_str = locale
        self.alpha = {'analysismask':0.4,'statsanalysisbkgnd':1.0,'legendbg':0.4}
        self.palette = {'background':'#FFFFFF','grid':'#E5E5E5','ylabel':'#808080','xlabel':'#808080','title':'#0C6AA6', 'title_focus':'#cc0f50',
                        'rect1':'#E5E5E5','rect2':'#B2B2B2','rect3':'#E5E5E5','rect4':'#BDE0EE','rect5':'#D3D3D3',
                        'et':'#cc0f50','bt':'#0A5C90','xt':'#404040','yt':'#404040','deltaet':'#cc0f50',
                        'deltabt':'#0A5C90','markers':'#000000','text':'#000000','watermarks':'#FFFF00','timeguide':'#0A5C90',
                        'canvas':'#F8F8F8','legendbg':'#FFFFFF','legendborder':'#A9A9A9',
                        'specialeventbox':'#FF5871','specialeventtext':'#FFFFFF',
                        'bgeventmarker':'#7F7F7F','bgeventtext':'#000000',
                        'mettext':'#FFFFFF','metbox':'#CC0F50',
                        'aucguide':'#0C6AA6','messages':'#000000','aucarea':'#767676',
                        'analysismask':'#BABABA','statsanalysisbkgnd':'#FFFFFF'}
        self.palette1 = self.palette.copy()
        self.EvalueColor_default = ['#43A7CF','#49B160','#800080','#AD0427']
        self.EvalueTextColor_default = ['white','#FFFFFF','white','#FFFFFF']

        # standard math functions allowed in symbolic formulas
        self.mathdictionary_base = {
            'min':min,'max':max,'sin':math.sin,'cos':math.cos,'tan':math.tan,
            'pow':math.pow,'exp':math.exp,'pi':math.pi,'e':math.e,
            'abs':abs,'acos':math.acos,'asin':math.asin,'atan':math.atan,
            'log':math.log,'radians':math.radians,
            'sqrt':math.sqrt,'degrees':math.degrees}


        self.artisanflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Clean Cup'),
                                            QApplication.translate('Textbox', 'Head'),
                                            QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Body')]

        # custom labels are stored in the application settings and can be edited by the user
        self.customflavorlabels = self.artisanflavordefaultlabels

# old SCAA spec (note the typo in the variable name):
# replaced by the specification below for v2.6.0:
#        self.SCCAflavordefaultlabels: Final = [[QApplication.translate("Textbox", "Sour"),
#                                        QApplication.translate("Textbox", "Flavor"),
#                                        QApplication.translate("Textbox", "Critical\nStimulus"),
#                                        QApplication.translate("Textbox", "Aftertaste"),
#                                        QApplication.translate("Textbox", "Bitter"),
#                                        QApplication.translate("Textbox", "Astringency"),
#                                        QApplication.translate("Textbox", "Solubles\nConcentration"),
#                                        QApplication.translate("Textbox", "Mouthfeel"),
#                                        QApplication.translate("Textbox", "Other"),
#                                        QApplication.translate("Textbox", "Aromatic\nComplexity"),
#                                        QApplication.translate("Textbox", "Roast\nColor"),
#                                        QApplication.translate("Textbox", "Aromatic\nPungency"),
#                                        QApplication.translate("Textbox", "Sweet"),
#                                        QApplication.translate("Textbox", "Acidity"),
#                                        QApplication.translate("Textbox", "pH"),
#                                        QApplication.translate("Textbox", "Balance")]

        self.SCAAflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Aftertaste'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Uniformity'),
                                        QApplication.translate('Textbox', 'Balance'),
                                        QApplication.translate('Textbox', 'Clean Cup'),
                                        QApplication.translate('Textbox', 'Sweetness'),
                                        QApplication.translate('Textbox', 'Overall')]

        self.SCAflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Aftertaste'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Intensity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Uniformity'),
                                        QApplication.translate('Textbox', 'Balance'),
                                        QApplication.translate('Textbox', 'Clean Cup'),
                                        QApplication.translate('Textbox', 'Sweetness'),
                                        QApplication.translate('Textbox', 'Overall')]

        self.CQIflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Fragance'),
                                        QApplication.translate('Textbox', 'Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Aftertaste')]

        self.SweetMariasflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Dry Fragrance'),
                                            QApplication.translate('Textbox', 'Uniformity'),
                                            QApplication.translate('Textbox', 'Complexity'),
                                            QApplication.translate('Textbox', 'Clean Cup'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Finish'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Flavor'),
                                            QApplication.translate('Textbox', 'Brightness'),
                                            QApplication.translate('Textbox', 'Wet Aroma')]

        self.Cflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Taste'),
                                            QApplication.translate('Textbox', 'Nose'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Acidity')]

        self.Eflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Flavor'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Balance')]


        self.coffeegeekflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Mouthfeel'),
                                            QApplication.translate('Textbox', 'Flavour'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Balance')]

        self.Intelligentsiaflavordefaultlabels: Final = [QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Finish')]

        self.IstitutoInternazionaleAssaggiatoriCaffe: Final = [QApplication.translate('Textbox', 'Roast Color'),
                                            QApplication.translate('Textbox', 'Crema Texture'),
                                            QApplication.translate('Textbox', 'Crema Volume'),
                                            QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Bitterness'),
                                            QApplication.translate('Textbox', 'Defects'),
                                            QApplication.translate('Textbox', 'Aroma Intensity'),
                                            QApplication.translate('Textbox', 'Aroma Persistence'),
                                            QApplication.translate('Textbox', 'Balance')]

        self.WorldCoffeeRoastingChampionship: Final = [QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Flavour'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Overall')]

        self.ax1 = self.ax2 = None

        # Ambient Data Worker and Thread
        self.ambiWorker = None
        self.ambiThread = None

        # used by sample_processing
        self.afterTP = False
        self.decay_weights = None
        self.temp_decay_weights = None

        self.flavorlabels = list(self.artisanflavordefaultlabels)
        #Initial flavor parameters.
        self.flavors_default_value = 5.
        self.flavors = [5.]*len(self.flavorlabels)
        self.flavorstartangle = 90
        self.flavoraspect = 1.0  #aspect ratio
        # flavor chart graph plots and annotations
        self.flavorchart_plotf = None
        self.flavorchart_angles = None
        self.flavorchart_plot = None
        self.flavorchart_fill = None
        self.flavorchart_labels = None
        self.flavorchart_total = None

        #F = Fahrenheit; C = Celsius
        self.mode = 'F'
        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if QSettings().value('AppleTemperatureUnit') == 'Celsius':
                    self.mode = 'C'
            except Exception: # pylint: disable=broad-except
                pass

        self.mode_tempsliders = self.mode # the temperature mode of event slider to convert min/max limits

        self.errorlog = []

        # default delay between readings in milliseconds
        self.default_delay: Final = 2000 # default 2s
        self.delay = self.default_delay
        self.min_delay = 250 # 500 # 1000

        # extra event sampling interval in milliseconds. If 0, then extra sampling commands are sent "in sync" with the standard sampling commands
        self.extra_event_sampling_delay = 0 # sync, 0.5s, 1.0s, 1.5s,.., 5s => 0, 500, 1000, 1500, ..

        #watermarks limits: dryphase1, dryphase2 (DRY), midphase (FCs), and finish phase Y limits
        self.phases_fahrenheit_defaults: Final = [300,300,390,450]
        self.phases_celsius_defaults: Final = [150,150,200,230]
        self.phases = list(self.phases_fahrenheit_defaults) # contains either the phases_filter or phases_espresso, depending on the mode
        #this flag makes the main push buttons DryEnd, and FCstart change the phases[1] and phases[2] respectively
        self.phasesbuttonflag = True #False no change; True make the DRY and FC buttons change the phases during roast automatically
        self.phasesfromBackgroundflag = False # False: no change; True: set phases from background profile on load
        self.watermarksflag = True
        self.step100temp = None # if set to a temperature value, the 100% event value in step modes is aligned with the given temperature, otherwise with the lowest phases limit

        #show phases LCDs during roasts
        self.phasesLCDflag = True
        self.phasesLCDmode = 1 # one of 0: time, 1: percentage, 2: temp mode
        self.phasesLCDmode_l = [1,1,1]
        self.phasesLCDmode_all = [False,False,True]


        #statistics flags selects to display: stat. time, stat. bar, (stat. flavors), stat. area, stat. deg/min, stat. ETBTarea
        # NOTE: stat. flavors not used anymore. The code has been removed.
        #       statisticsflags[5] area is not used anymore
        self.statisticsflags = [1,1,0,1,0,0,1]
        self.statisticsmode = 1 # one of 0: standard computed values, 1: roast properties

        # Area Under Curve (AUC)
        self.AUCbegin = 1 # counting begins after 0: CHARGE, 1: TP (default), 2: DE, 3: FCs
        self.AUCbase = 212 # base temperature above which the area is calculated (default 212F/110C)
        self.AUCbaseFlag = False # if True, base AUC is taken from BT at AUCbegin event
        self.AUCtarget = 640 # target AUC for prediction
        self.AUCbackground = -1 # AUC of background profile or -1 if none loaded
        self.AUCtargetFlag = False # if True, target is taken from the background else from self.AUCtarget
        self.AUCguideFlag = False # if True a prediction line is drawn at the time the target area is reached considering current RoR
        self.AUClcdFlag = False # if True a AUC LCD is displayed next to the phases LCDs to show current AUC or AUC difference to target
        self.AUCLCDmode = 0 # one of 0: abs value, 1: delta to target/background, 2: AUC since FCs
        self.AUCvalue = 0 # the running AUC value calculated during recording
        self.AUCsinceFCs = 0 # the running AUC since FCs calculated during recording
        self.AUCguideTime = 0 # the expected time in seconds the AUC target is reached (calculated by the AUC guide mechanism)
        self.AUCshowFlag = False

        # timing statistics on loaded profile
        self.statisticstimes = [0,0,0,0,0] # total, dry phase, mid phase, finish phase  and cooling phase times

        #DEVICES
        self.device = 18                                    # default device selected to None (18). Calls appropriate function

        self.device_logging = False # turn on/off device debug logging (MODBUS, ..) # Note that MODBUS log messages are written to the main artisan log file
        # Phidget messages are logged to the artisan device log
        self.device_log_file_name = 'artisan_device'
        self.device_log_file = getDirectory(self.device_log_file_name,'.log')

        # Phidget variables

        self.phidget_dataRatesStrings : Final = ['32ms','64ms','128ms','256ms','512ms','768ms','1s'] # too fast: "8ms","16ms","32ms","64ms","0.12s",
        self.phidget_dataRatesValues : Final = [32,64,128,256,512,768,1024] # 8,16,32,64,128,

        # probe type values (along the Phidgets21 lib): k-type => 1, j-type => 2, e-type => 3, t-type => 4
        # Artisan will keep on using the Phidgets21 mapping
        self.phidget1048_types = [1,1,1,1] # defaults all to k-type probes (values are 0-based)
        self.phidget1048_async = [False]*4
        self.phidget1048_changeTriggers = [0]*4
        self.phidget1048_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1048_changeTriggersStrings = list(map(lambda x:f'{x:.1f}C',self.phidget1048_changeTriggersValues)) # pylint: disable=unnecessary-lambda
        # add 0.02C and 0.05C change triggers
        self.phidget1048_changeTriggersValues.insert(1,0.05)
        self.phidget1048_changeTriggersValues.insert(1,0.02)
        self.phidget1048_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1048_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1048_dataRate = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active on v21 API, 256ms on v22 API)

        self.phidget1045_async = False
        self.phidget1045_changeTrigger = 0
        self.phidget1045_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1045_changeTriggersStrings = list(map(lambda x:f'{x}C',self.phidget1045_changeTriggersValues))
        # add 0.02C and 0.05C change triggers
        self.phidget1045_changeTriggersValues.insert(1,0.05)
        self.phidget1045_changeTriggersValues.insert(1,0.02)
        self.phidget1045_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1045_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1045_emissivity = 1.0
        self.phidget1045_dataRate = 256

        self.phidget1200_async = False
        self.phidget1200_formula = 0
        self.phidget1200_formulaValues: Final = ['PT100  3850', 'PT100  3920','PT1000 3850', 'PT1000 3920']
        self.phidget1200_wire = 0
        self.phidget1200_wireValues: Final = ['2-wire', '3-wire','4-wire']
        self.phidget1200_changeTrigger = 0
        self.phidget1200_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1200_changeTriggersStrings = list(map(lambda x:f'{x}C',self.phidget1200_changeTriggersValues))
        # add 0.02C and 0.05C change triggers
        self.phidget1200_changeTriggersValues.insert(1,0.05)
        self.phidget1200_changeTriggersValues.insert(1,0.02)
        self.phidget1200_changeTriggersValues.insert(1,0.01)
        self.phidget1200_changeTriggersValues.insert(1,0.005)
        self.phidget1200_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.01C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.005C')
        self.phidget1200_dataRate = 250
        self.phidget1200_dataRatesStrings: Final = ['250ms','500ms','750ms','1s']
        self.phidget1200_dataRatesValues: Final = [250,500,700,1024]

        self.phidget1200_2_async = False
        self.phidget1200_2_formula = 0
        self.phidget1200_2_wire = 0
        self.phidget1200_2_changeTrigger = 0
        self.phidget1200_2_dataRate = 250

        self.phidget1046_async = [False]*4
        self.phidget1046_gain = [1]*4 # defaults to no gain (values are 0-based)
        self.phidget1046_gainValues: Final = ['1', '8','16','32','64','128'] # 1 for no gain
        self.phidget1046_formula: Final = [1]*4 # 0: 1K Ohm Wheatstone Bridge, 1: 1K Ohm Voltage Divider, 2: raw
        self.phidget1046_formulaValues: Final = ['WS', 'Div','raw']
        self.phidget1046_dataRate = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active)

        self.phidgetRemoteFlag = False # if True the specified remote server is harvestd to potentially attached Phidget devices
        self.phidgetRemoteOnlyFlag = False # if True only Phidgets attached to remote servers are attached
        self.phidgetServerID = ''
        self.phidgetPassword = ''
        self.phidgetPort = 5661
        self.phidgetServerAdded = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetServiceDiscoveryStarted = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetManager = None

        self.probatManager = None

        self.yoctoRemoteFlag = False
        self.yoctoServerID = '127.0.0.1'
        self.YOCTOchanUnit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan1Unit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan2Unit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTO_emissivity = 1.0
        self.YOCTO_async = [False]*2
        self.YOCTO_dataRate = 256 # in ms
        self.YOCTO_dataRatesStrings: Final = ['32ms','64ms','128ms','256ms','512ms','768ms','1s','1s*']
        self.YOCTO_dataRatesValues: Final = [32,64,128,256,512,768,1000,1024] # the 1024 mode returns every sec an average over the period, while 1000 returns every second the last sample

        self.phidget1018valueFactor = 1000 # we map the 0-5V voltage returned by the Phidgets22 API to mV (0-5000)
        self.phidget1018_async = [False]*8
        self.phidget1018_ratio = [False]*8 # if True VoltageRatio instead of VoltageInput is returned
        self.phidget1018_dataRates = [256]*8 # in ms; (Phidgets default 256ms, min is 8ms, 16ms if wireless is active), max 1000ms
                # with the new PhidgetsAPI the 1011/1018 dataRate is from 1ms to 1.000ms
        self.phidget1018_changeTriggers = [10]*8
        self.phidget1018_changeTriggersValues: Final = range(0,51,1)
        self.phidget1018_changeTriggersStrings: Final = list(map(lambda x:str(x*10)+'mV',self.phidget1018_changeTriggersValues))

        self.phidgetVCP100x_voltageRanges = [VoltageRange.VOLTAGE_RANGE_AUTO]*8
        self.phidgetVCP100x_voltageRangeValues: Final = [
            VoltageRange.VOLTAGE_RANGE_AUTO,
            VoltageRange.VOLTAGE_RANGE_10mV,
            VoltageRange.VOLTAGE_RANGE_40mV,
            VoltageRange.VOLTAGE_RANGE_200mV,
            VoltageRange.VOLTAGE_RANGE_312_5mV,
            VoltageRange.VOLTAGE_RANGE_400mV,
            VoltageRange.VOLTAGE_RANGE_1000mV,
            VoltageRange.VOLTAGE_RANGE_2V,
            VoltageRange.VOLTAGE_RANGE_5V,
            VoltageRange.VOLTAGE_RANGE_15V,
            VoltageRange.VOLTAGE_RANGE_40V
        ]
        self.phidgetVCP100x_voltageRangeStrings: Final = [
            'Auto',
            '10mV',
            '40mV',
            '200mV',
            '312.5mV',
            '400mV',
            '1000mV',
            '2V',
            '5V',
            '15V',
            '40V'
        ]

        self.phidgetDAQ1400_powerSupplyStrings: Final = ['--','12V','24V']
        self.phidgetDAQ1400_powerSupply = 1
        self.phidgetDAQ1400_inputModeStrings: Final = ['NPN','PNP']
        self.phidgetDAQ1400_inputMode = 0

        #menu of thermocouple devices
        #device with first letter + only shows in extra device tab
        #device with first letter - does not show in any tab (but its position in the list is important)
        # device labels (used in Dialog config).

        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:" in the code
        # (check also the tags in comm.py and devices.py!!)
        # - add to self.devices
        self.devices: Final = [#Fuji PID        #0
                       'Omega HH806AU',         #1
                       'Omega HH506RA',         #2
                       'CENTER 309',            #3
                       'CENTER 306',            #4
                       'CENTER 305',            #5
                       'CENTER 304',            #6
                       'CENTER 303',            #7
                       'CENTER 302',            #8
                       'CENTER 301',            #9
                       'CENTER 300',            #10
                       'VOLTCRAFT K204',        #11
                       'VOLTCRAFT K202',        #12
                       'VOLTCRAFT 300K',        #13
                       'VOLTCRAFT 302KJ',       #14
                       'EXTECH 421509',         #15
                       'Omega HH802U',          #16
                       'Omega HH309',           #17
                       'NONE',                  #18
                       '-ARDUINOTC4',           #19
                       'TE VA18B',              #20
                       '+CENTER 309 34',        #21
                       '+PID SV/DUTY %',        #22
                       'Omega HHM28[6]',        #23
                       '+VOLTCRAFT K204 34',    #24
                       '+Virtual',              #25
                       '-DTAtemperature',       #26
                       'Program',               #27
                       '+ArduinoTC4 34',        #28
                       'MODBUS',                #29
                       'VOLTCRAFT K201',        #30
                       'Amprobe TMD-56',        #31
                       '+ArduinoTC4 56',        #32
                       '+MODBUS 34',            #33
                       'Phidget 1048 4xTC 01',  #34
                       '+Phidget 1048 4xTC 23', #35
                       '+Phidget 1048 4xTC AT', #36
                       'Phidget 1046 4xRTD 01', #37
                       '+Phidget 1046 4xRTD 23',#38
                       'Mastech MS6514',        #39
                       'Phidget IO 01',         #40
                       '+Phidget IO 23',        #41
                       '+Phidget IO 45',        #42
                       '+Phidget IO 67',        #43
                       '+ArduinoTC4 78',        #44
                       'Yocto Thermocouple',    #45
                       'Yocto PT100',           #46
                       'Phidget 1045 IR',       #47
                       '+Program 34',           #48
                       '+Program 56',           #49
                       'DUMMY',                 #50
                       '+CENTER 304 34',        #51
                       'Phidget 1051 1xTC 01',  #52
                       'Hottop BT/ET',          #53
                       '+Hottop Heater/Fan',    #54
                       '+MODBUS 56',            #55
                       'Apollo DT301',          #56
                       'EXTECH 755',            #57
                       'Phidget TMP1101 4xTC 01',  #58
                       '+Phidget TMP1101 4xTC 23', #59
                       '+Phidget TMP1101 4xTC AT', #60
                       'Phidget TMP1100 1xTC',  #61
                       'Phidget 1011 IO 01',    #62
                       'Phidget HUB IO 01', #63
                       '+Phidget HUB IO 23',#64
                       '+Phidget HUB IO 45',#65
                       '-Omega HH806W',         #66 NOT WORKING
                       'VOLTCRAFT PL-125-T2',   #67
                       'Phidget TMP1200 1xRTD A', #68
                       'Phidget IO Digital 01',         #69
                       '+Phidget IO Digital 23',        #70
                       '+Phidget IO Digital 45',        #71
                       '+Phidget IO Digital 67',        #72
                       'Phidget 1011 IO Digital 01',    #73
                       'Phidget HUB IO Digital 01', #74
                       '+Phidget HUB IO Digital 23',#75
                       '+Phidget HUB IO Digital 45',#76
                       'VOLTCRAFT PL-125-T4',       #77
                       '+VOLTCRAFT PL-125-T4 34',   #78
                       'S7',                        #79
                       '+S7 34',                    #80
                       '+S7 56',                    #81
                       '+S7 78',                    #82
                       'Aillio Bullet R1 BT/DT',             #83
                       '+Aillio Bullet R1 Heater/Fan',       #84
                       '+Aillio Bullet R1 BT RoR/Drum',      #85
                       '+Aillio Bullet R1 Voltage/Exhaust',  #86
                       '+Aillio Bullet R1 State/Fan RPM',    #87
                       '+Program 78',               #88
                       '+Program 910',              #89
                       '+Slider 01',                #90
                       '+Slider 23',                #91
                       '-Probat Middleware',                 #92
                       '-Probat Middleware burner/drum',     #93
                       '-Probat Middleware fan/pressure',    #94
                       'Phidget DAQ1400 Current',   #95
                       'Phidget DAQ1400 Frequency', #96
                       'Phidget DAQ1400 Digital',   #97
                       'Phidget DAQ1400 Voltage',   #98
                       'Aillio Bullet R1 IBTS/BT',  #99
                       'Yocto IR',                  #100
                       'Behmor BT/CT',              #101
                       '+Behmor 34',                #102
                       'VICTOR 86B',                #103
                       '+Behmor 56',                #104
                       '+Behmor 78',                #105
                       'Phidget HUB IO 0',          #106
                       'Phidget HUB IO Digital 0',  #107
                       'Yocto 4-20mA Rx',           #108
                       '+MODBUS 78',                #109
                       '+S7 910',                   #110
                       'WebSocket',                 #111
                       '+WebSocket 34',             #112
                       '+WebSocket 56',             #113
                       '+Phidget TMP1200 1xRTD B',  #114
                       'HB BT/ET',                  #115
                       '+HB DT/IT',                 #116
                       '+HB AT',                    #117
                       '+WebSocket 78',             #118
                       '+WebSocket 910',            #119
                       'Yocto 0-10V Rx',            #120
                       'Yocto milliVolt Rx',        #121
                       'Yocto Serial',              #122
                       'Phidget VCP1000',           #123
                       'Phidget VCP1001',           #124
                       'Phidget VCP1002',           #125
                       'ARC BT/ET',                 #126
                       '+ARC MET/IT',               #127
                       '+ARC AT'                    #128
                       ]

        # ADD DEVICE:
        # ids of (main) Phidget devices (without a + in front of their name string)
        self.phidgetDevices : Final = [
            34, # Phidget 1048
            37, # Phidget 1046
            40, # Phidget IO
            47, # Phidget 1045
            52, # Phidget 1051
            58, # Phidget TMP1101
            61, # Phidget TMP1100
            62, # Phidget 1011
            63, # Phidget HUB IO 01
            68, # Phidget TMP1200
            69, # Phidget IO Digital
            73, # Phidget 1011 IO Digital
            74, # Phidget HUB IO Digital 01
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            123, # Phidget VCP1000
            124, # Phidget VCP1001
            125  # Phidget VCP1002
        ]

        # ADD DEVICE:
        # ids of (main) devices (without a + in front of their name string)
        # that do NOT communicate via any serial port thus do not need any serial port configuration
        self.nonSerialDevices : Final = self.phidgetDevices + [
            27, # Program
            45, # Yocto Thermocouple
            46, # Yocto PT100
            79, # S7
            83, # Aillio Bullet R1 BT/DT
            99, # Aillio Bullet R1 IBTS/BT
            100, # Yocto IR
            108, # Yocto 4-20mA Rx
            111,  # WebSocket
            120, # Yocto-0-10V-Rx
            121, # Yocto-milliVolt-Rx
            122  # Yocto-Serial
        ]

        # ADD DEVICE:
        # ids of devices temperature conversions should not be applied
        self.nonTempDevices : Final = [
            22, # +PID SV/DUTY %
            25, # +Virtual
            40, # Phidget IO 01
            41, # +Phidget IO 23
            42, # +Phidget IO 45
            43, # +Phidget IO 67
            50, # DUMMY
            54, # +Hottop Heater/Fan
            57, # EXTECH 755
            62, # Phidget 1011 IO 01
            63, # Phidget HUB IO 01
            64, # +Phidget HUB IO 23
            65, # +Phidget HUB IO 45
            69, # Phidget IO Digital 01
            70, # +Phidget IO Digital 23
            71, # +Phidget IO Digital 45
            72, # +Phidget IO Digital 67
            73, # Phidget 1011 IO Digital 01
            74, # Phidget HUB IO Digital 0
            75, # +Phidget HUB IO Digital 23
            76, # +Phidget HUB IO Digital 45
            84, # +Aillio Bullet R1 Heater/Fan
            87, # +Aillio Bullet R1 State
            90, # +Slider 01
            91, # +Slider 23
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            108, # Yocto 4-20mA Rx
            120, # Yocto-0-10V-Rx
            121, # Yocto-milliVolt-Rx
            122, # Yocto-Serial
            123, # Phidget VCP1000
            124, # Phidget VCP1001
            125  # Phidget VCP1002
        ]

        #extra devices
        self.extradevices = []                                      # list with indexes for extra devices
        self.extratimex = []                                        # individual time for each extra device (more accurate). List of lists (2 dimension)
        self.extradevicecolor1 = []                                 # extra line 1 color. list with colors.
        self.extradevicecolor2 = []                                 # extra line 2 color. list with colors.
        self.extratemp1,self.extratemp2 = [],[]                     # extra temp1, temp2. List of lists
        self.extrastemp1,self.extrastemp2 = [],[]                   # smoothed extra temp1, temp2. List of lists
        self.extractimex1,self.extractimex2,self.extractemp1,self.extractemp2 = [],[],[],[] # variants of extratimex/extratemp1/extratemp2 with -1 dropout values removed (or replaced by None)
        # NOTE: those extractimexN, extractempBN lists can be shorter than the regular extratimexN, extratempN lists,
        # however, the invariants len(extractimex1) = len(extractemp1) and len(extractimex2) = len(extractemp2) always hold
        self.extratemp1lines,self.extratemp2lines = [],[]           # lists with extra lines for speed drawing
        self.extraname1,self.extraname2 = [],[]                     # name of labels for line (like ET or BT) - legend
        self.extramathexpression1,self.extramathexpression2 = [],[]           # list with user defined math evaluating strings. Example "2*cos(x)"
        self.extralinestyles1,self.extralinestyles2 = [],[]         # list of extra curve line styles
        self.extradrawstyles1,self.extradrawstyles2 = [],[]         # list of extra curve drawing styles
        self.extralinewidths1,self.extralinewidths2 = [],[]         # list of extra curve linewidth
        self.extramarkers1,self.extramarkers2 = [],[]               # list of extra curve marker styles
        self.extramarkersizes1,self.extramarkersizes2 = [],[]       # list of extra curve marker size

        self.devicetablecolumnwidths = []

        # the following two list are generated on ON from the extradevices types and might be longer or smaller than len(self.extradevices)
        # if no entry is available, a temperature curve that needs C<->F translation is assumed
        # note that ET/BT main curves are assumed to always hold temperatures
        self.extraNoneTempHint1 = []                                # list of flags indicating which extra 1 curves are not holding temperature values
        self.extraNoneTempHint2 = []                                # list of flags indicating which extra 2 curves are not holding temperature values

        #holds math expressions to plot
        self.plotcurves=['']*9
        self.plotcurvecolor = ['black']*9

        self.overlapList = []

        self.tight_layout_params: Final = {'pad':.3,'h_pad':0.0,'w_pad':0.0} # slightly less space for axis labels
        self.fig = Figure(tight_layout=self.tight_layout_params,frameon=True,dpi=dpi)
        # with tight_layout=True, the matplotlib canvas expands to the maximum using figure.autolayout

        self.fig.patch.set_facecolor(str(self.palette['canvas']))

        self.ax = self.fig.add_subplot(111,facecolor=self.palette['background'])
        self.delta_ax = self.ax.twinx()

        #legend location
        self.legendloc = 7
        self.legendloc_pos = None # holds the custom position of the legend set on profile load and reset after first redraw

        self.fig.subplots_adjust(
            # all values in percent
            top=0.93, # the top of the subplots of the figure (default: 0.9)
            bottom=0.1, # the bottom of the subplots of the figure (default: 0.1)
            left=0.067, # the left side of the subplots of the figure (default: 0.125)
            right=.925) # the right side of the subplots of the figure (default: 0.9
        FigureCanvas.__init__(self, self.fig)

        self.fig.canvas.set_cursor = lambda _: None # deactivate the busy cursor on slow full redraws

        # important to make the Qt canvas transparent (note that this changes stylesheets of children like popups too!):
        self.fig.canvas.setStyleSheet('background-color:transparent;') # default is white

        self.onclick_cid = self.fig.canvas.mpl_connect('button_press_event', self.onclick)
        self.oncpick_cid = self.fig.canvas.mpl_connect('pick_event', self.onpick)
        self.ondraw_cid = self.fig.canvas.mpl_connect('draw_event', self._draw_event)

        self.fig.canvas.mpl_connect('button_release_event', self.onrelease_after_pick)

        # set the parent widget
        self.setParent(parent)
        # we define the widget as
        FigureCanvas.setSizePolicy(self,QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)  #@UndefinedVariable
        # notify the system of updated policy
        FigureCanvas.updateGeometry(self)  #@UndefinedVariable

        # the rate of change of temperature
        self.rateofchange1 = 0.0
        self.rateofchange2 = 0.0

        #read and plot on/off flag
        self.flagon = False  # Artisan turned on (sampling)
        self.flagstart = False # Artisan logging/recording
        self.flagKeepON = False # turn Artisan ON again after pressing OFF during recording
        self.flagOpenCompleted = False # after completing a recording with OFF, send the saved profile to be opened in the ArtisanViewer
        self.flagsampling = False # if True, Artisan is still in the sampling phase and one has to wait for its end to turn OFF
        self.flagsamplingthreadrunning = False
        #log flag that tells to log ET when using device 18 (manual mode)
        self.manuallogETflag = 0

        self.zoom_follow = False # if True, Artisan "follows" BT in the center by panning during recording. Activated via a click on the HOME icon

        #self.flagalignFCs = False
        self.alignEvent = 0 # 0:CHARGE, 1:DRY, 2:FCs, 3:FCe, 4:SCs, 5:SCe, 6:DROP, 7:ALL
        self.alignnames = [
            QApplication.translate('Label','CHARGE'),
            QApplication.translate('Label','DRY'),
            QApplication.translate('Label','FCs'),
            QApplication.translate('Label','FCe'),
            QApplication.translate('Label','SCs'),
            QApplication.translate('Label','SCe'),
            QApplication.translate('Label','DROP'),
            QApplication.translate('Label','ALL'),
            ]
        self.compareAlignEvent = 0 # 0:CHARGE, 1:DRY, 2:FCs, 3:FCe, 4:SCs, 5:SCe, 6:DROP
        self.compareEvents = 0 # 0: no events, 1: event type 1, 2: event type 2, 3: event type 3, 4: event type 4
        self.compareET = False
        self.compareBT = True
        self.compareDeltaET = False
        self.compareDeltaBT = True
        self.compareMainEvents = True
        # Comparator: Roast (compareBBP=False & compareRoast=True); BBP+Roast (compareBBP=True & compareRoast=True); BBP (compareBBP=True & compareRoast=False)
        #   the state compareBBP=False and compareRoast=False should never occur
        self.compareBBP = False # if True incl. BBP
        self.compareRoast = True # if False roast should not be compared (self.compareBBP should be True in this case!)

        self.replayType = 0 # 0: by time, 1: by BT, 2: by ET
        self.replayedBackgroundEvents = [] # set of BackgroundEvent indices that have already been replayed (cleared in ClearMeasurements)
        self.beepedBackgroundEvents = [] # set of BackgroundEvent indices that have already been beeped for (cleared in ClearMeasurements)

        self.roastpropertiesflag = 1  #resets roast properties if not zero
        self.roastpropertiesAutoOpenFlag = 0  #open roast properties dialog on CHARGE if not zero
        self.roastpropertiesAutoOpenDropFlag = 0  #open roast properties dialog on DROP if not zero
        self.title = QApplication.translate('Scope Title', 'Roaster Scope')
        self.title_show_always = False
        self.ambientTemp = 0.
        self.ambientTemp_sampled = 0. # keeps the measured ambientTemp over a restart
        self.ambientTempSource = 0 # indicates the temperature curve that is used to automatically fill the ambient temperature on DROP
#                                  # 0 : None; 1 : ET, 2 : BT, 3 : 0xT1, 4 : 0xT2,
        self.ambient_temperature_device = 0
        self.ambient_pressure = 0.
        self.ambient_pressure_sampled = 0. # keeps the measured ambientTemp over a restart
        self.ambient_pressure_device = 0
        self.ambient_humidity = 0.
        self.ambient_humidity_sampled = 0. # keeps the measured ambientTemp over a restart
        self.ambient_humidity_device = 0
        self.elevation = 0

        self.temperaturedevicefunctionlist: Final = [
            '',                #0
            'Phidget HUM100x', #1
            'Yocto Meteo',     #2
            'Phidget TMP1000', #3
        ]
        self.humiditydevicefunctionlist: Final = [
            '',                #0
            'Phidget HUM100x', #1
            'Yocto Meteo',     #2
        ]
        self.pressuredevicefunctionlist: Final = [
            '',                #0
            'Phidget PRE1000', #1
            'Yocto Meteo',     #2
        ]

        self.moisture_greens = 0.
        self.moisture_roasted = 0.
        self.greens_temp = 0.

        self.beansize = 0.0
        self.beansize_min = 0
        self.beansize_max = 0

        self.whole_color = 0
        self.ground_color = 0
        self.color_systems: Final = ['','Tonino','ColorTest','Colorette','ColorTrack','Agtron']
        self.color_system_idx = 0

        # roast property flags
        self.heavyFC_flag = False
        self.lowFC_flag = False
        self.lightCut_flag = False
        self.darkCut_flag = False
        self.drops_flag = False
        self.oily_flag = False
        self.uneven_flag = False
        self.tipping_flag = False
        self.scorching_flag = False
        self.divots_flag = False

        #list to store the time in seconds of each reading. Most IMPORTANT variable.
        self.timex = []

        #lists to store temps and rates of change. Second most IMPORTANT variables. All need same dimension.
        #self.temp1 = ET ; self.temp2 = BT; self.delta1 = deltaMET; self.delta2 = deltaBT
        self.temp1,self.temp2,self.delta1, self.delta2 = [],[],[],[]
        self.stemp1,self.stemp2 = [],[] # smoothed versions of temp1/temp2 used in redraw()
        self.tstemp1,self.tstemp2 = [],[] # (temporarily) smoothed version of temp1/temp2 used in sample() to compute the RoR
        self.ctimex1, self.ctimex2, self.ctemp1,self.ctemp2 = [], [],[],[] # (potential shorter) variants of timex/temp1/temp2 with -1 dropout values removed (or replaced by None)
        # NOTE: those ctimexN, ctempN lists can be shorter than the original timex/tempN lists as some dropout values may have been removed,
        # however, the invariants len(ctimex1) = len(ctemp1) and len(timex2) = len(ctemp2) always hold
        self.unfiltereddelta1, self.unfiltereddelta2 = [],[] # Delta mathexpressions applied; used in sample()
        self.unfiltereddelta1_pure, self.unfiltereddelta2_pure = [],[] # Delta mathexpressions not applied; used in sample() and by projections

        # arrays to use while monitoring but not recording
        self.on_timex = []
        self.on_temp1 = []
        self.on_temp2 = []
        self.on_ctimex1 = []
        self.on_ctemp1 = []
        self.on_ctimex2 = []
        self.on_ctemp2 = []
        self.on_tstemp1 = []
        self.on_tstemp2 = []
        self.on_unfiltereddelta1 = []
        self.on_unfiltereddelta2 = []
        self.on_delta1 = []
        self.on_delta2 = []
        # list of lists:
        self.on_extratemp1 = []
        self.on_extratemp2 = []
        self.on_extratimex = []
        self.on_extractimex1 = []
        self.on_extractemp1 = []
        self.on_extractimex2 = []
        self.on_extractemp2 = []

        #indexes for CHARGE[0],DRYe[1],FCs[2],FCe[3],SCs[4],SCe[5],DROP[6] and COOLe[7]
        #Example: Use as self.timex[self.timeindex[1]] to get the time of DryEnd
        #Example: Use self.temp2[self.timeindex[4]] to get the BT temperature of SCs

        self.timeindex = [-1,0,0,0,0,0,0,0] #CHARGE index init set to -1 as 0 could be an actal index used

        #applies a Y(x) function to ET or BT
        self.ETfunction,self.BTfunction = '',''

        #applies a Y(x) function to DeltaET or DeltaBT
        self.DeltaETfunction,self.DeltaBTfunction = '',''

        #put a "aw.qmc.safesaveflag = True" whenever there is a change of a profile like at [DROP], edit properties Dialog, etc
        #prevents accidentally deleting a modified profile. ("dirty file")
        #ATTENTION: never change this flag directly. Use the methods aw.qmc.fileDirty() and aw.qmc.fileClean() instead!!
        self.safesaveflag = False

        self.pid = pid.PID()

        #background profile
        self.background = False # set to True if loaded background profile is shown and False if hidden
        self.backgroundprofile = None # if not None, a background profile is loaded
        self.backgroundprofile_moved_x = 0 # background profile moved in horizontal direction
        self.backgroundprofile_moved_y = 0 # background profile moved in vertical direction
        self.backgroundDetails = True
        self.backgroundeventsflag = True
        self.backgroundpath = ''
        self.backgroundUUID = None
        self.backgroundmovespeed = 30
        self.backgroundShowFullflag = False
        self.titleB = ''
        self.roastbatchnrB = 0
        self.roastbatchprefixB = ''
        self.roastbatchposB = 1
        self.temp1B,self.temp2B,self.temp1BX,self.temp2BX,self.timeB,self.temp1Bdelta,self.temp2Bdelta = [],[],[],[],[],[],[]
        self.stemp1B,self.stemp2B,self.stemp1BX,self.stemp2BX = [],[],[],[] # smoothed versions of the background curves
        self.extraname1B,self.extraname2B = [],[]
        self.extratimexB = []
        self.xtcurveidx = 0 # the selected first extra background courve to be displayed
        self.ytcurveidx = 0 # the selected second extra background courve to be displayed
        self.delta1B,self.delta2B = [],[]
        self.timeindexB = [-1,0,0,0,0,0,0,0]
        self.TP_time_B_loaded = None # the time in seconds the background TP happened. TP_time_B_loaded does not change and should be used for display
        self.backgroundEvents = [] #indexes of background events
        self.backgroundEtypes = []
        self.backgroundEvalues = []
        self.backgroundEStrings = []
        self.backgroundalpha = 0.2
        self.backgroundmetcolor = self.palette['et']
        self.backgroundbtcolor = self.palette['bt']
        self.backgroundxtcolor = self.palette['xt']
        self.backgroundytcolor = self.palette['yt']
        self.backgrounddeltaetcolor = self.palette['deltaet']
        self.backgrounddeltabtcolor = self.palette['deltabt']
        self.backmoveflag = 1 # aligns background on redraw if 1
        self.detectBackgroundEventTime = 20 #seconds
        self.backgroundReproduce = False
        self.backgroundReproduceBeep = False
        self.backgroundPlaybackEvents = False
        self.backgroundPlaybackDROP = False
        self.Betypes = [QApplication.translate('ComboBox', 'Air'),
                        QApplication.translate('ComboBox', 'Drum'),
                        QApplication.translate('ComboBox', 'Damper'),
                        QApplication.translate('ComboBox', 'Burner'),
                        '--']
        self.backgroundFlavors = []
        self.flavorbackgroundflag = False
        #background by value
        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
        self.l_backgroundeventtype1dots = None
        self.l_backgroundeventtype2dots = None
        self.l_backgroundeventtype3dots = None
        self.l_backgroundeventtype4dots = None

        # background Deltas
        self.DeltaETBflag = False
        self.DeltaBTBflag = True
        self.clearBgbeforeprofileload = False
        self.hideBgafterprofileload = False

        self.heating_types: Final = [
            '',
            QApplication.translate('ComboBox', 'Propane Gas (LPG)'),
            QApplication.translate('ComboBox', 'Natural Gas (NG)'),
            QApplication.translate('ComboBox', 'Electric')
        ]

        #General notes. Accessible through "edit graph properties" of graph menu. WYSIWYG viewer/editor.
        # setup of the current profile
        self.operator: str = ''
        self.organization: str = ''
        self.roastertype: str = ''
        self.roastersize: int = 0
        self.roasterheating = 0 # 0: ??, 1: LPG, 2: NG, 3: Elec
        self.drumspeed: str = ''
        # kept in app settings
        self.organization_setup = ''
        self.operator_setup = ''
        self.roastertype_setup = ''
        self.roastersize_setup = 0 # in kg
        self.roasterheating_setup = 0
        self.drumspeed_setup = ''
        #
        self.last_batchsize = 0 # in unit of self.weight[2]; remember the last batchsize used to be applied as default for the next batch
        #
        self.machinesetup_energy_ratings = None # read from predefined machine setups and used if available to set energy defaults
        #
        self.machinesetup = ''
        self.roastingnotes = ''
        self.cuppingnotes = ''
        self.roastdate = QDateTime.currentDateTime()
        # system batch nr system
        self.roastepoch = self.roastdate.toSecsSinceEpoch() # in seconds
        self.lastroastepoch = self.roastepoch # the epoch of the last roast in seconds
        self.batchcounter = -1 # global batch counter; if batchcounter is -1, batchcounter system is inactive
        self.batchsequence = 1 # global counter of position in sequence of batches of one session
        self.batchprefix = ''
        self.neverUpdateBatchCounter = False
        # profile batch nr
        self.roastbatchnr = 0 # batch number of the roast; if roastbatchnr=0, prefix/counter is hidden/inactiv (initialized to 0 on roast START)
        self.roastbatchprefix = self.batchprefix # batch prefix of the roast
        self.roastbatchpos = 1 # position of the roast in the roast session (first batch, second batch,..)
        self.roasttzoffset = libtime.timezone # timezone offset to be added to roastepoch to get time in local timezone; NOTE: this is not set/updated on loading a .alog profile!
        # profile UUID
        self.roastUUID = None

#PLUS
        # the default store selected by the user (save in the  app settings)
        self.plus_default_store = None
        # the current profiles coffee or blend and associated store ids (saved in the *.alog profile)
        self.plus_store = None # holds the plus hr_id of the selected store of the current profile or None
        self.plus_store_label = None # holds the plus label of the selected store of the current profile or None
        self.plus_coffee = None # holds the plus hr_id of the selected coffee of the current profile or None
        self.plus_coffee_label = None # holds the plus label of the selected coffee of the current profile or None
        self.plus_blend_spec = None # the plus blend structure [<blend_label>,[[<coffee_label>,<hr_id>,<ratio>],...,[<coffee_label>,<hr_id>,<ratio>]]] # label + ingredients
        self.plus_blend_spec_labels = None # a list of labels as long as the list of ingredients in self.plus_blend_spec or None
        self.plus_blend_label = None # holds the plus selected label of the selected blend of the current profile or None
        self.plus_custom_blend = None # holds the one custom blend, an instance of plus.blend.Blend, or None
        self.plus_sync_record_hash = None
        self.plus_file_last_modified = None # holds the last_modified timestamp of the loaded profile as EPOCH (float incl. milliseconds as returned by time.time())
        # plus_file_last_modified is set on load, reset on RESET, and updated on save. It is also update, if not None and new data is received from the server (sync:applyServerUpdates)
        # this timestamp is used in sync:fetchServerUpdate to ask server for updated data

        self.beans = ''

        self.curveVisibilityCache = None # caches the users curve visibility settings to be reset after recording

        #flags to show projections, draw Delta ET, and draw Delta BT
        self.projectFlag = True
        self.projectDeltaFlag = False
        self.ETcurve = True
        self.BTcurve = True
        self.ETlcd = True
        self.BTlcd = True
        self.swaplcds = False # if set draw ET curver on top of BT curve and show ET LCD above BT LCD by default
        self.LCDdecimalplaces = 1
        self.foregroundShowFullflag = True
        self.DeltaETflag = False
        self.DeltaBTflag = True
        self.DeltaETlcdflag = False
        self.DeltaBTlcdflag = True
        self.swapdeltalcds = False
        self.PIDbuttonflag = True # TC4 PID firmware available?
        self.Controlbuttonflag = False # PID Control active (either internal/external or Fuji)
        # user filter values x are translated as follows to internal filter values: y = x*2 + 1 (to go the other direction: x = y/2)
        # this is to ensure, that only uneven window values are used and no wrong shift is happening through smoothing
        self.deltaETfilter = 7 # => corresponds to 3 on the user interface
        self.deltaBTfilter = 7 # => corresponds to 3 on the user interface
        self.curvefilter = 3 # => corresponds to 1 on the user interface
        # a deltaET span of 0 indicates that the delta RoR is computed by two succeeding readings
        self.deltaETspan = 20 # the time period taken to compute one deltaET value (1-30sec) # deltaETspan >= 0
        self.deltaBTspan = 20 # the time period taken to compute one deltaBT value (1-30sec) # deltaBTspan >= 0
        # deltaETsamples == 1 (sample) implies that the delta RoR is computed from only two readings:
        self.deltaETsamples: int = 6 # the number of samples that make up the delta span, to be used in the delta computations (>= 1!)
        self.deltaBTsamples: int = 6 # the number of samples that make up the delta span, to be used in the delta computations (>= 1!)
        self.profile_sampling_interval = None # will be updated on loading a profile
        self.background_profile_sampling_interval = None # will be updated on loading a profile into the background
        self.profile_meter = 'Unknown' # will be updated on loading a profile

        self.optimalSmoothing = False
        self.polyfitRoRcalc = False

        self.patheffects = 1
        self.graphstyle = 0
        self.graphfont = 0

        #variables to configure the 8 default buttons
        # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END;
        self.buttonvisibility = [True,True,True,True,True,False,True,False]
        self.buttonactions = [0]*8
        self.buttonactionstrings = ['']*8
        #variables to configure the 0: ON, 1: OFF, 2: SAMPLE, 3:RESET, 4:START
        self.extrabuttonactions = [0]*3
        self.extrabuttonactionstrings = ['']*3
        #variables to configure the 0:RESET, 1:START
        self.xextrabuttonactions = [0]*2
        self.xextrabuttonactionstrings = ['']*2

        #flag to activate the automatic marking of the CHARGE and DROP events
        self.chargeTimerFlag: bool = False
        self.chargeTimerPeriod: int = 0 # period until CHARGE since START if CHARGE timer is active
        self.autoChargeFlag: bool = True
        self.autoDropFlag: bool = True
        #autodetected CHARGE and DROP index
        self.autoChargeIdx = 0
        self.autoDropIdx = 0

        self.markTPflag = True
        self.autoTPIdx = 0 # set by sample() on recognition and cleared once TP is marked

        # flags to control automatic DRY and FCs events based on phases limits
        self.autoDRYflag = False
        self.autoFCsFlag = False

        self.autoCHARGEenabled = True # gets disabled on undo of the CHARGE event and prevents further autoCHARGE marks
        self.autoDRYenabled = True # gets disabled on undo of the DRY event and prevents further autoDRY marks
        self.autoFCsenabled = True # gets disabled on undo of the FCs event and prevents further autoFCs marks
        self.autoDROPenabled = True # gets disabled on undo of the DROP event and prevents further autoDROP marks

        self.autoDryIdx = 0 # set by sample() on recognition and cleared once DRY is marked
        self.autoFCsIdx = 0 # set by sample() on recognition and cleared once FCs is marked


        # projection variables of change of rate
        self.projectionconstant = 1
        self.projectionmode = 0     # 0 = linear; 1 = quadratic;   # 2 = newton#disabled

        # profile transformator mapping mode
        self.transMappingMode = 0 # 0: discrete, 1: linear, 2: quadratic

        self.weight_units = ['g','Kg','lb','oz']
        #[0]weight in, [1]weight out, [2]units (string)
        self.weight = [0,0,self.weight_units[0]]

        self.volume_units = ['l','gal','qt','pt','cup','ml']
        #[0]volume in, [1]volume out, [2]units (string)
        self.volume = [0,0,self.volume_units[0]]

        #[0]probe weight, [1]weight unit, [2]probe volume, [3]volume unit
#        self.density = [0.,self.weight_units[0],1.,self.volume_units[0]]
        self.density = [0,'g',1.,'l']
        # density weight and volume units are not to be used any longer and assumed to be fixed to g/l
        # thus also probe volume is not used anymore, and only self.density[0] holds the green been density in g/l

        self.density_roasted = [0,'g',1.,'l'] # this holds the roasted beans density in g/l


        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if not QSettings().value('AppleMetricUnits'):
                    self.weight = [0,0,self.weight_units[2]]
                    self.volume = [0,0,self.volume_units[1]]
            except Exception: # pylint: disable=broad-except
                pass

        self.volumeCalcUnit = 0
        self.volumeCalcWeightInStr = ''
        self.volumeCalcWeightOutStr = ''

        # container scale tare
        self.container_names = []
        self.container_weights = [] # all weights in g and as int
        self.container_idx = -1 # the empty field (as -1 + 2 = 1)

        #stores _indexes_ of self.timex to record events.
        # Use as self.timex[self.specialevents[x]] to get the time of an event
        # use self.temp2[self.specialevents[x]] to get the BT temperature of an event.
        self.specialevents = []
        #ComboBox text event types. They can be modified in eventsDlg()
        self.etypes = [QApplication.translate('ComboBox', 'Air'),
                       QApplication.translate('ComboBox', 'Drum'),
                       QApplication.translate('ComboBox', 'Damper'),
                       QApplication.translate('ComboBox', 'Burner'),
                       '--']
        #default etype settings to restore
        self.etypesdefault: Final = [QApplication.translate('ComboBox', 'Air'),
                              QApplication.translate('ComboBox', 'Drum'),
                              QApplication.translate('ComboBox', 'Damper'),
                              QApplication.translate('ComboBox', 'Burner'),
                              '--']
        #stores the type of each event as index of self.etypes. None = 0, Power = 1, etc.
        self.specialeventstype = []
        #stores text string descriptions for each event.
        self.specialeventsStrings = []
        #event values are from 0-10
        #stores the value for each event
        self.specialeventsvalue = []
        #flag that makes the events location type bars (horizontal bars) appear on the plot. flag read on redraw()
        # 0 = no event bars (flags); 1 = type bars (4 bars); 2 = step lines; 3 = step+ (combination of 0 and 2); 4 = combo (as 2, but values rendered on lines instead of flags)
        self.eventsGraphflag = 2
        self.clampEvents = False # if True, custom events are drawn w.r.t. the temperature scale
        self.renderEventsDescr = False # if True, descriptions are rendered instead of type/value tags
        self.eventslabelschars = 6 # maximal number of chars to render as events label
        #flag that shows events in the graph
        self.eventsshowflag = 1
        #flag that shows major event annotations in the graph
        self.annotationsflag = 1
        #shows events anchored to the BT curve if true, events anchored to greater of ET or BT curve if false
        self.showeventsonbt = False
        #selectively show/hide event types
        self.showEtypes = [True]*5
        #plot events by value
        self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
        self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
        self.EvalueColor = self.EvalueColor_default.copy()
        self.EvalueTextColor = self.EvalueTextColor_default.copy()
        self.EvalueMarker = ['o','s','h','D']
        self.EvalueMarkerSize = [4,4,4,4]
        self.Evaluelinethickness = [1,1,1,1]
        self.Evaluealpha = [.8,.8,.8,.8]
        #the event value position bars are calculated at redraw()
        self.eventpositionbars = [0.]*120
        self.specialeventannotations = ['','','','']
        self.specialeventannovisibilities = [0,0,0,0]
        self.specialeventplaybackaid = [True, True, True, True] # per event type decides if playback aid is active
        self.specialeventplayback = [True, True, True, True] # per event type decides if background events are playbacked or not
        self.overlappct = 100

        #curve styles
        self.linestyle_default: Final = '-'
        self.drawstyle_default: Final = 'default'
        self.linewidth_default: Final = 1.5
        self.back_linewidth_default: Final = 2
        self.delta_linewidth_default: Final = 1
        self.back_delta_linewidth_default: Final = 1.5
        self.extra_linewidth_default: Final = 1
        self.marker_default: Final = None
        self.markersize_default: Final = 6

        self.BTlinestyle = self.linestyle_default
        self.BTdrawstyle = self.drawstyle_default
        self.BTlinewidth = self.linewidth_default
        self.BTmarker = self.marker_default
        self.BTmarkersize = self.markersize_default
        self.ETlinestyle = self.linestyle_default
        self.ETdrawstyle = self.drawstyle_default
        self.ETlinewidth = self.linewidth_default
        self.ETmarker = self.marker_default
        self.ETmarkersize = self.markersize_default
        self.BTdeltalinestyle = self.linestyle_default
        self.BTdeltadrawstyle = self.drawstyle_default
        self.BTdeltalinewidth = self.delta_linewidth_default
        self.BTdeltamarker = self.marker_default
        self.BTdeltamarkersize = self.markersize_default
        self.ETdeltalinestyle = self.linestyle_default
        self.ETdeltadrawstyle = self.drawstyle_default
        self.ETdeltalinewidth = self.delta_linewidth_default
        self.ETdeltamarker = self.marker_default
        self.ETdeltamarkersize = self.markersize_default
        self.BTbacklinestyle = self.linestyle_default
        self.BTbackdrawstyle = self.drawstyle_default
        self.BTbacklinewidth = self.back_linewidth_default
        self.BTbackmarker = self.marker_default
        self.BTbackmarkersize = self.markersize_default
        self.ETbacklinestyle = self.linestyle_default
        self.ETbackdrawstyle = self.drawstyle_default
        self.ETbacklinewidth = self.back_linewidth_default
        self.ETbackmarker = self.marker_default
        self.ETbackmarkersize = self.markersize_default
        self.XTbacklinestyle = self.linestyle_default
        self.XTbackdrawstyle = self.drawstyle_default
        self.XTbacklinewidth = self.extra_linewidth_default
        self.XTbackmarker = self.marker_default
        self.XTbackmarkersize = self.markersize_default
        self.YTbacklinestyle = self.linestyle_default
        self.YTbackdrawstyle = self.drawstyle_default
        self.YTbacklinewidth = self.extra_linewidth_default
        self.YTbackmarker = self.marker_default
        self.YTbackmarkersize = self.markersize_default
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.back_delta_linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.back_delta_linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default

        #Temperature Alarms lists. Data is written in  alarmDlg
        self.alarmsetlabel = ''
        self.alarmflag = []    # 0 = OFF; 1 = ON flags
        self.alarmguard = []   # points to another alarm by index that has to be triggered before; -1 indicates no guard
        self.alarmnegguard = []   # points to another alarm by index that should not has been triggered before; -1 indicates no guard
        self.alarmtime = []    # time event after which each alarm becomes effective. Usage: self.timeindex[self.alarmtime[i]]
#                               # -1 : START.
#                               # 0: CHARGE, 1: DRY END; 2: FCs, 3: FCe, 4: SCs, 5: SCe, 6: DROP, 7: COOL (corresponding to those timeindex positions)
#                               # 8: TP
#                               # 9: ON
#                               # 10: If Alarm
        self.alarmoffset = []  # for timed alarms, the seconds after alarmtime the alarm is triggered
        self.alarmtime2menuidx: Final = [2,4,5,6,7,8,9,10,3,0,11,1] # maps self.alarmtime index to menu idx (to move TP in menu from index 9 to 3)
        self.menuidx2alarmtime: Final = [9,-1,0,8,1,2,3,4,5,6,7,10] # inverse of above (note that those two are only inverse in one direction!)
        self.alarmcond = []    # 0 = falls below; 1 = rises above
        # alarmstate is set to 'not triggered' on reset(). This is needed so that the user does not have to turn the alarms ON next roast after alarm being used once.
        self.alarmstate = []   # <idx>=triggered, -1=not triggered.
        self.alarmsource = []   # -3=None, -2=DeltaET, -1=DeltaBT, 0=ET , 1=BT, 2=extratemp1[0], 3=extratemp2[0], 4=extratemp2[1],....
        self.alarmtemperature = []  # set temperature number (example 500; can be negative)
        self.alarmaction = []       # -1 = no action; 0 = open a window;
                                    # 1 = call program with a filepath equal to alarmstring;
                                    # 2 = activate button with number given in description;
                                    # 3,4,5,6 = move slider with value given in description
                                    # 7 (START), 8 (DRY), 9 (FCs), 10 (FCe), 11 (SCs), 12 (SCe), 13 (DROP), 14 (COOL), 15 (OFF)
                                    # 16 (CHARGE),
                                    # 17 (RampSoak_ON), 18 (RampSoak_OFF), 19 (PID_ON), 20 (PID_OFF)
        self.alarmbeep = []    # 0 = OFF; 1 = ON flags
        self.alarmstrings = []      # text descriptions, action to take, or filepath to call another program (comments after # are ignored)
        self.alarmtablecolumnwidths = []
        self.silent_alarms = False # if this is true (can be set via a + button action "alarm(1)", alarms are triggered, but actions are not fired

        # alarm sets
        self.alarmsets_count: Final = 10 # number of alarm sets
        self.alarmsets = []
        for _ in range(self.alarmsets_count):
            self.alarmsets.append([
                '',
                [], # alarmflags
                [], # alarmguards
                [], # alarmnegguards
                [], # alarmtimes
                [], # alarmoffsets
                [], # alarmsources
                [], # alarmconds
                [], # alarmtemperatures
                [], # alarmactions
                [], # alarmbeeps
                [], # alarmstrings
            ])

        self.loadalarmsfromprofile = False # if set, alarms are loaded from profile
        self.loadalarmsfrombackground = False # if set, alarms are loaded from background profiles
        self.alarmsfile = '' # filename alarms were loaded from
        self.temporaryalarmflag = -3 #holds temporary index value of triggered alarm in updategraphics()
        self.TPalarmtimeindex = None # is set to the current  aw.qmc.timeindex by sample(), if alarms are defined and once the TP is detected

        self.rsfile = '' # filename Ramp/Soak patterns were loaded from

        self.temporary_error = None # set by adderror() to a new error message, send to the message line by updategraphics()
        self.temporarymovepositiveslider = None # set by pidcontrol.setEnergy (indirectly called from sample())
                # holds tuple (slidernr,value) and is executed and reset by updategraphics
        self.temporarymovenegativeslider = None
        self.temporayslider_force_move = True # if True move the slider independent of the slider position to fire slider action!

        self.quantifiedEvent = [] # holds an event quantified during sample(), a tuple [<eventnr>,<value>,<recordEvent>]

        self.loadaxisfromprofile = False # if set, axis are loaded from profile

        # set initial limits for X and Y axes. But they change after reading the previous seetings at aw.settingsload()
        self.startofx_default: Final = -30
        self.endofx_default: Final = 600 # 10min*60

        self.xgrid_default: Final = 120

        self.ylimit_F_default: Final = 500
        self.ylimit_min_F_default: Final = 100
        self.ygrid_F_default: Final = 100
        self.zlimit_F_default: Final = 45
        self.zlimit_min_F_default: Final = 0
        self.zgrid_F_default: Final = 10

        self.ylimit_C_default: Final = 250
        self.ylimit_min_C_default: Final = 0
        self.ygrid_C_default: Final = 50
        self.zlimit_C_default: Final = 25
        self.zlimit_min_C_default: Final = 0
        self.zgrid_C_default: Final = 5

        self.temp_grid = False
        self.time_grid = False

        # maximum accepted min/max settings for y and z axis
        self.zlimit_max = 500
        self.zlimit_min_max = -500
        self.ylimit_max = 9999
        self.ylimit_min_max = -9999

        #----
        # set limits to F defaults

        self.ylimit = self.ylimit_F_default
        self.ylimit_min = self.ylimit_min_F_default
        self.zlimit = self.zlimit_F_default
        self.zlimit_min = self.zlimit_min_F_default


        # RoR display limits
        # user configurable RoR limits (only applied if flag is True; applied before TP during recording as well as full redraw)
        self.RoRlimitFlag = True
        self.RoRlimit = 95
        self.RoRlimitm = -95
        # system fixed RoR limits (only applied if flag is True; usually higher than the user configurable once and always applied)
        self.maxRoRlimit: Final = 170
        # axis limits
        self.endofx = self.endofx_default     # endofx is the display time in seconds of the right x-axis limit (excluding any shift of CHARGE time)
        self.startofx = self.startofx_default # startofx is the time in seconds of the left x-axis limit in data time (display time in seconds of the left x-axis limit plus the CHARGE time in seconds); NOTE: as startofx depends CHARGE it has to be adjusted whenever CHARGE is adjusted
        self.resetmaxtime = 600  #time when pressing RESET: 10min*60
        self.chargemintime = self.startofx_default  #time when pressing CHARGE: -30sec
        self.fixmaxtime = False # if true, do not automatically extend the endofx by 3min if needed because the measurements get out of the x-axis
        self.locktimex = False # if true, do not set time axis min and max from profile on load
        self.autotimex = True # automatically set time axis min and max from profile CHARGE/DROP on load
        self.autotimexMode = 0 # mode for autotimex with 0: profile (CHARGE/DROP(, 1: BBP+profile (START/DROP), 2: BBP (START/CHARGE)
        self.autodeltaxET = False # automatically set the delta axis max to the max(DeltaET)
        self.autodeltaxBT = False # automatically set the delta axis max to the max(DeltaBT)
        self.locktimex_start = self.startofx_default # seconds of x-axis min as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.locktimex_end = self.endofx_default # seconds of x-axis max as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.xgrid = self.xgrid_default   #initial time separation; 60 = 1 minute
        self.ygrid = self.ygrid_F_default  #initial temperature separation
        self.zgrid = self.zgrid_F_default   #initial RoR separation
        self.gridstyles =    ['-','--','-.',':',' ']  #solid,dashed,dash-dot,dotted,None
        self.gridlinestyle = 0
        self.gridthickness = 1
        self.gridalpha = .2
        self.xrotation = 0

        #height of statistics bar
        self.statisticsheight = 650
        self.statisticsupper = 655
        self.statisticslower = 617

        # autosave
        self.autosaveflag = 0
        self.autosaveprefix = ''
        self.autosavepath = ''
        self.autosavealsopath = ''
        self.autosaveaddtorecentfilesflag = False

        self.autosaveimage = False # if true save an image along alog files

        self.autoasaveimageformat_types = ['PDF', 'PDF Report', 'SVG', 'PNG', 'JPEG', 'BMP', 'CSV', 'JSON']
        self.autosaveimageformat = 'PDF' # one of the supported image file formats PDF, SVG, PNG, JPEG, BMP, CSV, JSON

        #used to place correct height of text to avoid placing text over text (annotations)
        self.ystep_down = 0
        self.ystep_up = 0

        self.ax.set_xlim(self.startofx, self.endofx)
        self.ax.set_ylim(self.ylimit_min,self.ylimit)

        if self.delta_ax:
            self.delta_ax.set_xlim(self.startofx, self.endofx)
            self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
            self.delta_ax.set_autoscale_on(False)

        # disable figure autoscale
        self.ax.set_autoscale_on(False)

        #set grid + axis labels + title
        grid_axis = None
        if self.temp_grid and self.time_grid:
            grid_axis = 'both'
        elif self.temp_grid:
            grid_axis = 'y'
        elif self.time_grid:
            grid_axis = 'x'
        if grid_axis is not None:
            self.ax.grid(True,axis=grid_axis,color=self.palette['grid'],linestyle = self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha)

        #change label colors
        for label in self.ax.yaxis.get_ticklabels():
            label.set_color(self.palette['ylabel'])

        for label in self.ax.xaxis.get_ticklabels():
            label.set_color(self.palette['xlabel'])

        self.backgroundETcurve = True
        self.backgroundBTcurve = True

        # generates first "empty" plot (lists are empty) of temperature and deltaT
        self.l_temp1 = None
        self.l_temp2 = None
        self.l_delta1 = None
        self.l_delta2 = None
        self.l_back1 = None
        self.l_back2 = None
        self.l_back3 = None # first extra background curve
        self.l_back4 = None # second extra background curve
        self.l_delta1B = None
        self.l_delta2B = None

        self.l_subtitle = None # the subtitle artist if any as used to render the background title

        self.l_BTprojection = None
        self.l_ETprojection = None
        self.l_DeltaBTprojection = None
        self.l_DeltaETprojection = None

        self.l_AUCguide = None

        self.l_horizontalcrossline = None
        self.l_verticalcrossline = None

        self.l_timeline = None

        self.legend = None

        self.l_eventtype1dots = None
        self.l_eventtype2dots = None
        self.l_eventtype3dots = None
        self.l_eventtype4dots = None

        self.l_eteventannos = []
        self.l_bteventannos = []
        self.l_eventtype1annos = []
        self.l_eventtype2annos = []
        self.l_eventtype3annos = []
        self.l_eventtype4annos = []

        self.l_annotations = []
        self.l_background_annotations = []

        # NOTE: the l_annotations_pos_dict is set on profile load and its positions are preferred over those in l_annotations_dict, but deleted at the end of the first redraw()
        self.l_annotations_dict = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time annotations
        self.l_annotations_pos_dict = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time xyann coordinate pairs
        self.l_event_flags_dict = {} # associating event flag annotations id (event number) to its draggable text annotation
        self.l_event_flags_pos_dict = {} # associating event flag annotations id (event number) to its draggable text xyann coordinates

        self.ai = None # holds background logo image

        ###########################  TIME  CLOCK     ##########################
        # create an object time to measure and record time (in milliseconds)

        self.timeclock = ArtisanTime()

        ############################  Thread Server #################################################
        #server that spawns a thread dynamically to sample temperature (press button ON to make a thread press OFF button to kill it)
        self.threadserver = Athreadserver()


        ##########################     Designer variables       #################################
        self.designerflag = False
        self.designerconnections = [None,None,None,None]   #mouse event ids
        self.mousepress = None
        self.indexpoint = 0
        self.workingline = 2  #selects ET or BT
        self.eventtimecopy = []
        self.specialeventsStringscopy = []
        self.specialeventsvaluecopy = []
        self.specialeventstypecopy = []
        self.currentx = 0               #used to add point when right click
        self.currenty = 0               #used to add point when right click
        self.designertimeinit = [50,300,540,560,660,700,800,900]
        self.BTsplinedegree = 3
        self.ETsplinedegree = 3
        self.reproducedesigner = 0      #flag to add events to help reproduce (replay) the profile: 0 = none; 1 = sv; 2 = ramp
        self.designertemp1init = []
        self.designertemp2init = []

        ###########################         filterDropOut variables     ################################

        # constants

        self.filterDropOut_replaceRoR_period = 3
        self.filterDropOut_spikeRoR_period = 3

        # defaults

        self.filterDropOut_tmin_C_default = 10
        self.filterDropOut_tmax_C_default = 700
        self.filterDropOut_tmin_F_default = 50
        self.filterDropOut_tmax_F_default = 1292
        self.filterDropOut_spikeRoR_dRoR_limit_C_default = 4.2
        self.filterDropOut_spikeRoR_dRoR_limit_F_default = 7

        # variables

        self.filterDropOuts = True # Smooth Spikes
        self.filterDropOut_tmin = self.filterDropOut_tmin_F_default
        self.filterDropOut_tmax = self.filterDropOut_tmax_F_default
        self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_F_default # the limit of additional RoR in temp/sec compared to previous readings
        self.minmaxLimits = False
        self.dropSpikes = False
        self.dropDuplicates = False
        self.dropDuplicatesLimit = 0.3

        self.liveMedianETfilter = LiveMedian(3)
        self.liveMedianBTfilter = LiveMedian(3)
        self.liveMedianRoRfilter = LiveMedian(5) # the offline filter uses a window length of 5, introducing some delay, compared to the medfilt() in offline mode which does not introduce any delay

        self.interpolatemax = 3 # maximal number of dropped readings (-1) that will be interpolated

        self.swapETBT = False

        ###########################         wheel graph variables     ################################
        self.wheelflag = False
        #data containers for wheel
        self.wheelnames,self.segmentlengths,self.segmentsalpha,self.wheellabelparent,self.wheelcolor = [],[],[],[],[]

        #properties
        #store radius of each circle as percentage(sum of all must at all times add up to 100.0%)
        self.wradii = [25.,20.,20.,35.]
        #starting angle for each circle (0-360).
        self.startangle = [0,0,0,0]
        #text projection: 0 = Flat, 1 = perpendicular to center, 2 = radial from center
        self.projection = [0,1,1,2]
        self.wheeltextsize = [10,10,10,10]
        self.wheelcolorpattern = 0                  #pattern
        self.wheeledge = .02                        #overlapping decorative edge
        self.wheellinewidth = 1
        self.wheellinecolor = 'black'               #initial color of lines
        self.wheeltextcolor = 'black'               #initial color of text
        self.wheelconnections = [0,0,0]
        self.wheelx,self.wheelz = 0,0                   #temp variables to pass index values
        self.wheellocationx,self.wheellocationz = 0.,0.  #temp vars to pass mouse location (angleX+radiusZ)
        self.wheelaspect = 1.0

        # a nicer demo flavor wheel
        self.wheelnames = [[''], ['Fruity', 'Sour', 'Green', 'Other', 'Roasted', 'Spices', 'Nutty', 'Sweet', 'Floral'], ['Floral', 'Berry', 'Dried fruit', 'Other fruit', 'Citrus fruit', 'Sour', 'Alcohol', 'Olive oil', 'Raw', 'Green', 'Beany', 'Musty', 'Chemical', 'Pipe tobaco', 'Tobaco', 'Burnt', 'Cereal', 'Pungent', 'Pepper', 'Brown spice', 'Nutty', 'Cocoa', 'Brown sugar', 'Vanilla', 'Vanillin', 'Overall sweet', 'Sweet Aromatics', 'Black Tea']]
        self.segmentsalpha = [[0.09], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]]
        self.segmentlengths = [[100.0], [11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 5.109999999999999], [2.5549999999999997, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 3.95375, 3.95375, 3.95375, 5.930625, 5.930625, 2.37225, 2.37225, 2.37225, 2.37225, 2.37225, 2.5549999999999997]]
        self.wheellabelparent = [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 8, 8, 9]]
        self.wheelcolor = [['#fdfffb'], ['#cd001b', '#dea20e', '#186923', '#1693a6', '#bb3424', '#9b0f2f', '#976751', '#de4126', '#cf0055'], ['#d6588a', '#d33440', '#bb3435', '#ed513b', '#d47e1d', '#d9b913', '#a08727', '#91a41f', '#5e7927', '#309543', '#4d8a6d', '#8ca3a9', '#65b4c0', '#be9452', '#d7b06b', '#b07351', '#d4a04f', '#653540', '#bf2732', '#9f3845', '#ba7456', '#ac623b', '#c84347', '#f4866d', '#ee5e61', '#df4255', '#c33d4d', '#844a5a']]
        self.wheellinecolor = '#ffffff'
        self.wheeltextcolor = '#ffffff'
        self.wradii = [7.83, 30.9006201171875, 61.2693798828125]
        self.startangle = [0, 42, 33]
        self.wheeledge = 0.01
        self.wheellinewidth = 2
        self.projection = [1, 2, 2]


        self.samplingSemaphore = QSemaphore(1)
        self.profileDataSemaphore = QSemaphore(1)
        self.messagesemaphore = QSemaphore(1)
        self.errorsemaphore = QSemaphore(1)
        self.serialsemaphore = QSemaphore(1)
        self.seriallogsemaphore = QSemaphore(1)
        self.eventactionsemaphore = QSemaphore(1)
        self.updateBackgroundSemaphore = QSemaphore(1)
        self.alarmSemaphore = QSemaphore(1)
        self.rampSoakSemaphore = QSemaphore(1)

        #flag to plot cross lines from mouse
        self.crossmarker = False
        self.crossmouseid = None # connect mouse signal id
        self.onreleaseid = None # connect release signal id

        #
        self.analyzer_connect_id = None # analyzer connect signal id


        #########  temporary serial variables
        #temporary storage to pass values. Holds extra T3 and T4 values for center 309
        self.extra309T3 = -1
        self.extra309T4 = -1
        self.extra309TX = 0.

        #temporary storage to pass values. Holds all values retrieved from a Hottop roaster
        self.hottop_ET = -1
        self.hottop_BT = -1
        self.hottop_HEATER = 0 # 0-100
        self.hottop_MAIN_FAN = 0 # 0-10 (!)
        self.hottop_TX = 0.

        #temporary storage to pass values. Holds all values retrieved from an R1 roaster
        self.R1_DT = -1
        self.R1_BT = -1
        self.R1_BT_ROR = -1
        self.R1_EXIT_TEMP = -1
        self.R1_HEATER = 0 # 0-9
        self.R1_FAN = 0 # 0-12
        self.R1_DRUM = 0 # 1-9
        self.R1_VOLTAGE = 0 # 0-300
        self.R1_TX = 0.
        self.R1_STATE = 0
        self.R1_FAN_RPM = 0
        self.R1_STATE_STR = ''

        #used by extra device +ArduinoTC4_XX to pass values
        self.extraArduinoT1 = 0.  # Arduino T3: chan 3
        self.extraArduinoT2 = 0.  # Arduino T4: chan 4
        self.extraArduinoT3 = 0.  # Arduino T5: heater duty %
        self.extraArduinoT4 = 0.  # Arduino T6: fan duty %
        self.extraArduinoT5 = 0.  # Arduino T7: SV
        self.extraArduinoT6 = 0.  # Arduino T8: TC4 internal ambient temperature

        #used by extra device +Program_34, +Program_56, +Program_78 and +Program_910 to pass values
        self.program_t3 = -1
        self.program_t4 = -1
        self.program_t5 = -1
        self.program_t6 = -1
        self.program_t7 = -1
        self.program_t8 = -1
        self.program_t9 = -1
        self.program_t10 = -1

        #temporary storage to pass values. Holds the power % ducty cycle of Fuji PIDs and ET-BT
        self.dutycycle = -1
        self.dutycycleTX = 0.
        self.currentpidsv = 0.

        self.linecount = None # linecount cache for resetlines(); has to be reset if visibility of ET/BT or extra lines or background ET/BT changes
        self.deltalinecount = None # deltalinecount cache for resetdeltalines(); has to be reset if visibility of deltaET/deltaBT or background deltaET/deltaBT

        #variables to organize the delayed update of the backgrounds for bitblitting
        self.ax_background = None
        self.block_update = False

        # flag to toggle between Temp and RoR scale of xy-display
        self.fmt_data_RoR = False
        self.fmt_data_ON = True #; if False, the xy-display is deactivated
        # toggle between using the 0: y-cursor pos, 1: BT@x, 2: ET@x, 3: BTB@x, 4: ETB@x (thus BT, ET or the corresponding background curve data at cursor position x)
        # to display the y of the cursor coordinates
        self.fmt_data_curve = 0
        self.running_LCDs = 0 # if not 0 and not sampling visible LCDs show the readings at the cursor position of 1: foreground profile, 2: background profile

        #holds last values calculated from plotter
        self.plotterstack = [0]*10
        #holds results for each equation (9 total)
        self.plotterequationresults = [[],[],[],[],[],[],[],[],[]]
        #message string for plotter
        self.plottermessage = ''

        self.alarm_popup_timout = 10


        #buffers for real time symbolic evaluation
        self.RTtemp1=0.
        self.RTtemp2=0.
        self.RTextratemp1=[]
        self.RTextratemp2=[]
        self.RTextratx=[]

        if self.mode == 'C':
            self.mode = 'F'
            self.celsiusMode()
            self.phases = self.phases_celsius_defaults

        #Extras more info
        self.idx_met = None
        self.showmet = False
        self.met_annotate = None
        self.met_timex_temp1_delta = None
        self.extendevents = True
        self.statssummary = False
        self.showtimeguide = True
        self.statsmaxchrperline = 30

        #EnergyUse
        self.energyunits: Final = ['BTU', 'kJ', 'kCal', 'kWh', 'hph']
        self.powerunits: Final = ['BTU/h', 'kJ/h', 'kCal/h', 'kW', 'hp']
        self.sourcenames: Final = ['LPG', 'NG', QApplication.translate('ComboBox','Elec')]
        ## setup defaults (stored in app :
        # Burners
        self.loadlabels_setup = ['']*4                   # burner labels
        self.loadratings_setup = [0]*4                   # in ratingunits
        self.ratingunits_setup = [0]*4                   # index in list self.powerunits
        self.sourcetypes_setup = [0]*4                   # index in list self.sourcenames
        self.load_etypes_setup = [0]*4                   # index of the etype that is the gas/burner setting
        self.presssure_percents_setup = [False]*4        # event value in pressure percent
        self.loadevent_zeropcts_setup = [0]*4            # event value corresponding to 0 percent
        self.loadevent_hundpcts_setup = [100]*4          # event value corresponding to 100 percent
        # Protocol
        self.preheatDuration_setup = 0                     # length of preheat in seconds
        self.preheatenergies_setup = [0]*4                 # rating of the preheat burner
        self.betweenbatchDuration_setup = 0                # length of bbp in seconds
        self.betweenbatchenergies_setup = [0]*4            # rating of the between batch burner
        self.coolingDuration_setup = 0                     # length of cooling in seconds
        self.coolingenergies_setup = [0]*4                 # rating of the cooling burner
        self.betweenbatch_after_preheat_setup = True       # True adds BBP to pre-heating (and cooling) for the first batch.
        self.electricEnergyMix_setup = 0                   # the amount of renewable electric energy in the energy mix in %
        # Others
        self.energyresultunit_setup = 0                    # index in list self.powerunits
        self.kind_list: Final = [QApplication.translate('Label','Preheat Measured'),
                          QApplication.translate('Label','Preheat %'),
                          QApplication.translate('Label','BBP Measured'),
                          QApplication.translate('Label','BBP %'),
                          QApplication.translate('Label','Cooling Measured'),
                          QApplication.translate('Label','Cooling %'),
                          QApplication.translate('Label','Continuous'),
                          QApplication.translate('Label','Roast Event')]

        ## working variables (stored in .alog profiles):
        # Burners
        self.loadlabels = self.loadlabels_setup[:]               # burner labels
        self.loadratings = self.loadratings_setup[:]             # in ratingunits
        self.ratingunits = self.ratingunits_setup[:]             # index in list self.heatunits
        self.sourcetypes = self.sourcetypes_setup[:]             # index in list self.sourcetypes
        self.load_etypes = self.load_etypes_setup[:]             # index of the etype that is the gas/burner setting
        self.presssure_percents = self.presssure_percents_setup[:]  # event value in pressure percent
        self.loadevent_zeropcts = self.loadevent_zeropcts_setup[:]  # event value corresponding to 0 percent
        self.loadevent_hundpcts = self.loadevent_hundpcts_setup[:]  # event value corresponding to 100 percent
        # Protocol
        self.preheatDuration = self.preheatDuration_setup               # length of preheat in seconds
        self.preheatenergies = self.preheatenergies_setup[:]            # rating of the preheat burner
        self.betweenbatchDuration = self.betweenbatchDuration_setup     # length of bbp in seconds
        self.betweenbatchenergies = self.betweenbatchenergies_setup[:]  # rating of the between batch burner
        self.coolingDuration = self.coolingDuration_setup               # length of cooling in seconds
        self.coolingenergies = self.coolingenergies_setup[:]            # rating of the cooling burner
        self.betweenbatch_after_preheat = self.betweenbatch_after_preheat_setup # True if after preheat a BBP is done
        self.electricEnergyMix = self.electricEnergyMix_setup        # the amount of renewable electric energy in the energy mix in %

        #mouse cross lines measurement
        self.baseX,self.baseY = None, None
        self.base_horizontalcrossline, self.base_verticalcrossline = None, None
        self.base_messagevisible = False

        #threshold for deltaE color difference comparisons
        self.colorDifferenceThreshold = 20

        #references to legend objects
        self.handles = []
        self.labels = []
        self.legend_lines = []

        #used for picked event messages
        self.eventmessage = ''
        self.backgroundeventmessage = ''
        self.eventmessagetimer = None

        self.resizeredrawing = 0 # holds timestamp of last resize triggered redraw

        self.logoimg = None # holds the background logo image
        self.analysisresultsloc_default: Final = [.49,.5]
        self.analysisresultsloc = self.analysisresultsloc_default
        self.analysispickflag = False
        self.analysisresultsstr = ''
        self.analysisstartchoice = 1
        self.analysisoffset = 180
        self.curvefitstartchoice = 0
        self.curvefitoffset = 180
        self.segmentresultsloc_default: Final = [.5,.5]
        self.segmentresultsloc = self.segmentresultsloc_default
        self.segmentpickflag = False
        self.segmentdeltathreshold = 0.6
        self.segmentsamplesthreshold = 3

        self.stats_summary_rect = None

        # temp vars used to truncate title and statistic line (x_label) to width of MPL canvas
        self.title_text = None
        self.title_artist = None
        self.title_width = None
        self.background_title_width = 0
        self.xlabel_text = None
        self.xlabel_artist = None
        self.xlabel_width = None

        self.lazyredraw_on_resize_timer =  QTimer()
        self.lazyredraw_on_resize_timer.timeout.connect(self.lazyredraw_on_resize)
        self.lazyredraw_on_resize_timer.setSingleShot(True)

        self.updategraphicsSignal.connect(self.updategraphics)
        self.updateLargeLCDsSignal.connect(self.updateLargeLCDs)
        self.updateLargeLCDsReadingsSignal.connect(self.updateLargeLCDsReadings)
        self.setTimerLargeLCDcolorSignal.connect(self.setTimerLargeLCDcolor)
        self.showAlarmPopupSignal.connect(self.showAlarmPopup)
        self.updateLargeLCDsTimeSignal.connect(self.updateLargeLCDsTime)
        self.fileDirtySignal.connect(self.fileDirty)
        self.fileCleanSignal.connect(self.fileClean)
        self.markChargeSignal.connect(self.markChargeDelay)
        self.markDRYSignal.connect(self.markDRYTrigger)
        self.markFCsSignal.connect(self.markFCsTrigger)
        self.markFCeSignal.connect(self.markFCeTrigger)
        self.markSCsSignal.connect(self.markSCsTrigger)
        self.markSCeSignal.connect(self.markSCeTrigger)
        self.markDropSignal.connect(self.markDropTrigger)
        self.markCoolSignal.connect(self.markCoolTrigger)
        self.toggleMonitorSignal.connect(self.toggleMonitorTigger)
        self.toggleRecorderSignal.connect(self.toggleRecorderTigger)
        self.processAlarmSignal.connect(self.processAlarm, type=Qt.ConnectionType.QueuedConnection) # queued to avoid deadlock between RampSoak processing and EventRecordAction, both accessing the same critical section protected by profileDataSemaphore
        self.alarmsetSignal.connect(self.selectAlarmSet)
        self.moveBackgroundSignal.connect(self.moveBackgroundAndRedraw)
        self.eventRecordSignal.connect(self.EventRecordSlot)
        self.showCurveSignal.connect(self.showCurve)
        self.showExtraCurveSignal.connect(self.showExtraCurve)
        self.showEventsSignal.connect(self.showEvents)
        self.showBackgroundEventsSignal.connect(self.showBackgroundEvents)

    #NOTE: empty Figure is initially drawn at the end of aw.settingsload()
    #################################    FUNCTIONS    ###################################
    #####################################################################################

    # toggles the y cursor coordinate see self.qmc.fmt_data_curve
    def nextFmtDataCurve(self):
        self.fmt_data_curve = (self.fmt_data_curve+1) % 5
        if aw.qmc.backgroundprofile is None and self.fmt_data_curve in [3,4]:
            self.fmt_data_curve = 0
        if len(aw.qmc.timex)<3 and self.fmt_data_curve in [1,2]:
            if aw.qmc.backgroundprofile is None:
                self.fmt_data_curve = 0
            else:
                self.fmt_data_curve = 3
        s = 'cursor position'
        if self.fmt_data_curve == 1:
            s = aw.BTname
        elif self.fmt_data_curve == 2:
            s = aw.ETname
        elif self.fmt_data_curve == 3:
            s = f'{QApplication.translate("Label","Background")} {aw.BTname}'
        elif self.fmt_data_curve == 4:
            s = f'{QApplication.translate("Label","Background")} {aw.ETname}'
        aw.ntb.update_message()
        aw.sendmessage(QApplication.translate('Message', 'set y-coordinate to {}').format(s))

    @pyqtSlot(str, bool)
    def showCurve(self, name: str, state: bool):
        changed = False
        if name == 'ET' and self.ETcurve != state:
            self.ETcurve = state
            changed = True
        elif name == 'BT' and self.BTcurve != state:
            self.BTcurve = state
            changed = True
        elif name == 'DeltaET' and self.DeltaETflag != state:
            self.DeltaETflag = state
            changed = True
        elif name == 'DeltaBT' and self.DeltaBTflag != state:
            self.DeltaBTflag = state
            changed = True
        elif name == 'BackgroundET' and self.backgroundETcurve != state:
            self.backgroundETcurve = state
            changed = True
        elif name == 'BackgroundBT' and self.backgroundBTcurve != state:
            self.backgroundBTcurve = state
            changed = True
        if changed:
            self.redraw(recomputeAllDeltas=False,smooth=False)

    @pyqtSlot(int, str, bool)
    def showExtraCurve(self, extra_device: int, curve: str, state: bool):
        if curve.strip() == 'T1' and len(aw.extraCurveVisibility1) > extra_device and aw.extraCurveVisibility1[extra_device] != state:
            aw.extraCurveVisibility1[extra_device] = state
            self.redraw(recomputeAllDeltas=False,smooth=False)
        elif curve.strip() == 'T2' and len(aw.extraCurveVisibility2) > extra_device and aw.extraCurveVisibility2[extra_device] != state:
            aw.extraCurveVisibility2[extra_device] = state
            self.redraw(recomputeAllDeltas=False,smooth=False)

    @pyqtSlot(int, bool)
    def showEvents(self, event_type: int, state: bool):
        event_type -= 1
        if len(self.showEtypes) > event_type > 0 and self.showEtypes[event_type] != state:
            self.showEtypes[event_type] = state
            self.redraw(recomputeAllDeltas=False,smooth=False)

    @pyqtSlot(bool)
    def showBackgroundEvents(self, state: bool):
        if state != self.backgroundeventsflag:
            self.backgroundeventsflag = state
            self.redraw(recomputeAllDeltas=False,smooth=False)

    def ax_lines_clear(self):
        if isinstance(self.ax.lines,list): # MPL < v3.5
            self.ax.lines = []
        else:
            while len(self.ax.lines) > 0:
                self.ax.lines[0].remove()

    # set current burner settings as defaults
    def setEnergyLoadDefaults(self):
        self.loadlabels_setup = self.loadlabels[:]
        self.loadratings_setup = self.loadratings[:]
        self.ratingunits_setup = self.ratingunits[:]
        self.sourcetypes_setup = self.sourcetypes[:]
        self.load_etypes_setup = self.load_etypes[:]
        self.presssure_percents_setup = self.presssure_percents[:]
        self.loadevent_zeropcts_setup = self.loadevent_zeropcts[:]
        self.loadevent_hundpcts_setup = self.loadevent_hundpcts[:]
        self.electricEnergyMix_setup = self.electricEnergyMix

    # restore burner settings to their defaults
    def restoreEnergyLoadDefaults(self):
        self.loadlabels = self.loadlabels_setup[:]
        self.loadratings = self.loadratings_setup[:]
        self.ratingunits = self.ratingunits_setup[:]
        self.sourcetypes = self.sourcetypes_setup[:]
        self.load_etypes = self.load_etypes_setup[:]
        self.presssure_percents = self.presssure_percents_setup[:]
        self.loadevent_zeropcts = self.loadevent_zeropcts_setup[:]
        self.loadevent_hundpcts = self.loadevent_hundpcts_setup[:]
        self.electricEnergyMix = self.electricEnergyMix_setup

    # set current protocol settings as defaults
    def setEnergyProtocolDefaults(self):
        self.preheatDuration_setup = self.preheatDuration
        self.preheatenergies_setup = self.preheatenergies[:]
        self.betweenbatchDuration_setup = self.betweenbatchDuration
        self.betweenbatchenergies_setup = self.betweenbatchenergies[:]
        self.coolingDuration_setup = self.coolingDuration
        self.coolingenergies_setup = self.coolingenergies[:]
        self.betweenbatch_after_preheat_setup = self.betweenbatch_after_preheat

    # restore protocol settings to their defaults
    def restoreEnergyProtocolDefaults(self):
        self.preheatDuration = self.preheatDuration_setup
        self.preheatenergies = self.preheatenergies_setup[:]
        self.betweenbatchDuration = self.betweenbatchDuration_setup
        self.betweenbatchenergies = self.betweenbatchenergies_setup[:]
        self.coolingDuration = self.coolingDuration_setup
        self.coolingenergies = self.coolingenergies_setup[:]
        self.betweenbatch_after_preheat = self.betweenbatch_after_preheat_setup

    @pyqtSlot()
    def fileDirty(self):
        self.safesaveflag = True
        aw.updateWindowTitle()

    @pyqtSlot()
    def fileClean(self):
        self.safesaveflag = False
        aw.updateWindowTitle()

    def lazyredraw_on_resize(self):
        self.lazyredraw(recomputeAllDeltas=False)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        # we only trigger a redraw on resize if a watermark is displayed to fix its aspect ratio
        if aw.redrawOnResize and aw.logofilename != '':
            dw = event.size().width() - event.oldSize().width()   # width change
            dh = event.size().height() - event.oldSize().height() # height change
#            t = libtime.time()
#            # ensure that we redraw during resize only once per second
#            if self.resizeredrawing + 0.5 < t and ((dw != 0) or (dh != 0)):
#                self.resizeredrawing = t
#                QTimer.singleShot(1, lazyredraw_on_resize)
            if ((dw != 0) or (dh != 0)):
                self.lazyredraw_on_resize_timer.start(10)


    # update the aw.qmc.deltaBTspan and deltaETspan from the given sampling interval, aw.qmc.deltaETsamples and aw.qmc.deltaBTsamples
    # interval is expected in seconds (either from the profile on load or from the sampling interval set for recording)
    # both deltaBTsamples and deltaETsamples are at least one
    def updateDeltaSamples(self):
        if self.flagstart or self.profile_sampling_interval is None:
            speed = self.timeclock.getBase()/1000
            interval = speed * (self.delay / 1000)
        else:
            interval = self.profile_sampling_interval
        self.deltaBTsamples = max(1,int(round(self.deltaBTspan / interval)))
        self.deltaETsamples = max(1,int(round(self.deltaETspan / interval)))

    def updateBackground(self):
        if not self.block_update and aw.qmc.ax is not None:
            try:
                aw.qmc.updateBackgroundSemaphore.acquire(1)
                self.block_update = True
                self.doUpdate()
            finally:
                if aw.qmc.updateBackgroundSemaphore.available() < 1:
                    aw.qmc.updateBackgroundSemaphore.release(1)

    def doUpdate(self):
        if not self.designerflag:
            self.resetlinecountcaches() # ensure that the line counts are up to date
            self.resetlines() # get rid of projection, cross lines and AUC line

            try:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw() # this triggers _draw_event(self,evt)
                #self.fig.canvas.draw_idle() # ask the canvas to kindly draw it self some time in the future when Qt thinks it is convenient
                # make sure that the GUI framework has a chance to run its event loop
                # and clear any GUI events.  This needs to be in a try/except block
                # because the default implementation of this method is to raise
                # NotImplementedError
                #self.fig.canvas.flush_events() # don't FLUSH event as this can lead to a second redraw started from within the same GUI thread and
                # causen a hang by the blocked semaphore
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            self.ax_background = self.fig.canvas.copy_from_bbox(aw.qmc.ax.get_figure().bbox)

        self.block_update = False

    def getetypes(self):
        if len(self.etypes) == 4:
            self.etypes.append('--')
        return self.etypes

    def etypesf(self, i):
        if len(self.etypes) == 4:
            self.etypes.append('--')
        if i > 4:
            return self.etypes[i-5]
        return self.etypes[i]

    def Betypesf(self, i, prefix=False):
        if len(self.Betypes) == 4:
            self.Betypes.append('--')
        if prefix and i < 4:
            return 'Background'+self.Betypes[i]
        return self.Betypes[i]

    def ambientTempSourceAvg(self):
        res = None
        if self.ambientTempSource:
            try:
                start = 0
                end = len(aw.qmc.temp1) - 1
                if self.timeindex[0] > -1: # CHARGE
                    start = self.timeindex[0]
                if self.timeindex[6] > 0: # DROP
                    end = self.timeindex[6]
                if self.ambientTempSource == 1: # from ET
                    res = numpy.mean([e for e in aw.qmc.temp1[start:end] if e is not None and e != -1])
                elif self.ambientTempSource == 2: # from BT
                    res = numpy.mean([e for e in aw.qmc.temp2[start:end] if e is not None and e != -1])
                elif self.ambientTempSource > 2 and ((self.ambientTempSource - 3) < (2*len(aw.qmc.extradevices))):
                    # from an extra device
                    if (self.ambientTempSource)%2==0:
                        res = numpy.mean([e for e in aw.qmc.extratemp2[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1])
                    else:
                        res = numpy.mean([e for e in aw.qmc.extratemp1[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1])
            except Exception as ex: # pylint: disable=broad-except # the array to average over might get empty and mean thus invoking an exception
                _log.exception(ex)
        if res:
            res = aw.float2float(res)
        return res

    def updateAmbientTempFromPhidgetModulesOrCurve(self):
        if not self.ambientTempSource:
            AT_device = None
            try:
                AT_device = aw.qmc.extradevices.index(36)
            except Exception: # pylint: disable=broad-except
                try:
                    AT_device = aw.qmc.extradevices.index(60)
                except Exception: # pylint: disable=broad-except
                    pass
            if AT_device is not None:
                # 1048_AT channel #36, TMP1101_AT channel #60
                # we try to access that devices first channel to retrieve the temperature data
                try:
                    ser = aw.extraser[AT_device]
                    if ser.PhidgetTemperatureSensor is not None:
                        at = ser.PhidgetTemperatureSensor[0].getTemperature()
                        if aw.qmc.mode == 'F':
                            at = aw.float2float(fromCtoF(at))
                        aw.qmc.ambientTemp = aw.float2float(at)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            # in case the AT channel of the 1048 or the TMP1101 is not used as extra device, we try to attach to it anyhow and read the temp off
            elif aw.qmc.ambientTemp == 0.0 and aw.qmc.device in [34,58]: # Phidget 1048 or TMP1101 channel 4 (use internal temp)
                try:
                    if aw.ser.PhidgetTemperatureSensor is not None and aw.ser.PhidgetTemperatureSensor[0].getAttached():
                        from Phidget22.Devices.TemperatureSensor import TemperatureSensor as PhidgetTemperatureSensor
                        ambient = PhidgetTemperatureSensor()
                        ambient.setDeviceSerialNumber(aw.ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber())
                        if aw.qmc.device == 58:
                            ambient.setHubPort(aw.ser.PhidgetTemperatureSensor[0].getHubPort())
                        ambient.setChannel(4)
                        ambient.openWaitForAttachment(1000) # timeout in ms
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                        t = ambient.getTemperature()
                        if aw.qmc.mode == 'F':
                            aw.qmc.ambientTemp = aw.float2float(fromCtoF(t))
                        else:
                            aw.qmc.ambientTemp = aw.float2float(t)
                        if ambient.getAttached():
                            ambient.close()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        res = aw.qmc.ambientTempSourceAvg()
        if res is not None and (isinstance(res, (float,int))) and not math.isnan(res):
            aw.qmc.ambientTemp = aw.float2float(float(res))

    def updateAmbientTemp(self):
        self.updateAmbientTempFromPhidgetModulesOrCurve()
        try:
            aw.qmc.startPhidgetManager()
            aw.qmc.getAmbientData()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # eventsvalues maps the given internal event value v to an external event int value as displayed to the user as special event value
    # v is expected to be float value of range [-11.0,11.0]
    # negative values are not used as event values, but as step arguments in extra button definitions
    #   11.0 => 100
    #   10.1 => 91
    #   10.0 => 90
    #   1.1 => 1
    #   1.0 => 0
    #     0 => 0
    #  -1.0 => 0
    #  -1.1 => -1
    # -10.0 => -90
    # -10.1 => -91
    # -11.0 => -100
    @staticmethod
    def eventsInternal2ExternalValue(v):
        if v is None:
            return 0
        if -1.0 <= v <= 1.0:
            return 0
        if v < -1.0:
            return -(int(round(abs(v)*10)) - 10)
        return int(round(v*10)) - 10

    # the inverse of eventsInternal2ExternalValue, converting an external to an internal event value
    @staticmethod
    def eventsExternal2InternalValue(v):
        if -1.0 < v < 1.0:
            return 1.0
        if v >= 1.0:
            return v/10. + 1.
        return v/10. - 1.

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0-10]
    # negative values are mapped to ""
    # 0.1 to "1"
    # ..
    # 1.0 to "10"
    # ..
    # 10.0 to "100"
    def eventsvalues(self,v):
        return str(self.eventsInternal2ExternalValue(v))

    # 100.0 to "10" and 10.1 to "1"
    @staticmethod
    def eventsvaluesShort(v):
        value = v*10. - 10.
        if value == -10:
            return '0'
        if value < 0:
            return ''
        return str(int(round(value)))

    # the inverse to eventsvalues above (string -> value)
    def str2eventsvalue(self,s):
        st = s.strip()
        if st is None or len(st) == 0:
            return -1
        return self.eventsExternal2InternalValue(float(st))

    def fit_titles(self):
        #truncate title and statistic line to width of axis system to avoid that the MPL canvas goes into miser mode
        try:
            if self.ax is not None:
                r = None
                try:
                    r = self.fig.canvas.get_renderer() # MPL fails on savePDF with 'FigureCanvasPdf' object has no attribute 'get_renderer'
                except Exception: # pylint: disable=broad-except
                    pass
                if r is None:
                    ax_width = self.ax.get_window_extent().width
                else:
                    ax_width = self.ax.get_window_extent(renderer=r).width
                ax_width_for_title = ax_width - self.background_title_width
                redraw = False
                if self.title_text is not None and self.title_artist is not None and self.title_width is not None:
                    try:
                        prev_title_text = self.title_artist.get_text()
                        if ax_width_for_title <= self.title_width:
                            chars = max(3,int(ax_width_for_title / (self.title_width / len(self.title_text))) - 2)
                            self.title_artist.set_text(f'{self.title_text[:chars].strip()}...')
                        else:
                            self.title_artist.set_text(self.title_text)
                        if prev_title_text != self.title_artist.get_text():
                            redraw = True
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                if self.xlabel_text is not None and self.xlabel_artist is not None and self.xlabel_width is not None:
                    try:
                        prev_xlabel_text = self.xlabel_artist.get_text()
                        if ax_width <= self.xlabel_width:
                            chars = max(3,int(ax_width / (self.xlabel_width / len(self.xlabel_text))) - 2)
                            self.xlabel_artist.set_text(f'{self.xlabel_text[:chars].strip()}...')
                        else:
                            self.xlabel_artist.set_text(self.xlabel_text)
                        if prev_xlabel_text != self.xlabel_artist.get_text():
                            redraw = True
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                try:
                    if redraw:
                        # Temporarily disconnect any callbacks to the draw event...
                        # (To avoid recursion)
                        func_handles = self.fig.canvas.callbacks.callbacks['draw_event']
                        self.fig.canvas.callbacks.callbacks['draw_event'] = {}
                        # Re-draw the figure..
                        with warnings.catch_warnings():
                            warnings.simplefilter('ignore')
                            self.fig.canvas.draw()
                        # Reset the draw event callbacks
                        self.fig.canvas.callbacks.callbacks['draw_event'] = func_handles
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # hook up to mpls event handling framework for draw events
    # this is emitted after the canvas has finished a full redraw
    def _draw_event(self, _):
        #self.fig.canvas.flush_events() # THIS prevents the black border on >Qt5.5, but slows down things (especially resizings) on redraw otherwise!!!
        self.ax_background = None
        # we trigger a re-fit of the titles to fit to the resized MPL canvas
        self.fit_titles()

    @pyqtSlot()
    def sendeventmessage(self):
        self.eventmessagetimer = None
        if len(self.backgroundeventmessage) != 0:
            aw.sendmessage(self.backgroundeventmessage,append=True)
            self.backgroundeventmessage = ''
            self.starteventmessagetimer(2)  #hack to ensure that the background event message is written first
            return
        if len(self.eventmessage) != 0:
            aw.sendmessage(self.eventmessage,append=True)
            self.eventmessage = ''

    def starteventmessagetimer(self,time=120):
        if self.eventmessagetimer:
            self.eventmessagetimer.stop()
            self.eventmessagetimer.deleteLater()
        self.eventmessagetimer = QTimer()
        self.eventmessagetimer.timeout.connect(self.sendeventmessage)
        self.eventmessagetimer.setSingleShot(True)
        self.eventmessagetimer.start(time)

    def onpick(self,event):
        try:
            # display MET information by clicking on the MET marker
            if isinstance(event.artist, mpl.text.Annotation) and self.showmet and event.artist in [self.met_annotate]:
                if self.met_timex_temp1_delta[2] is not None and self.met_timex_temp1_delta[2] >= 0:
                    met_time_str = str(self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate('Message','seconds before FCs')
                else:
                    met_time_str = str(-1*self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate('Message','seconds after FCs')

                message = 'MET {}{} @ {}, {} {}'.format(
                    str(aw.float2float(self.met_timex_temp1_delta[1],1)),
                    aw.qmc.mode,
                    stringfromseconds(self.met_timex_temp1_delta[0]),
                    met_time_str,
                    met_time_msg)
                aw.sendmessage(message)

            # the analysis results were clicked
            elif aw.analysisresultsanno is not None and isinstance(event.artist, mpl.text.Annotation) and event.artist in [aw.analysisresultsanno]:
                self.analysispickflag = True

            # the segment results were clicked
            elif aw.segmentresultsanno is not None and isinstance(event.artist, mpl.text.Annotation) and event.artist in [aw.segmentresultsanno]:
                self.segmentpickflag = True

            # toggle visibility of graph lines by clicking on the legend
            elif self.legend is not None and event.artist != self.legend and isinstance(event.artist, (mpl.lines.Line2D, mpl.text.Text)) \
                and event.artist not in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots] \
                and event.artist not in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                idx = None
                # deltaLabelMathPrefix (legend label)
                # deltaLabelUTF8 (artist)
                if isinstance(event.artist, mpl.text.Text):
                    try:
                        label = event.artist.get_text()
                        idx = self.labels.index(label)
                    except Exception: # pylint: disable=broad-except
                        pass
                    if label==aw.ETname:
                        label = 'ET'  #allows for a match below to the label in legend_lines
                        try:
                            for a in self.l_eteventannos:
                                a.set_visible(not a.get_visible())
                            if self.met_annotate != None:
                                self.met_annotate.set_visible(not self.met_annotate.get_visible())
                        except Exception: # pylint: disable=broad-except
                            pass
                    elif label==aw.BTname:
                        label = 'BT'  #allows for a match below to the label in legend_lines
                        try:
                            for a in self.l_bteventannos:
                                a.set_visible(not a.get_visible())
                        except Exception: # pylint: disable=broad-except
                            pass
                    try:
                        # toggle also the visibility of the legend handle
                        clean_label = label.replace(deltaLabelMathPrefix,deltaLabelUTF8)
                        artist = next((x for x in self.legend_lines if x.get_label() == clean_label), None)
                        if artist:
                            artist.set_visible(not artist.get_visible())
                    except Exception: # pylint: disable=broad-except
                        pass
                # toggle the visibility of the corresponding line
                if idx is not None and artist:
                    artist = self.handles[idx]
                    artist.set_visible(not artist.get_visible())
                    if self.eventsGraphflag in [2,3,4]:
                        # if events are rendered in Combo style we need to hide also the corresponding annotations:
                        try:
                            i = [aw.arabicReshape(et) for et in self.etypes[:4]].index(label)
                            if i == 0:
                                for a in self.l_eventtype1annos:
                                    a.set_visible(not a.get_visible())
                            elif i == 1:
                                for a in self.l_eventtype2annos:
                                    a.set_visible(not a.get_visible())
                            elif i == 2:
                                for a in self.l_eventtype3annos:
                                    a.set_visible(not a.get_visible())
                            elif i == 3:
                                for a in self.l_eventtype4annos:
                                    a.set_visible(not a.get_visible())
                        except Exception: # pylint: disable=broad-except
                            pass


            # show event information by clicking on event lines in step, step+ and combo modes
            elif isinstance(event.artist, mpl.lines.Line2D):
                if isinstance(event.ind, (int)):
                    ind = event.ind
                else:
                    if not len(event.ind): return
                    ind = event.ind[0]
                digits = (1 if aw.qmc.LCDdecimalplaces else 0)
                if event.artist in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]:
                    timex = self.backgroundtime2index(event.artist.get_xdata()[ind])
                    for i in range(len(self.backgroundEvents)):
                        if (re.search(
                                    f'(Background{self.Betypesf(self.backgroundEtypes[i])})',
                                    str(event.artist))
                                and (timex in [self.backgroundEvents[i],self.backgroundEvents[i] -1,self.backgroundEvents[i] + 1])):
                            if aw.qmc.timeindex[0] != -1:
                                start = aw.qmc.timex[aw.qmc.timeindex[0]]
                            else:
                                start = 0
                            if len(self.backgroundeventmessage) != 0:
                                self.backgroundeventmessage += ' | '
                            else:
                                self.backgroundeventmessage += 'Background: '
                            self.backgroundeventmessage = f'{self.backgroundeventmessage}{self.Betypesf(self.backgroundEtypes[i])} = {self.eventsvalues(self.backgroundEvalues[i])}'
                            if aw.qmc.renderEventsDescr and self.backgroundEStrings[i] and self.backgroundEStrings[i]!='':
                                self.backgroundeventmessage = f'{self.backgroundeventmessage} ({self.backgroundEStrings[i].strip()[:aw.qmc.eventslabelschars]})'
                            self.backgroundeventmessage = f'{self.backgroundeventmessage} @ {(stringfromseconds(self.timeB[self.backgroundEvents[i]] - start))} {aw.float2float(self.temp2B[self.backgroundEvents[i]],digits)}{aw.qmc.mode}'
                            self.starteventmessagetimer()
                            break
                elif event.artist in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                    timex = self.time2index(event.artist.get_xdata()[ind])
                    for i in range(len(self.specialevents)):
                        if (re.search(
                                    f'({self.etypesf(self.specialeventstype[i])})',
                                    str(event.artist))
                                and (timex in [self.specialevents[i], self.specialevents[i] + 1, self.specialevents[i] -1])):
                            if aw.qmc.timeindex[0] != -1:
                                start = aw.qmc.timex[aw.qmc.timeindex[0]]
                            else:
                                start = 0
                            if len(self.eventmessage) != 0:
                                self.eventmessage = f'{self.eventmessage} | '
                            self.eventmessage = f'{self.eventmessage}{self.etypesf(self.specialeventstype[i])} = {self.eventsvalues(self.specialeventsvalue[i])}'
                            if aw.qmc.renderEventsDescr and self.specialeventsStrings[i] and self.specialeventsStrings[i]!='':
                                self.eventmessage = f'{self.eventmessage} ({self.specialeventsStrings[i].strip()[:aw.qmc.eventslabelschars]})'
                            self.eventmessage = f'{self.eventmessage}@ {stringfromseconds(self.timex[self.specialevents[i]] - start)} {aw.float2float(self.temp2[self.specialevents[i]],digits)}{aw.qmc.mode}'
                            self.starteventmessagetimer()
                            break
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' onpick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def onrelease_after_pick(self,_):
        if self.legend is not None:
            QTimer.singleShot(1,self.updateBackground)

    def onrelease(self,event):     # NOTE: onrelease() is connected/disconnected in togglecrosslines()
        try:
            if event.button == 1:
                self.baseX,self.baseY = None, None
                try:
                    aw.qmc.ax.lines.remove(self.base_horizontalcrossline)
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    aw.qmc.ax.lines.remove(self.base_verticalcrossline)
                except Exception: # pylint: disable=broad-except
                    pass
                self.base_horizontalcrossline, self.base_verticalcrossline = None, None
            # save the location of analysis results after dragging
            if self.analysispickflag:
                self.analysispickflag = False
                corners = aw.qmc.ax.transAxes.inverted().transform(aw.analysisresultsanno.get_bbox_patch().get_extents())
                aw.qmc.analysisresultsloc = (corners[0][0], corners[0][1] + (corners[1][1] - corners[0][1])/2)
            # save the location of segment results after dragging
            if self.segmentpickflag:
                self.segmentpickflag = False
                corners = aw.qmc.ax.transAxes.inverted().transform(aw.segmentresultsanno.get_bbox_patch().get_extents())
                aw.qmc.segmentresultsloc = (corners[0][0], corners[0][1] + (corners[1][1] - corners[0][1])/2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' onclick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))


    @staticmethod
    def disconnect_draggableannotations_motion_notifiers():
        cids = []
        try:
            if 'motion_notify_event' in aw.qmc.fig.canvas.callbacks.callbacks:
                motion_notify_event_handlers = aw.qmc.fig.canvas.callbacks.callbacks['motion_notify_event']
                for cid, func_ref in motion_notify_event_handlers.items():
                    func = func_ref()
                    if func.__self__ is not None: # a bound method
                        c = func.__self__.__class__
                        if c == mpl.offsetbox.DraggableAnnotation:
                            cids.append(cid)
            # disconnecting all established motion_notify_event_handlers of DraggableAnnotations
            for cid in cids:
                aw.qmc.fig.canvas.mpl_disconnect(cid)
        except Exception: # pylint: disable=broad-except
            pass

    def onclick(self,event):
        try:
            if not self.designerflag and not self.wheelflag and event.inaxes is None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button == 3:
                aw.qmc.statisticsmode = (aw.qmc.statisticsmode + 1)%2
                aw.qmc.writecharacteristics()
                aw.qmc.fig.canvas.draw_idle()
                return

#PLUS
            if not self.designerflag and not self.wheelflag and event.inaxes is None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button == 1 and event.dblclick==True and \
                    event.x < event.y:
                if aw.qmc.roastUUID is not None:
                    QDesktopServices.openUrl(QUrl(plus.util.roastLink(aw.qmc.roastUUID), QUrl.ParsingMode.TolerantMode))
                    return

            if not self.designerflag and not self.wheelflag and event.inaxes is None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button == 1 and event.dblclick==False and event.x > event.y:
                fig = self.ax.get_figure()
                s = fig.get_size_inches()*fig.dpi
                if event.x > s[0]*2/3 and event.y > s[1]*2/3:
                    if self.backgroundprofile is None and __release_sponsor_domain__ and __release_sponsor_url__:
                        QDesktopServices.openUrl(QUrl(__release_sponsor_url__, QUrl.ParsingMode.TolerantMode))
                        return
                    if self.backgroundprofile is not None:
                        # toggle background if right top corner above canvas where the subtitle is clicked
                        self.background = not self.background
                        aw.autoAdjustAxis(background=True)
                        self.redraw(recomputeAllDeltas=True)
                        return

            if event.button == 1 and event.inaxes and aw.qmc.crossmarker and not self.designerflag and not self.wheelflag and not aw.qmc.flagon:
                self.baseX,self.baseY = event.xdata, event.ydata
                if self.base_horizontalcrossline is None and self.base_verticalcrossline is None:
                    # Mark starting point of click-and-drag with a marker
                    self.base_horizontalcrossline, = self.ax.plot(self.baseX,self.baseY,'r+', markersize=20)
                    self.base_verticalcrossline, = self.ax.plot(self.baseX,self.baseY,'wo', markersize = 2)
            elif event.button == 3 and event.inaxes and not self.designerflag and not self.wheelflag and not aw.ntb.mode in ['pan/zoom', 'zoom rect']:# and not self.flagon:
                # popup not available if pan/zoom or zoom rect is active as it interacts
                timex = self.time2index(event.xdata)
                if timex > 0:
                    # reset the zoom rectangles
                    menu = QMenu(aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
#                    menu.setStyleSheet("QMenu::item {background-color: palette(window); selection-color: palette(window); selection-background-color: darkBlue;}")
                    # populate menu
                    ac = QAction(menu)
                    bt = self.temp2[timex]
                    if self.mode == 'C':
                        btdelta = 50
                    else:
                        btdelta = 70
                    if bt != -1 and abs(bt-event.ydata) < btdelta:
                        # we suppress the popup if not clicked close enough to the BT curve
                        if self.timeindex[0] > -1:
                            ac.setText(f"{QApplication.translate('Label', 'at')} {stringfromseconds(event.xdata - self.timex[self.timeindex[0]])}")
                        else:
                            ac.setText(f"{QApplication.translate('Label', 'at')} {stringfromseconds(event.xdata)}")
                        ac.setEnabled(False)
                        menu.addAction(ac)
                        for k in [(QApplication.translate('Label','CHARGE'),0),
                                  (QApplication.translate('Label','DRY END'),1),
                                  (QApplication.translate('Label','FC START'),2),
                                  (QApplication.translate('Label','FC END'),3),
                                  (QApplication.translate('Label','SC START'),4),
                                  (QApplication.translate('Label','SC END'),5),
                                  (QApplication.translate('Label','DROP'),6),
                                  (QApplication.translate('Label','COOL'),7)]:
                            idx_before = idx_after = 0
                            for i in range(k[1]):
                                if self.timeindex[i] and self.timeindex[i] != -1:
                                    idx_before = self.timeindex[i]
                            for i in range(6,k[1],-1) :
                                if self.timeindex[i] and self.timeindex[i] != -1:
                                    idx_after = self.timeindex[i]
                            if ((not idx_before) or timex > idx_before) and ((not idx_after) or timex < idx_after):
                                if not self.flagstart or (k[1] == 0) or (k[1] != 0 and self.timeindex[k[1]] != 0): # only add menu item during recording if already a value is set (via a button)
                                    ac = QAction(menu)
                                    ac.key = (k[1],timex)
                                    ac.setText(' ' + k[0])
                                    menu.addAction(ac)
                        # add user EVENT entry
                        ac = QAction(menu)
                        ac.setText(' ' + QApplication.translate('Label', 'EVENT'))
                        ac.key = (-1,timex)
                        menu.addAction(ac)

                        # we deactivate all active motion_notify_event_handlers of draggable annotations that might have been connected by this click to
                        # avoid redraw conflicts between Artisan canvas bitblit caching and the matplotlib internal bitblit caches.
                        self.disconnect_draggableannotations_motion_notifiers()

                        # show menu
                        menu.triggered.connect(self.event_popup_action)
                        menu.popup(QCursor.pos())
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' onclick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot('QAction*')
    def event_popup_action(self,action):
        if action.key[0] >= 0:
            # we check if this is the first DROP mark on this roast
            firstDROP = (action.key[0] == 6 and self.timeindex[6] == 0)
            timeindex_before = self.timeindex[action.key[0]]
            self.timeindex[action.key[0]] = action.key[1]
            # clear custom label positions cache entry
            if action.key[0] in aw.qmc.l_annotations_dict:
                del aw.qmc.l_annotations_dict[action.key[0]]
            try:
                # clear the event mark position cache
                self.l_annotations_dict.pop(action.key[0])
            except Exception: # pylint: disable=broad-except
                pass
            if action.key[0] == 0: # CHARGE
                try:
                    # clear the TP mark position cache (TP depends on CHARGE!)
                    self.l_annotations_dict.pop(-1)
                except Exception: # pylint: disable=broad-except
                    pass
                # realign to background
                if self.flagon:
                    try:
                        if self.locktimex:
                            self.startofx = self.locktimex_start + self.timex[self.timeindex[0]]
                        else:
                            self.startofx = self.chargemintime + self.timex[self.timeindex[0]] # we set the min x-axis limit to the CHARGE Min time
                    except Exception: # pylint: disable=broad-except
                        pass
                else:
                    # we keep xaxis limit the same but adjust to updated timeindex[0] mark
                    if timeindex_before > -1:
                        self.startofx += (self.timex[self.timeindex[0]] - self.timex[timeindex_before])
                    else:
                        self.startofx += self.timex[self.timeindex[0]]
                    aw.autoAdjustAxis(deltas=False)
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            elif action.key[0] == 6: # DROP
                try:
                    # clear the TP mark position cache (TP depends on DROP!)
                    self.l_annotations_dict.pop(-1)
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    # update ambient temperature if a ambient temperature source is configured and no value yet established
                    aw.qmc.updateAmbientTempFromPhidgetModulesOrCurve()
                except Exception: # pylint: disable=broad-except
                    pass
#PLUS
                # only on first setting the DROP event (not set yet and no previous DROP undone), we upload to PLUS
                if firstDROP and aw.qmc.autoDROPenabled and aw.plus_account is not None:
                    try:
                        aw.updatePlusStatus()
                    except Exception: # pylint: disable=broad-except
                        pass
                        # add to out-queue
                    try:
                        plus.queue.addRoast()
                    except Exception: # pylint: disable=broad-except
                        pass
                if not self.flagon:
                    aw.autoAdjustAxis(deltas=False)

            # update phases
            elif action.key[0] == 1 and self.phasesbuttonflag: # DRY
                self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
            elif action.key[0] == 2 and self.phasesbuttonflag: # FCs
                self.phases[2] = int(round(self.temp2[self.timeindex[2]]))

            aw.qmc.fileDirtySignal.emit()
            self.redraw(recomputeAllDeltas=(action.key[0] in [0,6])) # on moving CHARGE or DROP, we have to recompute the Deltas
        else:
            # add a special event at the current timepoint
            from artisanlib.events import customEventDlg
            dlg = customEventDlg(aw,aw,action.key[1])
            if dlg.exec():
                self.specialevents.append(action.key[1]) # absolute time index
                self.specialeventstype.append(dlg.type) # default: "--"
                self.specialeventsStrings.append(dlg.description)
                self.specialeventsvalue.append(dlg.value)
                aw.orderEvents()
                self.fileDirtySignal.emit()
                self.redraw(recomputeAllDeltas=(action.key[0] in [0,6])) # on moving CHARGE or DROP, we have to recompute the Deltas
            try:
                dlg.dialogbuttons.accepted.disconnect()
                dlg.dialogbuttons.rejected.disconnect()
                QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                try: # sip not supported on older PyQt versions (RPi!)
                    sip.delete(dlg)
                    #print(sip.isdeleted(dlg))
                except Exception: # pylint: disable=broad-except
                    pass
            except Exception: # pylint: disable=broad-except
                pass

    @staticmethod
    def updateWebLCDs(bt=None, et=None, time=None, alertTitle=None, alertText=None, alertTimeout=None):
        try:
            url = f'http://127.0.0.1:{aw.WebLCDsPort}/send'
            headers = {'content-type': 'application/json'}
            payload = {'data': {}}
            if not (bt is None and et is None) and aw.qmc.flagon and not aw.qmc.flagstart:
                # in monitoring only mode, timer might be set by PID RS
                time = None
            if bt is not None:
                payload['data']['bt'] = bt
            if et is not None:
                payload['data']['et'] = et
            if time is not None:
                payload['data']['time'] = time
            if alertText is not None:
                payload['alert'] = {}
                payload['alert']['text'] = alertText
                if alertTitle:
                    payload['alert']['title'] = alertTitle
                if alertTimeout:
                    payload['alert']['timeout'] = alertTimeout
            import requests
            from json import dumps as json_dumps
            requests.post(url, data=json_dumps(payload),headers=headers,timeout=0.3)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here (time might update, but not the values)
    @pyqtSlot(str,str,str)
    # pylint: disable=no-self-use # used as slot
    def updateLargeLCDs(self, bt, et, time):
        try:
            if aw.largeLCDs_dialog is not None:
                if aw.qmc.flagon and not aw.qmc.flagstart:
                    # in monitoring only mode, timer might be set by PID RS
                    time = None
                aw.largeLCDs_dialog.updateValues([et],[bt],time=time)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str,str)
    # pylint: disable=no-self-use # used as slot
    def setTimerLargeLCDcolor(self, fc, bc):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.setTimerLCDcolor(fc,bc)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str,int)
    # pylint: disable=no-self-use # used as slot
    def showAlarmPopup(self, message, timeout):
        # alarm popup message with <aw.qmc.alarm_popup_timout>sec timeout
        amb = ArtisanMessageBox(aw,QApplication.translate('Message', 'Alarm notice'),message,timeout=timeout,modal=False)
        amb.show()
        #send alarm also to connected WebLCDs clients
        if aw.WebLCDs and aw.WebLCDsAlerts:
            aw.qmc.updateWebLCDs(alertText=message,alertTimeout=timeout)

    @pyqtSlot(str,str)
    # pylint: disable=no-self-use # used as slot
    def updateLargeLCDsReadings(self, bt, et):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.updateValues([et],[bt])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    # pylint: disable=no-self-use # used as slot
    def updateLargeLCDsTime(self, time):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.updateValues([],[],time=time)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    @staticmethod
    def updateLargeDeltaLCDs(deltabt=None, deltaet=None):
        try:
            if aw.largeDeltaLCDs_dialog is not None:
                aw.largeDeltaLCDs_dialog.updateValues([deltaet],[deltabt])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    @staticmethod
    def updateLargePIDLCDs(sv=None, duty=None):
        try:
            if aw.largePIDLCDs_dialog is not None:
                aw.largePIDLCDs_dialog.updateValues([sv],[duty])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    @staticmethod
    def updateLargeScaleLCDs(weight=None, total=None):
        try:
            if aw.largeScaleLCDs_dialog is not None:
                aw.largeScaleLCDs_dialog.updateValues([weight],[total])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @staticmethod
    def updateLargeExtraLCDs(extra1=None, extra2=None):
        try:
            if aw.largeExtraLCDs_dialog is not None:
                aw.largeExtraLCDs_dialog.updateValues(extra1,extra2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # returns True if the extra device n, channel c, is of type MODBUS or S7, has no factor defined, nor any math formula, and is of type int
    # channel c is either 0 or 1
    def intChannel(self,n,c):
        if aw is not None and len(self.extradevices) > n:
            no_math_formula_defined = False
            if c == 0:
                no_math_formula_defined = bool(aw.qmc.extramathexpression1[n] == '')
            if c == 1:
                no_math_formula_defined = bool(aw.qmc.extramathexpression2[n] == '')
            if self.extradevices[n] == 29: # MODBUS
                if c == 0:
                    return ((aw.modbus.inputFloatsAsInt[0] or aw.modbus.inputBCDsAsInt[0] or not aw.modbus.inputFloats[0]) and
                        aw.modbus.inputDivs[0] == 0 and
                        aw.modbus.inputModes[0] == '' and
                        no_math_formula_defined)
                return ((aw.modbus.inputFloatsAsInt[1] or aw.modbus.inputBCDsAsInt[1] or not aw.modbus.inputFloats[1]) and
                    aw.modbus.inputDivs[1] == 0 and
                    aw.modbus.inputModes[1] == '' and
                    no_math_formula_defined)
            if self.extradevices[n] == 33: # MODBUS_34
                if c == 0:
                    return ((aw.modbus.inputFloatsAsInt[2] or aw.modbus.inputBCDsAsInt[2] or not aw.modbus.inputFloats[2]) and
                        aw.modbus.inputDivs[2] == 0 and
                        aw.modbus.inputModes[2] == '' and
                        no_math_formula_defined)
                return ((aw.modbus.inputFloatsAsInt[3] or aw.modbus.inputBCDsAsInt[3] or not aw.modbus.inputFloats[3]) and
                    aw.modbus.inputDivs[3] == 0 and
                    aw.modbus.inputModes[3] == '' and
                    no_math_formula_defined)
            if self.extradevices[n] == 55: # MODBUS_56
                if c == 0:
                    return ((aw.modbus.inputFloatsAsInt[4] or aw.modbus.inputBCDsAsInt[4] or not aw.modbus.inputFloats[4]) and
                        aw.modbus.inputDivs[4] == 0 and
                        aw.modbus.inputModes[4] == '' and
                        no_math_formula_defined)
                return ((aw.modbus.inputFloatsAsInt[5] or aw.modbus.inputBCDsAsInt[5] or not aw.modbus.inputFloats[5]) and
                    aw.modbus.inputDivs[5] == 0 and
                    aw.modbus.inputModes[5] == '' and
                    no_math_formula_defined)
            if self.extradevices[n] == 109: # MODBUS_78
                if c == 0:
                    return ((aw.modbus.inputFloatsAsInt[6] or aw.modbus.inputBCDsAsInt[6] or not aw.modbus.inputFloats[6]) and
                        aw.modbus.inputDivs[6] == 0 and
                        aw.modbus.inputModes[6] == '' and
                        no_math_formula_defined)
                return ((aw.modbus.inputFloatsAsInt[7] or aw.modbus.inputBCDsAsInt[7] or not aw.modbus.inputFloats[7]) and
                    aw.modbus.inputDivs[7] == 0 and
                    aw.modbus.inputModes[7] == '' and
                    no_math_formula_defined)
            if self.extradevices[n] == 70: # S7
                return aw.s7.type[0+c] != 1 and aw.s7.mode[0+c] == 0 and (aw.s7.div[0+c] == 0 or aw.s7.type[0+c] == 2) and no_math_formula_defined
            if self.extradevices[n] == 80: # S7_34
                return aw.s7.type[2+c] != 1 and aw.s7.mode[2+c] == 0 and (aw.s7.div[2+c] == 0 or aw.s7.type[2+c] == 2) and no_math_formula_defined
            if self.extradevices[n] == 81: # S7_56
                return aw.s7.type[4+c] != 1 and aw.s7.mode[4+c] == 0 and (aw.s7.div[4+c] == 0 or aw.s7.type[4+c] == 2) and no_math_formula_defined
            if self.extradevices[n] == 82: # S7_78
                return aw.s7.type[6+c] != 1 and aw.s7.mode[6+c] == 0 and (aw.s7.div[6+c] == 0 or aw.s7.type[6+c] == 2) and no_math_formula_defined
            if self.extradevices[n] == 110: # S7_910
                return aw.s7.type[8+c] != 1 and aw.s7.mode[8+c] == 0 and (aw.s7.div[8+c] == 0 or aw.s7.type[8+c] == 2) and no_math_formula_defined
            return False
        return False

    def update_additional_artists(self):
        if aw.qmc.flagstart and ((aw.qmc.device == 18 and aw.simulator is None) or aw.qmc.showtimeguide): # not NONE device
            tx = aw.qmc.timeclock.elapsedMilli()
            if aw.qmc.l_timeline is None:
                self.l_timeline = self.ax.axvline(tx,color = self.palette['timeguide'],
                                        label=aw.arabicReshape(QApplication.translate('Label', 'TIMEguide')),
                                        linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])
            else:
                aw.qmc.l_timeline.set_xdata(tx)
                aw.qmc.ax.draw_artist(aw.qmc.l_timeline)
        if aw.qmc.projectFlag:
            if self.l_BTprojection is not None and aw.qmc.BTcurve:
                aw.qmc.ax.draw_artist(self.l_BTprojection)
            if self.l_ETprojection is not None and aw.qmc.ETcurve:
                aw.qmc.ax.draw_artist(self.l_ETprojection)
            if aw.qmc.projectDeltaFlag:
                if self.l_DeltaBTprojection is not None and aw.qmc.DeltaBTflag:
                    aw.qmc.ax.draw_artist(self.l_DeltaBTprojection)
                if self.l_DeltaETprojection is not None and aw.qmc.DeltaETflag:
                    aw.qmc.ax.draw_artist(self.l_DeltaETprojection)

        if aw.qmc.AUCguideFlag and aw.qmc.AUCguideTime and aw.qmc.AUCguideTime > 0:
            aw.qmc.ax.draw_artist(self.l_AUCguide)

    # input filter
    # if temp (the actual reading) is outside of the interval [tmin,tmax] or
    # a spike is detected, the previous value is repeated or if that happened already before, -1 is returned
    # note that here we assume that the actual measured temperature time/temp was not already added to the list of previous measurements timex/tempx
    @staticmethod
    def inputFilter(timex, tempx, time, temp, BT=False):
        try:
            wrong_reading = 0
            #########################
            # a) detect duplicates: remove a reading if it is equal to the previous or if that is -1 to the one before that
            if aw.qmc.dropDuplicates and ((len(tempx)>1 and tempx[-1] == -1 and abs(temp - tempx[-2]) <= aw.qmc.dropDuplicatesLimit) or (len(tempx)>0 and abs(temp - tempx[-1]) <= aw.qmc.dropDuplicatesLimit)):
                wrong_reading = 2 # replace by previous reading not by -1
            #########################
            # b) detect overflows
            if aw.qmc.minmaxLimits and (temp < aw.qmc.filterDropOut_tmin or temp > aw.qmc.filterDropOut_tmax):
                wrong_reading = 1
            #########################
            # c) detect spikes (on BT only after CHARGE if autoChargeFlag=True not to have a conflict here)
            n = aw.qmc.filterDropOut_spikeRoR_period
            dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit # the limit of additional RoR in temp/sec (4C for C / 7F for F) compared to previous readings
            if aw.qmc.dropSpikes and ((not aw.qmc.autoChargeFlag) or (not BT) or (aw.qmc.timeindex[0] != -1 and (aw.qmc.timeindex[0] + n) < len(timex))) and not wrong_reading and len(tempx) >= n:
                # no min/max overflow detected
                # check if RoR caused by actual measurement is way higher then the previous one
                # calc previous RoR (pRoR) taking the last n samples into account
                pdtemp = tempx[-1] - tempx[-n]
                pdtime = timex[-1] - timex[-n]
                if pdtime > 0:
                    pRoR = abs(pdtemp/pdtime)
                    dtemp = tempx[-1] - temp
                    dtime = timex[-1] - time
                    if dtime > 0:
                        RoR = abs(dtemp/dtime)
                        if RoR > (pRoR + dRoR_limit):
                            wrong_reading = 2
            #########################
            # c) handle outliers if it could be detected
            if wrong_reading:
                if len(tempx) > 0 and tempx[-1] != -1:
                    # repeate last correct reading if not done before in the last two fixes (min/max violation are always filtered)
                    if len(tempx) == 1 or (len(tempx) > 3 and (tempx[-1] != tempx[-2] or tempx[-2] != tempx[-3])):
                        return tempx[-1]
                    if wrong_reading == 1:
                        return -1
                    # no way to correct this
                    return temp
                if wrong_reading == 1:
                    return -1
                # no way to correct this
                return temp
            # try to improve a previously corrected reading timex/temp[-1] based on the current reading time/temp (just in this case the actual reading is not a drop)
            if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes or aw.qmc.dropDuplicates):
                if len(tempx) > 2 and tempx[-1] == tempx[-2] == tempx[-3] and tempx[-1] != -1 and tempx[-1] != temp and temp!=-1: # previous reading was a drop and replaced by reading[-2] and same for the one before
                    delta = (tempx[-3] - temp) / 3.0
                    tempx[-1] = tempx[-3] - 2*delta
                    tempx[-2] = tempx[-3] - delta
                elif len(tempx) > 1 and tempx[-1] == tempx[-2] and tempx[-1] != -1 and tempx[-1] != temp and temp!=-1: # previous reading was a drop and replaced by reading[-2]
                    tempx[-1] = (tempx[-2] + temp) / 2.0
            return temp
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' filterDropOuts() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return temp

    # the temp gets averaged using the given decay weights after resampling
    # to linear time based on tx and the current sampling interval
    # -1 and None values are skipped/ignored
    @staticmethod
    def decay_average(tx_in,temp_in,decay_weights):
        if len(tx_in) != len(temp_in):
            if len(temp_in)>0:
                return temp_in[-1]
            return -1
        # remove items where temp[i]=None to fulfil precond. of numpy.interp
        tx = []
        temp = []
        for i in range(len(temp_in)):
            if temp_in[i] not in [None, -1] and not numpy.isnan(temp_in[i]):
                tx.append(tx_in[i])
                temp.append(temp_in[i])
        if len(temp) == 0:
            return -1
        #
        l = min(len(decay_weights),len(temp))
        d = aw.qmc.delay / 1000.
        tx_org = tx[-l:] # as len(tx)=len(temp) here, it is guaranteed that len(tx_org)=l
        # we create a linearly spaced time array starting from the newest timestamp in sampling interval distance
        tx_lin = numpy.flip(numpy.arange(tx_org[-1],tx_org[-1]-l*d,-d), axis=0) # by construction, len(tx_lin)=len(tx_org)=l
        temp_trail = temp[-l:] # by construction, len(temp_trail)=len(tx_lin)=len(tx_org)=l
        temp_trail_re = numpy.interp(tx_lin, tx_org, temp_trail) # resample data into that linear spaced time
        try:
            return numpy.average(temp_trail_re[-len(decay_weights):],axis=0,weights=decay_weights[-l:])  # len(decay_weights)>len(temp_trail_re)=l is possible
        except Exception: # pylint: disable=broad-except
            # in case something goes very wrong we at least return the standard average over temp, this should always work as len(tx)=len(temp)
            return numpy.average(tx,temp)

    # returns true after BT passed the TP
    def checkTPalarmtime(self):
        seconds_since_CHARGE = int(aw.qmc.timex[-1]-aw.qmc.timex[aw.qmc.timeindex[0]])
        # if v[-1] is the current temperature then check if
        #   we are 20sec after CHARGE
        #   len(BT) > 4
        # BT[-5] <= BT[-4] abd BT[-5] <= BT[-3] and BT[-5] <= BT[-2] and BT[-5] <= BT[-1] and BT[-5] < BT[-1]
        if seconds_since_CHARGE > 20 and not self.afterTP and len(aw.qmc.temp2) > 3 and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-4]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-3]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-2]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-1]) and (aw.qmc.temp2[-5] < aw.qmc.temp2[-1]):
            self.afterTP = True
        return self.afterTP

    # sample devices at interval self.delay milliseconds.
    # we can assume within the processing of sample_processing() that flagon=True
    # NOTE: sample_processing is processed in the GUI thread NOT the sample thread!
    def sample_processing(self, local_flagstart, temp1_readings, temp2_readings, timex_readings):
        ##### (try to) lock resources  #########
        gotlock = aw.qmc.profileDataSemaphore.tryAcquire(1,200) # we try to catch a lock for 200ms, if we fail we just skip this sampling round (prevents stacking of waiting calls)
#        gotlock = aw.qmc.profileDataSemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        if gotlock:
            try:
                # duplicate system state flag flagstart locally and only refer to this copy within this function to make it behaving uniquely (either append or overwrite mode)

                # initialize the arrays modified depending on the recording state
                if local_flagstart:
                    sample_timex = aw.qmc.timex
                    sample_temp1 = aw.qmc.temp1
                    sample_temp2 = aw.qmc.temp2
                    sample_ctimex1 = self.ctimex1
                    sample_ctemp1 = self.ctemp1
                    sample_ctimex2 = self.ctimex2
                    sample_ctemp2 = self.ctemp2
                    sample_tstemp1 = aw.qmc.tstemp1
                    sample_tstemp2 = aw.qmc.tstemp2
                    sample_unfiltereddelta1 = aw.qmc.unfiltereddelta1 # no sample_unfiltereddelta1_pure as used only during recording for projections
                    sample_unfiltereddelta2 = aw.qmc.unfiltereddelta2 # no sample_unfiltereddelta2_pure as used only during recording for projections
                    sample_delta1 = aw.qmc.delta1
                    sample_delta2 = aw.qmc.delta2
                    # list of lists:
                    sample_extratimex = aw.qmc.extratimex
                    sample_extratemp1 = aw.qmc.extratemp1
                    sample_extratemp2 = aw.qmc.extratemp2
                    sample_extractimex1 = aw.qmc.extractimex1
                    sample_extractemp1 = aw.qmc.extractemp1
                    sample_extractimex2 = aw.qmc.extractimex2
                    sample_extractemp2 = aw.qmc.extractemp2
                else:
                    m_len = aw.qmc.curvefilter #*2
                    sample_timex = aw.qmc.on_timex = aw.qmc.on_timex[-m_len:]
                    sample_temp1 = aw.qmc.on_temp1 = aw.qmc.on_temp1[-m_len:]
                    sample_temp2 = aw.qmc.on_temp2 = aw.qmc.on_temp2[-m_len:]
                    sample_ctimex1 = self.on_ctimex1 = self.on_ctimex1[-m_len:]
                    sample_ctemp1 = self.on_ctemp1 = self.on_ctemp1[-m_len:]
                    sample_ctimex2 = self.on_ctimex2 = self.on_ctimex2[-m_len:]
                    sample_ctemp2 = self.on_ctemp2 = self.on_ctemp2[-m_len:]
                    sample_tstemp1 = aw.qmc.on_tstemp1 = aw.qmc.on_tstemp1[-m_len:]
                    sample_tstemp2 = aw.qmc.on_tstemp2 = aw.qmc.on_tstemp2[-m_len:]
                    sample_unfiltereddelta1 = aw.qmc.on_unfiltereddelta1 = aw.qmc.on_unfiltereddelta1[-m_len:] # no sample_unfiltereddelta1_pure as used only during recording for projections
                    sample_unfiltereddelta2 = aw.qmc.on_unfiltereddelta2 = aw.qmc.on_unfiltereddelta2[-m_len:] # no sample_unfiltereddelta2_pure as used only during recording for projections
                    sample_delta1 = aw.qmc.on_delta1 = aw.qmc.on_delta1[-m_len:]
                    sample_delta2 = aw.qmc.on_delta2 = aw.qmc.on_delta2[-m_len:]
                    # list of lists:
                    for i in range(len(aw.qmc.extradevices)):
                        aw.qmc.on_extratimex[i] = aw.qmc.on_extratimex[i][-m_len:]
                        aw.qmc.on_extratemp1[i] = aw.qmc.on_extratemp1[i][-m_len:]
                        aw.qmc.on_extratemp2[i] = aw.qmc.on_extratemp2[i][-m_len:]
                        aw.qmc.on_extractimex1[i] = aw.qmc.on_extractimex1[i][-m_len:]
                        aw.qmc.on_extractemp1[i] = aw.qmc.on_extractemp1[i][-m_len:]
                        aw.qmc.on_extractimex2[i] = aw.qmc.on_extractimex2[i][-m_len:]
                        aw.qmc.on_extractemp2[i] = aw.qmc.on_extractemp2[i][-m_len:]
                    sample_extratimex = aw.qmc.on_extratimex
                    sample_extratemp1 = aw.qmc.on_extratemp1
                    sample_extratemp2 = aw.qmc.on_extratemp2
                    sample_extractimex1 = aw.qmc.on_extractimex1
                    sample_extractemp1 = aw.qmc.on_extractemp1
                    sample_extractimex2 = aw.qmc.on_extractimex2
                    sample_extractemp2 = aw.qmc.on_extractemp2

                #if using a meter (thermocouple device)
                if aw.qmc.device != 18 or aw.simulator is not None: # not NONE device

                    t1 = temp1_readings[0]
                    t2 = temp2_readings[0]
                    tx = timex_readings[0]

                    aw.qmc.RTtemp1 = t1 # store readings for real-time symbolic evaluation
                    aw.qmc.RTtemp2 = t2
                    ##############  if using Extra devices
                    nxdevices = len(aw.qmc.extradevices)
                    if nxdevices:
                        les,led,let =  len(aw.extraser),nxdevices,len(sample_extratimex)
                        if les == led == let:
                            xtra_dev_lines1 = 0
                            xtra_dev_lines2 = 0
                            #1 clear extra device buffers
                            aw.qmc.RTextratemp1,aw.qmc.RTextratemp2,aw.qmc.RTextratx = [],[],[]
                            #2 load RT buffers
                            aw.qmc.RTextratemp1 = temp1_readings[1:]
                            aw.qmc.RTextratemp2 = temp2_readings[1:]
                            aw.qmc.RTextratx = timex_readings[1:]
                            #3 evaluate symbolic expressions
                            for i in range(nxdevices):
                                extratx = aw.qmc.RTextratx[i]
                                extrat1 = aw.qmc.RTextratemp1[i]
                                extrat2 = aw.qmc.RTextratemp2[i]
                                if len(aw.qmc.extramathexpression1) > i and aw.qmc.extramathexpression1[i] is not None and len(aw.qmc.extramathexpression1[i]):
                                    try:
                                        extrat1 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression1[i],aw.qmc.RTextratx[i],RTsname='Y'+str(2*i+3),RTsval=aw.qmc.RTextratemp1[i])
                                        aw.qmc.RTextratemp1[i] = extrat1
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                if len(aw.qmc.extramathexpression2) > i and aw.qmc.extramathexpression2[i] is not None and len(aw.qmc.extramathexpression2[i]):
                                    try:
                                        extrat2 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression2[i],aw.qmc.RTextratx[i],RTsname='Y'+str(2*i+4),RTsval=aw.qmc.RTextratemp2[i])
                                        aw.qmc.RTextratemp2[i] = extrat2
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)

                                et1_prev = et2_prev = None
                                et1_prevprev = et2_prevprev = None
                                if aw.qmc.extradevices[i] != 25: # don't apply input filters to virtual devices

                                    ## Apply InputFilters. As those might modify destructively up to two older readings in temp1/2 via interpolation for drop outs we try to detect this and copy those
                                    # changes back to the ctemp lines that are rendered.
                                    if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes or aw.qmc.dropDuplicates):
                                        if len(sample_extratemp1[i])>0:
                                            et1_prev = sample_extratemp1[i][-1]
                                            if len(sample_extratemp1[i])>1:
                                                et1_prevprev = sample_extratemp1[i][-2]
                                        if len(sample_extratemp2[i])>0:
                                            et2_prev = sample_extratemp2[i][-1]
                                            if len(sample_extratemp2[i])>1:
                                                et2_prevprev = sample_extratemp2[i][-2]
                                    extrat1 = self.inputFilter(sample_extratimex[i],sample_extratemp1[i],extratx,extrat1)
                                    extrat2 = self.inputFilter(sample_extratimex[i],sample_extratemp2[i],extratx,extrat2)

                                    # now copy the destructively modified values from temp1/2 to ctemp1/2 if any (to ensure to pick the right elements we compare the timestamps at those indices)
                                    if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes or aw.qmc.dropDuplicates):
                                        if len(sample_extractimex1[i])>0:
                                            if et1_prev is not None and sample_extractimex1[i][-1] == sample_extratimex[i][-1] and et1_prev != sample_extratemp1[i][-1]:
                                                sample_extractemp1[i][-1] = sample_extratemp1[i][-1]
                                            if len(sample_extractimex1[i])>1 and et1_prevprev is not None and sample_extractimex1[i][-2] == sample_extratimex[i][-2] and et1_prevprev != sample_extratemp1[i][-2]:
                                                sample_extractemp1[i][-2] = sample_extratemp1[i][-2]
                                        if len(sample_extractimex2[i])>0:
                                            if et2_prev is not None and sample_extractimex2[i][-1] == sample_extratimex[i][-1] and et2_prev != sample_extratemp2[i][-1]:
                                                sample_extractemp2[i][-1] = sample_extratemp2[i][-1]
                                            if len(sample_extractimex2[i])>1 and et2_prevprev is not None and sample_extractimex2[i][-2] == sample_extratimex[i][-2] and et2_prevprev != sample_extratemp2[i][-2]:
                                                sample_extractemp2[i][-2] = sample_extratemp2[i][-2]

                                sample_extratimex[i].append(extratx)
                                sample_extratemp1[i].append(float(extrat1))
                                sample_extratemp2[i].append(float(extrat2))

                                # gaps larger than 3 readings are not connected in the graph (as util.py:fill_gaps() is not interpolating them)
                                if extrat1 != -1:
                                    sample_extractimex1[i].append(float(extratx))
                                    sample_extractemp1[i].append(float(extrat1))
                                elif len(sample_extratemp1[i])>(aw.qmc.interpolatemax+1) and all(v == -1 for v in sample_extratemp1[i][-(aw.qmc.interpolatemax+1):]):
                                    sample_extractimex1[i].append(float(extratx))
                                    sample_extractemp1[i].append(None)
                                if extrat2 != -1:
                                    sample_extractimex2[i].append(float(extratx))
                                    sample_extractemp2[i].append(float(extrat2))
                                elif len(sample_extratemp2[i])>(aw.qmc.interpolatemax+1) and all(v == -1 for v in sample_extratemp2[i][-(aw.qmc.interpolatemax+1):]):
                                    sample_extractimex2[i].append(float(extratx))
                                    sample_extractemp2[i].append(None)

                                # update extra lines

                                if aw.extraCurveVisibility1[i] and len(aw.qmc.extratemp1lines) > xtra_dev_lines1:
                                    aw.qmc.extratemp1lines[xtra_dev_lines1].set_data(sample_extractimex1[i], sample_extractemp1[i])
                                    xtra_dev_lines1 = xtra_dev_lines1 + 1
                                if aw.extraCurveVisibility2[i] and len(aw.qmc.extratemp2lines) > xtra_dev_lines2:
                                    aw.qmc.extratemp2lines[xtra_dev_lines2].set_data(sample_extractimex2[i], sample_extractemp2[i])
                                    xtra_dev_lines2 = xtra_dev_lines2 + 1
                        #ERROR FOUND
                        else:
                            lengths = [les,led,let]
                            location = ['Extra-Serial','Extra-Devices','Extra-Temp']
                            #find error
                            if (nxdevices-1) in lengths:
                                indexerror =  lengths.index(nxdevices-1)
                            elif (nxdevices+1) in lengths:
                                indexerror =  lengths.index(nxdevices+1)
                            else:
                                indexerror = 1000
                            if indexerror != 1000:
                                errormessage = 'ERROR: length of %s (=%i) does not have the necessary length (=%i)'%(location[indexerror],lengths[indexerror],nxdevices)
                                errormessage += '\nPlease Reset: Extra devices'
                            else:
                                string = f'{location[0]}= {lengths[0]} {location[1]}= {lengths[1]} {location[2]}= {lengths[2]}'
                                errormessage = "ERROR: extra devices lengths don't match: %s"%string
                                errormessage += '\nPlease Reset: Extra devices'
                            raise Exception(errormessage)

                    ####### all values retrieved

                    if aw.qmc.ETfunction is not None and len(aw.qmc.ETfunction):
                        try:
                            t1 = aw.qmc.eval_math_expression(aw.qmc.ETfunction,tx,RTsname='Y1',RTsval=t1)
                            aw.qmc.RTtemp1 = t1
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    if aw.qmc.BTfunction is not None and len(aw.qmc.BTfunction):
                        try:
                            t2 = aw.qmc.eval_math_expression(aw.qmc.BTfunction,tx,RTsname='Y2',RTsval=t2)
                            aw.qmc.RTtemp2 = t2
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    # if modbus device do the C/F conversion if needed (done after mathexpression, not to mess up with x/10 formulas)
                    # modbus channel 1+2, respect input temperature scale setting

                    ## Apply InputFilters. As those might modify destructively up to two older readings in temp1/2 via interpolation for drop outs we try to detect this and copy those
                    # changes back to the ctemp lines that are rendered.
                    t1_prev = t2_prev = None
                    t1_prevprev = t2_prevprev = None
                    if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes or aw.qmc.dropDuplicates):
                        if len(sample_temp1)>0:
                            t1_prev = sample_temp1[-1]
                            if len(sample_temp1)>1:
                                t1_prevprev = sample_temp1[-2]
                        if len(sample_temp2)>0:
                            t2_prev = sample_temp2[-1]
                            if len(sample_temp2)>1:
                                t2_prevprev = sample_temp2[-2]
                    t1 = self.inputFilter(sample_timex,sample_temp1,tx,t1)
                    t2 = self.inputFilter(sample_timex,sample_temp2,tx,t2,True)


                    length_of_qmc_timex = len(sample_timex)

                    # now copy the destructively modified values from temp1/2 to ctemp1/2 if any (to ensure to pick the right elements we compare the timestamps at those indices)
                    if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes or aw.qmc.dropDuplicates):
                        if len(sample_ctimex1)>0:
                            if t1_prev is not None and sample_ctimex1[-1] == sample_timex[-1] and t1_prev != sample_temp1[-1]:
                                sample_ctemp1[-1] = sample_temp1[-1]
                            if len(sample_ctimex1)>1 and t1_prevprev is not None and sample_ctimex1[-2] == sample_timex[-2] and t1_prevprev != sample_temp1[-2]:
                                sample_ctemp1[-2] = sample_temp1[-2]
                        if len(sample_ctimex2)>0:
                            if t2_prev is not None and sample_ctimex2[-1] == sample_timex[-1] and t2_prev != sample_temp2[-1]:
                                sample_ctemp2[-1] = sample_temp2[-1]
                            if len(sample_ctimex2)>1 and t2_prevprev is not None and sample_ctimex2[-2] == sample_timex[-2] and t2_prevprev != sample_temp2[-2]:
                                sample_ctemp2[-2] = sample_temp2[-2]
                    t1_final = t1
                    t2_final = t2
                    sample_temp1.append(t1_final)
                    sample_temp2.append(t2_final)
                    sample_timex.append(tx)
                    length_of_qmc_timex += 1
                    if t1_final != -1:
                        sample_ctimex1.append(tx)
                        sample_ctemp1.append(t1_final)
                    elif len(sample_temp1)>(aw.qmc.interpolatemax+1) and all(v == -1 for v in sample_temp1[-(aw.qmc.interpolatemax+1):]):
                        sample_ctimex1.append(tx)
                        sample_ctemp1.append(None)
                    if t2_final != -1:
                        sample_ctimex2.append(tx)
                        sample_ctemp2.append(t2_final)
                    elif len(sample_temp2)>(aw.qmc.interpolatemax+1) and all(v == -1 for v in sample_temp2[-(aw.qmc.interpolatemax+1):]):
                        sample_ctimex2.append(tx)
                        sample_ctemp2.append(None)


                    #we populate the temporary smoothed ET/BT data arrays (with readings cleansed from -1 dropouts)
                    cf = aw.qmc.curvefilter #*2 - 1 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                    if self.temp_decay_weights is None or len(self.temp_decay_weights) != cf: # recompute only on changes
                        self.temp_decay_weights = numpy.arange(1,cf+1)
                    # we don't smooth st'x if last, or butlast temperature value were a drop-out not to confuse the RoR calculation
                    if -1 in sample_temp1[-(cf+1):]:
                        dw1 = [1]
                    else:
                        dw1 = self.temp_decay_weights
                    if -1 in sample_temp2[-(cf+1):]:
                        dw2 = [1]
                    else:
                        dw2 = self.temp_decay_weights
                    # average smoothing
                    if len(sample_ctemp1) > 0:
                        st1 = self.decay_average(sample_ctimex1,sample_ctemp1,dw1)
                    else:
                        st1 = -1
                    if len(sample_ctemp2) > 0:
                        st2 = self.decay_average(sample_ctimex2,sample_ctemp2,dw2)
                    else:
                        st2 = -1

                    # we apply a minimal live median spike filter minimizing the delay by choosing a window smaller than in the offline medfilt
                    if aw.qmc.filterDropOuts and not self.delay > 2000:
                        st1 = aw.qmc.liveMedianETfilter(st1)
                        st2 = aw.qmc.liveMedianBTfilter(st2)

                    # register smoothed values
                    sample_tstemp1.append(st1)
                    sample_tstemp2.append(st2)

                    if local_flagstart:
                        if aw.qmc.ETcurve:
                            aw.qmc.l_temp1.set_data(sample_ctimex1, sample_ctemp1)
                        if aw.qmc.BTcurve:
                            aw.qmc.l_temp2.set_data(sample_ctimex2, sample_ctemp2)

                    if (aw.qmc.Controlbuttonflag and aw.pidcontrol.pidActive and \
                            not aw.pidcontrol.externalPIDControl()): # any device and + Artisan Software PID lib
                        if aw.pidcontrol.pidSource == 1:
                            aw.qmc.pid.update(st2) # smoothed BT
                        else:
                            aw.qmc.pid.update(st1) # smoothed ET

                    #we need a minimum of two readings to calculate rate of change
#                    if local_flagstart and length_of_qmc_timex > 1:
                    if length_of_qmc_timex > 1:
                        # compute T1 RoR
                        if t1_final == -1 or len(sample_ctimex1)<2:  # we repeat the last RoR if underlying temperature dropped
                            if sample_unfiltereddelta1:
                                aw.qmc.rateofchange1 = sample_unfiltereddelta1[-1]
                            else:
                                aw.qmc.rateofchange1 = 0.
                        else: # normal data received
                            #   Delta T = (changeTemp/ChangeTime)*60. =  degrees per minute;
                            left_index = min(len(sample_ctimex1),len(sample_tstemp1),max(2, aw.qmc.deltaETsamples + 1))
                            # ****** Instead of basing the estimate on the window extremal points,
                            #        grab the full set of points and do a formal LS solution to a straight line and use the slope estimate for RoR
                            if aw.qmc.polyfitRoRcalc:
                                try:
                                    time_vec = sample_ctimex1[-left_index:]
                                    temp_samples = sample_tstemp1[-left_index:]
                                    with warnings.catch_warnings():
                                        warnings.simplefilter('ignore')
                                        # using stable polyfit from numpy polyfit module
                                        LS_fit = numpy.polynomial.polynomial.polyfit(time_vec, temp_samples, 1)
                                        aw.qmc.rateofchange1 = LS_fit[1]*60.
                                except Exception: # pylint: disable=broad-except
                                    # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                                    # https://github.com/numpy/numpy/issues/16744
                                    # we fall back to the two point algo
                                    timed = sample_ctimex1[-1] - sample_ctimex1[-left_index]   #time difference between last aw.qmc.deltaETsamples readings
                                    aw.qmc.rateofchange1 = ((sample_tstemp1[-1] - sample_tstemp1[-left_index])/timed)*60.  #delta ET (degrees/minute)
                            else:
                                timed = sample_ctimex1[-1] - sample_ctimex1[-left_index]   #time difference between last aw.qmc.deltaETsamples readings
                                aw.qmc.rateofchange1 = ((sample_tstemp1[-1] - sample_tstemp1[-left_index])/timed)*60.  #delta ET (degrees/minute)

                        # compute T2 RoR
                        if t2_final == -1 or len(sample_ctimex2)<2:  # we repeat the last RoR if underlying temperature dropped
                            if sample_unfiltereddelta2:
                                aw.qmc.rateofchange2 = sample_unfiltereddelta2[-1]
                            else:
                                aw.qmc.rateofchange2 = 0.
                        else: # normal data received
                            #   Delta T = (changeTemp/ChangeTime)*60. =  degrees per minute;
                            left_index = min(len(sample_ctimex2),len(sample_tstemp2),max(2, aw.qmc.deltaBTsamples + 1))
                            # ****** Instead of basing the estimate on the window extremal points,
                            #        grab the full set of points and do a formal LS solution to a straight line and use the slope estimate for RoR
                            if aw.qmc.polyfitRoRcalc:
                                try:
                                    time_vec = sample_ctimex2[-left_index:]
                                    temp_samples = sample_tstemp2[-left_index:]
                                    with warnings.catch_warnings():
                                        warnings.simplefilter('ignore')
                                        LS_fit = numpy.polynomial.polynomial.polyfit(time_vec, temp_samples, 1)
                                        aw.qmc.rateofchange2 = LS_fit[1]*60.
                                except Exception: # pylint: disable=broad-except
                                    # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                                    # https://github.com/numpy/numpy/issues/16744
                                    # we fall back to the two point algo
                                    timed = sample_ctimex2[-1] - sample_ctimex2[-left_index]   #time difference between last aw.qmc.deltaBTsamples readings
                                    aw.qmc.rateofchange2 = ((sample_tstemp2[-1] - sample_tstemp2[-left_index])/timed)*60.  #delta BT (degrees/minute)
                            else:
                                timed = sample_ctimex2[-1] - sample_ctimex2[-left_index]   #time difference between last aw.qmc.deltaBTsamples readings
                                aw.qmc.rateofchange2 = ((sample_tstemp2[-1] - sample_tstemp2[-left_index])/timed)*60.  #delta BT (degrees/minute)


                        # aw.qmc.unfiltereddelta{1,2}_pure contain the RoR values respecting the delta_span, but without any delta smoothing NOR delta mathformulas applied
                        aw.qmc.unfiltereddelta1_pure.append(aw.qmc.rateofchange1)
                        aw.qmc.unfiltereddelta2_pure.append(aw.qmc.rateofchange2)

                        # apply the math formula before the delta smoothing
                        if aw.qmc.DeltaETfunction is not None and len(aw.qmc.DeltaETfunction):
                            try:
                                aw.qmc.rateofchange1 = aw.qmc.eval_math_expression(aw.qmc.DeltaETfunction,tx,RTsname='R1',RTsval=aw.qmc.rateofchange1)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        if aw.qmc.DeltaBTfunction is not None and len(aw.qmc.DeltaBTfunction):
                            try:
                                aw.qmc.rateofchange2 = aw.qmc.eval_math_expression(aw.qmc.DeltaBTfunction,tx,RTsname='R2',RTsval=aw.qmc.rateofchange2)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)

                        # unfiltereddelta1/2 contains the RoRs respecting the delta_span, but without any delta smoothing AND delta mathformulas applied
                        # we apply a minimal live median spike filter minimizing the delay by choosing a window smaller than in the offline medfilt
                        if aw.qmc.filterDropOuts and not self.delay > 2000:
                            aw.qmc.rateofchange1 = aw.qmc.liveMedianRoRfilter(aw.qmc.rateofchange1)
                            aw.qmc.rateofchange2 = aw.qmc.liveMedianRoRfilter(aw.qmc.rateofchange2)

                        sample_unfiltereddelta1.append(aw.qmc.rateofchange1)
                        sample_unfiltereddelta2.append(aw.qmc.rateofchange2)

                        #######   filter deltaBT deltaET
                        # decay smoothing
                        if aw.qmc.deltaETfilter:
                            user_filter = int(round(aw.qmc.deltaETfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(sample_unfiltereddelta1) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = numpy.arange(1,user_filter+1)
                                aw.qmc.rateofchange1 = self.decay_average(sample_timex,sample_unfiltereddelta1,self.decay_weights)
                        if aw.qmc.deltaBTfilter:
                            user_filter = int(round(aw.qmc.deltaBTfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(sample_unfiltereddelta2) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = numpy.arange(1,user_filter+1)
                                aw.qmc.rateofchange2 = self.decay_average(sample_timex,sample_unfiltereddelta2,self.decay_weights)
                        rateofchange1plot = aw.qmc.rateofchange1
                        rateofchange2plot = aw.qmc.rateofchange2
                    else:
                        sample_unfiltereddelta1.append(0.)
                        sample_unfiltereddelta2.append(0.)
                        aw.qmc.rateofchange1,aw.qmc.rateofchange2,rateofchange1plot,rateofchange2plot = 0.,0.,0.,0.

                    # limit displayed RoR #(only before TP is recognized) # WHY?
                    if aw.qmc.RoRlimitFlag: # not aw.qmc.TPalarmtimeindex and aw.qmc.RoRlimitFlag:
                        if not (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < rateofchange1plot < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)):
                            rateofchange1plot = None
                        if not (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < rateofchange2plot < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)):
                            rateofchange2plot = None

                    # append new data to the rateofchange arrays
                    sample_delta1.append(rateofchange1plot)
                    sample_delta2.append(rateofchange2plot)

                    if local_flagstart:
                        ror_start = 0
                        ror_end = length_of_qmc_timex
                        if self.timeindex[6] > 0:
                            ror_end = self.timeindex[6]+1
                        if self.DeltaETflag:
                            if self.timeindex[0] > -1:
                                ror_start = max(self.timeindex[0],self.timeindex[0]+int(round(self.deltaETfilter/2.)) + max(2,(self.deltaETsamples + 1)))
                                self.l_delta1.set_data(sample_timex[ror_start:ror_end], sample_delta1[ror_start:ror_end])
                            else:
                                self.l_delta1.set_data([], [])
                        if self.DeltaBTflag:
                            if self.timeindex[0] > -1:
                                ror_start = max(self.timeindex[0],self.timeindex[0]+int(round(self.deltaBTfilter/2.)) + max(2,(self.deltaBTsamples + 1)))
                                self.l_delta2.set_data(sample_timex[ror_start:ror_end], sample_delta2[ror_start:ror_end])
                            else:
                                self.l_delta2.set_data([], [])

                        #readjust xlimit of plot if needed
                        if  not self.fixmaxtime and not self.locktimex:
                            now = (sample_timex[-1] if self.timeindex[0] == -1 else sample_timex[-1] - sample_timex[self.timeindex[0]])
                            if now > (self.endofx - 45):            # if difference is smaller than 45 seconds
                                self.endofx = int(now + 180.)       # increase x limit by 3 minutes
                                self.xaxistosm()
                        if self.projectFlag:
                            self.updateProjection()

                        # autodetect CHARGE event
                        # only if BT > 77C/170F
                        if not aw.qmc.autoChargeIdx and aw.qmc.autoChargeFlag and aw.qmc.autoCHARGEenabled and aw.qmc.timeindex[0] < 0 and length_of_qmc_timex >= 5 and \
                            ((aw.qmc.mode == 'C' and sample_temp2[-1] > 77) or (aw.qmc.mode == 'F' and sample_temp2[-1] > 170)):
                            if aw.qmc.mode == 'C':
                                o = 0.5
                            else:
                                o = 0.5 * 1.8
                            b = aw.BTbreak(length_of_qmc_timex - 1,o)
                            if b > 0:
                                # we found a BT break at the current index minus b
                                aw.qmc.autoChargeIdx = length_of_qmc_timex - b
                        # check for TP event if already CHARGEed and not yet recognized (earliest in the next call to sample())
                        elif not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and aw.qmc.timeindex[0]+8 < len(sample_temp2) and self.checkTPalarmtime():
                            try:
                                tp = aw.findTP()
                                if ((aw.qmc.mode == 'C' and sample_temp2[tp] > 50 and sample_temp2[tp] < 150) or \
                                    (aw.qmc.mode == 'F' and sample_temp2[tp] > 100 and sample_temp2[tp] < 300)): # only mark TP if not an error value!
                                    aw.qmc.autoTPIdx = 1
                                    aw.qmc.TPalarmtimeindex = tp
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                            try:
                                # if 2:30min into the roast and TPalarmtimeindex alarmindex not yet set,
                                # we place the TPalarmtimeindex at the current index to enable in airoasters without TP the autoDRY and autoFCs functions and activate the TP Phases LCDs
                                if aw.qmc.TPalarmtimeindex is None and ((sample_timex[-1] - sample_timex[aw.qmc.timeindex[0]]) > 150):
                                    aw.qmc.TPalarmtimeindex = length_of_qmc_timex - 1
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        # autodetect DROP event
                        # only if 8min into roast and BT>160C/320F
                        if not aw.qmc.autoDropIdx and aw.qmc.autoDropFlag and aw.qmc.autoDROPenabled and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6] and \
                            length_of_qmc_timex >= 5 and ((aw.qmc.mode == 'C' and sample_temp2[-1] > 160) or (aw.qmc.mode == 'F' and sample_temp2[-1] > 320)) and\
                            ((sample_timex[-1] - sample_timex[aw.qmc.timeindex[0]]) > 420):
                            if aw.qmc.mode == 'C':
                                o = 0.2
                            else:
                                o = 0.2 * 1.8
                            b = aw.BTbreak(length_of_qmc_timex - 1,o)
                            if b > 0:
                                # we found a BT break at the current index minus b
                                aw.qmc.autoDropIdx = length_of_qmc_timex - b
                        #check for autoDRY: # only after CHARGE and TP and before FCs if not yet set
                        if aw.qmc.autoDRYflag and aw.qmc.autoDRYenabled and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and not aw.qmc.timeindex[2]:
                            # if DRY event not yet set check for BT exceeding Dry-max as specified in the phases dialog
                            if sample_temp2[-1] >= aw.qmc.phases[1]:
                                aw.qmc.autoDryIdx = 1
                        #check for autoFCs: # only after CHARGE and TP and before FCe if not yet set
                        if aw.qmc.autoFCsFlag and aw.qmc.autoFCsenabled and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[2] and not aw.qmc.timeindex[3]:
                            # after DRY (if FCs event not yet set) check for BT exceeding FC-min as specified in the phases dialog
                            if sample_temp2[-1] >= aw.qmc.phases[2]:
                                aw.qmc.autoFCsIdx = 1

                    #process active quantifiers
                    try:
                        aw.process_active_quantifiers()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    #update SV on Arduino/TC4, Hottop, or MODBUS if in Ramp/Soak or Background Follow mode and PID is active
                    if aw.qmc.flagon: # only during sampling
                        #update SV on FujiPIDs
                        if aw.qmc.device == 0 and aw.fujipid.followBackground and aw.qmc.flagstart: # no SV updates while not yet recording for Fuji PIDs
                            # calculate actual SV
                            sv = aw.fujipid.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.fujipid.setsv(sv,silent=True) # this is called in updategraphics() within the GUI thread to move the sliders
                        elif (aw.pidcontrol.pidActive and aw.pidcontrol.svMode == 1) or aw.pidcontrol.svMode == 2:
                            # in BackgroundFollow mode we update the SV even if not active, just we do not move the SV slider
                            # calculate actual SV
                            sv = aw.pidcontrol.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != aw.pidcontrol.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.pidcontrol.setSV(sv,init=False) # this is called in updategraphics() within the GUI thread to move the sliders

                    # update AUC running value
                    if local_flagstart: # only during recording
                        try:
                            aw.updateAUC()
                            if aw.qmc.AUCguideFlag:
                                aw.updateAUCguide()
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)

                    #output ET, BT, ETB, BTB to output program
                    if aw.ser.externaloutprogramFlag:
                        try:
                            from subprocess import call as subprocesscall# @Reimport
                            if aw.qmc.background:
                                if aw.qmc.timeindex[0] != -1:
                                    j = aw.qmc.backgroundtime2index(tx - sample_timex[aw.qmc.timeindex[0]])
                                else:
                                    j = aw.qmc.backgroundtime2index(tx)
                                ETB = aw.qmc.temp1B[j]
                                BTB = aw.qmc.temp2B[j]
                            else:
                                ETB = -1
                                BTB = -1
                            subprocesscall([aw.ser.externaloutprogram,
                                f'{sample_temp1[-1]:.1f}',
                                f'{sample_temp2[-1]:.1f}',
                                f'{ETB:.1f}',
                                f'{BTB:.1f}'])
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)

                    #check for each alarm that was not yet triggered
                    try:
                        aw.qmc.alarmSemaphore.acquire(1)
                        for i in range(len(aw.qmc.alarmflag)):
                            #if alarm on, and not triggered, and time is after set time:
                            # menu: 0:ON, 1:START, 2:CHARGE, 3:TP, 4:DRY, 5:FCs, 6:FCe, 7:SCs, 8:SCe, 9:DROP, 10:COOL
                            # qmc.alarmtime = -1 (None == START)
                            # qmc.alarmtime = 0 (CHARGE)
                            # qmc.alarmtime = 1 (DRY)
                            # qmc.alarmtime = 2 (FCs)
                            # qmc.alarmtime = 3 (FCe)
                            # qmc.alarmtime = 4 (SCs)
                            # qmc.alarmtime = 5 (SCe)
                            # qmc.alarmtime = 6 (DROP)
                            # qmc.alarmtime = 7 (COOL)
                            # qmc.alarmtime = 8 (TP)
                            # qmc.alarmtime = 9 (ON)
                            # qmc.alamrtime = 10 (If Alarm)
                            # Cases: (only between CHARGE and DRY we check for TP if alarmtime[i]=8)
                            # 1) the alarm From is START
                            # 2) the alarm was not triggered yet
                            # 3) the alarm From is ON
                            # 4) the alarm From is CHARGE
                            # 5) the alarm From is any other event but TP
                            # 6) the alarm From is TP, it is CHARGED and the TP pattern is recognized
                            if aw.qmc.alarmflag[i] \
                              and aw.qmc.alarmstate[i] == -1 \
                              and (aw.qmc.alarmguard[i] < 0 or (0 <= aw.qmc.alarmguard[i] < len(aw.qmc.alarmstate) and aw.qmc.alarmstate[aw.qmc.alarmguard[i]] != -1)) \
                              and (aw.qmc.alarmnegguard[i] < 0 or (0 <= aw.qmc.alarmnegguard[i] < len(aw.qmc.alarmstate) and aw.qmc.alarmstate[aw.qmc.alarmnegguard[i]] == -1)) \
                              and ((aw.qmc.alarmtime[i] == 9) or (aw.qmc.alarmtime[i] < 0 and local_flagstart) \
                                or (local_flagstart and aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1) \
                                or (local_flagstart and aw.qmc.alarmtime[i] > 0 and aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0) \
                                or (aw.qmc.alarmtime[i] == 10 and aw.qmc.alarmguard[i] != -1)  \
                                or (local_flagstart and aw.qmc.alarmtime[i] == 8 and aw.qmc.timeindex[0] > -1 \
                                    and aw.qmc.TPalarmtimeindex)):
                                #########
                                # check alarmoffset (time after From event):
                                if aw.qmc.alarmoffset[i] > 0:
                                    alarm_time = aw.qmc.timeclock.elapsed()/1000.
                                    if aw.qmc.alarmtime[i] < 0: # time after START
                                        pass # the alarm_time is the clock time
                                    elif local_flagstart and aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1: # time after CHARGE
                                        alarm_time = alarm_time - sample_timex[aw.qmc.timeindex[0]]
                                    elif local_flagstart and aw.qmc.alarmtime[i] == 8 and aw.qmc.TPalarmtimeindex: # time after TP
                                        alarm_time = alarm_time - sample_timex[aw.qmc.TPalarmtimeindex]
                                    elif local_flagstart and aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0: # time after any other event
                                        alarm_time = alarm_time - sample_timex[aw.qmc.timeindex[aw.qmc.alarmtime[i]]]
                                    elif local_flagstart and aw.qmc.alarmtime[i] == 10: # time or temp after the trigger of the alarmguard (if one is set)
                                        # we know here that the alarmstate of the guard is valid as it has triggered
                                        alarm_time = alarm_time - sample_timex[aw.qmc.alarmstate[aw.qmc.alarmguard[i]]]

                                    if alarm_time >= aw.qmc.alarmoffset[i]:
                                        aw.qmc.temporaryalarmflag = i
                                #########
                                # check alarmtemp:
                                alarm_temp = None
                                if aw.qmc.alarmtime[i] == 10: # IF ALARM and only during recording as otherwise no data to refer to is available
                                    # and this is a conditional alarm with alarm_time set to IF ALARM
                                    if_alarm_state = aw.qmc.alarmstate[aw.qmc.alarmguard[i]] # reading when the IF ALARM triggered
                                    if if_alarm_state != -1:
                                        if if_alarm_state < len(sample_timex):
                                            alarm_idx = if_alarm_state
                                        else:
                                            alarm_idx = -1
                                    # we subtract the reading at alarm_idx from the current reading of the channel determined by alarmsource
                                else:
                                    alarm_idx = None
                                if aw.qmc.alarmsource[i] == -2 and sample_delta1[-1]:  #check DeltaET (might be None)
                                    alarm_temp = sample_delta1[-1]
                                    if alarm_idx != None:
                                        alarm_temp -= sample_delta1[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif aw.qmc.alarmsource[i] == -1 and sample_delta2[-1]: #check DeltaBT (might be None
                                    alarm_temp = sample_delta2[-1]
                                    if alarm_idx != None:
                                        alarm_temp -= sample_delta2[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif aw.qmc.alarmsource[i] == 0:                      #check ET
                                    alarm_temp = sample_temp1[-1]
                                    if alarm_idx != None:
                                        alarm_temp -= sample_temp1[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif aw.qmc.alarmsource[i] == 1:                      #check BT
                                    alarm_temp = sample_temp2[-1]
                                    if alarm_idx != None:
                                        alarm_temp -= sample_temp2[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif aw.qmc.alarmsource[i] > 1 and ((aw.qmc.alarmsource[i] - 2) < (2*len(aw.qmc.extradevices))):
                                    if (aw.qmc.alarmsource[i])%2==0:
                                        alarm_temp = sample_extratemp1[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                        if alarm_idx != None:
                                            alarm_temp -= sample_extratemp1[(aw.qmc.alarmsource[i] - 2)//2][alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                    else:
                                        alarm_temp = sample_extratemp2[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                        if alarm_idx != None:
                                            alarm_temp -= sample_extratemp2[(aw.qmc.alarmsource[i] - 2)//2][alarm_idx] # subtract the reading at alarm_idx for IF ALARMs

                                alarm_limit = aw.qmc.alarmtemperature[i]

                                if alarm_temp is not None and alarm_temp != -1 and (
                                        (aw.qmc.alarmcond[i] == 1 and alarm_temp > alarm_limit) or
                                        (aw.qmc.alarmcond[i] == 0 and alarm_temp < alarm_limit) or
                                        (alarm_idx != None and alarm_temp == alarm_limit)): # for relative IF_ALARMS we include the equality
                                    aw.qmc.temporaryalarmflag = i
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    finally:
                        if aw.qmc.alarmSemaphore.available() < 1:
                            aw.qmc.alarmSemaphore.release(1)

                #############    if using DEVICE 18 (no device). Manual mode
                # temperatures are entered when pressing push buttons like for example at aw.qmc.markDryEnd()
                else:
                    tx = int(aw.qmc.timeclock.elapsed()/1000.)
                    #readjust xlimit of plot if needed
                    if  not self.fixmaxtime and not self.locktimex:
                        now = (tx if self.timeindex[0] == -1 else tx - sample_timex[self.timeindex[0]])
                        if now > (self.endofx - 45):            # if difference is smaller than 45 seconds
                            self.endofx = now + 180              # increase x limit by 3 minutes (180)
                            self.ax.set_xlim(aw.qmc.startofx,self.endofx)
                            self.xaxistosm()
                    # also in the manual case we check for TP
                    if local_flagstart:
                        # check for TP event if already CHARGEed and not yet recognized
                        if not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[0]+5 < len(sample_temp2) and self.checkTPalarmtime():
                            aw.qmc.autoTPIdx = 1
                            aw.qmc.TPalarmtimeindex = aw.findTP()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' sample() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
                #update screen in main GUI thread
                self.updategraphicsSignal.emit()


    # idx is the index to be displayed, by default -1 (the last item of each given array)
    # if idx is None, the default error values are displayed
    # all other parameters are expected to be lists of values, but for PID_SV and PID_DUTY
    # time is the time at in second to be displayed (might be negative, but negative times are rendered as 00:00)
    # if time is None, the timer LCD is not updated
    # time is only updated if not sampling (aw.qmc.flagon=False)
    # values of -1 are suppressed to their default "off" representation
    # XTs1 and XTs2 are lists of lists of values for the corresponding extra LCDs
    def updateLCDs(self, time, temp1, temp2, delta1, delta2, XTs1, XTs2, PID_SV=-1, PID_DUTY=-1, idx=-1):
        try:
            if self.LCDdecimalplaces:
                lcdformat = '%.1f'
                if idx is None:
                    resLCD = '-.-'
                else:
                    resLCD = 'u.u'
            else:
                lcdformat = '%.0f'
                if idx is None:
                    resLCD = '--'
                else:
                    resLCD = 'uu'
            timestr = None
            ## TIMER LCDS:
            if not self.flagon and time is not None:
                timestr = '00:00'
                if time > 0:
                    try:
                        timestr = stringfromseconds(time)
                    except Exception: # pylint: disable=broad-except
                        pass
                self.setLCDtimestr(timestr)

            ## ET LCD:
            etstr = resLCD
            try: # if temp1 is None, which should never be the case, this fails
                if temp1 and idx is not None and idx < len(temp1) and temp1[idx] not in [None, -1] and not numpy.isnan(temp1[idx]):
                    if -100 < temp1[idx] < 1000:
                        etstr = lcdformat%temp1[idx]
                    elif self.LCDdecimalplaces and -10000 < temp1[idx] < 100000:
                        etstr = '%.0f'%temp1[idx]
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            aw.lcd2.display(etstr)

            ## BT LCD:
            btstr = resLCD
            try:
                if temp2 and idx is not None and idx < len(temp2) and temp2[idx] not in [None, -1] and not numpy.isnan(temp2[idx]):
                    if -100 < temp2[idx] < 1000:
                        btstr = lcdformat%temp2[idx]            # BT
                    elif self.LCDdecimalplaces and -10000 < temp2[idx] < 100000:
                        btstr = '%.0f'%float(temp2[idx])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            aw.lcd3.display(btstr)

            ## Delta LCDs:
            deltaetstr = resLCD
            deltabtstr = resLCD
            try:
                if delta1 and idx is not None and idx < len(delta1) and delta1[idx] not in [None, -1] and not numpy.isnan(delta1[idx]):
                    if -100 < delta1[idx] < 1000:
                        deltaetstr = lcdformat%delta1[idx]        # rate of change ET (degrees per minute)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            try:
                if delta2 and idx is not None and idx < len(delta2) and delta2[idx] not in [None, -1] and not numpy.isnan(delta2[idx]):
                    if -100 < delta2[idx] < 1000:
                        deltabtstr = lcdformat%delta2[idx]        # rate of change BT (degrees per minute)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            aw.lcd4.display(deltaetstr)
            aw.lcd5.display(deltabtstr)
            try:
                self.updateLargeDeltaLCDs(deltabt=deltabtstr,deltaet=deltaetstr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # Fuji/Delta LCDs
            try:
                if aw.ser.showFujiLCDs and self.device in (0, 26):
                    pidsvstr = resLCD
                    piddutystr = resLCD
                    if PID_SV not in [None, -1] and not numpy.isnan(PID_SV) and PID_DUTY not in [None, -1] and not numpy.isnan(PID_DUTY):
                        pidsvstr = lcdformat%PID_SV
                        piddutystr = lcdformat%PID_DUTY
                    aw.lcd6.display(pidsvstr)
                    aw.lcd7.display(piddutystr)
                    self.updateLargePIDLCDs(sv=pidsvstr,duty=piddutystr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # LargeLCDs and WebLCDs
            if aw.WebLCDs:
                self.updateWebLCDs(bt=btstr,et=etstr,time=timestr)
            try:
                if timestr is None:
                    self.updateLargeLCDsReadingsSignal.emit(btstr,etstr)
                else:
                    self.updateLargeLCDsSignal.emit(btstr,etstr,timestr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # Extra LCDs
            ndev = min(len(XTs1),len(XTs2))
            extra1_values = []
            extra2_values = []
            for i in range(ndev):
                if i < aw.nLCDS:
                    try:
                        extra1_value = resLCD
                        if idx is not None and XTs1[i] and idx < len(XTs1[i]):
                            fmt = lcdformat
                            v = float(XTs1[i][idx])
                            if v is not None and v != -1:
                                if self.intChannel(i,0):
                                    fmt = '%.0f'
                                if -100 < v < 1000:
                                    extra1_value = fmt%v # everything fits
                                elif self.LCDdecimalplaces and -10000 < v < 100000:
                                    fmt = '%.0f'
                                    extra1_value = fmt%v
                            elif self.intChannel(i,0):
                                extra1_value = 'uu'
                        aw.extraLCD1[i].display(extra1_value)
                        extra1_values.append(extra1_value)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        extra1_value = '--'
                        extra1_values.append(extra1_value)
                        aw.extraLCD1[i].display(extra1_value)
                    try:
                        extra2_value = resLCD
                        if idx is not None and XTs2[i] and idx < len(XTs2[i]):
                            fmt = lcdformat
                            v = float(XTs2[i][idx])
                            if v is not None and v != -1:
                                if self.intChannel(i,1):
                                    fmt = '%.0f'
                                if -100 < v < 1000:
                                    extra2_value = fmt%v # everything fits
                                elif self.LCDdecimalplaces and -10000 < v < 100000:
                                    fmt = '%.0f'
                                    extra2_value = fmt%v
                            elif self.intChannel(i,1):
                                extra2_value = 'uu'
                        aw.extraLCD2[i].display(extra2_value)
                        extra2_values.append(extra2_value)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        extra2_value = '--'
                        extra2_values.append(extra2_value)
                        aw.extraLCD2[i].display(extra2_value)

            self.updateLargeExtraLCDs(extra1=extra1_values,extra2=extra2_values)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # runs from GUI thread.
    # this function is called by a signal at the end of the thread sample()
    # during sample, updates to GUI widgets or anything GUI must be done here (never from thread)
    @pyqtSlot()
    def updategraphics(self):
        QApplication.processEvents() # without this we see some flickers (canvas redraws) on using multiple button event actions on macOS!?
        try:
            if self.flagon:
                #### lock shared resources #####
                self.profileDataSemaphore.acquire(1)
                try:
                    # initialize the arrays depending on the recording state
                    if (self.flagstart and len(self.timex) > 0) or not self.flagon: # on recording or off we use the standard data structures
                        sample_timex = self.timex
                        sample_temp1 = self.temp1
                        sample_temp2 = self.temp2
                        sample_extratimex = self.extratimex
                        sample_extratemp1 = self.extratemp1
                        sample_extratemp2 = self.extratemp2

                        sample_delta1 = self.delta1
                        sample_delta2 = self.delta2

                    else: # only on ON we use the temporary sampling datastructures
                        sample_timex = self.on_timex
                        sample_temp1 = self.on_temp1
                        sample_temp2 = self.on_temp2
                        sample_extratimex = self.extratimex
                        sample_extratemp1 = self.on_extratemp1
                        sample_extratemp2 = self.on_extratemp2

                        sample_delta1 = self.on_delta1
                        sample_delta2 = self.on_delta2

                    if len(sample_timex):
                        # update all LCDs (small, large, Web,..)
                        self.updateLCDs(
                            None,
                            sample_temp1,
                            sample_temp2,
                            sample_delta1,
                            sample_delta2,
                            sample_extratemp1,
                            sample_extratemp2,
                            self.currentpidsv,
                            self.dutycycle)

                finally:
                    if self.profileDataSemaphore.available() < 1:
                        self.profileDataSemaphore.release(1)

                #check move slider pending actions
                if self.temporarymovepositiveslider is not None:
                    slidernr,value = self.temporarymovepositiveslider # pylint: disable=unpacking-non-sequence
                    if aw.sliderpos(slidernr) != value or self.temporayslider_force_move:
                        aw.moveslider(slidernr,value) # move slider
                        aw.fireslideraction(slidernr) # fire action
                        aw.extraeventsactionslastvalue[slidernr] = int(round(value)) # remember last value for relative event buttons
                        self.temporayslider_force_move = False
                self.temporarymovepositiveslider = None
                if self.temporarymovenegativeslider is not None:
                    slidernr,value = self.temporarymovenegativeslider # pylint: disable=unpacking-non-sequence
                    if aw.sliderpos(slidernr) != value or self.temporayslider_force_move:
                        aw.moveslider(slidernr,value) # move slider
                        aw.fireslideraction(slidernr) # fire action
                        aw.extraeventsactionslastvalue[slidernr] = int(round(value)) # remember last value for relative event buttons
                        self.temporayslider_force_move = False
                self.temporarymovenegativeslider = None

                #write error message
                if self.temporary_error is not None:
                    aw.sendmessage(self.temporary_error)
                    self.temporary_error = None # clear flag
                    # update error dlg
                    if aw.error_dlg:
                        aw.error_dlg.update()

                #update serial_dlg
                if aw.serial_dlg:
                    try:
                        #### lock shared resources #####
                        aw.qmc.seriallogsemaphore.acquire(1)
                        aw.serial_dlg.update()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    finally:
                        if aw.qmc.seriallogsemaphore.available() < 1:
                            aw.qmc.seriallogsemaphore.release(1)

                #update message_dlg
                if aw.message_dlg:
                    aw.message_dlg.update()

                #check quantified events; do this before the canvas is redraw as additional annotations might be added here, but do not recursively call updategraphics
                # NOTE: that EventRecordAction has to be called from outside the critical section protected by the profileDataSemaphore as it is itself accessing this section!!
                for el in self.quantifiedEvent:
                    try:
                        aw.moveslider(el[0],el[1])
                        if self.flagstart:
                            value = aw.float2float((el[1] + 10.0) / 10.0)
                            self.EventRecordAction(extraevent = 1,eventtype=el[0],eventvalue=value,eventdescription='Q'+self.eventsvalues(value),doupdategraphics=False)
                        if self.flagon and aw.eventquantifieraction[el[0]]:
                            aw.fireslideractionSignal.emit(el[0])
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                self.quantifiedEvent = []

                if self.flagstart:
                    if  self.zoom_follow: # aw.ntb._active == 'ZOOM'
                        if aw.qmc.fmt_data_RoR == False:
                            # center current temp reading on canvas
                            temp = None
                            if self.temp2 and len(self.temp2)>0:
                                temp = self.temp2[-1]
                                if temp is not None:
                                    tx = self.timex[-1]
                                    # get current limits
                                    xlim = self.ax.get_xlim()
                                    xlim_offset = (xlim[1] - xlim[0]) / 2.
                                    xlim_new = (tx - xlim_offset, tx + xlim_offset)
                                    ylim = self.ax.get_ylim()
                                    ylim_offset = (ylim[1] - ylim[0]) / 2.
                                    ylim_new = (temp - ylim_offset, temp + ylim_offset)
                                    if ylim != ylim_new or xlim != xlim_new:
                                        # set new limits to center current temp on canvas
                                        self.ax.set_xlim(xlim_new)
                                        self.ax.set_ylim(ylim_new)
                                        if self.twoAxisMode() and self.delta_ax:
                                            # keep the RoR axis constant
                                            zlim = self.delta_ax.get_ylim()
                                            zlim_offset = (zlim[1] - zlim[0]) / 2.
                                            tempd = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,temp))[1]))[1])
                                            zlim_new = (tempd - zlim_offset, tempd + zlim_offset)
                                            self.delta_ax.set_ylim(zlim_new)
                                        self.ax_background = None
                        else:
                            # center current RoR reading on canvas
                            ror = None
                            two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or (self.background and (self.DeltaETBflag or self.DeltaBTBflag)))
                            if two_ax_mode and self.delta_ax and self.delta2 and len(self.delta2)>0:
                                ror = self.delta2[-1]
                            if ror is not None:
                                tx = self.timex[-1]
                                # get current limits
                                xlim = self.ax.get_xlim()
                                xlim_offset = (xlim[1] - xlim[0]) / 2.
                                xlim_new = (tx - xlim_offset, tx + xlim_offset)
                                ylim = self.ax.get_ylim()
                                ylim_offset = (ylim[1] - ylim[0]) / 2.
                                rord = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,ror))[1]))[1])
                                ylim_new = (rord - ylim_offset, rord + ylim_offset)
                                if ylim != ylim_new or xlim != xlim_new:
                                    # set new limits to center current temp on canvas
                                    self.ax.set_xlim(xlim_new)
                                    self.ax.set_ylim(ylim_new)
                                    # keep the RoR axis constant
                                    zlim = self.delta_ax.get_ylim()
                                    zlim_offset = (zlim[1] - zlim[0]) / 2.
                                    zlim_new = (ror - zlim_offset, ror + zlim_offset)
                                    self.delta_ax.set_ylim(zlim_new)
                                    self.ax_background = None

                    if self.patheffects:
                        rcParams['path.effects'] = [PathEffects.withStroke(linewidth=self.patheffects, foreground=self.palette['background'])]
                    else:
                        rcParams['path.effects'] = []

                    #auto mark CHARGE (this forces a realignment/redraw by resetting the cache ax_background)
                    if self.autoChargeIdx and self.timeindex[0] < 0:
                        self.markCharge() # we do not reset the autoChargeIdx to avoid another trigger
                        self.autoChargeIdx = 0

                    #auto mark TP/DRY/FCs/DROP
                    # we set marks already here to have the canvas, incl. the projections, immediately redrawn
                    if self.autoTPIdx != 0:
                        self.markTP()
                        self.autoTPIdx = 0
                    if self.autoDryIdx != 0:
                        self.markDryEnd()
                        self.autoDryIdx = 0
                    if self.autoFCsIdx != 0:
                        self.mark1Cstart()
                        self.autoFCsIdx = 0
                    if self.autoDropIdx > 0 and self.timeindex[0] > -1 and not self.timeindex[6]:
                        self.markDrop() # we do not reset the autoDropIdx here to avoid another trigger
                        self.autoDropIdx = -1 # we set the autoDropIdx to a negative value to prevent further triggers after undo markDROP

                    ##### updated canvas
                    try:
                        if not self.block_update:
                        #-- start update display
                            #### lock shared resources to ensure that no other redraw is interfering with this one here #####
                            self.profileDataSemaphore.acquire(1)
                            try:
                                if self.ax_background is not None:
                                    self.fig.canvas.restore_region(self.ax_background)
                                    # draw eventtypes
# this seems not to be needed and hides partially event by value "Combo-type" annotations
#                                    if self.eventsshowflag and self.eventsGraphflag in [2,3,4]:
#                                        self.ax.draw_artist(self.l_eventtype1dots)
#                                        self.ax.draw_artist(self.l_eventtype2dots)
#                                        self.ax.draw_artist(self.l_eventtype3dots)
#                                        self.ax.draw_artist(self.l_eventtype4dots)
                                    # draw delta lines

                                    if self.swapdeltalcds:
                                        if self.DeltaETflag and self.l_delta1 is not None:
                                            try:
                                                self.ax.draw_artist(self.l_delta1)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                        if self.DeltaBTflag and self.l_delta2 is not None:
                                            try:
                                                self.ax.draw_artist(self.l_delta2)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                    else:
                                        if self.DeltaBTflag and self.l_delta2 is not None:
                                            try:
                                                self.ax.draw_artist(self.l_delta2)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                        if self.DeltaETflag and self.l_delta1 is not None:
                                            try:
                                                self.ax.draw_artist(self.l_delta1)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)

                                    # draw extra curves
                                    xtra_dev_lines1 = 0
                                    xtra_dev_lines2 = 0

                                    try:
                                        for i in range(min(len(aw.extraCurveVisibility1),len(aw.extraCurveVisibility1),len(sample_extratimex),len(sample_extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(sample_extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                                            if aw.extraCurveVisibility1[i] and len(self.extratemp1lines) > xtra_dev_lines1:
                                                try:
                                                    self.ax.draw_artist(self.extratemp1lines[xtra_dev_lines1])
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                                xtra_dev_lines1 = xtra_dev_lines1 + 1
                                            if aw.extraCurveVisibility2[i] and len(self.extratemp2lines) > xtra_dev_lines2:
                                                try:
                                                    self.ax.draw_artist(self.extratemp2lines[xtra_dev_lines2])
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                                xtra_dev_lines2 = xtra_dev_lines2 + 1
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    if self.swaplcds:
                                        # draw ET
                                        if self.ETcurve:
                                            try:
                                                self.ax.draw_artist(self.l_temp1)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                        # draw BT
                                        if self.BTcurve:
                                            try:
                                                self.ax.draw_artist(self.l_temp2)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                    else:
                                        # draw BT
                                        if self.BTcurve:
                                            try:
                                                self.ax.draw_artist(self.l_temp2)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)
                                        # draw ET
                                        if self.ETcurve:
                                            try:
                                                self.ax.draw_artist(self.l_temp1)
                                            except Exception as e: # pylint: disable=broad-except
                                                _log.exception(e)

                                    try:
                                        if self.BTcurve:
                                            for a in self.l_annotations:
                                                self.ax.draw_artist(a)
                                    except Exception as e : # pylint: disable=broad-except
                                        _log.exception(e)

                                    try:
                                        self.update_additional_artists()
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)

                                    self.fig.canvas.blit(self.ax.get_figure().bbox)

                                else:
                                    # we do not have a background to bitblit, so do a full redraw
                                    self.updateBackground() # does the canvas draw, but also fills the ax_background cache
                                    self.update_additional_artists()
                            finally:
                                if self.profileDataSemaphore.available() < 1:
                                    self.profileDataSemaphore.release(1)
                        #-- end update display
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.adderror((QApplication.translate('Error Message','Exception:') + ' updategraphics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    try:
                        if self.backgroundprofile is not None and (self.timeindex[0] > -1 or self.timeindexB[0] < 0):
                            if self.backgroundReproduce or self.backgroundPlaybackEvents:
                                self.playbackevent()
                            if self.backgroundPlaybackDROP:
                                self.playbackdrop()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.adderror((QApplication.translate('Error Message','Exception:') + ' updategraphics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    #####
                    if self.patheffects:
                        rcParams['path.effects'] = []

                    #update phase lcds
                    aw.updatePhasesLCDs()

                    #update AUC lcd
                    if self.AUClcdFlag:
                        aw.updateAUCLCD()

                #check triggered alarms
                if self.temporaryalarmflag > -3:
                    i = self.temporaryalarmflag  # reset self.temporaryalarmflag before calling alarm
                    self.temporaryalarmflag = -3 # self.setalarm(i) can take longer to run than the sampling interval
                    self.setalarm(i)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' updategraphics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def setLCDtimestr(self, timestr):
        aw.lcd1.display(timestr)
        # update connected WebLCDs
        if aw.WebLCDs:
            self.updateWebLCDs(time=timestr)
        if aw.largeLCDs_dialog:
            self.updateLargeLCDsTimeSignal.emit(timestr)

    def setLCDtime(self,ts):
        timestr = stringfromseconds(ts)
        self.setLCDtimestr(timestr)

    def updateLCDtime(self):
        if self.flagstart and self.flagon:
            tx = self.timeclock.elapsedMilli()
            if aw.simulator is not None:
                speed = self.timeclock.getBase()/1000
                nextreading = (1000. - 1000.*(tx%1.) ) / speed
            else:
                nextreading = 1000. - 1000.*(tx%1.)

            try:
                if aw.sample_loop_running and type(self.timeindex) is list and len(self.timeindex) == 8: # ensure we have a valid self.timeindex array

                    if self.timeindex[0] != -1 and type(self.timex) is list and len(self.timex) > self.timeindex[0]:
                        ts = tx - self.timex[self.timeindex[0]]
                    else:
                        ts = tx

                    # if more than max cool (from statistics) past DROP and not yet COOLend turn the time LCD red:
                    if aw.qmc.timeindex[0]!=-1 and aw.qmc.timeindex[6] and not aw.qmc.timeindex[7] and ((len(self.timex) == 1+self.timeindex[6]) or (4*60+2 > (tx - aw.qmc.timex[aw.qmc.timeindex[6]]) > 4*60)):
                        # switch LCD color to "cooling" color (only after 4min cooling we switch to slowcoolingtimer color)
                        if (tx - aw.qmc.timex[aw.qmc.timeindex[6]]) > 4*60:
                            timer_color = 'slowcoolingtimer'
                        else:
                            timer_color = 'rstimer'
                        aw.setTimerColor(timer_color)

                    if self.chargeTimerFlag and self.timeindex[0] == -1 and self.chargeTimerPeriod!= 0:
                        if self.chargeTimerPeriod > ts:
                            ts = self.chargeTimerPeriod - ts
                        else:
                            ts = 0

                    self.setLCDtime(ts)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                QTimer.singleShot(int(round(nextreading)),self.updateLCDtime)

    # redraws at least the canvas if redraw=True and force=True
    def timealign(self,redraw=True,recompute=False,force=False):
        try:
            ptime = None
            btime = None
            if aw.qmc.alignEvent in [6,7] and self.timeindexB[6] and self.timeindex[6]: # DROP
                ptime = self.timex[self.timeindex[6]]
                btime = self.timeB[self.timeindexB[6]]
            elif aw.qmc.alignEvent in [5,7] and self.timeindexB[5] and self.timeindex[5]: # SCe
                ptime = self.timex[self.timeindex[5]]
                btime = self.timeB[self.timeindexB[5]]
            elif aw.qmc.alignEvent in [4,7] and self.timeindexB[4] and self.timeindex[4]: # SCs
                ptime = self.timex[self.timeindex[4]]
                btime = self.timeB[self.timeindexB[4]]
            elif aw.qmc.alignEvent in [3,7] and self.timeindexB[3] and self.timeindex[3]: # FCe
                ptime = self.timex[self.timeindex[3]]
                btime = self.timeB[self.timeindexB[3]]
            elif aw.qmc.alignEvent in [2,7] and self.timeindexB[2] and self.timeindex[2]: # FCs
                ptime = self.timex[self.timeindex[2]]
                btime = self.timeB[self.timeindexB[2]]
            elif aw.qmc.alignEvent in [1,7] and self.timeindexB[1] and self.timeindex[1]: # DRY
                ptime = self.timex[self.timeindex[1]]
                btime = self.timeB[self.timeindexB[1]]
            elif self.timeindexB[0] != -1 and self.timeindex[0] != -1: # CHARGE
                ptime = self.timex[self.timeindex[0]]
                btime = self.timeB[self.timeindexB[0]]
            elif self.timeindexB[0] != -1: # if no foreground profile, align 0:00 to the CHARGE event of the background profile
                ptime = 0
                if self.flagstart:
                    if len(self.timeB)>0:
                        btime = self.timeB[0]
                    else:
                        btime = 0
                else:
                    if len(self.timeB)>self.timeindexB[0]:
                        btime = self.timeB[self.timeindexB[0]]
                    else:
                        btime = 0
            if ptime is not None and btime is not None:
                difference = ptime - btime
                if difference > 0:
                    self.movebackground('right',abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif difference < 0:
                    self.movebackground('left',abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif redraw and force: # ensure that we at least redraw the canvas
                    self.updateBackground()
            elif redraw and force: # only on aligning with CHARGE we redraw even if nothing is moved to redraw the time axis
                self.updateBackground()
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' timealign() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # we count
    # - foreground curves
    # . ET/BT, even if not visible
    # . all visible extra curves
    # . all foreground event curves
    # - background curves
    # . background ET/BT, even if not visible
    # . 3rd background curve only if visible
    # . background event curves if not empty
    def lenaxlines(self):
        active_curves = len(self.extratimex)
        curves = aw.extraCurveVisibility1[0:active_curves] + aw.extraCurveVisibility2[0:active_curves] + [aw.qmc.ETcurve,aw.qmc.BTcurve]
        c = curves.count(True)
        if aw.qmc.background:
            c += 2 # those are alwyays populated
            if aw.qmc.xtcurveidx > 0: # 3rd background curve set?
                idx3 = aw.qmc.xtcurveidx - 1
                n3 = idx3 // 2
                if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                    c += 1
            if aw.qmc.ytcurveidx > 0: # 4th background curve set?
                idx4 = aw.qmc.xtcurveidx - 1
                n4 = idx4 // 2
                if len(self.stemp1BX) > n4 and len(self.stemp2BX) > n4 and len(self.extratimexB) > n4:
                    c += 1
            if aw.qmc.backgroundeventsflag and aw.qmc.eventsGraphflag in [2,3,4]:
                unique_etypes = set(aw.qmc.backgroundEtypes)
                # only those background event lines exists that are active and hold events
                active_background_events = list(map(lambda e : e < 4 and aw.qmc.showEtypes[e],unique_etypes)) # we remove the "untyped" event as this is only drawn as annotation
                c += sum(active_background_events)
        if aw.qmc.eventsshowflag and aw.qmc.eventsGraphflag in [2,3,4]:
            c += 4 # the foreground event lines (in contrast to the background ones) are always all present in those modes
        return c

    # we count
    # - deltaET if visible
    # - deltaBT if visible
    # - background deltaET if visible
    # - background deltaBT if visible
    def lendeltaaxlines(self):
        linecount = 0
        if self.DeltaETflag:
            linecount += 1
        if  self.DeltaBTflag:
            linecount += 1
        if aw.qmc.background:
            if self.DeltaETBflag:
                linecount += 1
            if self.DeltaBTBflag:
                linecount += 1
        return linecount

    @staticmethod
    def resetlinecountcaches():
        aw.qmc.linecount = None
        aw.qmc.deltalinecount = None

    # NOTE: delta lines are also drawn on the main ax
    # ATTENTION: all lines that should be populated need to established in self.ax.lines thus for example delta lines should be established (with empty point lists)
    #   even if they are not drawn before CHARGE to ensure that the linecount corresponds to the fixes lines in self.ax.lines!!
    def resetlines(self):
        if self.ax is not None and not bool(aw.comparator):
            #note: delta curves are now in self.delta_ax and have been removed from the count of resetlines()
            if self.linecount is None:
                self.linecount = self.lenaxlines()
            if self.deltalinecount is None:
                self.deltalinecount = self.lendeltaaxlines()
            total_linecount = self.linecount+self.deltalinecount
            # remove lines beyond the max limit of self.linecount)
            if isinstance(self.ax.lines,list): # MPL < v3.5
                self.ax.lines = self.ax.lines[0:total_linecount]
            else:
                for i in range(len(self.ax.lines)-1,-1,-1):
                    if i >= total_linecount:
                        self.ax.lines[i].remove()
                    else:
                        break

    @pyqtSlot(int)
    def getAlarmSet(self,n):
        try:
            self.alarmSemaphore.acquire(1)
            if 0<= n < len(self.alarmsets):
                return self.alarmsets[n]
            return None
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    def setAlarmSet(self,n,alarmset):
        try:
            self.alarmSemaphore.acquire(1)
            self.alarmsets[n] = alarmset
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    @pyqtSlot(int)
    def selectAlarmSet(self,n):
        alarmset = self.getAlarmSet(n)
        if alarmset is not None:
            try:
                self.alarmSemaphore.acquire(1)
                #
                self.alarmsetlabel = alarmset[0]
                self.alarmflag = alarmset[1][:]
                self.alarmguard = alarmset[2][:]
                self.alarmnegguard = alarmset[3][:]
                self.alarmtime = alarmset[4][:]
                self.alarmoffset = alarmset[5][:]
                self.alarmsource = alarmset[6][:]
                self.alarmcond = alarmset[7][:]
                self.alarmtemperature = alarmset[8][:]
                self.alarmaction = alarmset[9][:]
                self.alarmbeep = alarmset[10][:]
                self.alarmstrings = alarmset[11][:]
                # update the alarmstate array to the new size:
                self.alarmstate = [-1]*len(self.alarmflag)
            finally:
                if self.alarmSemaphore.available() < 1:
                    self.alarmSemaphore.release(1)

    @pyqtSlot(str,int)
    def moveBackgroundAndRedraw(self,direction,step):
        aw.qmc.movebackground(direction,step)
        self.backmoveflag = 0 # do not align background automatically during redraw!
        aw.qmc.redraw(recomputeAllDeltas=(direction in ['left', 'right']),sampling=aw.qmc.flagon)

    def findAlarmSet(self,label):
        try:
            self.alarmSemaphore.acquire(1)
            for i in range(len(self.alarmsets)):
                if self.alarmsets[i][0] == label:
                    return i
            return None
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    @staticmethod
    def makeAlarmSet(label, flag, guard, negguard, time, offset, source, cond, temperature, action, beep, alarmstrings):
        return [label,flag,guard,negguard,time,offset,source,cond,temperature,action,beep,alarmstrings]

    # number is alarmnumber+1 (the 1-based alarm number the user sees), for alarms triggered from outside the alarmtable (like PID RS alarms) number is 0
    @pyqtSlot(int,bool,int,str)
    def processAlarm(self,number,beep,action,string):
        if not self.silent_alarms:
            try:
                if beep:
                    QApplication.beep()
                if action == 0:
                    self.showAlarmPopupSignal.emit(string,aw.qmc.alarm_popup_timout)
                elif action == 1:
                    # alarm call program
                    fname = string.split('#')[0]
        # take c the QDir().current() directory changes with loads and saves
        #            QDesktopServices.openUrl(QUrl("file:///" + str(QDir().current().absolutePath()) + "/" + fname, QUrl.ParsingMode.TolerantMode))
                    if False and platf == 'Windows': # this Windows version fails on commands with arguments # pylint: disable=condition-evals-to-constant
                        f = f'file:///{QApplication.applicationDirPath()}/{fname}'
                        res = QDesktopServices.openUrl(QUrl(f, QUrl.ParsingMode.TolerantMode))
                    else:
                        # MacOS X: script is expected to sit next to the Artisan.app or being specified with its full path
                        # Linux: script is expected to sit next to the artisan binary or being specified with its full path
                        #
                        # to get the effect of speaking alarms a text containing the following two lines called "say.sh" could do
                        #                #!/bin/sh
                        #                say "Hello" &
                        # don't forget to do
                        #                # cd
                        #                # chmod +x say.sh
                        #
                        # alternatively use "say $@ &" as command and send text strings along
                        # Voices:
                        #  -v Alex (male english)
                        #  -v Viki (female english)
                        #  -v Victoria (female english)
                        #  -v Yannick (male german)
                        #  -v Anna (female german)
                        #  -v Paolo (male italian)
                        #  -v Silvia (female italian)
                        aw.call_prog_with_args(fname)
                        res = True
                    if res:
                        aw.sendmessage(QApplication.translate('Message','Alarm is calling: {0}').format(fname))
                    else:
                        aw.qmc.adderror(QApplication.translate('Message','Calling alarm failed on {0}').format(f))
                elif action == 2:
                    # alarm event button
                    button_number = None
                    text = string.split('#')[0]
                    bnrs = text.split(',')
                    for bnr in bnrs:
                        try:
                            button_number = int(str(bnr.strip())) - 1 # the event buttons presented to the user are numbered from 1 on
                        except Exception: # pylint: disable=broad-except
                            aw.sendmessage(QApplication.translate('Message',"Alarm trigger button error, description '{0}' not a number").format(string))
                        if button_number is not None:
                            if -1 < button_number < len(aw.buttonlist):
                                aw.recordextraevent(button_number)
                elif action in [3,4,5,6]:
                    # alarm slider 1-4
                    slidernr = None
                    try:
                        text = string.split('#')[0].strip()
                        if action == 3:
                            slidernr = 0
                        elif action == 4:
                            slidernr = 1
                        elif action == 5:
                            slidernr = 2
                        elif action == 6:
                            slidernr = 3
                        if slidernr is not None:
                            slidervalue = max(aw.eventslidermin[slidernr],min(aw.eventslidermax[slidernr],int(str(text))))
                            aw.moveslider(slidernr,slidervalue)
                            # we set the last value to be used for relative +- button action as base
                            aw.extraeventsactionslastvalue[slidernr] = int(round(slidervalue))
                            if aw.qmc.flagstart:
                                value = aw.float2float((slidervalue + 10.0) / 10.0)
                                aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,eventdescription=str('A%d (S%d)'%(number,slidernr)))
                            aw.fireslideraction(slidernr)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' setalarm() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                        aw.sendmessage(QApplication.translate('Message',"Alarm trigger slider error, description '{0}' not a valid number [0-100]").format(string))

                elif action == 7:
                    # START
                    if aw.buttonSTARTSTOP.isEnabled():
                        aw.qmc.ToggleRecorder()
                elif action == 8:
                    # DRY
                    aw.qmc.autoDryIdx = len(aw.qmc.timex)
                elif action == 9:
                    # FCs
                    aw.qmc.autoFCsIdx = len(aw.qmc.timex)
                elif action == 10:
                    # FCe
                    if aw.buttonFCe.isEnabled():
                        aw.qmc.mark1Cend()
                elif action == 11:
                    # SCs
                    if aw.buttonSCs.isEnabled():
                        aw.qmc.mark2Cstart()
                elif action == 12:
                    # SCe
                    if aw.buttonSCe.isEnabled():
                        aw.qmc.mark2Cend()
                elif action == 13:
                    # DROP
                    #if aw.buttonDROP.isEnabled():
                    #    aw.qmc.markDrop()
                    aw.qmc.autoDropIdx = len(aw.qmc.timex)
                elif action == 14:
                    # COOL
                    if aw.buttonCOOL.isEnabled():
                        aw.qmc.markCoolEnd()
                elif action == 15:
                    # OFF
                    if aw.buttonONOFF.isEnabled():
                        aw.qmc.ToggleMonitor()
                elif action == 16:
                    # CHARGE
                    aw.qmc.autoChargeIdx = len(aw.qmc.timex)
                elif action == 17 and aw.qmc.Controlbuttonflag:
                    # RampSoak ON
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setrampsoak(1)
                    elif aw.pidcontrol: # internal or external MODBUS PID control
                        aw.pidcontrol.svMode = 1
                        aw.pidcontrol.pidOn()
                elif action == 18 and aw.qmc.Controlbuttonflag:
                    # RampSoak OFF
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setrampsoak(0)
                    elif aw.pidcontrol:  # internal or external MODBUS PID control
                        aw.pidcontrol.svMode = 0
                        aw.pidcontrol.pidOff()
                elif action == 19 and aw.qmc.Controlbuttonflag:
                    # PID ON
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setONOFFstandby(0)
                    elif aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        aw.pidcontrol.pidOn()
                elif action == 20 and aw.qmc.Controlbuttonflag:
                    # PID OFF
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setONOFFstandby(1)
                    elif aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        aw.pidcontrol.pidOff()
                elif action == 21:
                    # SV slider alarm
                    try:
                        text = string.split('#')[0]
                        sv = float(str(text))
                        if aw.qmc.device == 0:
                            if sv is not None and sv != aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.fujipid.setsv(sv,silent=True)
                        #elif aw.pidcontrol.pidActive:
                        else:
                            if sv is not None and sv != aw.pidcontrol.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.pidcontrol.setSV(sv,init=False)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' processAlarm() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                        aw.sendmessage(QApplication.translate('Message',"Alarm trigger SV slider error, description '{0}' not a valid number").format(string))
                elif action == 22:
                    # Playback ON
                    aw.qmc.backgroundPlaybackEvents = True
                elif action == 23:
                    # Playback OFF
                    aw.qmc.backgroundPlaybackEvents = False
                elif action == 24:
                    # grab only the color definition
                    c = re.match('#[0-9,a-f,A-F]{6}',string.strip()).group()
                    # Set Canvas Color
                    aw.setCanvasColorSignal.emit(c)
                elif action == 25:
                    # Reset Canvas Color
                    aw.resetCanvasColorSignal.emit()

            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message','Exception:') + ' processAlarm() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))


    def setalarm(self,alarmnumber):
        try:
            self.alarmSemaphore.acquire(1)
            self.alarmstate[alarmnumber] = max(0,len(self.timex) - 1) # we have to ensure that alarmstate of triggered alarms is never negative
            alarm_beep = len(self.alarmbeep) > alarmnumber and self.alarmbeep[alarmnumber] # beep?
            alarm_action = self.alarmaction[alarmnumber]
            alarm_string = self.alarmstrings[alarmnumber]
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)
        aw.sendmessage(QApplication.translate('Message','Alarm {0} triggered').format(alarmnumber + 1))
        self.processAlarmSignal.emit(alarmnumber+1,alarm_beep,alarm_action,alarm_string)

    # called only after CHARGE
    def playbackdrop(self):
        try:
            #needed when using device NONE
            if len(self.timex) and self.timeindexB[6] and not self.timeindex[6]:
                if ((aw.qmc.replayType == 0 and self.timeB[self.timeindexB[6]] - self.timeclock.elapsed()/1000. <= 0) or # by time
                    (aw.qmc.replayType == 1 and aw.qmc.TPalarmtimeindex and self.ctemp2[-1] != None and self.stemp2B[self.timeindexB[6]] - self.ctemp2[-1] <= 0) or # by BT
                    (aw.qmc.replayType == 2 and aw.qmc.TPalarmtimeindex and self.ctemp1[-1] != None and self.stemp1B[self.timeindexB[6]] - self.ctemp1[-1] <= 0)): # by ET
                    aw.qmc.autoDropIdx = len(aw.qmc.timex) - 2
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' playbackdrop() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # called only after CHARGE
    def playbackevent(self):
        try:
            reproducing = None # index of the event that is currently replaying (suppress other replays in this round)
            #needed when using device NONE
            if len(self.timex):
                #find time or temp distances
                slider_events = {} # keep event type value pairs to move sliders (but only once per slider and per interval!)
                next_byTemp_checked = False # we take care to reply events by temperature in order!
                now = self.timeclock.elapsedMilli()
                for i in range(len(self.backgroundEvents)):
                    if (i not in aw.qmc.replayedBackgroundEvents and # never replay one event twice
                        (self.timeindexB[6]==0 or self.backgroundEvents[i] < self.timeindexB[6])): # don't replay events that happend after DROP in the backgroundprofile
                        timed = self.timeB[self.backgroundEvents[i]] - now
                        delta = 1 # by default don't trigger this one
                        if aw.qmc.replayType == 0: # replay by time
                            delta = timed
                        elif not next_byTemp_checked and aw.qmc.replayType == 1: # replay by BT (after TP)
                            if aw.qmc.TPalarmtimeindex:
                                if self.ctemp2[-1] != None:
                                    delta = self.stemp2B[self.backgroundEvents[i]] - self.ctemp2[-1]
                                    next_byTemp_checked = True
                            else: # before TP we switch back to time-based
                                delta = timed
                                next_byTemp_checked = True
                        elif not next_byTemp_checked and aw.qmc.replayType == 2: # replay by ET (after TP)
                            if aw.qmc.TPalarmtimeindex:
                                if self.ctemp1[-1] != None:
                                    delta = self.stemp1B[self.backgroundEvents[i]] - self.ctemp1[-1]
                                    next_byTemp_checked = True
                            else: # before TP we switch back to time-based
                                delta = timed
                                next_byTemp_checked = True
                        else:
                            delta = 1 # don't trigger this one
                        if (reproducing is None and
                                self.backgroundEtypes[i] < 4 and self.specialeventplaybackaid[self.backgroundEtypes[i]] and  # only show playback aid for event types with activated playback aid
                                aw.qmc.backgroundReproduce and 0 < timed < self.detectBackgroundEventTime):
                            if i not in aw.qmc.beepedBackgroundEvents and aw.qmc.backgroundReproduceBeep:
                                aw.qmc.beepedBackgroundEvents.append(i)
                                QApplication.beep()
                            #write text message
                            message = '> [{}] [{}] : <b>{}</b> : {}'.format(
                                str(self.Betypesf(self.backgroundEtypes[i])),
                                self.eventsvalues(self.backgroundEvalues[i]),
                                stringfromseconds(timed),
                                self.backgroundEStrings[i])
                            #rotate colors to get attention
                            if int(round(timed))%2:
                                style = "background-color:'transparent';"
                            else:
                                style = "background-color:'yellow';"

                            aw.sendmessage(message,style=style)
                            reproducing = i

                        if delta <= 0:
                            #for devices that support automatic roaster control
                            #if Fuji PID
                            if self.device == 0:

                                # COMMAND SET STRINGS
                                #  (adjust the SV PID to the float VALUE1)
                                # SETRS::VALUE1::VALUE2::VALUE3  (VALUE1 = target SV. float VALUE2 = time to reach int VALUE 1 (ramp) in minutes. int VALUE3 = hold (soak) time in minutes)

                                # IMPORTANT: VALUES are for controlling ET only (not BT). The PID should control ET not BT. The PID should be connected to ET only.
                                # Therefore, these values don't reflect a BT defined profile. They define an ET profile.
                                # They reflect the changes in ET, which indirectly define BT after some time lag

                                # There are two ways to record a roast. One is by changing Set Values (SV) during the roast,
                                # the other is by using ramp/soaks segments (RS).
                                # Examples:

                                # SETSV::560.3           sets an SV value of 560.3F in the PID at the time of the recorded background event

                                # SETRS::440.2::2::0     starts Ramp Soak mode so that it reaches 440.2F in 2 minutes and holds (soaks) 440.2F for zero minutes

                                # SETRS::300.0::2::3::SETRS::540.0::6::0::SETRS::560.0::4::0::SETRS::560::0::0
                                #       this command has 4 comsecutive commands inside (4 segments)
                                #       1 SETRS::300.0::2::3 reach 300.0F in 2 minutes and hold it for 3 minutes (ie. total dry phase time = 5 minutes)
                                #       2 SETRS::540.0::6::0 then reach 540.0F in 6 minutes and hold it there 0 minutes (ie. total mid phase time = 6 minutes )
                                #       3 SETRS::560.0::4::0 then reach 560.0F in 4 minutes and hold it there 0 minutes (ie. total finish phase time = 4 minutes)
                                #       4 SETRS::560::0::0 then do nothing (because ramp time and soak time are both 0)
                                #       END ramp soak mode

                                if '::' in self.backgroundEStrings[i]:
                                    aw.fujipid.replay(self.backgroundEStrings[i])
                                    libtime.sleep(.5)  #avoid possible close times (rounding off)


                            # if playbackevents is active, we fire the event by moving the slider, but only if
                            # a event type is given (type!=4), the background event type is named exactly as the one of the foreground
                            # the event slider is active/visible and has an action defined
                            if (aw.qmc.backgroundPlaybackEvents and self.backgroundEtypes[i] < 4 and
                                    self.specialeventplayback[self.backgroundEtypes[i]] and # only replay event types activated for replay
                                    (str(self.etypesf(self.backgroundEtypes[i]) == str(self.Betypesf(self.backgroundEtypes[i])))) and
                                    aw.eventslidervisibilities[self.backgroundEtypes[i]]): #  and aw.eventslideractions[self.backgroundEtypes[i]]
                                slider_events[self.backgroundEtypes[i]] = self.eventsInternal2ExternalValue(self.backgroundEvalues[i]) # add to dict (later overwrite earlier slider moves!)
                                # we move sliders only after processing all pending events (from the collected dict)
                                #aw.moveslider(self.backgroundEtypes[i],self.eventsInternal2ExternalValue(self.backgroundEvalues[i])) # move slider and update slider LCD
                                #aw.sliderReleased(self.backgroundEtypes[i],force=True) # record event

                            aw.qmc.replayedBackgroundEvents.append(i) # in any case we mark this event as processed

                # now move the sliders to the new values (if any)
                for k in slider_events.keys():
                    aw.moveslider(k,slider_events[k])
                    aw.sliderReleased(k,force=True)

                #delete existing message
                if reproducing is None:
                    text = aw.messagelabel.text()
                    if len(text):
                        if text[0] == '>':
                            aw.clearMessageLine(style="background-color:'transparent';")
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' playbackevent() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    #make a projection of change of rate of BT on the graph
    def updateProjection(self):
        try:
            # projections are only drawn after CHARGE and before DROP
            if (self.timeindex[0] != -1 and self.timeindex[6] == 0) and len(self.timex)>0:
                charge = self.timex[self.timeindex[0]] # in data time (corresponds to display time 00:00)
                now = self.timex[-1]                   # in data time (incl. time to charge)
                _,xlim_right = self.ax.get_xlim()      # in data time like timex (incl. time to charge)
                #self.resetlines()
                if self.projectionmode == 0 or (self.projectionmode == 1 and (self.timex[-1]-charge)<=60*5): # linear temperature projection mode based on current RoR
                    #calculate the temperature endpoint at endofx according to the latest rate of change
                    if self.l_BTprojection is not None:
                        if self.BTcurve and len(self.unfiltereddelta2_pure) > 0 and self.unfiltereddelta2_pure[-1] is not None and len(self.ctemp2) > 0 and self.ctemp2[-1] not in [None, -1] and not numpy.isnan(self.ctemp2[-1]):
                            # projection extended to the plots current endofx
                            left = now
                            right = max(left, xlim_right + charge) # never have the right point be left of left;)
                            BTprojection = self.ctemp2[-1] + self.unfiltereddelta2_pure[-1]*(right - left)/60.
                            #plot projection
                            self.l_BTprojection.set_data([left,right], [self.ctemp2[-1], BTprojection])
                        else:
                            self.l_BTprojection.set_data([],[])
                    if self.l_ETprojection is not None:
                        if self.ETcurve and len(self.unfiltereddelta1_pure) > 0 and self.unfiltereddelta1_pure[-1] is not None and len(self.ctemp1) > 0 and self.ctemp1[-1] not in [None, -1] and not numpy.isnan(self.ctemp1[-1]):
                            # projection extended to the plots current endofx
                            left = now
                            right = max(left,xlim_right + charge) # never have the right point be left of left;)
                            ETprojection = self.ctemp1[-1] + self.unfiltereddelta1_pure[-1]*(right - left)/60.
                            #plot projection
                            self.l_ETprojection.set_data([left,right], [self.ctemp1[-1], ETprojection])
                        else:
                            self.l_ETprojection.set_data([],[])

                # quadratic temperature projection based on linear RoR approximation
                # only active 5min after CHARGE
                elif self.projectionmode == 1 and (self.timex[-1]-charge)>60*5:
                    delta_interval_BT = max(10, self.deltaBTsamples) # at least a span of 10 readings
                    delta_interval_ET = max(10, self.deltaETsamples) # at least a span of 10 readings
                    deltadeltalimit = 0.002
                    delay = self.delay/1000.

                    # NOTE: we use the unfiltered deltas here to make this work also with a delta symbolic formula like x/2 to render RoR in C/30sec
                    if self.l_BTprojection is not None:
                        if (len(self.ctemp2) > 0 and self.ctemp2[-1] not in [None, -1] and not numpy.isnan(self.ctemp2[-1]) and
                                len(self.unfiltereddelta2_pure)>delta_interval_BT and
                                self.unfiltereddelta2_pure[-1] and
                                self.unfiltereddelta2_pure[-1]>0 and
                                self.unfiltereddelta2_pure[-delta_interval_BT] and
                                self.unfiltereddelta2_pure[-delta_interval_BT]>0):

                            deltadelta_secsec = (((self.unfiltereddelta2_pure[-1] - self.unfiltereddelta2_pure[-delta_interval_BT])/60) /
                                    (now - self.timex[-delta_interval_BT])) # linear BT RoRoR   C/sec/sec
                            # limit deltadelta
                            deltadelta_secsec = max(-deltadeltalimit,min(deltadeltalimit,deltadelta_secsec))
                            xpoints = numpy.arange(now, xlim_right, delay)
                            ypoints = [self.ctemp2[-1]]
                            delta_sec = self.unfiltereddelta2_pure[-1]/60
                            for _ in range(len(xpoints)-1):
                                ypoints.append(ypoints[-1] + delta_sec*delay)
                                delta_sec = delta_sec + deltadelta_secsec*delay
                            #plot BT curve
                            self.l_BTprojection.set_data(xpoints, ypoints)
                        else:
                            self.l_BTprojection.set_data([],[])

                    if self.l_ETprojection is not None:
                        if (len(self.ctemp1) > 0 and self.ctemp1[-1] not in [None, -1] and not numpy.isnan(self.ctemp1[-1]) and
                                len(self.unfiltereddelta1_pure)>delta_interval_BT and
                                self.unfiltereddelta1_pure[-1] and
                                self.unfiltereddelta1_pure[-1]>0 and
                                self.unfiltereddelta1_pure[-delta_interval_BT] and
                                self.unfiltereddelta1_pure[-delta_interval_BT]>0):

                            deltadelta_secsec = (((self.unfiltereddelta1_pure[-1] - self.unfiltereddelta1_pure[-delta_interval_ET])/60) /
                                    (self.timex[-1] - self.timex[-delta_interval_ET])) # linear ET RoRoR   C/sec/sec
                            # limit deltadelta
                            deltadelta_secsec = max(-deltadeltalimit,min(deltadeltalimit,deltadelta_secsec))
                            xpoints = numpy.arange(now, xlim_right, delay)
                            ypoints = [self.ctemp1[-1]]
                            delta_sec = self.unfiltereddelta1_pure[-1]/60
                            for _ in range(len(xpoints)-1):
                                ypoints.append(ypoints[-1] + delta_sec*delay)
                                delta_sec = delta_sec + deltadelta_secsec*delay
                            #plot ET curve
                            self.l_ETprojection.set_data(xpoints, ypoints)
                        else:
                            self.l_ETprojection.set_data([],[])

                # RoR projections
                if self.projectDeltaFlag and (self.timex[-1]-charge)>60*5:
                    delay = self.delay/1000.

                    if self.l_DeltaBTprojection is not None:
                        delta_interval_BT = max(10, self.deltaBTsamples*2) # at least a span of 10 readings
                        if (self.DeltaBTflag and len(self.delta2)>0 and len(self.delta2)>delta_interval_BT and
                                self.delta2[-1] and
                                self.delta2[-1]>0 and
                                self.delta2[-delta_interval_BT] and
                                self.delta2[-delta_interval_BT]>0):
                            # compute deltadelta_secsec from delta2 adjusted to delta math formulas
                            deltadelta_secsec = (((self.delta2[-1] - self.delta2[-delta_interval_BT])/60) /
                                (now - self.timex[-delta_interval_BT])) # linear BT RoRoR   C/sec/sec
                            left = now
                            right = max(left, xlim_right) # never have the right point be left of left;)
                            DeltaBTprojection = self.delta2[-1] + deltadelta_secsec * (right - left) * 60
                            # projection extended to the plots current endofx
                            self.l_DeltaBTprojection.set_data([left,right], [self.delta2[-1], DeltaBTprojection])
                        else:
                            self.l_DeltaBTprojection.set_data([],[])

                    if self.l_DeltaETprojection is not None:
                        delta_interval_ET = max(10, self.deltaETsamples*2) # at least a span of 10 readings
                        if (self.DeltaETflag and len(self.delta1)>0 and len(self.delta1)>delta_interval_ET and
                                self.delta1[-1] and
                                self.delta1[-1]>0 and
                                self.delta1[-delta_interval_ET] and
                                self.delta1[-delta_interval_ET]>0):
                            # compute deltadelta_secsec from delta1 adjusted to delta math formulas
                            deltadelta_secsec = (((self.delta1[-1] - self.delta1[-delta_interval_ET])/60) /
                                (now - self.timex[-delta_interval_ET])) # linear ET RoRoR   C/sec/sec
                            left = now
                            right = max(left, xlim_right) # never have the right point be left of left;)
                            DeltaETprojection = self.delta1[-1] + deltadelta_secsec * (right - left) * 60
                            # projection extended to the plots current endofx
                            self.l_DeltaETprojection.set_data([left,right], [self.delta1[-1], DeltaETprojection])
                        else:
                            self.l_DeltaETprojection.set_data([],[])

# disabled
#                elif self.projectionmode == 2:
#                    # Under Test. Newton's Law of Cooling
#                    # This comes from the formula of heating (with ET) a cool (colder) object (BT).
#                    # The difference equation (discrete with n elements) is: DeltaT = T(n+1) - T(n) = K*(ET - BT)
#                    # The formula is a natural decay towards ET. The closer BT to ET, the smaller the change in DeltaT
#                    # projectionconstant is a multiplier factor. It depends on
#                    # 1 Damper or fan. Heating by convection is _faster_ than heat by conduction,
#                    # 2 Mass of beans. The heavier the mass, the _slower_ the heating of BT
#                    # 3 Gas or electric power: gas heats BT _faster_ because of hoter air.
#                    # Every roaster will have a different constantN (self.projectionconstant).
#
#                    if self.l_BTprojection is not None:
#                        if len(self.ctemp2) > 0 and self.ctemp2[-1] not in [None, -1] and not numpy.isnan(self.ctemp2[-1]) and len(self.ctemp1) > 0 and self.ctemp1[-1] not in [None, -1] and  not numpy.isnan(self.ctemp1[-1]):
#                            den = self.ctemp1[-1] - self.ctemp2[-1]  #denominator ETn - BTn
#                            if den > 0 and len(self.delta2)>0 and self.delta2[-1]: # if ETn > BTn
#                                starttime = self.timex[self.timeindex[0]]
#                                #get x points
#                                xpoints = list(numpy.arange(self.timex[-1],self.endofx + starttime, self.delay/1000.))
#                                #get y points
#                                ypoints = [self.ctemp2[-1]]                                  # start initializing with last BT
#                                K =  self.projectionconstant*self.delta2[-1]/den/60.         # multiplier
#                                for _ in range(len(xpoints)-1):                              # create new points from previous points
#                                    DeltaT = K*(self.ctemp1[-1]- ypoints[-1])                # DeltaT = K*(ET - BT)
#                                    ypoints.append(ypoints[-1]+ DeltaT)                      # add DeltaT to the next ypoint
#                                self.l_BTprojection.set_data(xpoints, ypoints)
#                            else:
#                                self.l_BTprojection.set_data([],[])
#                        else:
#                            self.l_BTprojection.set_data([],[])
#                    if self.l_ETprojection is not None:
#                        if len(self.ctemp1) > 0 and self.ctemp1[-1] not in [None, -1] and not numpy.isnan(self.ctemp1[-1]):
#                            starttime = self.timex[self.timeindex[0]]
#                            self.l_ETprojection.set_data([self.timex[-1],self.endofx + starttime], [self.ctemp1[-1], self.ctemp1[-1]])
#                        else:
#                            self.l_ETprojection.set_data([],[])
            else:
                if self.l_BTprojection is not None:
                    self.l_BTprojection.set_data([],[])
                if self.l_ETprojection is not None:
                    self.l_ETprojection.set_data([],[])
                if self.l_DeltaBTprojection is not None:
                    self.l_DeltaBTprojection.set_data([],[])
                if self.l_DeltaETprojection is not None:
                    self.l_DeltaETprojection.set_data([],[])


        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' updateProjection() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            if self.l_BTprojection is not None:
                self.l_BTprojection.set_data([],[])
            if self.l_ETprojection is not None:
                self.l_ETprojection.set_data([],[])
            if self.l_DeltaBTprojection is not None:
                self.l_DeltaBTprojection.set_data([],[])
            if self.l_DeltaETprojection is not None:
                self.l_DeltaETprojection.set_data([],[])

    # takes array with readings, the current index, the sign of the shift as character and the shift value
    # returns val, evalsign
    @staticmethod
    def shiftValueEvalsign(readings,index,sign,shiftval):
        if sign == '-': #  ie. original [1,2,3,4,5,6]; shift right 2 = [1,1,1,2,3,4]
            evalsign = '0'      # "-" becomes digit "0" for python eval compatibility
            shiftedindex = index - shiftval
        elif sign == '+': #"+" original [1,2,3,4,5,6]; shift left 2  = [3,4,5,6,6,6]
            evalsign = '1'      #digit 1 = "+"
            shiftedindex = index + shiftval
        if len(readings) > 0:
            if shiftedindex >= len(readings):
                shiftedindex = len(readings)- 1
            if shiftedindex < 0:
                return -1, evalsign
            return readings[shiftedindex], evalsign
        return -1, evalsign

    # mathexpression = formula; t = a number to evaluate(usually time);
    # equeditnumber option = plotter edit window number; RTsname = option RealTime var name; RTsval = RealTime var val
    # The given mathexpression has to be a non-empty string!
    def eval_math_expression(self,mathexpression,t,equeditnumber=None, RTsname=None,RTsval=None,t_offset=0):
        if len(mathexpression):
            mathdictionary = {}
            mathdictionary.update(self.mathdictionary_base) # extend by the standard math symbolic formulas

            if aw.qmc.flagstart or not aw.qmc.flagon:
                sample_timex = self.timex
                sample_temp1 = self.temp1
                sample_temp2 = self.temp2
                sample_delta1 = self.delta1
                sample_delta2 = self.delta2
                sample_extratimex = self.extratimex
                sample_extratemp1 = self.extratemp1
                sample_extratemp2 = self.extratemp2
            else:
                sample_timex = self.on_timex
                sample_temp1 = self.on_temp1
                sample_temp2 = self.on_temp2
                sample_delta1 = self.on_delta1
                sample_delta2 = self.on_delta2
                sample_extratimex = self.on_extratimex
                sample_extratemp1 = self.on_extratemp1
                sample_extratemp2 = self.on_extratemp2

            #if sampling
            if RTsname is not None and RTsname != '':
                if len(sample_timex):
                    index = len(sample_timex)-1
                else:
                    index = 0
                #load real time buffers acquired at sample() to the dictionary
                mathdictionary['Y1'] = self.RTtemp1 # ET
                mathdictionary['Y2'] = self.RTtemp2 # BT

                mathdictionary['R1'] = self.rateofchange1 # ET RoR
                mathdictionary['R2'] = self.rateofchange2 # BT RoR

                for d in range(len(self.RTextratemp1)):
                    mathdictionary[f'Y{(d*2+3):.0f}'] = self.RTextratemp1[d]
                    mathdictionary[f'Y{(d*2+4):.0f}'] = self.RTextratemp2[d]
                if str(RTsname) not in mathdictionary:
                    mathdictionary[str(RTsname)] = float(RTsval)

            else: # get index from the time.
                if len(sample_timex):
                    index = self.time2index(t)  # If using the plotter with loaded profile. Background index done below at "B"
                else:
                    index = 0      #if plotting but nothing loaded.
            #if background
            if self.backgroundprofile is not None and 'B' in mathexpression:
                bindex = self.backgroundtime2index(t)         #use background time

            replacements = {'+':'p','-':'m','*':'m','/':'d','(':'o',')':'c'} # characters to be replaced from symb variable for substitution

            #symbolic variables holding the index of main events from self.timeindex to be used to retrieve time and temp data from the corresponding t and Y variables
            #using the absolute access symbolic variables t{<i>} and Y{<i>} defined below
            #those variable are set to the error item -1 if no index is yet available

            main_events = ['CHARGE','DRY','FCs','FCe','SCs','SCe','DROP', 'COOL']
            for i,v in enumerate(main_events):
                if (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0):
                    mathdictionary[v] = self.timeindex[i]
                else:
                    mathdictionary[v] = -1

            if self.background:
                background_main_events = ['bCHARGE','bDRY','bFCs','bFCe','bSCs','bSCe','bDROP', 'bCOOL']
                for i,v in enumerate(background_main_events):
                    if (i == 0 and self.timeindexB[i] > -1) or (self.timeindexB[i] > 0):
                        mathdictionary[v] = self.timeindexB[i]
                    else:
                        mathdictionary[v] = -1

            # time in seconds after those events. If an event was not issued yet this evaluates to 0
            delta_main_events = ['dCHARGE','dDRY','dFCs','dFCe','dSCs','dSCe','dDROP', 'dCOOL']
            try:
                for i,v in enumerate(delta_main_events):
                    if len(sample_timex)>0 and (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0) and len(sample_timex)>self.timeindex[i]:
                        # we return the time after the event in seconds
                        mathdictionary[v] = sample_timex[-1] - sample_timex[self.timeindex[i]]
                    else:
                        # before the event we return 0
                        mathdictionary[v] = 0
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            try:
                mathdictionary['aTMP'] = self.ambientTemp
                mathdictionary['aHUM'] = self.ambient_humidity
                mathdictionary['aPRE'] = self.ambient_pressure
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # prediction of the time to DRY and FCs before the event
            # this evaluates to None before TP and 0 after the event
            try:
                for v in ['pDRY','pFCs']:
                    if len(sample_delta2) > 0 and sample_delta2[-1] and sample_delta2[-1] > 0:
                        mathdictionary[v] = 0
                        if v == 'pDRY':
                            if self.backgroundprofile is not None and self.timeindexB[1] and not self.autoDRYflag: # with AutoDRY, we always use the set DRY phase temperature as target
                                drytarget = self.temp2B[self.timeindexB[1]] # Background DRY BT temperature
                            else:
                                drytarget = self.phases[1] # Drying max phases definition
                            if drytarget > sample_temp2[-1]:
                                mathdictionary[v] = (drytarget - sample_temp2[-1])/(sample_delta2[-1]/60.)
                        elif v == 'pFCs':
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.backgroundprofile is not None and self.timeindexB[2]:
                                fcstarget = self.temp2B[self.timeindexB[2]] # Background FCs BT temperature
                            else:
                                fcstarget = self.phases[2] # FCs min phases definition
                            if fcstarget > sample_temp2[-1]:
                                mathdictionary[v] = (fcstarget - sample_temp2[-1])/(sample_delta2[-1]/60.)
                    else:
                        # if a prediction is not possible (before TP), we return the error value -1
                        mathdictionary[v] = -1
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # add AUC variables (AUCbase, AUCtarget, AUCvalue)
            try:
                mathdictionary['AUCvalue'] = self.AUCvalue
                if self.AUCbaseFlag:
                    if self.AUCbegin == 0 and self.timeindex[0] > -1: # start after CHARGE
                        idx = self.timeindex[0]
                    elif self.AUCbegin == 1 and self.TPalarmtimeindex: # start ater TP
                        idx = self.TPalarmtimeindex
                    elif self.AUCbegin == 2 and self.timeindex[1] > 0: # DRY END
                        idx = self.timeindex[1]
                    elif self.AUCbegin == 3 and self.timeindex[2] > 0: # FC START
                        idx = self.timeindex[2]
                    else:
                        idx = -1
                    if idx > -1: # we passed the AUCbegin event
                        mathdictionary['AUCbase'] = sample_temp2[idx]
                    else:
                        mathdictionary['AUCbase'] = None # Event not set yet, no AUCbase
                else:
                    mathdictionary['AUCbase'] = self.AUCbase
                if self.AUCtargetFlag and self.backgroundprofile is not None and self.AUCbackground > 0:
                    mathdictionary['AUCtarget'] = self.AUCbackground
                else:
                    mathdictionary['AUCtarget'] = self.AUCtarget
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            #timeshift working vars
            timeshiftexpressions = []           #holds strings like "Y10040" as explained below
            timeshiftexpressionsvalues = []     #holds the evaluated values (float) for the above

            try:
                t = float(t)
                #extract Ys
                Yval = []                   #stores value number example Y9 = 9 => Yval = ['9']
                mlen = len(mathexpression)
                for i in range(mlen):
                    #Start symbolic assignment
                    #Y + one digit
                    if mathexpression[i] == 'Y':
                        #find Y number for ET,BT,Extras (up to 9)
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                seconddigitstr = ''
                                if i+2 < mlen and mathexpression[i+2].isdigit():
                                    offset = 1
                                    nint = int(f'{mathexpression[i+1]}{mathexpression[i+2]}')  # two digits Ynumber int
                                else:
                                    offset = 0
                                    nint = int(mathexpression[i+1])                      # one digit Ynumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]"
                                if i+5+offset < mlen and mathexpression[i+2+offset] == '[':
                                    Yshiftval = int(mathexpression[i+offset+4])
                                    sign = mathexpression[i+offset+3]

                                    #timeshift with two digits
                                    if mathexpression[i+offset+5].isdigit():
                                        seconddigitstr = mathexpression[i+offset+5]
                                        mathexpression = f'{mathexpression[:i+offset+5]}{mathexpression[i+offset+6:]}'
                                        Yshiftval = 10*Yshiftval + int(seconddigitstr)

                                    if nint == 1: #ET
                                        readings = sample_temp1
                                    elif nint == 2: #BT
                                        readings = sample_temp2
                                    elif nint > 2:
                                        #map the extra device
                                        edindex = (nint-1)//2 - 1
                                        if nint%2:
                                            readings = sample_extratemp1[edindex]
                                        else:
                                            readings = sample_extratemp2[edindex]
                                    val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)

                                    #add expression and values found
                                    evaltimeexpression = f'Y{mathexpression[i+1:i+2+offset]}{evalsign*2}{mathexpression[i+offset+4]}{seconddigitstr}{evalsign}'
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    #convert "Y2[+9]" to Ynumber compatible for python eval() to add to dictionary
                                    #METHOD USED: replace all non digits chars with sign value.
                                    #Example1 "Y2[-7]" = "Y20070"   Example2 "Y2[+9]" = "Y21191"
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+offset+6:]))
                                #direct index access: e.g. "Y2{CHARGE}" or "Y2{12}"
                                elif i+5+offset < len(mathexpression) and mathexpression[i+offset+2] == '{' and mathexpression.find('}',i+offset+3) > -1:
                                    end_idx = mathexpression.index('}',i+offset+3)
                                    body = mathexpression[i+3:end_idx]
                                    val = -1
                                    try:
                                        absolute_index = eval(body,{'__builtins__':None},mathdictionary) # pylint: disable=eval-used
                                        if absolute_index > -1:
                                            if nint == 1: #ET
                                                val = sample_temp1[absolute_index]
                                            elif nint == 2: #BT
                                                val = sample_temp2[absolute_index]
                                            elif nint > 2:
                                                #map the extra device
                                                edindex = (nint-1)//2 - 1
                                                if nint%2:
                                                    val = sample_extratemp1[edindex][absolute_index]
                                                else:
                                                    val = sample_extratemp2[edindex][absolute_index]
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    #add expression and values found
                                    literal_body = body
                                    for k, v in replacements.items():
                                        literal_body = literal_body.replace(k,v)
                                    evaltimeexpression = f'Y{mathexpression[i+1]}u{literal_body}u' # curle brackets replaced by "u"
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                # Y + TWO digits. Y10-Y99 . 4+ extra devices. No timeshift
                                elif i+2 < mlen and mathexpression[i+2].isdigit():
                                    Yval.append(f'{mathexpression[i+1]}{mathexpression[i+2]}')
                                # No timeshift Y1,Y2,Y3,etc.
                                else:
                                    Yval.append(mathexpression[i+1])

                    #the actual value
                    elif mathexpression[i] == 'x':
                        if 'x' not in mathdictionary:
                            if RTsval is not None:                   # zero could be a valid value
                                mathdictionary['x'] = RTsval         # add x to the math dictionary
                            else:
                                mathdictionary['x'] = -1

                    #the factor to plot C/min delta_ax values on the standard temperature axis
                    elif mathexpression[i] == 'k':
                        if 'k' not in mathdictionary:
                            try:
                                mathdictionary['k'] = (aw.qmc.ylimit - aw.qmc.ylimit_min) / float(aw.qmc.zlimit - aw.qmc.zlimit_min)
                            except Exception: # pylint: disable=broad-except
                                mathdictionary['k'] = 1

                    #the offset to plot C/min delta_ax values on the standard temperature axis
                    elif mathexpression[i] == 'o':
                        if 'o' not in mathdictionary:
                            try:
                                mathdictionary['o'] = aw.qmc.ylimit_min - (aw.qmc.zlimit_min * (aw.qmc.ylimit - aw.qmc.ylimit_min) / float(aw.qmc.zlimit - aw.qmc.zlimit_min))
                            except Exception: # pylint: disable=broad-except
                                mathdictionary['o'] = 0

                    elif mathexpression[i] == 'R':
                        try:
                            if i+1 < mlen:
                                if mathexpression[i+1] == 'B': # RBnn : RoR of Background Profile
                                    k = 1
                                    c = 'RB'
                                else:
                                    k = 0
                                    c = 'R'
                                seconddigitstr = ''
                                if mathexpression[i+k+1].isdigit():
                                    nint = int(mathexpression[i+k+1])              #Rnumber int
                                    #check for TIMESHIFT 0-9 (one digit). Example: "R1[-2]"
                                    if i+k+5 < len(mathexpression) and mathexpression[i+k+2] == '[':
                                        Yshiftval = int(mathexpression[i+k+4])
                                        sign = mathexpression[i+k+3]

                                        # TWO digits shifting
                                        if mathexpression[i+k+5].isdigit():
                                            seconddigit = int(mathexpression[i+k+5])
                                            seconddigitstr = mathexpression[i+k+5]
                                            mathexpression = f'{mathexpression[:i+k+5]}{mathexpression[i+k+6:]}'
                                            Yshiftval = 10*Yshiftval + seconddigit
                                        if nint == 1: #DeltaET
                                            if k == 0:
                                                readings = sample_delta1
                                            else:
                                                readings = self.delta1B
                                        elif nint == 2: #DeltaBT
                                            if k == 0:
                                                readings = sample_delta2
                                            else:
                                                readings = self.delta2B
                                        val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)

                                        #add expression and values found
                                        evaltimeexpression = ''.join((c,mathexpression[i+k+1],evalsign*2,mathexpression[i+k+4],seconddigitstr,evalsign))
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        #convert "R2[+9]" to Rnumber compatible for python eval() to add to dictionary
                                        #METHOD USED: replace all non digits chars with sign value.
                                        #Example1 "R2[-7]" = "R20070"   Example2 "R2[+9]" = "R21191"
                                        mathexpression = evaltimeexpression.join((mathexpression[:i+k],mathexpression[i+k+6:]))

                                    #direct index access: e.g. "R2{CHARGE}" or "R2{12}"
                                    elif i+k+5 < len(mathexpression) and mathexpression[i+k+2] == '{' and mathexpression.find('}',i+k+3) > -1:
                                        end_idx = mathexpression.index('}',i+k+3)
                                        body = mathexpression[i+k+3:end_idx]
                                        val = -1
                                        try:
                                            absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                            if absolute_index > -1:
                                                if nint == 1: #DeltaET
                                                    if k == 0:
                                                        val = sample_delta1[absolute_index]
                                                    else:
                                                        val = self.delta1B[absolute_index]
                                                else: # nint == 2: #DeltaBT
                                                    if k == 0:
                                                        val = sample_delta2[absolute_index]
                                                    else:
                                                        val = self.delta2B[absolute_index]
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                        #add expression and values found
                                        literal_body = body
                                        for j, v in replacements.items():
                                            literal_body = literal_body.replace(j,v)
                                        evaltimeexpression = ''.join((c,mathexpression[i+1],'z',literal_body,'z')) # curle brackets replaced by "z"
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))

                                    #no shift
                                    else:
                                        if mathexpression[i+k+1] == '1':
                                            if k == 0:
                                                mathdictionary['R1'] = sample_delta1[index]
                                            else:
                                                mathdictionary['RB1'] = self.delta1B[index]
                                        elif mathexpression[i+k+1] == '2':
                                            if k == 0:
                                                mathdictionary['R2'] = sample_delta2[index]
                                            else:
                                                mathdictionary['RB2'] = self.delta2B[index]
                        except Exception: # pylint: disable=broad-except
                            # if deltas of backgrounds are not visible the data is not calculated and thus this fails with an exception
                            pass

                    #Add to dict Event1-4 external value
                    elif mathexpression[i] == 'E':
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])-1              #Enumber int
                                #find right most occurrence before index of given event type
                                if nint in self.specialeventstype and nint < 4:
                                    spevtylen = len(self.specialeventstype)-1
                                    for iii in range(spevtylen,-1,-1):
                                        if self.specialeventstype[iii] == nint and index >= self.specialevents[iii]:
                                            break  #index found
                                    val = self.eventsInternal2ExternalValue(self.specialeventsvalue[iii])
                                else:
                                    val = 0
                                e_string = f'E{mathexpression[i+1]}'
                                if e_string not in mathdictionary:
                                    mathdictionary[e_string] = val

                    # time timeshift of absolute time (not relative to CHARGE)
                    # t : to access the foreground profiles time (sample_timex)
                    # b : to access the background profiles time (self.timeB)
                    elif mathexpression[i] in ['t','b']:
                        if mathexpression[i] == 't':
                            timex = sample_timex
                        else:
                            timex = self.timeB
                        seconddigitstr = ''
                        if i+4 < len(mathexpression) and mathexpression[i+1] == '[':
                            Yshiftval = int(mathexpression[i+3])
                            sign = mathexpression[i+2]

                            if mathexpression[i+4].isdigit():
                                seconddigit = int(mathexpression[i+4])
                                seconddigitstr = mathexpression[i+4]
                                mathexpression = f'{mathexpression[:i+4]}{mathexpression[i+5:]}'
                                Yshiftval = 10*Yshiftval + seconddigit

                            val, evalsign = self.shiftValueEvalsign(timex,index,sign,Yshiftval)

                            val = val - t_offset
                            evaltimeexpression = ''.join((mathexpression[i],evalsign*2,mathexpression[i+3],seconddigitstr,evalsign))
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+5:]))
                        #direct index access: e.g. "t{CHARGE}" or "t{12}"
                        elif i+3 < len(mathexpression) and mathexpression[i+1] == '{' and mathexpression.find('}',i+2) > -1:
                            end_idx = mathexpression.index('}',i+2)
                            body = mathexpression[i+2:end_idx]
                            val = -1
                            try:
                                absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                if absolute_index > -1:
                                    val = timex[absolute_index]
                            except Exception: # pylint: disable=broad-except
                                pass
                            literal_body = body
                            for k, v in replacements.items():
                                literal_body = literal_body.replace(k,v)
                            evaltimeexpression = ''.join((mathexpression[i],'q',literal_body,'q')) # curle brackets replaced by "q"
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                        #no timeshift
                        else:
                            if mathexpression[i] == 't' and 't' not in mathdictionary:
                                mathdictionary['t'] = t - t_offset         #add t to the math dictionary
                            # b is only valid with index

                    #Add to dict plotter Previous results (cascading) from plotter field windows (1-9)
                    elif mathexpression[i] == 'P':
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])              #Ynumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]"
                                if i+5 < len(mathexpression) and mathexpression[i+2] == '[' and mathexpression[i+5] == ']':
                                    Yshiftval = int(mathexpression[i+4])
                                    sign = mathexpression[i+3]
                                    evaltimeexpression = ''.join(('P',mathexpression[i+1],evalsign*2,mathexpression[i+4],evalsign))
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                #no shift
                                else:
                                    if index < len(self.plotterequationresults[nint-1]):
                                        val = self.plotterequationresults[nint-1][index]
                                    else:
                                        val = -1000
                                    p_string = f'P{mathexpression[i+1]}'
                                    if p_string not in mathdictionary:
                                        mathdictionary[p_string] = val

                    #Background B1 = ETbackground; B2 = BTbackground
                    elif mathexpression[i] == 'B':
                        if i+1 < mlen:
                            seconddigitstr = ''
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])              #Bnumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "B1[-2]"
                                if i+5 < len(mathexpression) and mathexpression[i+2] == '[':
                                    Yshiftval = int(mathexpression[i+4])
                                    sign = mathexpression[i+3]

                                    # TWO digits shifting
                                    if mathexpression[i+5].isdigit():
                                        seconddigit = int(mathexpression[i+5])
                                        seconddigitstr = mathexpression[i+5]
                                        mathexpression = f'{mathexpression[:i+5]}{mathexpression[i+6:]}'
                                        Yshiftval = 10*Yshiftval + seconddigit

                                    if not len(self.timeB):
                                        # no background, set to 0
                                        val = 0
                                        evalsign = '0'
                                    else:
                                        if nint == 1: #ETbackground
                                            readings = self.temp1B
                                        elif nint == 2: #BTbackground
                                            readings = self.temp2B
                                        #B3, B4, B5, ...
                                        elif nint > 2:
                                            idx3 = aw.qmc.xtcurveidx - 1
                                            n3 = idx3//2
                                            if aw.qmc.xtcurveidx%2:
                                                readings = self.temp1BX[n3]
                                            else:
                                                readings = self.temp2BX[n3]
                                        val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)
                                    evaltimeexpression = ''.join(('B',mathexpression[i+1],evalsign*2,mathexpression[i+4],seconddigitstr,evalsign))
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                #direct index access: e.g. "B2{CHARGE}" or "B2{12}"
                                elif i+5 < len(mathexpression) and mathexpression[i+2] == '{' and mathexpression.find('}',i+3) > -1:
                                    end_idx = mathexpression.index('}',i+3)
                                    body = mathexpression[i+3:end_idx]
                                    val = -1
                                    try:
                                        absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                        if absolute_index > -1:
                                            if nint == 1: #ET
                                                val = self.temp1B[absolute_index]
                                            elif nint == 2: #BT
                                                val = self.temp2B[absolute_index]
                                            else:
                                                idx3 = aw.qmc.xtcurveidx - 1
                                                n3 = idx3//2
                                                #map the extra device
                                                b = [0,0,1,1,2,2,3]
                                                edindex = b[nint-3]
                                                if aw.qmc.xtcurveidx%2:
                                                    val = self.temp1BX[n3][absolute_index]
                                                else:
                                                    val = self.temp2BX[n3][absolute_index]
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    #add expression and values found
                                    literal_body = body
                                    for k, v in replacements.items():
                                        literal_body = literal_body.replace(k,v)
                                    evaltimeexpression = ''.join(('B',mathexpression[i+1],'z',literal_body,'z')) # curle brackets replaced by "z"
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                #no shift
                                else:
                                    if not len(self.timeB):
                                        # no background, set to 0
                                        mathdictionary[f'B{mathexpression[i+1]}'] = 0
                                    else:
                                        if nint == 1:
                                            val = self.temp1B[bindex]
                                        elif nint == 2:
                                            val = self.temp2B[bindex]
                                        else:
                                            idx3 = aw.qmc.xtcurveidx - 1
                                            n3 = idx3//2
                                            if aw.qmc.xtcurveidx%2:
                                                val = self.temp1BX[n3][bindex]
                                            else:
                                                val = self.temp2BX[n3][bindex]

                                        mathdictionary[f'B{mathexpression[i+1]}'] = val

                    # Feedback from previous result. Stack = [10,9,8,7,6,5,4,3,2,1]
                    # holds the ten previous formula results (same window) in order.
                    # F1 is the last result. F5 is the past 5th result
                    elif mathexpression[i] == 'F':
                        if i+1 < mlen:
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])
                                val = self.plotterstack[-1*nint]
                                f_string = f'F{mathexpression[i+1]}'
                                if f_string not in mathdictionary:
                                    mathdictionary[f_string] = val

                    # add channel tare values (T1 => ET, T2 => BT, T3 => E1c1, T4 => E1c2, T5 => E2c1,
                    # set by clicking on the corresponding LCD
                    elif mathexpression[i] == 'T':
                        if i+1 < mlen:                          #check for out of range
                            nint = -1 #Enumber int
                            if i+2 < mlen and mathexpression[i+2].isdigit():
                                nint = int(f'{mathexpression[i+1]}{mathexpression[i+2]}')-1
                                mexpr = f'T{mathexpression[i+1]}{mathexpression[i+2]}'
                            elif mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])-1
                                mexpr = f'T{mathexpression[i+1]}'
                            if nint != -1:
                                if len(aw.channel_tare_values) > nint:
                                    mathdictionary[mexpr] = aw.channel_tare_values[nint]
                                else:
                                    mathdictionary[mexpr] = 0.0

                    #############   end of mathexpression loop ##########################

                #created Ys values
                try:
                    if len(sample_timex)>0:
                        if RTsname:
                            Y = [sample_temp1[-1], sample_temp2[-1]] # in realtime mode we take the last value
                        else:
                            Y = [sample_temp1[index], sample_temp2[index]]
                        if len(sample_extratimex):
                            for i in range(len(self.extradevices)):
                                if len(sample_extratimex[i]):
                                    if RTsname:
                                        Y.append(sample_extratemp1[i][-1])
                                        Y.append(sample_extratemp2[i][-1])
                                    else:
                                        Y.append(sample_extratemp1[i][index])
                                        Y.append(sample_extratemp2[i][index])

                        #add Ys and their value to math dictionary
                        for i in range(len(Yval)):
                            y_string = f'Y{Yval[i]}'
                            if y_string not in mathdictionary:
                                idx = int(Yval[i])-1
                                if len(Y) > idx > -1:
                                    mathdictionary[y_string] = Y[idx]

                        #add other timeshifted expressions to the math dictionary: shifted t and P
                        for i in range(len(timeshiftexpressions)):
                            if timeshiftexpressions[i] not in mathdictionary:
                                mathdictionary[timeshiftexpressions[i]] = timeshiftexpressionsvalues[i]
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

                #background symbols just in case there was no profile loaded but a background loaded.
                if len(self.timeB) > 0:
                    for i in range(len(timeshiftexpressions)):
                        if timeshiftexpressions[i] not in mathdictionary:
                            mathdictionary[timeshiftexpressions[i]] = timeshiftexpressionsvalues[i]
                try:
                    # we exclude the main_events as they occur as substrings in others like CHARGE in dCHARGE
                    # the special case of a variable Y1 overlapping with a variable Y11,..,Y12 in this simple test has to be excluded to avoid
                    # that if mathexpression="Y11" and mathdictionary contains {"Y1":-1} -1 is returned instead of the correct value of Y11
                    # "x" occurs in "max" and has also to be excluded, as "t" and "b"
                    me = mathexpression.strip()
                    propagate_error = True # if any variable occurring in me is bound to -1 the whole me evals to -1
                    try:
                        if me[0] == '(' and me[-1] == ')':
                            # only if the whole expression is in brackets, errors bound to variables are not propagated
                            propagate_error = False
                    except Exception: # pylint: disable=broad-except
                        pass
                    if propagate_error and any((((k in me) if k not in (['Y1','x','t','b'] if ('max' in me) else ['Y1','t','b']) else False) for k,v in mathdictionary.items() if (v == -1 and not (k in main_events)))):
                        # if any variable is bound to the error value -1 we return -1 for the full formula
                        res = -1
                    else:
                        res = float(eval(me,{'__builtins__':None},mathdictionary)) # pylint: disable=eval-used
                except TypeError:
                    res = -1
                except ValueError:
                    res = -1
                except ZeroDivisionError:
                    res = -1
                except IndexError:
                    res = -1
                if res is None:
                    return -1
                #stack (use in feedback "F" in same formula)
                self.plotterstack.insert(10,res)
                self.plotterstack.pop(0)
                #Pnumber results storage
                if equeditnumber:
                    self.plotterequationresults[equeditnumber-1].append(res)
                return res

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                #if plotter
                if equeditnumber:
                    self.plottermessage = f'P{equeditnumber}: {e}'
                    return -1
                #if sample()
                #virtual devices with symbolic may need 2 samples min.
                if len(sample_timex) > 2:
                    e = str(e)
                    _, _, exc_tb = sys.exc_info()
                    mathexpression = mathexpression.replace('{','(').replace('}',')') # avoid {x} leading to key arrows
                    self.adderror((QApplication.translate('Error Message', 'Exception:') + ' eval_curve_expression(): %s {0} '%mathexpression).format(e),getattr(exc_tb, 'tb_lineno', '?'))
                return -1
        return -1


    #format X axis labels
    def xaxistosm(self,redraw=True,min_time=None,max_time=None):
        try:
            if min_time is None:
                startofx = self.startofx
            else:
                startofx = min_time
            if max_time is None:
                endofx = self.endofx
            else:
                endofx = max_time

            if bool(aw.comparator):
                starttime = 0
            else:
                if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
                    starttime = self.timex[self.timeindex[0]]
                else:
                    starttime = 0

            endtime = endofx + starttime

            self.ax.set_xlim(startofx,endtime)

            if self.xgrid != 0:

                mfactor1 =  round(float(2. + abs(int(round(startofx-starttime))/int(round(self.xgrid)))))
                mfactor2 =  round(float(2. + abs(int(round(endofx))/int(round(self.xgrid)))))

                majorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid)
                if self.xgrid == 60:
                    minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 30)
                else:
                    minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 60)

                majorlocator = ticker.FixedLocator(majorloc)
                minorlocator = ticker.FixedLocator(minorloc)

                self.ax.xaxis.set_major_locator(majorlocator)
                self.ax.xaxis.set_minor_locator(minorlocator)

                formatter = ticker.FuncFormatter(self.formtime)
                self.ax.xaxis.set_major_formatter(formatter)


                #adjust the length of the minor ticks
                for i in self.ax.xaxis.get_minorticklines() + self.ax.yaxis.get_minorticklines():
                    i.set_markersize(4)

                #adjust the length of the major ticks
                for i in self.ax.get_xticklines() + self.ax.get_yticklines():
                    i.set_markersize(6)
                    #i.set_markeredgewidth(2)   #adjust the width

                # check x labels rotation
                if self.xrotation:
                    for label in self.ax.xaxis.get_ticklabels():
                        label.set_rotation(self.xrotation)

            if not aw.qmc.LCDdecimalplaces:
                if self.ax:
                    self.ax.minorticks_off()
                if self.delta_ax:
                    self.delta_ax.minorticks_off()

            # we have to update the canvas cache
            if redraw:
                self.updateBackground()
            else:
                self.ax_background = None
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def fmt_timedata(self,x):
        if bool(aw.comparator):
            starttime = 0
        else:
            if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
                starttime = self.timex[self.timeindex[0]]
            else:
                starttime = 0
        if x >=  starttime:
            sign = ''
        else:
            sign = '-'
        m,s = divmod(abs(x - starttime), 60)
        return '%s%d:%02d'%(sign,m,s)

    def fmt_data(self,x):
        res = x
        if self.fmt_data_ON and self.delta_ax and self.fmt_data_RoR and self.twoAxisMode():
            try:
                # depending on the z-order of ax vs delta_ax the one or the other one is correct
                #res = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,x))[1]))[1])
                res = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,x))[1]))[1])
            except Exception: # pylint: disable=broad-except
                pass
        if aw.qmc.LCDdecimalplaces:
            return aw.float2float(res)
        return int(round(res))

    #used by xaxistosm(). Provides also negative time
    def formtime(self,x,_):
        if bool(aw.comparator):
            starttime = 0
        else:
            if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
                starttime = self.timex[self.timeindex[0]]
            else:
                starttime = 0

        if x >=  starttime:
            m,s = divmod((x - round(starttime)), 60)  #**NOTE**: divmod() returns here type numpy.float64, which could create problems
            #print type(m),type(s)                    #it is used in: formatter = ticker.FuncFormatter(self.formtime) in xaxistosm()
            s = int(round(s))
            m = int(m)

            if s >= 59:
                return '%d'%(m+1)
            if abs(s - 30) < 1:
                return '%d.5'%m
            if s > 1:
                return  '%d:%02d'%(m,s)
            return '%d'%m

        m,s = divmod(abs(x - round(starttime)), 60)
        s = int(round(s))
        m = int(m)

        if s >= 59:
            return '-%d'%(m+1)
        if abs(s-30) < 1:
            return '-%d.5'%m
        if s > 1:
            return  '-%d:%02d'%(m,s)
        if m == 0:
            return '0'
        return '-%d'%m

    # returns True if nothing to save, discard or save was selected and False if canceled by the user
    def checkSaved(self,allow_discard=True):
        #prevents deleting accidentally a finished roast
        if self.safesaveflag == True and len(aw.qmc.timex) > 3:
            if allow_discard:
                string = QApplication.translate('Message','Save the profile, Discard the profile (Reset), or Cancel?')
                buttons = QMessageBox.StandardButton.Discard|QMessageBox.StandardButton.Save|QMessageBox.StandardButton.Cancel
            else:
                string = QApplication.translate('Message','Save the profile or Cancel?')
                buttons = QMessageBox.StandardButton.Save|QMessageBox.StandardButton.Cancel
            reply = QMessageBox.warning(aw,QApplication.translate('Message','Profile unsaved'),string,
                                buttons)
            if reply == QMessageBox.StandardButton.Save:
                return aw.fileSave(aw.curFile)  #if accepted, calls fileClean() and thus turns safesaveflag = False
            if reply == QMessageBox.StandardButton.Discard:
                self.fileCleanSignal.emit()
                return True
            if reply == QMessageBox.StandardButton.Cancel:
                aw.sendmessage(QApplication.translate('Message','Action canceled'))
            return False
        # nothing to be saved
        return True

    def clearLCDs(self):
        if self.LCDdecimalplaces:
            zz = '-.-'
        else:
            zz = '--'
        aw.lcd2.display(zz)
        aw.lcd3.display(zz)
        aw.lcd4.display(zz)
        aw.lcd5.display(zz)
        aw.lcd6.display(zz)
        aw.lcd7.display(zz)
        for i in range(aw.nLCDS):
            if self.intChannel(i,0):
                zz0 = '--'
            else:
                zz0 = zz
            aw.extraLCD1[i].display(zz0)
            if self.intChannel(i,1):
                zz1 = '--'
            else:
                zz1 = zz
            aw.extraLCD2[i].display(zz1)
        if aw.largeLCDs_dialog is not None:
            aw.largeLCDs_dialog.updateDecimals()
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.updateDecimals()
        if aw.largePIDLCDs_dialog is not None:
            aw.largePIDLCDs_dialog.updateDecimals()
        if aw.largeExtraLCDs_dialog is not None:
            aw.largeExtraLCDs_dialog.updateDecimals()
        if aw.largePhasesLCDs_dialog is not None:
            aw.largePhasesLCDs_dialog.updateDecimals()

    def clearMeasurements(self,andLCDs=True):
        try:
            #### lock shared resources #####
            aw.qmc.profileDataSemaphore.acquire(1)
            self.fileCleanSignal.emit()
            self.rateofchange1 = 0.0
            self.rateofchange2 = 0.0
            charge = 0
            if self.timeindex[0] > -1:
                charge = self.timex[self.timeindex[0]]
            self.temp1, self.temp2, self.delta1, self.delta2, self.timex, self.stemp1, self.stemp2, self.ctimex1, self.ctimex2, self.ctemp1, self.ctemp2 = [],[],[],[],[],[],[],[],[],[],[]
            self.tstemp1,self.tstemp2 = [],[]
            self.unfiltereddelta1,self.unfiltereddelta2 = [],[]
            self.unfiltereddelta1_pure,self.unfiltereddelta2_pure = [],[]
            self.timeindex = [-1,0,0,0,0,0,0,0]
            # we set startofx to x-axis min limit as timeindex[0] is no cleared, to keep the axis limits constant (note that startx depends on timeindex[0]!)
            self.startofx = self.startofx - charge
            #extra devices
            for i in range(min(len(self.extradevices),len(self.extratimex),len(self.extratemp1),len(self.extratemp2),len(self.extrastemp1),len(self.extrastemp2))):
                self.extratimex[i],self.extratemp1[i],self.extratemp2[i],self.extrastemp1[i],self.extrastemp2[i] = [],[],[],[],[]            #reset all variables that need to be reset (but for the actually measurements that will be treated separately at the end of this function)
                self.extractimex1[i],self.extractimex2[i],self.extractemp1[i],self.extractemp2[i] = [],[],[],[]
            self.replayedBackgroundEvents=[]
            self.beepedBackgroundEvents=[]
            self.specialevents=[]
            aw.lcd1.display('00:00')
            if aw.WebLCDs:
                self.updateWebLCDs(time='00:00')
            if aw.largeLCDs_dialog:
                self.updateLargeLCDsTimeSignal.emit('00:00')
            if andLCDs:
                self.clearLCDs()

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' clearMeasurements() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)

    @pyqtSlot(bool)
    def resetButtonAction(self,_=False):
        self.disconnectProbes() # release serial/S7/MODBUS connections
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.KeyboardModifier.AltModifier:  #alt click
            # detach IO Phidgets
            try:
                aw.qmc.closePhidgetOUTPUTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            try:
                aw.qmc.closePhidgetAMBIENTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        self.reset()

    #Resets graph. Called from reset button. Deletes all data. Calls redraw() at the end
    # returns False if action was canceled, True otherwise
    # if keepProperties=True (a call from OnMonitor()), we keep all the pre-set roast properties
    def reset(self,redraw=True,soundOn=True,sampling=False,keepProperties=False,fireResetAction=True):
        try:
            focused_widget = QApplication.focusWidget()
            if focused_widget and focused_widget != aw.centralWidget():
                focused_widget.clearFocus()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

        if not self.checkSaved():
            return False

        # restore and clear extra device settings which might have been created on loading a profile with different extra devices settings configuration
        aw.restoreExtraDeviceSettingsBackup()

        if sampling and self.flagOpenCompleted and aw.curFile is not None:
            # always if ON is pressed while a profile is loaded, the profile is send to the Viewer
            # the file URL of the saved profile (if any) is send to the ArtisanViewer app to be opened if already running
            try:
                fileURL = QUrl.fromLocalFile(aw.curFile)
                fileURL.setQuery('background') # open the file URL without raising the app to the foreground
                QTimer.singleShot(10,lambda : app.sendMessage2ArtisanInstance(fileURL.toString(),app._viewer_id)) # pylint: disable=protected-access
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

        if soundOn:
            aw.soundpopSignal.emit()

        if fireResetAction:
            try:
                # the RESET button action needs to be fired outside of the semaphore to avoid lockups
                aw.eventactionx(aw.qmc.xextrabuttonactions[0],aw.qmc.xextrabuttonactionstrings[0])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        try:
            #### lock shared resources #####
            aw.qmc.profileDataSemaphore.acquire(1)
            #reset time
            self.resetTimer()

            self.roastUUID = None # reset UUID
            aw.qmc.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
            aw.qmc.roastbatchpos = 1 # initialized to 1, set to increased batchsequence on DROP
            aw.qmc.roastbatchprefix = aw.qmc.batchprefix

            aw.sendmessage(QApplication.translate('Message','Scope has been reset'))
            aw.AUClcd.setNumDigits(3)
            aw.buttonFCs.setDisabled(False)
            aw.buttonFCe.setDisabled(False)
            aw.buttonSCs.setDisabled(False)
            aw.buttonSCe.setDisabled(False)
            aw.buttonRESET.setDisabled(False)
            aw.buttonCHARGE.setDisabled(False)
            aw.buttonDROP.setDisabled(False)
            aw.buttonDRY.setDisabled(False)
            aw.buttonCOOL.setDisabled(False)
            aw.buttonFCs.setFlat(False)
            aw.buttonFCe.setFlat(False)
            aw.buttonSCs.setFlat(False)
            aw.buttonSCe.setFlat(False)
            aw.buttonRESET.setFlat(False)
            aw.buttonCHARGE.setFlat(False)
            aw.buttonCHARGE.stopAnimation()
            aw.buttonDROP.setFlat(False)
            aw.buttonDRY.setFlat(False)
            aw.buttonCOOL.setFlat(False)
            aw.buttonONOFF.setText(QApplication.translate('Button', 'ON'))
            if aw.simulator:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles_simulator['OFF'])
            else:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles['OFF'])
            aw.buttonSTARTSTOP.setText(QApplication.translate('Button', 'START'))
            if aw.simulator:
                aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles_simulator['STOP'])
            else:
                aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles['STOP'])

            # quantification is blocked if lock_quantification_sampling_ticks is not 0
            # (eg. after a change of the event value by button or slider actions)
            aw.block_quantification_sampling_ticks = [0,0,0,0]
            #aw.extraeventsactionslastvalue = [None,None,None,None] # used by +-% event buttons in ON mode when no event was registered yet

            # reset plus sync
            self.plus_sync_record_hash = None
            self.plus_file_last_modified = None

            # if we are in KeepON mode, the reset triggered by ON should respect the roastpropertiesflag ("Delete Properties on Reset")
            if self.roastpropertiesflag and (self.flagKeepON or not keepProperties):
                self.title = QApplication.translate('Scope Title', 'Roaster Scope')
                self.roastingnotes = ''
                self.cuppingnotes = ''
                self.beans = ''
                self.plus_store = None
                self.plus_coffee = None
                self.plus_blend_spec = None
                # copy setup
                self.organization = self.organization_setup
                self.operator = self.operator_setup
                self.roastertype = self.roastertype_setup
                self.roastersize = self.roastersize_setup
                self.roasterheating = self.roasterheating_setup
                self.drumspeed = self.drumspeed_setup
                # set energy defaults
                self.restoreEnergyLoadDefaults()
                self.restoreEnergyProtocolDefaults()
                #
                self.weight = [self.last_batchsize,0,self.weight[2]]
                self.volume = [0,0,self.volume[2]]
                self.density = [0,self.density[1],1,self.density[3]]
                # we reset ambient values to the last sampled readings in this session
                self.ambientTemp = self.ambientTemp_sampled
                self.ambient_humidity = self.ambient_humidity_sampled
                self.ambient_pressure = self.ambient_pressure_sampled
                self.beansize = 0.
                self.beansize_min = 0
                self.beansize_max = 0
                self.moisture_greens = 0.
                self.greens_temp = 0.
                self.volumeCalcWeightInStr = ''
                self.volumeCalcWeightOutStr = ''
            else:
                self.weight = [self.weight[0],0,self.weight[2]]
                self.volume = [self.volume[0],0,self.volume[2]]
            self.whole_color = 0
            self.ground_color = 0
            self.moisture_roasted = 0.
            self.density_roasted = [0,self.density_roasted[1],1,self.density_roasted[3]]

            # reset running AUC values
            self.AUCvalue = 0
            self.AUCsinceFCs = 0
            self.AUCguideTime = 0

            self.profile_sampling_interval = None

            self.statisticstimes = [0,0,0,0,0]

            self.roastdate = QDateTime.currentDateTime()
            self.roastepoch = QDateTime.currentDateTime().toSecsSinceEpoch()
            self.roasttzoffset = libtime.timezone
            if not sampling: # just if the RESET button is manually pressed we clear the error log
                self.errorlog = []
                aw.seriallog = []

            aw.qmc.zoom_follow = False # reset the zoom follow feature

            self.specialevents = []
            self.specialeventstype = []
            self.specialeventsStrings = []
            self.specialeventsvalue = []

            self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
            self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
            aw.eNumberSpinBox.setValue(0)
            aw.lineEvent.setText('')
            aw.etypeComboBox.setCurrentIndex(0)
            aw.valueEdit.setText('')
            #used to find length of arms in annotations
            self.ystep_down = 0
            self.ystep_up = 0

            # reset keyboard mode
            aw.keyboardmoveindex = 0 # points to the last activated button in keyboardButtonList; we start with the CHARGE button            aw.resetKeyboardButtonMarks()

            aw.setTimerColor('timer')

            #roast flags
            self.heavyFC_flag = False
            self.lowFC_flag = False
            self.lightCut_flag = False
            self.darkCut_flag = False
            self.drops_flag = False
            self.oily_flag = False
            self.uneven_flag = False
            self.tipping_flag = False
            self.scorching_flag = False
            self.divots_flag = False

            # renable autoCHARGE/autoDRY/autoFCs/autoDROP; all of those get set to False on UNDO of the event for the current roast
            self.autoCHARGEenabled = True
            self.autoDRYenabled = True
            self.autoFCsenabled = True
            self.autoDROPenabled = True

            #Designer variables
            self.indexpoint = 0
            self.workingline = 2            #selects ET or BT
            self.currentx = 0               #used to add point when right click
            self.currenty = 0               #used to add point when right click
            self.designertemp1init = []
            self.designertemp2init = []
#            if self.mode == 'C':
#                #CH, DE, FCs,FCe,SSs,SCe,DROP, COOL
#                self.designertemp1init = [290.,290.,290.,290.,280.,270.,260.,250]
#                self.designertemp2init = [230.,150.,190.,212.,218.,225.,230.,230.]
#            elif self.mode == 'F':
#                self.designertemp1init = [500,500,500,500,500,500,500]
#                self.designertemp2init = [380,300,390,395,410,412,420]
            self.disconnect_designer()  #sets designer flag false
            self.setCursor(Qt.CursorShape.ArrowCursor)

            # disconnect analyzer signal
            self.fig.canvas.mpl_disconnect(self.analyzer_connect_id)

            #reset cupping flavor values
            self.flavors = [5.]*len(self.flavorlabels)

            try:
                # reset color of last pressed button
                if aw.lastbuttonpressed != -1:
                    aw.setExtraEventButtonStyle(aw.lastbuttonpressed, style='normal')
                # reset lastbuttonpressed
                aw.lastbuttonpressed = -1
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            #aw.pidcontrol.sv = None
            aw.fujipid.sv = None
            aw.qmc.dutycycle = -1
            aw.qmc.dutycycleTX = 0.
            aw.qmc.currentpidsv = 0.

            # we remove the filename to force writing a new file
            # and avoid accidental overwriting of existing data
            #current file name
            aw.curFile = None
            aw.updateWindowTitle()

            # if on turn mouse crosslines off
            if aw.qmc.crossmarker:
                aw.qmc.togglecrosslines()

            #remove the analysis results annotation if it exists
            aw.qmc.analysisresultsstr = ''

            #autodetected CHARGE and DROP index
            self.autoChargeIdx = 0
            self.autoDropIdx = 0
            self.autoTPIdx = 0
            self.autoDryIdx = 0
            self.autoFCsIdx = 0

            self.l_annotations = [] # initiate the event annotations
            # we initialize the annotation position dict of the foreground profile
            self.deleteAnnoPositions(foreground=True, background=False)
            self.l_event_flags_dict = {} # initiate the event id to temp/time annotation dict for flags
            self.l_background_annotations = [] # initiate the background event annotations

            if not sampling:
                aw.hideDefaultButtons()
                aw.updateExtraButtonsVisibility()
                aw.enableEditMenus()

            #reset alarms
            self.temporaryalarmflag = -3
            self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
            #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
            aw.qmc.TPalarmtimeindex = None

            aw.pidcontrol.pidActive = False

            self.wheelflag = False
            self.designerflag = False

            #check and turn off mouse cross marker
            if self.crossmarker:
                self.togglecrosslines()

            if aw is not None:
                aw.updatePlusStatus()

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' reset() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)
        # now clear all measurements and redraw

        self.clearMeasurements()
        #clear PhasesLCDs
        aw.updatePhasesLCDs()
        #clear AUC LCD
        aw.updateAUCLCD()

        # if background is loaded we move it back to its original position (after regular load):
        if self.backgroundprofile is not None:
            moved = self.backgroundprofile_moved_x != 0 or self.backgroundprofile_moved_y != 0
            if self.backgroundprofile_moved_x != 0:
                self.movebackground('left',self.backgroundprofile_moved_x)
            if self.backgroundprofile_moved_y != 0:
                self.movebackground('down',self.backgroundprofile_moved_y)
            if moved:
                self.timealign(redraw=False)

        if not (self.autotimex and self.background):
            if self.locktimex:
                self.startofx = self.locktimex_start
                self.endofx = self.locktimex_end
            elif keepProperties:
                self.startofx = self.chargemintime
                self.endofx = self.resetmaxtime
        if self.endofx < 1:
            self.endofx = 60

        ### REDRAW  ##
        if redraw:
            aw.autoAdjustAxis(background=not keepProperties) # if reset() triggered by ON, we ignore background on adjusting the axis and adjust according to RESET min/max
            self.redraw(True,sampling=sampling,smooth=aw.qmc.optimalSmoothing) # we need to re-smooth with standard smoothing if ON and optimal-smoothing is ticked

        #QApplication.processEvents() # this one seems to be needed for a proper redraw in fullscreen mode on OS X if a profile was loaded and NEW is pressed
        #   this processEvents() seems not to be needed any longer!?
        return True

    # https://gist.github.com/bhawkins/3535131
    @staticmethod
    def medfilt(x, k):
        """Apply a length-k median filter to a 1D array x.
        Boundaries are extended by repeating endpoints.
        """
        assert k % 2 == 1, 'Median filter length must be odd.'
        assert x.ndim == 1, 'Input must be one-dimensional.'
        if len(x) == 0:
            return x
        k2 = (k - 1) // 2
        y = numpy.zeros ((len (x), k), dtype=x.dtype)
        y[:,k2] = x
        for i in range (k2):
            j = k2 - i
            y[j:,i] = x[:-j]
            y[:j,i] = x[0]
            y[:-j,-(i+1)] = x[j:]
            y[-j:,-(i+1)] = x[-1]
        return numpy.median(y, axis=1)
#        return numpy.nanmedian(y, axis=1) # produces artefacts

    # smoothes a list (or numpy.array) of values 'y' at taken at times indicated by the numbers in list 'x'
    # 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
    # 'flat' results in moving average
    # window_len should be odd
    # based on http://wiki.scipy.org/Cookbook/SignalSmooth
    # returns a smoothed numpy array or the original y argument
    @staticmethod
    def smooth(x, y, window_len=15, window='hanning'):
        try:
            if len(x) == len(y) and len(x) > 1:
                if window_len > 2:
                    # smooth curves
                    #s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
                    #s=numpy.r_[y[window_len-1:0:-1],y,y[-2:-window_len-1:-1]]
                    #s = y
                    s=numpy.r_[y[window_len-1:0:-1],y,y[-1:-window_len:-1]]
                    if window == 'flat': #moving average
                        w = numpy.ones(window_len,'d')
                    else:
                        w = eval('numpy.'+window+'(window_len)') # pylint: disable=eval-used
                    try:
                        ys = numpy.convolve(w/w.sum(),s,mode='valid')
                    except Exception: # pylint: disable=broad-except
                        return y
                    hwl = int(window_len/2)
                    res = ys[hwl:-hwl]
                    if len(res)+1 == len(y) and len(res) > 0:
                        try:
                            return ys[hwl-1:-hwl]
                        except Exception: # pylint: disable=broad-except
                            return y
                    elif len(res) != len(y):
                        return y
                    else:
                        return res
                else:
                    return y
            else:
                return y
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' smooth() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return x

    # re-sample, filter and smooth slice
    # takes numpy arrays a (time) and b (temp) of the same length and returns a numpy array representing the processed b values
    # precondition: (aw.qmc.filterDropOuts or window_len>2)
    def smooth_slice(self, a, b,
        window_len=7, window='hanning',decay_weights=None,decay_smoothing=False,
        re_sample=True,back_sample=True,a_lin=None):

        # 1. re-sample
        if re_sample:
            if a_lin is None or len(a_lin) != len(a):
                a_mod = numpy.linspace(a[0],a[-1],len(a))
            else:
                a_mod = a_lin
            b = numpy.interp(a_mod, a, b) # resample data to linear spaced time
        else:
            a_mod = a
        res = b # just in case the precondition (aw.qmc.filterDropOuts or window_len>2) does not hold
        # 2. filter spikes
        if aw.qmc.filterDropOuts:
            try:
                b = self.medfilt(b,5)  # k=3 seems not to catch all spikes in all cases; k=5 and k=7 seems to be ok; 13 might be the maximum; k must be odd!
# scipyernative which performs equal, but produces larger artefacts at the borders and for intermediate NaN values for k>3
#                from scipy.signal import medfilt as scipy_medfilt
#                b = scipy_medfilt(b,3)
                res = b
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                res = b
        # 3. smooth data
        if window_len>2:
            if decay_smoothing:
                # decay smoothing
                if decay_weights is None:
                    decay_weights = numpy.arange(1,window_len+1)
                else:
                    window_len = len(decay_weights)
                # invariant: window_len = len(decay_weights)
                if decay_weights.sum() == 0:
                    res = b
                else:
                    res = []
                    # ignore -1 readings in averaging and ensure a good ramp
                    for i in range(len(b)):
                        seq = b[max(0,i-window_len + 1):i+1]
#                        # we need to suppress -1 drop out values from this
#                        seq = list(filter(lambda item: item != -1,seq)) # -1 drop out values in b have already been replaced by numpy.nan above

                        w = decay_weights[max(0,window_len-len(seq)):]  # preCond: len(decay_weights)=window_len and len(seq) <= window_len; postCond: len(w)=len(seq)
                        if len(w) == 0:
                            res.append(b[i]) # we don't average if there is are no weights (e.g. if the original seq did only contain -1 values and got empty)
                        else:
                            res.append(numpy.average(seq,weights=w)) # works only if len(seq) = len(w)
                    # postCond: len(res) = len(b)
            else:
                # optimal smoothing (the default)
                win_len = max(0,window_len)
                if win_len != 1: # at the lowest level we turn smoothing completely off
                    res = self.smooth(a_mod,b,win_len,window)
                else:
                    res = b
        # 4. sample back
        if re_sample and back_sample:
            res = numpy.interp(a, a_mod, res) # re-sampled back to original timestamps
        return res

    # takes lists a (time array) and b (temperature array) containing invalid segments of -1/None values and returns a list with all segments of valid values smoothed
    # a: list of timestamps
    # b: list of readings
    # re_sample: if true re-sample readings to a linear spaced time before smoothing
    # back_sample: if true results are back-sampled to original timestamps given in "a" after smoothing
    # a_lin: pre-computed linear spaced timestamps of equal length than a
    # NOTE: result can contain NaN items on places where the input array contains the error element -1
    # result is a numpy array or the b as numpy array with drop out readings -1 replaced by NaN
    def smooth_list(self, a, b, window_len=7, window='hanning',decay_weights=None,decay_smoothing=False,fromIndex=-1,toIndex=0,re_sample=True,back_sample=True,a_lin=None):
        if len(a) > 1 and len(a) == len(b) and (aw.qmc.filterDropOuts or window_len>2):
            #pylint: disable=E1103
            # 1. truncate
            if fromIndex > -1: # if fromIndex is set, replace prefix up to fromIndex by None
                if toIndex==0: # no limit
                    toIndex=len(a)
            else: # smooth list on full length
                fromIndex = 0
                toIndex = len(a)
            a = numpy.array(a[fromIndex:toIndex], dtype=numpy.double)
            # we mask the error value -1 and Numpy  in the temperature array
            mb = numpy.ma.masked_equal(numpy.ma.masked_equal(b[fromIndex:toIndex], -1), None)
            # split in masked and
            unmasked_slices = [(x,False) for x in numpy.ma.clump_unmasked(mb)] # the valid readings
            masked_slices = [(x,True) for x in numpy.ma.clump_masked(mb)] # the dropped values
            sorted_slices = sorted(unmasked_slices + masked_slices, key=lambda tup: tup[0].start)
            b_smoothed = [] # b_smoothed collects the smoothed segments in order
            b_smoothed.append(numpy.full(fromIndex, numpy.nan, dtype=numpy.double)) # append initial segment to the list of resulting segments
            # we just smooth the unmsked slices and add the unmasked slices with NaN values
            for (s, m) in sorted_slices:
                if m:
                    # a slice with all masked (invalid) readings
                    b_smoothed.append(numpy.full(s.stop - s.start, numpy.nan, dtype=numpy.double))
                else:
                    # a slice with proper data
                    b_smoothed.append(self.smooth_slice(a[s], mb[s], window_len, window, decay_weights, decay_smoothing, re_sample, back_sample, a_lin))
            b_smoothed.append(numpy.full(len(a)-toIndex, numpy.nan, dtype=numpy.double)) # append the final segment to the list of resulting segments
            return numpy.concatenate(b_smoothed)
        b = numpy.array(b, dtype=numpy.double)
        b[b == -1] = numpy.nan
        return b


# REPLACED BY above slicing smooth_list
#    # a: list of timestamps
#    # b: list of readings
#    # re_sample: if true re-sample readings to a linear spaced time before smoothing
#    # back_sample: if true results are back-sampled to original timestamps given in "a" after smoothing
#    # a_lin: pre-computed linear spaced timestamps of equal length than a
#    # NOTE: result can contain NaN items on places where the input array contains the error element -1
#    # result is always a list (and not a numpy array)
#    def smooth_list(self, a, b, window_len=7, window='hanning',decay_weights=None,decay_smoothing=False,fromIndex=-1,toIndex=0,re_sample=True,back_sample=True,a_lin=None):  # default 'hanning'
#        if len(a) > 1 and len(a) == len(b) and (aw.qmc.filterDropOuts or window_len>2):
#            #pylint: disable=E1103
#            # 1. truncate
#            if fromIndex > -1: # if fromIndex is set, replace prefix up to fromIndex by None
#                if toIndex==0: # no limit
#                    toIndex=len(a)
#            else: # smooth list on full length
#                fromIndex = 0
#                toIndex = len(a)
#            # we replace the error value -1  in the temperature array by numpy.nan to avoid strange smoothing artifacts
#            # no need to substitute anything in the time array!
#            a = numpy.array(a[fromIndex:toIndex], dtype=numpy.double)
#            b = numpy.array(b[fromIndex:toIndex], dtype=numpy.double) # None replaced by numpy.nan
#            b[b==-1] = numpy.nan # -1 replaced by numpy.nan
#            # 2. re-sample
#            if re_sample:
#                if a_lin is None or len(a_lin) != len(a):
#                    a_mod = numpy.linspace(a[0],a[-1],len(a))
#                else:
#                    a_mod = a_lin
#                b = numpy.interp(a_mod, a, b) # resample data to linear spaced time
#            else:
#                a_mod = a
#            # 3. filter spikes
#            if aw.qmc.filterDropOuts:
#                try:
#                    b = self.medfilt(b,5)  # k=3 seems not to catch all spikes in all cases; k must be odd!
### scipy alternative which performs equal, but produces larger artefacts at the borders and for intermediate NaN values for k>3
##                    from scipy.signal import medfilt as scipy_medfilt
##                    b = scipy_medfilt(b,3)
#                    res = b
#                except Exception as e: # pylint: disable=broad-except
#                    _log.error(e)
#                    res = b
#            # 4. smooth data
#            if window_len>2:
#                if decay_smoothing:
#                    # decay smoothing
#                    if decay_weights is None:
#                        decay_weights = numpy.arange(1,window_len+1)
#                    else:
#                        window_len = len(decay_weights)
#                    # invariant: window_len = len(decay_weights)
#                    if decay_weights.sum() == 0:
#                        res = b
#                    else:
#                        res = []
#                        # ignore -1 readings in averaging and ensure a good ramp
#                        for i in range(len(b)):
#                            seq = b[max(0,i-window_len + 1):i+1]
##                            # we need to suppress -1 drop out values from this
##                            seq = list(filter(lambda item: item != -1,seq)) # -1 drop out values in b have already been replaced by numpy.nan above
#
#                            w = decay_weights[max(0,window_len-len(seq)):]  # preCond: len(decay_weights)=window_len and len(seq) <= window_len; postCond: len(w)=len(seq)
#                            if len(w) == 0:
#                                res.append(b[i]) # we don't average if there is are no weights (e.g. if the original seq did only contain -1 values and got empty)
#                            else:
#                                res.append(numpy.average(seq,weights=w)) # works only if len(seq) = len(w)
#                        # postCond: len(res) = len(b)
#                else:
#                    # optimal smoothing (the default)
#                    win_len = max(0,window_len)
#                    if win_len != 1: # at the lowest level we turn smoothing completely off
#                        res = self.smooth(a_mod,b,win_len,window)
#                    else:
#                        res = b
#            # 4. sample back
#            if re_sample and back_sample:
#                res = numpy.interp(a, a_mod, res) # re-sampled back to original timestamps
#            # Note: at this point res might be a list or a numpy array as decay smoothing generates a list which might not be back_sampled and optimal smoothing a numpy array.
#            return numpy.concatenate(([None]*(fromIndex),res,[None]*(len(a)-toIndex))).tolist()
#        return b

    # deletes saved annotation positions from l_annotations_dict
    # foreground annotations have position keys <=6, background annotation positions have keys > 6,
    def deleteAnnoPositions(self, foreground:bool = False, background:bool = False):
        if background and foreground:
            self.l_annotations_dict = {}
        else:
            for k in list(self.l_annotations_dict.keys()):
                if (background and k > 6) or (foreground and k <= 6):
                    self.l_annotations_dict.pop(k)

    def moveBackgroundAnnoPositionsX(self, step):
        for k in list(self.l_annotations_dict.keys()):
            if k > 6:
                for anno in self.l_annotations_dict[k]:
                    x,y = anno.get_position()
                    anno.set_position((x+step,y))

    def moveBackgroundAnnoPositionsY(self, step):
        for k in list(self.l_annotations_dict.keys()):
            if k > 6:
                for anno in self.l_annotations_dict[k]:
                    x,y = anno.get_position()
                    anno.set_position((x,y+step))

    # returns the position of the main event annotations as list of lists of the form
    #   [[id,temp_x,temp_y,time_x,time_y],...]
    # with id the main event id like -1 for TP, 0 for CHARGE, 1 for DRY,.., 6 for DROP (keys above 6 as used for background profile annotations are ignored)
    def getAnnoPositions(self):
        res = []
        for k,v in self.l_annotations_dict.items():
            if k<7:
                temp_anno = v[0].xyann
                time_anno = v[1].xyann
                if all(not numpy.isnan(e) for e in temp_anno + time_anno):
                    # we add the entry only if all of the coordinates are proper numpers and not nan
                    res.append([k,temp_anno[0],temp_anno[1],time_anno[0],time_anno[1]])
        return res

    def setAnnoPositions(self,anno_positions):
        for ap in anno_positions:
            if len(ap) == 5:
                i = ap[0]
                temp_x = ap[1]
                temp_y = ap[2]
                time_x = ap[3]
                time_y = ap[4]
                self.l_annotations_pos_dict[i] = ((temp_x,temp_y),(time_x,time_y))

    # returns the position of the custom event flag annotations as list of lists of the form
    #   [[id,x,y],...]
    # with id the event id
    def getFlagPositions(self):
        res = []
        for k,v in self.l_event_flags_dict.items():
            flag_anno = v.xyann
            if all(not numpy.isnan(e) for e in flag_anno):
                res.append([k,flag_anno[0],flag_anno[1]])
        return res

    def setFlagPositions(self,flag_positions):
        for fp in flag_positions:
            if len(fp) == 3:
                i = fp[0]
                x = fp[1]
                y = fp[2]
                self.l_event_flags_pos_dict[i] = (x,y)

    # temp and time are the two annotation
    # x,y is the position of the annotation line start
    # e is the x-axis offset, yup/ydown are the y-axis offsets of the annotations line ends and the annotation text
    # a is the alpha value
    def annotate(self, temp, time_str, x, y, yup, ydown,e=0,a=1.,draggable=True,draggable_anno_key=None):
        fontprop_small = aw.mpl_fontproperties.copy()
        fontsize = 'x-small'
        fontprop_small.set_size(fontsize)
        if aw.qmc.patheffects:
            rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette['background'])]
        else:
            rcParams['path.effects'] = []
        #annotate temp
        if aw.qmc.LCDdecimalplaces:
            fmtstr = '%.1f'
        else:
            fmtstr = '%.0f'
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file, those are removed after first rendering
            xytext = self.l_annotations_pos_dict[draggable_anno_key][0]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            # next we check the "live" dictionary
            xytext = self.l_annotations_dict[draggable_anno_key][0].xyann
        else:
            xytext = (x+e,y + yup)
        temp_anno = self.ax.annotate(fmtstr%(temp), xy=(x,y),xytext=xytext,
                            color=self.palette['text'],
                            arrowprops=dict(arrowstyle='-',color=self.palette['text'],alpha=a),
                            fontsize=fontsize,
                            alpha=a,
                            fontproperties=fontprop_small)
        try:
            temp_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            if draggable:
                temp_anno.draggable(use_blit=True)
                temp_anno.set_picker(aw.draggable_text_box_picker)
        except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
            pass
        #anotate time
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file
            xytext = self.l_annotations_pos_dict[draggable_anno_key][1]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            xytext = self.l_annotations_dict[draggable_anno_key][1].xyann
        else:
            xytext = (x+e,y - ydown)
        time_anno = self.ax.annotate(time_str,xy=(x,y),xytext=xytext,
                             color=self.palette['text'],arrowprops=dict(arrowstyle='-',color=self.palette['text'],alpha=a),
                             fontsize=fontsize,alpha=a,fontproperties=fontprop_small)
        try:
            time_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            if draggable:
                time_anno.draggable(use_blit=True)
                time_anno.set_picker(aw.draggable_text_box_picker)
        except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
            pass
        if aw.qmc.patheffects:
            rcParams['path.effects'] = []
        res = [temp_anno, time_anno]
        if draggable and draggable_anno_key is not None:
            aw.qmc.l_annotations_dict[draggable_anno_key] = [temp_anno, time_anno]
        return res

    def place_annotations(self,TP_index,d,timex,timeindex,temp,stemp,startB=None,timeindex2=None,TP_time_loaded=None,draggable=True):
        ystep_down = ystep_up = 0
        anno_artists = []
        #Add markers for CHARGE
        # add offset to annotation keys for background annotations to prevent them from being confused with those of the foreground profile and to prevent persisting them to alog files
        if startB == None:
            anno_key_offset = 0
        else:
            anno_key_offset = 10
        try:
            if len(timex) > 0:
                if timeindex[0] != -1 and len(timex) > timeindex[0]:
                    t0idx = timeindex[0] # time idx at CHARGE
                    t0 = timex[t0idx]    # time at CHARGE in sec.
                else:
                    t0idx = 0
                    t0 = 0
                if timeindex[0] != -1:
                    y = stemp[t0idx]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                    if startB is not None:
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                        e = 0
                        a = aw.qmc.backgroundalpha
                    else:
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                        if aw.qmc.graphfont == 1:
                            st1 = self.__to_ascii(st1)
                        e = 0
                        a = 1.
                    time_temp_annos = self.annotate(temp[t0idx],st1,t0,y,ystep_up,ystep_down,e,a,draggable,0+anno_key_offset)
                    anno_artists += time_temp_annos

                #Add TP marker
                if self.markTPflag:
                    if TP_index and TP_index > 0:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}'), stringfromseconds(timex[TP_index]-t0,False))
                        a = 1.
                        e = 0
                        anno_artists += self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1+anno_key_offset)
                    elif TP_time_loaded is not None:
                        if timeindex2:
                            a = aw.qmc.backgroundalpha
                        else:
                            a = 1.
                        e = 0
                        if timeindex[0]>0:
                            # CHARGE set
                            shift = timex[timeindex[0]]
                        else:
                            shift = 0
                        TP_index = self.backgroundtime2index(TP_time_loaded + shift)
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}'),stringfromseconds(TP_time_loaded,False))
                        anno_artists += self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1+anno_key_offset)
                #Add Dry End markers
                if timeindex[1]:
                    tidx = timeindex[1]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,1+anno_key_offset)

                #Add 1Cs markers
                if timeindex[2]:
                    tidx = timeindex[2]
                    if timeindex[1]: #if dryend
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[1]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,2+anno_key_offset)
                #Add 1Ce markers
                if timeindex[3]:
                    tidx = timeindex[3]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[2]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,3+anno_key_offset)
                    #add a water mark if FCs
                    if timeindex[2] and not timeindex2 and self.watermarksflag:
                        self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette['watermarks'], alpha=0.2)
                #Add 2Cs markers
                if timeindex[4]:
                    tidx = timeindex[4]
                    if timeindex[3]:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[3]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,4+anno_key_offset)
                #Add 2Ce markers
                if timeindex[5]:
                    tidx = timeindex[5]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[4]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,5+anno_key_offset)
                    #do water mark if SCs
                    if timeindex[4] and not timeindex2 and self.watermarksflag:
                        self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette['watermarks'], alpha=0.2)
                #Add DROP markers
                if timeindex[6]:
                    tidx = timeindex[6]
                    if timeindex[5]:
                        tx = timeindex[5]
                    elif timeindex[4]:
                        tx = timeindex[4]
                    elif timeindex[3]:
                        tx = timeindex[3]
                    elif timeindex[2]:
                        tx = timeindex[2]
                    elif timeindex[1]:
                        tx = timeindex[1]
                    else:
                        tx = t0idx
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}'),stringfromseconds(timex[tidx]-t0,False))
                    if aw.qmc.graphfont == 1:
                        st1 = self.__to_ascii(st1)
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = 0

                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,6+anno_key_offset)

                    #do water mark if FCs, but no FCe nor SCs nor SCe
                    if timeindex[2] and not timeindex[3] and not timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        fc_artist = self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette['watermarks'], alpha=0.2)
                        try:
                            fc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                    #do water mark if SCs, but no SCe
                    if timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        sc_artist = self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette['watermarks'], alpha=0.2)
                        try:
                            sc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                # add COOL mark
                if timeindex[7] and not timeindex2:
                    tidx = timeindex[7]
                    # as the right most data value of the axis in self.ax.get_xlim()[1] is only correctly set after the initial draw,
                    # we simply set it to twice as wide and trust that the clipping will cut of the part not within the axis system
                    endidx = 2*max(aw.qmc.timex[-1],aw.qmc.endofx,self.ax.get_xlim()[0],self.ax.get_xlim()[1])
                    if timex[tidx] < endidx and self.watermarksflag:
                        cool_mark = self.ax.axvspan(timex[tidx],endidx, facecolor=self.palette['rect4'], ec='none', alpha=0.3, clip_on=True, lw=None)#,lod=False)
                        try:
                            cool_mark.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' place_annotations() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return anno_artists

    @staticmethod
    def apply_symbolic_delta_formula(fct, deltas, timex, RTsname):
        try:
            if len(deltas) == len(timex):
                return [aw.qmc.eval_math_expression(fct,timex[i],RTsname=RTsname,RTsval=d) for i,d in enumerate(deltas)]
            return deltas
        except Exception: # pylint: disable=broad-except
            return deltas

    # computes the RoR over the time and temperature arrays tx and temp via polynoms of degree 1 at index i using a window of wsize
    # the window size wsize needs to be at least 1 (two succeeding readings)
    @staticmethod
    def polyRoR(tx, temp, wsize, i):
        if i == 0: # we duplicate the first possible RoR value instead of returning a 0
            i = 1
        if 0 < i < min(len(tx), len(temp)):
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                left_index = max(0,i-wsize)
                LS_fit = numpy.polynomial.polynomial.polyfit(tx[left_index:i+1],temp[left_index:i+1], 1)
                return LS_fit[1]*60.
        else:
            return 0

    @staticmethod
    # with window size wsize=1 the RoR is computed over succeeding readings; tx and temp assumed to be of type numpy.array
    def arrayRoR(tx, temp, wsize): # with wsize >=1
        res = (temp[wsize:] - temp[:-wsize]) / ((tx[wsize:] - tx[:-wsize])/60.)
        # length compensation done downstream, not necessary here!
        return res


    # returns deltas and linearized timex;  both results can be None
    # timex: the time array
    # temp: the temperature array
    # ds: the number of delta samples
    # timex_lin: the linearized time array or None
    # delta_symbolic_function: the symbolic function to be applied to the delta or None
    # RTsname: the symbolic variable name of the delta
    # deltaFilter: the deltaFilter setting
    # roast_start_idx: the index of CHARGE
    # roast_end_idx: the index of DROP
    def computeDeltas(self, timex, temp, ds, optimalSmoothing, timex_lin, delta_symbolic_function, RTsname, deltaFilter, roast_start_idx, roast_end_idx):
        if temp is not None:
            with numpy.errstate(divide='ignore'):
                lt = len(timex)
                ntemp = numpy.array([0 if x is None else x for x in temp]) # ERROR None Type object not scriptable! t==None on ON

                if optimalSmoothing and self.polyfitRoRcalc:
                    # optimal RoR computation using polynoms with out timeshift
                    if ds % 2 == 0:
                        dss = ds+1 # the savgol_filter expects odd window length of >=1
                    else:
                        dss = ds
                    if len(ntemp) > dss:
                        try:
                            # ntemp is not linearized yet:
                            if timex_lin is None or len(timex_lin) != len(ntemp):
                                timex_lin = numpy.linspace(timex[0],timex[-1],lt)
                            lin = timex_lin
                            ntemp_lin = numpy.interp(lin, timex, ntemp) # resample data in ntemp to linear spaced time
                            dist = (lin[-1] - lin[0]) / (len(lin) - 1)
                            from scipy.signal import savgol_filter # @Reimport
                            z1 = savgol_filter(ntemp_lin, dss, 1, deriv=1, delta=dss)
                            z1 = z1 * (60./dist) * dss
                        except Exception: # pylint: disable=broad-except
                            # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                            # https://github.com/numpy/numpy/issues/16744
                            # original version just picking the corner values:
                            z1 = self.arrayRoR(timex,ntemp,ds)
                    else:
                        # in this case we use the standard algo
                        try:
                            # variant using incremental polyfit RoR computation
                            z1 = [self.polyRoR(timex,ntemp,ds,i) for i in range(len(ntemp))]
                        except Exception: # pylint: disable=broad-except
                            # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                            # https://github.com/numpy/numpy/issues/16744
                            # original version just picking the corner values:
                            z1 = self.arrayRoR(timex,ntemp,ds)
                else:
                    if self.polyfitRoRcalc:
                        try:
                            # variant using incremental polyfit RoR computation
                            z1 = [self.polyRoR(timex,ntemp,ds,i) for i in range(len(ntemp))] # windows size ds needs to be at least 2
                        except Exception: # pylint: disable=broad-except
                            # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                            # https://github.com/numpy/numpy/issues/16744
                            # original version just picking the corner values:
                            z1 = self.arrayRoR(timex,ntemp,ds)
                    else:
                        z1 = self.arrayRoR(timex,ntemp,ds)

            ld1 = len(z1)
            # make lists equal in length
            if lt > ld1:
                z1 = numpy.append([z1[0] if ld1 else 0.]*(lt - ld1),z1)
            # apply smybolic formula
            if delta_symbolic_function is not None and len(delta_symbolic_function):
                z1 = self.apply_symbolic_delta_formula(delta_symbolic_function,z1,timex,RTsname=RTsname)
            # apply smoothing
            if optimalSmoothing:
                user_filter = deltaFilter
            else:
                user_filter = int(round(deltaFilter/2.))
            delta1 = self.smooth_list(timex,z1,window_len=user_filter,decay_smoothing=(not optimalSmoothing),a_lin=timex_lin)

            # cut out the part after DROP and before CHARGE and remove values beyond the RoRlimit
            delta1 = [
                d if ((roast_start_idx <= i <= roast_end_idx) and (d is not None and (not aw.qmc.RoRlimitFlag or
                    max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < d < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit))))
                else None
                for i,d in enumerate(delta1)
            ]

            if isinstance(delta1, (numpy.ndarray, numpy.generic)):
                delta1 = delta1.tolist()
            return delta1, timex_lin
        return None, timex_lin

    # computes the RoR deltas and returns the smoothed versions for both temperature channels
    # if t1 or t2 is not given (None), its RoR signal is not computed and None is returned instead
    # timex_lin: a linear spaced version of timex
    def recomputeDeltas(self,timex,CHARGEidx,DROPidx,t1,t2,optimalSmoothing=True,timex_lin=None,deltaETsamples=None,deltaBTsamples=None):
        try:
            tx_roast = numpy.array(timex) # timex non-linearized as numpy array
            lt = len(tx_roast)
            if CHARGEidx > -1:
                roast_start_idx = CHARGEidx
            else:
                roast_start_idx = 0
            if DROPidx > 0:
                roast_end_idx = DROPidx
            else:
                roast_end_idx = lt
            if deltaBTsamples is None:
                dsBT = max(1, aw.qmc.deltaBTsamples) # now as in sample_processing()
            else:
                dsBT = deltaBTsamples
            if deltaETsamples is None:
                dsET = max(1, aw.qmc.deltaETsamples) # now as in sample_processing()
            else:
                dsET = deltaETsamples
            if timex_lin is not None:
                if len(timex_lin) == len(timex):
                    timex_lin = numpy.array(timex_lin)
                else:
                    timex_lin = None
            delta1, timex_lin = self.computeDeltas(
                    tx_roast,
                    t1,
                    dsET,
                    optimalSmoothing,
                    timex_lin,
                    aw.qmc.DeltaETfunction,
                    'R1',
                    self.deltaETfilter,
                    roast_start_idx,
                    roast_end_idx)
            delta2, _ = self.computeDeltas(
                    tx_roast,
                    t2,
                    dsBT,
                    optimalSmoothing,
                    timex_lin,
                    aw.qmc.DeltaBTfunction,
                    'R2',
                    self.deltaBTfilter,
                    roast_start_idx,
                    roast_end_idx)

            return delta1, delta2
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' recomputeDeltas() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return [0]*len(timex),[0]*len(timex)

    @staticmethod
    def bisection(array, value):
        #Algorithm presumes 'array' is monotonic increasing.  This is not guaranteed for profiles so there
        #may be results that are not strictly correct.
        n = len(array)
        if (value < array[0]):
            return -1
        if (value > array[n-1]):
            return n
        if (value == array[0]): # edge cases at bottom
            return 0
        if (value == array[n-1]): # and top
            return n-1
        jl = 0   # Initialize lower
        ju = n-1 # and upper limits.
        while (ju-jl > 1):# If we are not yet done,
            jm=(ju+jl) >> 1 # compute a midpoint with a bitshift
            if (value >= array[jm]):
                jl=jm # and replace either the lower limit
            else:
                ju=jm # or the upper limit, as appropriate.
            # Repeat until the test condition is satisfied.
        if (abs(value - array[jl]) > abs(array[ju] - value)):
            return ju
        return jl

    def drawAUC(self):
        try:
            TP_Index = aw.findTP()
            if aw.qmc.AUCbaseFlag:
                _,_,_,idx = aw.ts()
                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],aw.qmc.stemp2[idx])
            else:
                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],aw.qmc.AUCbase)
            rtbt = aw.qmc.stemp2[idx]

            ix = self.timex[idx:self.timeindex[6]+1]
            iy = self.stemp2[idx:self.timeindex[6]+1]

            # Create the shaded region
            a = ix[0]
            b = ix[-1]
            verts = [ xy for xy in [(a, rtbt)] + list(zip(ix, iy)) + [(b, rtbt)] if xy[1] > 0 ]
            if verts:
                poly = Polygon(verts, facecolor=self.palette['aucarea'], edgecolor='0.5', alpha=0.3)
                self.ax.add_patch(poly)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def set_xlabel(self,xlabel):
        fontprop_medium = aw.mpl_fontproperties.copy()
        fontprop_medium.set_size('medium')
        self.xlabel_text = xlabel
        self.xlabel_artist = self.ax.set_xlabel(xlabel,color = self.palette['xlabel'],
#            fontproperties=fontprop_medium
            fontsize='medium',
            fontfamily=fontprop_medium.get_family()
            )
        try:
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.xlabel_width = self.xlabel_artist.get_window_extent(renderer=self.fig.canvas.get_renderer()).width
        except Exception: # pylint: disable=broad-except
            pass
        try:
            self.xlabel_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
            pass

    def setProfileBackgroundTitle(self,backgroundtitle):
        suptitleX = 1
        try:
            ax_width = self.ax.get_window_extent(renderer=self.fig.canvas.get_renderer()).width # total width of axis in display coordinates
            ax_begin = self.ax.transAxes.transform((0,0))[0] # left of axis in display coordinates
            suptitleX = self.fig.transFigure.inverted().transform((ax_width + ax_begin,0))[0]
        except Exception: # pylint: disable=broad-except
            pass

        self.background_title_width = 0
        backgroundtitle = backgroundtitle.strip()
        if backgroundtitle != '':
            if aw.qmc.graphfont in [1,9]: # if selected font is Humor we translate the unicode title into pure ascii
                backgroundtitle = self.__to_ascii(backgroundtitle)
            backgroundtitle = f'\n{abbrevString(backgroundtitle, 32)}'

        self.l_subtitle = self.fig.suptitle(backgroundtitle,
                horizontalalignment='right',verticalalignment='top',
                fontsize='x-small',
                x=suptitleX,y=1,
                color=(self.palette['title_focus'] if (self.backgroundprofile is not None and self.backgroundPlaybackEvents) else self.palette['title']))
        try:
            self.l_subtitle.set_in_layout(False)  # remove title from tight_layout calculation
        except Exception: # pylint: disable=broad-except  # set_in_layout not available in mpl<3.x
            pass
        try:
            if len(backgroundtitle)>0:
                self.background_title_width = self.l_subtitle.get_window_extent(renderer=self.fig.canvas.get_renderer()).width
            else:
                self.background_title_width = 0
        except Exception: # pylint: disable=broad-except
            self.background_title_width = 0

    # if updatebackground is True, the profileDataSemaphore is caught and updatebackground() is called
    @pyqtSlot(str,bool)
    def setProfileTitle(self,title,updatebackground=False):
        if ((self.flagon and not aw.curFile) or self.flagstart) and self.batchcounter != -1:
            bprefix = self.batchprefix
            bnr = self.batchcounter + 1
        else:
            bprefix = self.roastbatchprefix
            bnr = self.roastbatchnr
        if bnr != 0 and title != '':
            title = f'{bprefix}{str(bnr)} {title}'

        if self.graphfont in [1,9]: # if selected font is Humor or Dijkstra we translate the unicode title into pure ascii
            title = self.__to_ascii(title)

        self.title_text = aw.arabicReshape(title.strip())
        self.title_artist = self.ax.set_title(self.title_text, color=self.palette['title'], loc='left',
                    fontsize='xx-large',
                    horizontalalignment='left',verticalalignment='top',x=0)
        try: # this one seems not to work for titles, subtitles and axis!?
            self.title_artist.set_in_layout(False) # remove title from tight_layout calculation
        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
            pass
        try:
            self.title_width = self.title_artist.get_window_extent(renderer=self.fig.canvas.get_renderer()).width
        except Exception: # pylint: disable=broad-except
            pass

        if updatebackground:
            #### lock shared resources #####
            aw.qmc.profileDataSemaphore.acquire(1)
            try:
                self.updateBackground()
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)

    # resize the given list to the length ln by cutting away elements or padding with trailing -1 items
    # used to resize temperature data to the length of the corresponding timex times
    @staticmethod
    def resizeList(lst, ln):
        if lst is None:
            return None
        return (lst + [-1]*(ln-len(lst)))[:ln]

    def drawET(self,temp):
        if aw.qmc.ETcurve:
            try:
                if self.l_temp1 is not None:
                    self.l_temp1.remove()
            except Exception: # pylint: disable=broad-except
                pass
            # don't draw -1:
            temp = [r if r !=-1 else None for r in temp]
            self.l_temp1, = self.ax.plot(
                self.timex,
                temp,
                markersize=self.ETmarkersize,
                marker=self.ETmarker,
                sketch_params=None,
                path_effects=[PathEffects.withStroke(linewidth=self.ETlinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                linewidth=self.ETlinewidth,
                linestyle=self.ETlinestyle,
                drawstyle=self.ETdrawstyle,
                color=self.palette['et'],
                label=aw.arabicReshape(QApplication.translate('Label', 'ET')))

    def drawBT(self,temp):
        if aw.qmc.BTcurve:
            try:
                if self.l_temp2 is not None:
                    self.l_temp2.remove()
            except Exception: # pylint: disable=broad-except
                pass
            # don't draw -1:
            temp = [r if r !=-1 else None for r in temp]
            self.l_temp2, = self.ax.plot(
                self.timex,
                temp,
                markersize=self.BTmarkersize,
                marker=self.BTmarker,
                sketch_params=None,
                path_effects=[PathEffects.withStroke(linewidth=self.BTlinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                linewidth=self.BTlinewidth,
                linestyle=self.BTlinestyle,
                drawstyle=self.BTdrawstyle,
                color=self.palette['bt'],
                label=aw.arabicReshape(QApplication.translate('Label', 'BT')))

    def drawDeltaET(self,trans,start,end):
        if self.DeltaETflag:
            try:
                if self.l_delta1 is not None:
                    self.l_delta1.remove()
            except Exception: # pylint: disable=broad-except
                pass
            self.l_delta1, = self.ax.plot(
                self.timex[start:end],
                self.delta1[start:end],
                transform=trans,
                markersize=self.ETdeltamarkersize,
                marker=self.ETdeltamarker,
                sketch_params=None,
                path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                linewidth=self.ETdeltalinewidth,
                linestyle=self.ETdeltalinestyle,
                drawstyle=self.ETdeltadrawstyle,
                color=self.palette['deltaet'],
                label=aw.arabicReshape(f'{deltaLabelUTF8}{QApplication.translate("Label", "ET")}'))

    def drawDeltaBT(self,trans,start,end):
        if self.DeltaBTflag:
            try:
                if self.l_delta2 is not None:
                    self.l_delta2.remove()
            except Exception: # pylint: disable=broad-except
                pass
            self.l_delta2, = self.ax.plot(
                self.timex[start:end],
                self.delta2[start:end],
                transform=trans,
                markersize=self.BTdeltamarkersize,
                marker=self.BTdeltamarker,
                sketch_params=None,
                path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                linewidth=self.BTdeltalinewidth,
                linestyle=self.BTdeltalinestyle,
                drawstyle=self.BTdeltadrawstyle,
                color=self.palette['deltabt'],
                label=aw.arabicReshape(f'{deltaLabelUTF8}{QApplication.translate("Label", "BT")}'))

    # if profileDataSemaphore lock cannot be fetched the redraw is not performed
    def lazyredraw(self, recomputeAllDeltas=True, smooth=True,sampling=False):
        gotlock = aw.qmc.profileDataSemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this redraw round (prevents stacking of waiting calls)
        if gotlock:
            try:
                self.redraw(recomputeAllDeltas,smooth,sampling,takelock=False)
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)

    def smoothETBT(self,smooth,recomputeAllDeltas,sampling,decay_smoothing_p):
        try:
            # we resample the temperatures to regular interval timestamps
            if self.timex is not None and self.timex and len(self.timex)>1:
                timex_lin = numpy.linspace(self.timex[0],self.timex[-1],len(self.timex))
            else:
                timex_lin = None
            temp1_nogaps = fill_gaps(self.resizeList(self.temp1,len(self.timex)))
            temp2_nogaps = fill_gaps(self.resizeList(self.temp2,len(self.timex)))

            if smooth or len(self.stemp1) != len(self.timex):
                if self.flagon: # we don't smooth, but remove the dropouts
                    self.stemp1 = temp1_nogaps
                else:
                    self.stemp1 = self.smooth_list(self.timex,temp1_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
            if smooth or len(self.stemp2) != len(self.timex):
                if self.flagon:  # we don't smooth, but remove the dropouts
                    self.stemp2 = temp2_nogaps
                else:
                    self.stemp2 = self.smooth_list(self.timex,temp2_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)

            #populate delta ET (self.delta1) and delta BT (self.delta2)
            # calculated here to be available for parsepecialeventannotations(). the curve are plotted later.
            if (recomputeAllDeltas or (self.DeltaETflag and self.delta1 == []) or (self.DeltaBTflag and self.delta2 == [])) and not self.flagstart: # during recording we don't recompute the deltas
                cf = aw.qmc.curvefilter #*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                decay_smoothing_p = not aw.qmc.optimalSmoothing or sampling or aw.qmc.flagon
                t1 = self.smooth_list(self.timex,temp1_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
                t2 = self.smooth_list(self.timex,temp2_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
                # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                if aw.qmc.timeindex[0]>-1:
                    RoR_start = min(aw.qmc.timeindex[0]+10, len(self.timex)-1)
                else:
                    RoR_start = -1
                self.delta1, self.delta2 = self.recomputeDeltas(self.timex,RoR_start,aw.qmc.timeindex[6],t1,t2,optimalSmoothing=not decay_smoothing_p,timex_lin=timex_lin)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' smoothETBT() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def smoothETBTBkgnd(self,recomputeAllDeltas,decay_smoothing_p):
        try:
            if recomputeAllDeltas or (self.DeltaETBflag and self.delta1B == []) or (self.DeltaBTBflag and self.delta2B == []):

                # we resample the temperatures to regular interval timestamps
                if self.timeB is not None and self.timeB:
                    timeB_lin = numpy.linspace(self.timeB[0],self.timeB[-1],len(self.timeB))
                else:
                    timeB_lin = None

                # we populate temporary smoothed ET/BT data arrays
                cf = aw.qmc.curvefilter #*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                st1 = self.smooth_list(self.timeB,fill_gaps(self.temp1B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
                st2 = self.smooth_list(self.timeB,fill_gaps(self.temp2B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
                # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                if aw.qmc.timeindexB[0]>-1:
                    RoRstart = min(aw.qmc.timeindexB[0]+10, len(self.timeB)-1)
                else:
                    RoRstart = -1
                if aw.qmc.background_profile_sampling_interval is None:
                    dsET = None
                else:
                    dsET = max(1,int(round(aw.qmc.deltaETspan / aw.qmc.background_profile_sampling_interval)))
                if aw.qmc.background_profile_sampling_interval is None:
                    dsBT = None
                else:
                    dsBT = max(1,int(round(aw.qmc.deltaBTspan / aw.qmc.background_profile_sampling_interval)))
                self.delta1B, self.delta2B = self.recomputeDeltas(self.timeB,RoRstart,aw.qmc.timeindexB[6],st1,st2,optimalSmoothing=not decay_smoothing_p,timex_lin=timeB_lin,deltaETsamples=dsET,deltaBTsamples=dsBT)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' smmothETBTBkgnd() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def twoAxisMode(self):
        return (self.DeltaETflag or self.DeltaBTflag or
                    (self.background and self.backgroundprofile is not None and (self.DeltaETBflag or self.DeltaBTBflag)))

    #Redraws data
    # if recomputeAllDeltas, the delta arrays; if smooth the smoothed line arrays are recomputed (incl. those of the background curves)
    def redraw(self, recomputeAllDeltas=True, smooth=True, sampling=False, takelock=True, forceRenewAxis=False):
        if aw.qmc.designerflag:
            aw.qmc.redrawdesigner()
        elif bool(aw.comparator):
            aw.comparator.redraw()
            aw.qpc.redraw_phases()
        else:
            try:
                #### lock shared resources   ####
                if takelock:
                    aw.qmc.profileDataSemaphore.acquire(1)
                try:
                    # prevent interleaving of updateBackground() and redraw()
                    aw.qmc.updateBackgroundSemaphore.acquire(1)

                    if self.flagon:
                        # on redraw during recording we reset the linecounts to avoid issues with projection lines
                        self.resetlines()

                    decay_smoothing_p = (not aw.qmc.optimalSmoothing) or sampling or aw.qmc.flagon

                    rcParams['path.effects'] = []
                    if aw.qmc.graphstyle == 1:
                        scale = 1
                    else:
                        scale = 0
                    length = 700 # 100 (128 the default)
                    randomness = 12 # 2 (16 default)
                    rcParams['path.sketch'] = (scale, length, randomness)

                    rcParams['axes.linewidth'] = 0.8 # 1.5
                    rcParams['xtick.major.size'] = 6 # 8
                    rcParams['xtick.major.width'] = 1
    #                rcParams['xtick.major.pad'] = 5
                    rcParams['xtick.minor.width'] = 0.8

                    rcParams['ytick.major.size'] = 4 # 8
                    rcParams['ytick.major.width'] = 1
    #                rcParams['ytick.major.pad'] = 5
                    rcParams['ytick.minor.width'] = 1

                    rcParams['xtick.color'] = self.palette['xlabel']
                    rcParams['ytick.color'] = self.palette['ylabel']

                    #rcParams['text.antialiased'] = True

                    if forceRenewAxis:
                        self.fig.clf()
                    if self.ax is None or forceRenewAxis:
                        self.ax = self.fig.add_subplot(111,facecolor=self.palette['background'])
                    if self.delta_ax is None or forceRenewAxis:
                        self.delta_ax = self.ax.twinx()

                    # instead to remove and regenerate the axis object (we just clear and reuse it)

                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.ax.clear()
                    self.ax.set_facecolor(self.palette['background'])
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.delta_ax.clear()
                    self.ax.set_yticks([])
                    self.ax.set_xticks([])
                    self.delta_ax.set_yticks([])
                    self.delta_ax.set_xticks([])

                    self.ax.set_ylim(self.ylimit_min, self.ylimit)
                    self.ax.set_autoscale_on(False)

                    prop = aw.mpl_fontproperties.copy()
                    prop.set_size('small')
                    fontprop_small = aw.mpl_fontproperties.copy()
                    fontprop_small.set_size('xx-small')

                    grid_axis = None
                    if self.temp_grid and self.time_grid:
                        grid_axis = 'both'
                    elif self.temp_grid:
                        grid_axis = 'y'
                    elif self.time_grid:
                        grid_axis = 'x'
                    if grid_axis is not None:
                        self.ax.grid(True,axis=grid_axis,color=self.palette['grid'],linestyle=self.gridstyles[self.gridlinestyle],linewidth=self.gridthickness,alpha=self.gridalpha,sketch_params=0,path_effects=[])

                    if aw.qmc.flagstart and not aw.qmc.title_show_always:
                        self.setProfileTitle('')
                    else:
                        self.setProfileTitle(self.title)

                    # extra event names with substitution of event names applied
                    extraname1_subst = aw.qmc.extraname1[:]
                    extraname2_subst = aw.qmc.extraname2[:]
                    for i in range(len(aw.qmc.extratimex)):
                        try:
                            extraname1_subst[i] = extraname1_subst[i].format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
                        except Exception: # pylint: disable=broad-except
                            pass
                        try:
                            extraname2_subst[i] = extraname2_subst[i].format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
                        except Exception: # pylint: disable=broad-except
                            pass

                    if aw.qmc.flagstart or self.ygrid == 0:
                        y_label = self.ax.set_ylabel('')
                    else:
                        y_label = self.ax.set_ylabel(self.mode,color=self.palette['ylabel'],rotation=0,labelpad=10,
                                fontsize='medium',
                                fontfamily=prop.get_family())
                    if aw.qmc.flagstart or self.xgrid == 0:
                        self.set_xlabel('')
                    else:
                        self.set_xlabel(aw.arabicReshape(QApplication.translate('Label', 'min','abbrev. of minutes')))

                    try:
                        y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                    except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                        pass

                    two_ax_mode = (self.twoAxisMode() or
                        any(aw.extraDelta1[:len(self.extratimex)]) or
                        any(aw.extraDelta2[:len(self.extratimex)]))

                    titleB = ''
                    if not ((aw.qmc.flagstart and not aw.qmc.title_show_always) or self.title is None or self.title.strip() == ''):
                        if self.backgroundprofile != None:
                            if self.roastbatchnrB == 0:
                                titleB = self.titleB
                            else:
                                titleB = f'{self.roastbatchprefixB}{self.roastbatchnrB} {self.titleB}'
                        elif __release_sponsor_domain__:
                            sponsor = QApplication.translate('About','sponsored by {}').format(__release_sponsor_domain__)
                            titleB = f'\n{sponsor}'

                    if aw.qmc.flagon or sampling:
                        tick_dir = 'in'
                    else:
                        tick_dir = 'inout'
                    self.ax.tick_params(\
                        axis='x',           # changes apply to the x-axis
                        which='both',       # both major and minor ticks are affected
                        bottom=True,        # ticks along the bottom edge are on
                        top=False,          # ticks along the top edge are off
                        direction=tick_dir,
                        labelbottom=True)   # labels along the bottom edge are on
                    self.ax.tick_params(\
                        axis='y',           # changes apply to the y-axis
                        which='both',       # both major and minor ticks are affected
                        right=False,
                        bottom=True,        # ticks along the bottom edge are on
                        top=False,          # ticks along the top edge are off
                        direction=tick_dir,
                        labelbottom=True)   # labels along the bottom edge are on

                    # format temperature as int, not float in the cursor position coordinate indicator
                    self.ax.fmt_ydata = self.fmt_data
                    self.ax.fmt_xdata = self.fmt_timedata

                    self.ax.set_zorder(self.delta_ax.get_zorder()+1) # put ax in front of delta_ax (which remains empty!)
                    if two_ax_mode:
                        #create a second set of axes in the same position as self.ax
                        self.delta_ax.tick_params(\
                            axis='y',           # changes apply to the x-axis
                            which='both',       # both major and minor ticks are affected
                            left=False,         # ticks along the left edge are off
                            bottom=False,       # ticks along the bottom edge are off
                            top=False,          # ticks along the top edge are off
                            direction='inout', # tick_dir # this does not work as ticks are not drawn at all in ON mode with this!?
                            labelright=True,
                            labelleft=False,
                            labelbottom=False)   # labels along the bottom edge are on

                        self.ax.patch.set_visible(True)
                        if aw.qmc.flagstart or self.zgrid == 0:
                            y_label = self.delta_ax.set_ylabel('')
                        else:
                            y_label = self.delta_ax.set_ylabel(f'{aw.qmc.mode}{aw.arabicReshape("/min")}',
                                color = self.palette['ylabel'],
                                fontsize='medium',
                                fontfamily=prop.get_family()
                                )
                        try:
                            y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                        self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                        if self.zgrid > 0:
                            self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                            self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            for i in self.delta_ax.get_yticklines():
                                i.set_markersize(10)
                            for i in self.delta_ax.yaxis.get_minorticklines():
                                i.set_markersize(5)
                            for label in self.delta_ax.get_yticklabels() :
                                label.set_fontsize('small')
                            if not self.LCDdecimalplaces:
                                self.delta_ax.minorticks_off()

                        # translate y-coordinate from delta into temp range to ensure the cursor position display (x,y) coordinate in the temp axis
                        self.delta_ax.fmt_ydata = self.fmt_data
                        self.delta_ax.fmt_xdata = self.fmt_timedata
                    #put a right tick on the graph
                    else:
                        self.ax.tick_params(\
                            axis='y',
                            which='both',
                            right=False,
                            labelright=False)

                    self.ax.spines['top'].set_color('0.40')
                    self.ax.spines['bottom'].set_color('0.40')
                    self.ax.spines['left'].set_color('0.40')
                    self.ax.spines['right'].set_color('0.40')

                    self.ax.spines.top.set_visible(self.xgrid != 0 and self.ygrid != 0 and self.zgrid != 0)
                    self.ax.spines.bottom.set_visible(self.xgrid != 0)
                    self.ax.spines.left.set_visible(self.ygrid != 0)
                    self.ax.spines.right.set_visible(self.zgrid != 0)

                    self.l_eventtype1dots = None
                    self.l_eventtype2dots = None
                    self.l_eventtype3dots = None
                    self.l_eventtype4dots = None
                    self.l_eteventannos = []
                    self.l_bteventannos = []
                    self.l_eventtype1annos = []
                    self.l_eventtype2annos = []
                    self.l_eventtype3annos = []
                    self.l_eventtype4annos = []
                    self.l_backgroundeventtype1dots = None
                    self.l_backgroundeventtype2dots = None
                    self.l_backgroundeventtype3dots = None
                    self.l_backgroundeventtype4dots = None

                    if aw.qmc.graphstyle:
                        self.ax.spines['left'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['bottom'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['right'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['top'].set_sketch_params(scale, length, randomness)
                    # hide all spines from the delta_ax
    #                self.delta_ax.spines['left'].set_visible(False)
    #                self.delta_ax.spines['bottom'].set_visible(False)
    #                self.delta_ax.spines['right'].set_visible(False)
    #                self.delta_ax.spines['top'].set_visible(False)
                    self.delta_ax.set_frame_on(False) # hide all splines (as the four lines above)

                    if self.ygrid > 0:
                        self.ax.yaxis.set_major_locator(ticker.MultipleLocator(self.ygrid))
                        self.ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                        for i in self.ax.get_yticklines():
                            i.set_markersize(10)
                        for i in self.ax.yaxis.get_minorticklines():
                            i.set_markersize(5)
    #                else: # hide all spines from the ax
    #                    self.ax.spines['left'].set_visible(False)
    #                    self.ax.spines['bottom'].set_visible(False)
    #                    self.ax.spines['right'].set_visible(False)
    #                    self.ax.spines['top'].set_visible(False)

                    #update X ticks, labels, and rotating_colors
                    self.xaxistosm(redraw=False)

                    for label in self.ax.get_xticklabels() :
    # labels not rendered in PDF exports on MPL 3.4 if fontproperties are set:
    #                    label.set_fontproperties(prop)
                        label.set_fontsize('small')
                    for label in self.ax.get_yticklabels() :
    # labels not rendered in PDF exports on MPL 3.4 if fontproperties are set:
    #                    label.set_fontproperties(prop)
                        label.set_fontsize('small')

                    rcParams['path.sketch'] = (0,0,0)
                    trans = transforms.blended_transform_factory(self.ax.transAxes,self.ax.transData)

                    #draw water marks for dry phase region, mid phase region, and finish phase region
                    if aw.qmc.watermarksflag:
                        rect1 = patches.Rectangle((0,self.phases[0]), width=1, height=(self.phases[1]-self.phases[0]),
                                                  transform=trans, color=self.palette['rect1'],alpha=0.15)
                        rect2 = patches.Rectangle((0,self.phases[1]), width=1, height=(self.phases[2]-self.phases[1]),
                                                  transform=trans, color=self.palette['rect2'],alpha=0.15)
                        rect3 = patches.Rectangle((0,self.phases[2]), width=1, height=(self.phases[3] - self.phases[2]),
                                                  transform=trans, color=self.palette['rect3'],alpha=0.15)
                        self.ax.add_patch(rect1)
                        self.ax.add_patch(rect2)
                        self.ax.add_patch(rect3)

                    #if self.eventsGraphflag == 0 then that means don't plot event bars

                    if self.eventsGraphflag == 1: #plot event bars by type
                        # make blended transformations to help identify EVENT types
                        if self.mode == 'C':
                            step = 5
                            start = 20
                        else:
                            step = 10
                            start = 60
                        jump = 20
                        for i in range(4):
                            if aw.qmc.showEtypes[3-i]:
                                rectEvent = patches.Rectangle((0,self.phases[0]-start-jump), width=1, height = step, transform=trans, color=self.palette['rect5'],alpha=.15)
                                self.ax.add_patch(rectEvent)
                            if self.mode == 'C':
                                jump -= 10
                            else:
                                jump -= 20

                    #plot events bars by value
                    elif self.eventsGraphflag in [2,3,4]: # 2: step lines, 3: step+, 4: combo
                        # make blended transformations to help identify EVENT types
                        if self.clampEvents:
                            top = 100
                            bot = 0
                        else:
                            if self.step100temp is None:
                                top = self.phases[0]
                            else:
                                top = self.step100temp
                            bot = self.ylimit_min
                        step = (top-bot)/10
                        start = top - bot
                        small_step = step/10 # as we have 100 items
                        jump = 0

                        for j in range(110):
                            i = int(j/10)
                            barposition = top - start - jump
                            if i == j/10.:
                                c1 = 'rect5'
                                c2 = 'background'
                                if i == 0:
                                    color = self.palette[c1] #self.palette["rect3"] # brown
                                elif i%2:
                                    color = self.palette[c2] #self.palette["rect2"] # orange # the uneven ones
                                else:
                                    color = self.palette[c1] #self.palette["rect1"] # green # the even ones
                                if (i != 10): # don't draw the first and the last bar in clamp mode
                                    rectEvent = patches.Rectangle((0,barposition), width=1, height = step, transform=trans, color=color,alpha=.15)
                                    self.ax.add_patch(rectEvent)
                            self.eventpositionbars[j] = barposition
                            jump -= small_step

                    rcParams['path.sketch'] = (scale, length, randomness)

                    #check BACKGROUND flag
                    if self.background and self.backgroundprofile is not None:
                        if smooth:
                            # re-smooth background curves
                            tb = self.timeB
                            t1 = self.temp1B
                            t2 = self.temp2B
                            if tb is not None and tb:
                                tb_lin = numpy.linspace(tb[0],tb[-1],len(tb))
                            else:
                                tb_lin = None
                            self.stemp1B = self.smooth_list(tb,fill_gaps(t1),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)
                            self.stemp2B = self.smooth_list(tb,fill_gaps(t2),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)

                        self.l_background_annotations = []
                        #check to see if there is both a profile loaded and a background loaded
                        if self.backmoveflag:
                            self.timealign(redraw=False,recompute=False)

                        bcharge_idx = 0
                        if self.timeindexB[0] > -1:
                            bcharge_idx = self.timeindexB[0]
                        bdrop_idx = len(self.timeB)-1
                        if self.timeindexB[6] > 0:
                            bdrop_idx = self.timeindexB[6]

                        #draw one extra device on background stemp1BX
                        if aw.qmc.xtcurveidx > 0:
                            idx3 = aw.qmc.xtcurveidx - 1
                            n3 = idx3 // 2
                            if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                                if smooth:
                                    # re-smooth the extra background curve
                                    tx = self.extratimexB[n3]
                                    if tx is not None and tx:
                                        tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                                    else:
                                        tx_lin = None
                                if aw.qmc.xtcurveidx % 2:
                                    if aw.qmc.temp1Bdelta[n3]:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if smooth:
                                        stemp3B = self.smooth_list(tx,fill_gaps(self.temp1BX[n3]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                    else:
                                        stemp3B = self.stemp1BX[n3]
                                else:
                                    if aw.qmc.temp2Bdelta[n3]:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if smooth:
                                        stemp3B = self.smooth_list(tx,fill_gaps(self.temp2BX[n3]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                    else:
                                        stemp3B = self.stemp2BX[n3]
                                if not self.backgroundShowFullflag:
                                    if not self.autotimex or self.autotimexMode == 0:
                                        stemp3B = numpy.concatenate((
                                            numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                            stemp3B[bcharge_idx:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                    else:
                                        stemp3B = numpy.concatenate((
                                            stemp3B[0:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                try:
                                    if self.l_back3 is not None:
                                        self.l_back3.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                # don't draw -1:
                                stemp3B = numpy.array(stemp3B, dtype=numpy.double)
                                self.l_back3, = self.ax.plot(self.extratimexB[n3], stemp3B, markersize=self.XTbackmarkersize,marker=self.XTbackmarker,
                                                            sketch_params=None,path_effects=[],transform=trans,
                                                            linewidth=self.XTbacklinewidth,linestyle=self.XTbacklinestyle,drawstyle=self.XTbackdrawstyle,color=self.backgroundxtcolor,
                                                            alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundXT')))
                        if aw.qmc.ytcurveidx > 0:
                            idx4 = aw.qmc.ytcurveidx - 1
                            n4 = idx4 // 2
                            if len(self.stemp1BX) > n4 and len(self.stemp2BX) > n4 and len(self.extratimexB) > n4:
                                if smooth:
                                    # re-smooth the extra background curve
                                    tx = self.extratimexB[n4]
                                    if tx is not None and tx:
                                        tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                                    else:
                                        tx_lin = None
                                if aw.qmc.ytcurveidx % 2:
                                    if aw.qmc.temp1Bdelta[n4]:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if smooth:
                                        stemp4B = self.smooth_list(tx,fill_gaps(self.temp1BX[n4]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                    else:
                                        stemp4B = self.stemp1BX[n4]
                                else:
                                    if aw.qmc.temp2Bdelta[n4]:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if smooth:
                                        stemp4B = self.smooth_list(tx,fill_gaps(self.temp2BX[n4]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                    else:
                                        stemp4B = self.stemp2BX[n4]
                                if not self.backgroundShowFullflag:
                                    if not self.autotimex or self.autotimexMode == 0:
                                        stemp4B = numpy.concatenate((
                                            numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                            stemp4B[bcharge_idx:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                    else:
                                        stemp4B = numpy.concatenate((
                                            stemp4B[0:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                try:
                                    if self.l_back4 is not None:
                                        self.l_back4.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                # don't draw -1:
                                stemp4B = numpy.array(stemp4B, dtype=numpy.double)
                                self.l_back4, = self.ax.plot(self.extratimexB[n4], stemp4B, markersize=self.YTbackmarkersize,marker=self.YTbackmarker,
                                                            sketch_params=None,path_effects=[],transform=trans,
                                                            linewidth=self.YTbacklinewidth,linestyle=self.YTbacklinestyle,drawstyle=self.YTbackdrawstyle,color=self.backgroundytcolor,
                                                            alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundYT')))


                        #draw background
                        if aw.qmc.backgroundETcurve:
                            if self.backgroundShowFullflag:
                                temp_etb = self.stemp1B
                            else:
                                if not self.autotimex or self.autotimexMode == 0:
                                    # only draw background curve from CHARGE to DROP
                                    temp_etb = numpy.concatenate((
                                        numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                        self.stemp1B[bcharge_idx:bdrop_idx+1],
                                        numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    temp_etb = numpy.concatenate((
                                        self.stemp1B[0:bdrop_idx+1],
                                        numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                        else:
                            temp_etb = numpy.full(len(self.timeB), numpy.nan, dtype=numpy.double)
                        try:
                            if self.l_back1 is not None:
                                self.l_back1.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                        # don't draw -1:
                        temp_etb = [r if r !=-1 else None for r in temp_etb]
                        self.l_back1, = self.ax.plot(self.timeB,temp_etb,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                    sketch_params=None,path_effects=[],
                                                    linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                    alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundET')))
                        if aw.qmc.backgroundBTcurve:
                            if self.backgroundShowFullflag:
                                temp_btb = self.stemp2B
                            else:
                                if not self.autotimex or self.autotimexMode == 0:
                                    # only draw background curve from CHARGE to DROP
                                    temp_btb = numpy.concatenate((
                                        numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                        self.stemp2B[bcharge_idx:bdrop_idx+1],
                                        numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    temp_btb = numpy.concatenate((
                                        self.stemp2B[0:bdrop_idx+1],
                                        numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))

                        else:
                            temp_btb = numpy.full(len(self.timeB), numpy.nan, dtype=numpy.double)
                        try:
                            if self.l_back2 is not None:
                                self.l_back2.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                        # don't draw -1:
                        temp_btb = [r if r !=-1 else None for r in temp_btb]
                        self.l_back2, = self.ax.plot(self.timeB, temp_btb,markersize=self.BTbackmarkersize,marker=self.BTbackmarker,
                                                    linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                    sketch_params=None,path_effects=[],
                                                    alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundBT')))

                        self.smoothETBTBkgnd(recomputeAllDeltas,decay_smoothing_p)

                        #populate background delta ET (self.delta1B) and delta BT (self.delta2B)
                        if self.DeltaETBflag or self.DeltaBTBflag:
                            ##### DeltaETB,DeltaBTB curves
                            if self.delta_ax:
                                trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                                if self.DeltaETBflag and len(self.timeB) == len(self.delta1B):
                                    try:
                                        if self.l_delta1B is not None:
                                            self.l_delta1B.remove()
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    self.l_delta1B, = self.ax.plot(
                                        self.timeB,
                                        self.delta1B,
                                        transform=trans,
                                        markersize=self.ETBdeltamarkersize,
                                        sketch_params=None,path_effects=[],
                                        marker=self.ETBdeltamarker,
                                        linewidth=self.ETBdeltalinewidth,
                                        linestyle=self.ETBdeltalinestyle,
                                        drawstyle=self.ETBdeltadrawstyle,
                                        color=self.backgrounddeltaetcolor,
                                        alpha=self.backgroundalpha,
                                        label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundDeltaET')))
                                if self.DeltaBTBflag and len(self.timeB) == len(self.delta2B):
                                    try:
                                        if self.l_delta2B is not None:
                                            self.l_delta2B.remove()
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    self.l_delta2B, = self.ax.plot(
                                        self.timeB,
                                        self.delta2B,
                                        transform=trans,
                                        markersize=self.BTBdeltamarkersize,
                                        sketch_params=None,path_effects=[],
                                        marker=self.BTBdeltamarker,
                                        linewidth=self.BTBdeltalinewidth,
                                        linestyle=self.BTBdeltalinestyle,
                                        drawstyle=self.BTBdeltadrawstyle,
                                        color=self.backgrounddeltabtcolor,
                                        alpha=self.backgroundalpha,
                                        label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundDeltaBT')))
                        #check backgroundevents flag
                        if self.backgroundeventsflag:
                            if self.mode == 'F':
                                height = 50
                            else:
                                height = 20

                            for p in range(len(self.backgroundEvents)):
                                if self.eventsGraphflag not in [2,4] or self.backgroundEtypes[p] > 3:
                                    event_idx = self.backgroundEvents[p]
                                    if not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx):
                                        continue
                                    if self.backgroundEtypes[p] < 4:
                                        st1 = f'{self.Betypesf(self.backgroundEtypes[p])[0]}{self.eventsvaluesShort(self.backgroundEvalues[p])}'
                                    else:
                                        st1 = self.backgroundEStrings[p].strip()[:aw.qmc.eventslabelschars]
                                        if len(st1) == 0:
                                            st1 = 'E'
                                    # plot events on BT when showeventsonbt is true
                                    if not aw.qmc.showeventsonbt and self.temp1B[event_idx] > self.temp2B[event_idx]:
                                        temp = self.temp1B[event_idx]
                                    else:
                                        temp = self.temp2B[event_idx]
                                    if not aw.qmc.showEtypes[self.backgroundEtypes[p]]:
                                        continue
                                    anno = self.ax.annotate(st1, xy=(self.timeB[event_idx], temp),path_effects=[],
                                                        xytext=(self.timeB[event_idx], temp+height),
                                                        va='center', ha='center',
                                                        fontsize='x-small',
                                                        color=self.palette['bgeventtext'],
                                                        arrowprops=dict(arrowstyle='wedge',
                                                                        color=self.palette['bgeventmarker'],
                                                                        alpha=self.backgroundalpha),#relpos=(0,0)),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0))
                                    try:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                        pass
                                    self.l_background_annotations.append(anno)
                            #background events by value
                            if self.eventsGraphflag in [2,3,4]: # 2: step, 3: step+, 4: combo
                                self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
                                self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
                                E1b_last = E2b_last = E3b_last = E4b_last = 0  #not really necessary but guarantees that Exb_last is defined
                                E1_CHARGE_B = E2_CHARGE_B = E3_CHARGE_B = E4_CHARGE_B = None # remember event value @CHARGE (or last before CHARGE) to add if not self.backgroundShowFullflag
                                event_pos_offset = self.eventpositionbars[0]
                                event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                                #properties for the event annotation
                                eventannotationprop = aw.mpl_fontproperties.copy()
                                hoffset = 3  #relative to the event dot
                                voffset = 3  #relative to the event dot
                                eventannotationprop.set_size('x-small')
                                self.overlapList = []
                                for i in range(len(self.backgroundEvents)):
                                    event_idx = self.backgroundEvents[i]
                                    tx = self.timeB[event_idx]
                                    pos = max(0,int(round((self.backgroundEvalues[i]-1)*10)))
                                    skip_event = (not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx))
                                    if self.backgroundEtypes[i] == 0 and aw.qmc.showEtypes[0]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and tx < self.timeB[self.timeindexB[0]]):
                                                E1_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E1_CHARGE_B = (E1_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E1backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                        if self.clampEvents:
                                            self.E1backgroundvalues.append(pos)
                                        else:
                                            self.E1backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E1b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[0]:
                                                E1b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i, applyto='background')
                                                temp = self.E1backgroundvalues[-1]
                                                anno = self.ax.annotate(E1b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontsize='x-small',
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno)# , i, E1b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 1 and aw.qmc.showEtypes[1]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and tx < self.timeB[self.timeindexB[0]]):
                                                E2_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E2_CHARGE_B = (E2_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E2backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                        if self.clampEvents:
                                            self.E2backgroundvalues.append(pos)
                                        else:
                                            self.E2backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E2b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[1]:
                                                E2b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i, applyto='background')
                                                temp = self.E2backgroundvalues[-1]
                                                anno = self.ax.annotate(E2b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E2b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 2 and aw.qmc.showEtypes[2]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and tx < self.timeB[self.timeindexB[0]]):
                                                E3_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E3_CHARGE_B = (E3_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E3backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                        if self.clampEvents:
                                            self.E3backgroundvalues.append(pos)
                                        else:
                                            self.E3backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E3b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[2]:
                                                E3b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i, applyto='background')
                                                temp = self.E3backgroundvalues[-1]
                                                anno = self.ax.annotate(E3b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E3b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 3 and aw.qmc.showEtypes[3]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and tx < self.timeB[self.timeindexB[0]]):
                                                E4_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E4_CHARGE_B = (E4_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E4backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                        if self.clampEvents:
                                            self.E4backgroundvalues.append(pos)
                                        else:
                                            self.E4backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E4b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[3]:
                                                E4b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i, applyto='background')
                                                temp = self.E4backgroundvalues[-1]
                                                anno = self.ax.annotate(E4b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E4b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
    #                            every = None
                                if len(self.E1backgroundtimex)>0 and len(self.E1backgroundtimex)==len(self.E1backgroundvalues):
                                    if (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E1b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E1backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E1b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E1backgroundvalues.append(pos)
                                        else:
                                            self.E1backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E1_CHARGE_B is not None and len(self.E1backgroundvalues)>1 and self.E1backgroundvalues[0] != E1_CHARGE_B:
                                        E1xB = [self.timeB[self.timeindexB[0]]] + self.E1backgroundtimex
                                        E1yB = [E1_CHARGE_B] + self.E1backgroundvalues
                                    else:
                                        E1xB = self.E1backgroundtimex
                                        E1yB = self.E1backgroundvalues
                                    self.l_backgroundeventtype1dots, = self.ax.plot(E1xB, E1yB, color=self.EvalueColor[0],
                                                                                marker=(self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[0],
                                                                                picker=True,
                                                                                pickradius=2,
                                                                                #markevery=every,
                                                                                linestyle='-',drawstyle='steps-post',linewidth = self.Evaluelinethickness[0],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(0,True))
                                if len(self.E2backgroundtimex)>0 and len(self.E2backgroundtimex)==len(self.E2backgroundvalues):
                                    if (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E2b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E2backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E2b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E2backgroundvalues.append(pos)
                                        else:
                                            self.E2backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E2_CHARGE_B is not None and len(self.E2backgroundvalues)>1 and self.E2backgroundvalues[0] != E2_CHARGE_B:
                                        E2xB = [self.timeB[self.timeindexB[0]]] + self.E2backgroundtimex
                                        E2yB = [E2_CHARGE_B] + self.E2backgroundvalues
                                    else:
                                        E2xB = self.E2backgroundtimex
                                        E2yB = self.E2backgroundvalues
                                    self.l_backgroundeventtype2dots, = self.ax.plot(E2xB, E2yB, color=self.EvalueColor[1],
                                                                                marker=(self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[1],
                                                                                picker=True,
                                                                                pickradius=2,
                                                                                #markevery=every,
                                                                                linestyle='-',drawstyle='steps-post',linewidth = self.Evaluelinethickness[1],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(1,True))
                                if len(self.E3backgroundtimex)>0 and len(self.E3backgroundtimex)==len(self.E3backgroundvalues):
                                    if (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E3b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E3backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E3b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E3backgroundvalues.append(pos)
                                        else:
                                            self.E3backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E3_CHARGE_B is not None and len(self.E3backgroundvalues)>1 and self.E3backgroundvalues[0] != E3_CHARGE_B:
                                        E3xB = [self.timeB[self.timeindexB[0]]] + self.E3backgroundtimex
                                        E3yB = [E3_CHARGE_B] + self.E3backgroundvalues
                                    else:
                                        E3xB = self.E3backgroundtimex
                                        E3yB = self.E3backgroundvalues
                                    self.l_backgroundeventtype3dots, = self.ax.plot(E3xB, E3yB, color=self.EvalueColor[2],
                                                                                marker=(self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[2],
                                                                                picker=True,
                                                                                pickradius=2,
                                                                                #markevery=every,
                                                                                linestyle='-',drawstyle='steps-post',linewidth = self.Evaluelinethickness[2],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(2,True))
                                if len(self.E4backgroundtimex)>0 and len(self.E4backgroundtimex)==len(self.E4backgroundvalues):
                                    if (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E4b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E4backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E4b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E4backgroundvalues.append(pos)
                                        else:
                                            self.E4backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E4_CHARGE_B is not None and len(self.E4backgroundvalues)>1 and self.E4backgroundvalues[0] != E4_CHARGE_B:
                                        E4xB = [self.timeB[self.timeindexB[0]]] + self.E4backgroundtimex
                                        E4yB = [E4_CHARGE_B] + self.E4backgroundvalues
                                    else:
                                        E4xB = self.E4backgroundtimex
                                        E4yB = self.E4backgroundvalues
                                    self.l_backgroundeventtype4dots, = self.ax.plot(E4xB, E4yB, color=self.EvalueColor[3],
                                                                                marker=(self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[3],
                                                                                picker=True,
                                                                                pickradius=2,
                                                                                #markevery=every,
                                                                                linestyle='-',drawstyle='steps-post',linewidth = self.Evaluelinethickness[3],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(3,True))

                            if len(self.backgroundEvents) > 0:
                                if self.eventsGraphflag == 4:
                                    # we prepare copies of the background Evalues
                                    Bevalues = [self.E1backgroundvalues[:],self.E2backgroundvalues[:],self.E3backgroundvalues[:],self.E4backgroundvalues[:]]
                                for i in range(len(self.backgroundEvents)):
                                    event_idx = self.backgroundEvents[i]
                                    if not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx):
                                        continue
                                    if self.backgroundEtypes[i] == 4 or self.eventsGraphflag in [0,3,4]:
                                        if self.backgroundEtypes[i] < 4 and (not aw.qmc.renderEventsDescr or len(self.backgroundEStrings[i].strip()) == 0):
                                            Betype = self.Betypesf(self.backgroundEtypes[i])
                                            firstletter = str(Betype[0])
                                            secondletter = self.eventsvaluesShort(self.backgroundEvalues[i])
                                            if aw.eventslidertemp[self.backgroundEtypes[i]]:
                                                thirdletter = self.mode # postfix
                                            else:
                                                thirdletter = aw.eventsliderunits[self.backgroundEtypes[i]] # postfix
                                        else:
                                            firstletter = self.backgroundEStrings[i].strip()[:aw.qmc.eventslabelschars]
                                            if firstletter == '':
                                                firstletter = 'E'
                                            secondletter = ''
                                            thirdletter = ''
                                        if self.mode == 'F':
                                            height = 50
                                        else:
                                            height = 20

                                        if self.eventsGraphflag == 4 and self.backgroundEtypes[i] < 4 and aw.qmc.showEtypes[self.backgroundEtypes[i]] and len(Bevalues[self.backgroundEtypes[i]])>0:
                                            Btemp = Bevalues[self.backgroundEtypes[i]][0]
                                            Bevalues[self.backgroundEtypes[i]] = Bevalues[self.backgroundEtypes[i]][1:]
                                        else:
                                            Btemp = None

                                        if Btemp != None and aw.qmc.showEtypes[self.backgroundEtypes[i]]:
                                            if self.backgroundEtypes[i] == 0:
                                                boxstyle = 'roundtooth,pad=0.4'
                                                boxcolor = self.EvalueColor[0]
                                                textcolor = self.EvalueTextColor[0]
                                            elif self.backgroundEtypes[i] == 1:
                                                boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                                boxcolor = self.EvalueColor[1]
                                                textcolor = self.EvalueTextColor[1]
                                            elif self.backgroundEtypes[i] == 2:
                                                boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                                boxcolor = self.EvalueColor[2]
                                                textcolor = self.EvalueTextColor[2]
                                            elif self.backgroundEtypes[i] == 3:
                                                boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                                boxcolor = self.EvalueColor[3]
                                                textcolor = self.EvalueTextColor[3]
                                            elif self.backgroundEtypes[i] == 4:
                                                boxstyle = 'square,pad=0.1'
                                                boxcolor = self.palette['specialeventbox']
                                                textcolor = self.palette['specialeventtext']
                                            if self.eventsGraphflag in [0,3] or self.backgroundEtypes[i] > 3:
                                                anno = self.ax.annotate('f{firstletter}{secondletter}', xy=(self.timeB[int(self.backgroundEvents[i])], Btemp),
                                                             xytext=(self.timeB[int(self.backgroundEvents[i])],Btemp+height),
                                                             alpha=min(aw.qmc.backgroundalpha + 0.1, 1.0),
                                                             color=aw.qmc.palette['bgeventtext'],
                                                             va='center', ha='center',
                                                             arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=aw.qmc.backgroundalpha), # ,relpos=(0,0)
                                                             bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none', alpha=aw.qmc.backgroundalpha),
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                            elif self.eventsGraphflag == 4:
                                                if thirdletter != '':
                                                    firstletter = ''
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timeB[int(self.backgroundEvents[i])], Btemp),
                                                             xytext=(self.timeB[int(self.backgroundEvents[i])],Btemp),
                                                             alpha=min(aw.qmc.backgroundalpha + 0.3, 1.0),
                                                             color=aw.qmc.palette['bgeventtext'],
                                                             va='center', ha='center',
                                                             bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none',
                                                                alpha=min(aw.qmc.backgroundalpha, 1.0)),
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                        #check backgroundDetails flag
                        if self.backgroundDetails:
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            d = d - d/5
                            #if there is a profile loaded with CHARGE, then save time to get the relative time
                            if self.timeindex[0] != -1:   #verify it exists before loading it, otherwise the list could go out of index
                                startB = self.timex[self.timeindex[0]]
                            else:
                                if self.timeindexB[0] > 0:
                                    startB = self.timeB[self.timeindexB[0]]
                                else:
                                    startB = 0
                            try:
                                # background annotations are not draggable
                                aw.qmc.l_background_annotations.extend(self.place_annotations(
                                    -1, # TP_index
                                    d,
                                    self.timeB,
                                    self.timeindexB,
                                    self.temp2B,
                                    self.stemp2B,
                                    startB,
                                    self.timeindex, # timeindex2
                                    TP_time_loaded=self.TP_time_B_loaded,
                                    draggable=True))
                            except Exception: # pylint: disable=broad-except
                                pass

                        #show the analysis results if they exist
    #                    if len(self.analysisresultsstr) > 0:
    #                        aw.analysisShowResults(redraw=False)

                        #END of Background

                    if aw.qmc.patheffects:
                        rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette['background'])]

                    self.handles = []
                    self.labels = []
                    self.legend_lines = []

                    self.smoothETBT(smooth,recomputeAllDeltas,sampling,decay_smoothing_p)

    ## Output Idle Noise StdDev of BT RoR
    #                        try:
    #                            start = aw.qmc.timeindex[0]
    #                            end = aw.qmc.timeindex[6]
    #                            if start == -1:
    #                                start = 0
    #                            start = start + 30 # avoiding the empty begin of heavy smoothed data
    #                            if end == 0:
    #                                end = min(len(self.delta2) -1,100)
    #                            print("ET RoR mean:",numpy.mean([x for x in self.delta1[start:end] if x is not None]))
    #                            print("ET RoR std:",numpy.std([x for x in self.delta1[start:end] if x is not None]))
    #                            print("BT RoR mean:",numpy.mean([x for x in self.delta2[start:end] if x is not None]))
    #                            print("BT RoR std:",numpy.std([x for x in self.delta2[start:end] if x is not None]))
    #                            print("BT mean:",numpy.mean([x for x in self.temp2[start:end] if x is not None]))
    #                            print("BT std:",numpy.std([x for x in self.temp2[start:end] if x is not None]))
    #                            max_BT = numpy.max([x for x in self.temp2[start:end] if x is not None])
    #                            min_BT = numpy.max([x for x in self.temp2[start:end] if x is not None])
    #                            mean_BT = numpy.mean([x for x in self.temp2[start:end] if x is not None])
    #                            print("BT max delta:", max(mean_BT - min_BT,max_BT - mean_BT))
    #                        except Exception as e: # pylint: disable=broad-except
    #                            _log.exception(e)

                    # CHARGE-DROP curve index limits
                    charge_idx = 0
                    if self.timeindex[0] > -1:
                        charge_idx = self.timeindex[0]
                    drop_idx = len(self.timex)-1
                    if self.timeindex[6] > 0:
                        drop_idx = self.timeindex[6]

                    if self.eventsshowflag:
                        Nevents = len(self.specialevents)
                        #three modes of drawing events.
                        # the first mode just places annotations. They are text annotations.
                        # the second mode aligns the events types to a bar height so that they can be visually identified by type. They are text annotations
                        # the third mode plots the events by value. They are not annotations but actual lines.

                        if self.eventsGraphflag == 1 and Nevents:

                            char1 = self.etypes[0][0]
                            char2 = self.etypes[1][0]
                            char3 = self.etypes[2][0]
                            char4 = self.etypes[3][0]

                            if self.mode == 'F':
                                row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                            else:
                                row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}

                            #draw lines of color between events of the same type to help identify areas of events.
                            #count (as length of the list) and collect their times for each different type. Each type will have a different plot height
                            netypes=[[],[],[],[]]
                            for i in range(Nevents):
                                try:
                                    tx = self.timex[self.specialevents[i]]
                                    event_idx = int(self.specialevents[i])

                                    if self.flagstart or self.foregroundShowFullflag or (event_idx >= charge_idx and event_idx <= drop_idx) or (self.autotimex and self.autotimexMode != 0 and event_idx < charge_idx):
                                        if self.specialeventstype[i] == 0 and aw.qmc.showEtypes[0]:
                                            netypes[0].append(tx)
                                        elif self.specialeventstype[i] == 1 and aw.qmc.showEtypes[1]:
                                            netypes[1].append(tx)
                                        elif self.specialeventstype[i] == 2 and aw.qmc.showEtypes[2]:
                                            netypes[2].append(tx)
                                        elif self.specialeventstype[i] == 3 and aw.qmc.showEtypes[3]:
                                            netypes[3].append(tx)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.debug(e)

                            letters = ''.join((char1,char2,char3,char4))   #"NPDF" first letter for each type (None, Power, Damper, Fan)
                            rotating_colors = [self.palette['rect2'],self.palette['rect3']] #rotating rotating_colors
                            for p in range(len(letters)):
                                if len(netypes[p]) > 1:
                                    for i in range(len(netypes[p])-1):
                                        #draw differentiating color bars between events and place then in a different height according with type
                                        rect = patches.Rectangle((netypes[p][i], row[letters[p]]), width = (netypes[p][i+1]-netypes[p][i]), height = step, color = rotating_colors[i%2],alpha=0.5)
                                        self.ax.add_patch(rect)

                            # annotate event
                            for i in range(Nevents):
                                if self.specialeventstype[i] > 3:
                                    # a special event of type "--"
                                    pass
                                elif aw.qmc.showEtypes[self.specialeventstype[i]]:
                                    event_idx = int(self.specialevents[i])
                                    try:
                                        if not(self.flagstart or self.foregroundShowFullflag or (event_idx >= charge_idx and event_idx <= drop_idx) or (self.autotimex and self.autotimexMode != 0 and event_idx < charge_idx)):
                                            continue

                                        firstletter = self.etypes[self.specialeventstype[i]][0]
                                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])

                                        #some times ET is not drawn (ET = 0) when using device NONE
                                        if aw.qmc.ETcurve or aw.qmc.BTcurve:
                                            # plot events on BT when showeventsonbt is true
                                            if aw.qmc.showeventsonbt and aw.qmc.BTcurve:
                                                col = self.palette['bt']
                                                if aw.qmc.flagon:
                                                    temps = self.temp2
                                                else:
                                                    temps = self.stemp2
                                            elif (aw.qmc.ETcurve and self.temp1[event_idx] >= self.temp2[event_idx]) or (not aw.qmc.BTcurve):
                                                col = self.palette['et']
                                                if aw.qmc.flagon:
                                                    temps = self.temp1
                                                else:
                                                    temps = self.stemp1
                                            else:
                                                col = self.palette['bt']
                                                if aw.qmc.flagon:
                                                    temps = self.temp2
                                                else:
                                                    temps = self.stemp2
        #                                    fcolor=self.EvalueColor[self.specialeventstype[i]]
                                            if platf == 'Windows':
                                                vert_offset = 5.0
                                            else:
                                                vert_offset = 2.5
                                            anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                                             xy=(self.timex[event_idx],
                                                             temps[event_idx]),
                                                             xytext=(self.timex[event_idx],row[firstletter] + vert_offset),
                                                             alpha=1.,
                                                             va='center', ha='left',
                                                             bbox=dict(boxstyle='square,pad=0.1', fc=self.palette['specialeventbox'], ec='none'),
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             color=self.palette['specialeventtext'],
                                                             arrowprops=dict(arrowstyle='-',color=col,alpha=0.4,relpos=(0,0)),
                                                             fontsize='xx-small',
                                                             fontproperties=fontprop_small)
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)

                        elif self.eventsGraphflag in [2,3,4]: # in this mode we have to generate the plots even if Nevents=0 to avoid redraw issues resulting from an incorrect number of plot count
                            self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                            self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                            E1_nonempty = E2_nonempty = E3_nonempty = E4_nonempty = False
                            E1_last = E2_last = E3_last = E4_last = 0  #not really necessary but guarantees that Ex_last is defined
                            E1_CHARGE = E2_CHARGE = E3_CHARGE = E4_CHARGE = None # remember event value @CHARGE (or last before CHARGE) to add if not self.foregroundShowFullflag
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            #properties for the event annotations
                            eventannotationprop = aw.mpl_fontproperties.copy()
                            hoffset = 3  #relative to the event dot
                            voffset = 1  #relative to the event dot
                            self.overlapList = []
                            eventannotationprop.set_size('x-small')
                            for i in range(Nevents):
                                pos = max(0,int(round((self.specialeventsvalue[i]-1)*10)))
                                tx = self.timex[self.specialevents[i]]
                                skip_event = ((not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and self.timeindex[0] > -1 and tx < self.timex[self.timeindex[0]]) or
                                            (not self.foregroundShowFullflag and self.timeindex[6] > 0 and tx > self.timex[self.timeindex[6]]))
                                try:
                                    if self.specialeventstype[i] == 0 and aw.qmc.showEtypes[0]:
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and tx < self.timex[self.timeindex[0]]):
                                                E1_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E1_CHARGE = (E1_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E1timex.append(tx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E1values.append(pos)
                                        else:
                                            self.E1values.append((pos*event_pos_factor)+event_pos_offset)
                                        E1_nonempty = True
                                        E1_last = i
                                        try:
                                            if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.specialeventannovisibilities[0]:
                                                E1_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i)
                                                temp = self.E1values[-1]
                                                anno = self.ax.annotate(E1_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype1annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E1_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 1 and aw.qmc.showEtypes[1]:
                                        tx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and tx < self.timex[self.timeindex[0]]):
                                                E2_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E2_CHARGE = (E2_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E2timex.append(tx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E2values.append(pos)
                                        else:
                                            self.E2values.append((pos*event_pos_factor)+event_pos_offset)
                                        E2_nonempty = True
                                        E2_last = i
                                        try:
                                            if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.specialeventannovisibilities[1]:
                                                E2_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i)
                                                temp = self.E2values[-1]
                                                anno = self.ax.annotate(E2_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype2annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E2_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass

                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 2 and aw.qmc.showEtypes[2]:
                                        tx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and tx < self.timex[self.timeindex[0]]):
                                                E3_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E3_CHARGE = (E3_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E3timex.append(tx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E3values.append(pos)
                                        else:
                                            self.E3values.append((pos*event_pos_factor)+event_pos_offset)
                                        E3_nonempty = True
                                        E3_last = i
                                        try:
                                            if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.specialeventannovisibilities[2]:
                                                E3_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i)
                                                temp = self.E3values[-1]
                                                anno = self.ax.annotate(E3_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype3annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E3_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 3 and aw.qmc.showEtypes[3]:
                                        tx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and tx < self.timex[self.timeindex[0]]):
                                                E4_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E4_CHARGE = (E4_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E4timex.append(tx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E4values.append(pos)
                                        else:
                                            self.E4values.append((pos*event_pos_factor)+event_pos_offset)
                                        E4_nonempty = True
                                        E4_last = i
                                        try:
                                            if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.specialeventannovisibilities[3]:
                                                E4_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i)
                                                temp = self.E4values[-1]
                                                anno = self.ax.annotate(E4_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype4annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E4_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                            if len(self.E1timex) > 0 and len(self.E1values) == len(self.E1timex):
                                pos = max(0,int(round((self.specialeventsvalue[E1_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E1_last]]):   #if cool exists and last event was earlier
                                    self.E1timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E1values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E1_last]]):   #if drop exists and last event was earlier
                                    self.E1timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E1values.append(pos) #repeat last event value
                                E1x = self.E1timex
                                E1y = self.E1values
                                if E1_CHARGE is not None and len(E1y)>1 and E1y[0] != E1_CHARGE:
                                    E1x = [self.timex[self.timeindex[0]]] + E1x
                                    E1y = [E1_CHARGE] + E1y
                                ds = 'steps-post'
                            else:
                                E1x = [None]
                                E1y = [None]
                                ds = 'steps-post'
                            try:
                                if self.l_eventtype1dots is not None:
                                    self.l_eventtype1dots.remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_eventtype1dots, = self.ax.plot(E1x, E1y, color=self.EvalueColor[0],
                                                                marker = (self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[0],
                                                                picker=True,
                                                                pickradius=2,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0],label=self.etypesf(0))
                            if len(self.E2timex) > 0 and len(self.E2values) == len(self.E2timex):
                                pos = max(0,int(round((self.specialeventsvalue[E2_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E2_last]]):   #if cool exists and last event was earlier
                                    self.E2timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E2values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E2_last]]):   #if drop exists and last event was earlier
                                    self.E2timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E2values.append(pos) #repeat last event value
                                E2x = self.E2timex
                                E2y = self.E2values
                                if E2_CHARGE is not None and len(E2y)>1 and E2y[0] != E2_CHARGE:
                                    E2x = [self.timex[self.timeindex[0]]] + E2x
                                    E2y = [E2_CHARGE] + E2y
                                ds = 'steps-post'
                            else:
                                E2x = [None]
                                E2y = [None]
                                ds = 'steps-post'
                            try:
                                if self.l_eventtype2dots is not None:
                                    self.l_eventtype2dots.remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_eventtype2dots, = self.ax.plot(E2x, E2y, color=self.EvalueColor[1],
                                                                marker = (self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[1],
                                                                picker=True,
                                                                pickradius=2,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1],label=self.etypesf(1))
                            if len(self.E3timex) > 0 and len(self.E3values) == len(self.E3timex):
                                pos = max(0,int(round((self.specialeventsvalue[E3_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E3_last]]):   #if cool exists and last event was earlier
                                    self.E3timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E3values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E3_last]]):   #if drop exists and last event was earlier
                                    self.E3timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E3values.append(pos) #repeat last event value
                                E3x = self.E3timex
                                E3y = self.E3values
                                if E3_CHARGE is not None and len(E3y)>1 and E3y[0] != E3_CHARGE:
                                    E3x = [self.timex[self.timeindex[0]]] + E3x
                                    E3y = [E3_CHARGE] + E3y
                                ds = 'steps-post'
                            else:
                                E3x = [None]
                                E3y = [None]
                                ds = 'steps-post'
                            try:
                                if self.l_eventtype3dots is not None:
                                    self.l_eventtype3dots.remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_eventtype3dots, = self.ax.plot(E3x, E3y, color=self.EvalueColor[2],
                                                                marker = (self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[2],
                                                                picker=True,
                                                                pickradius=2,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2],label=self.etypesf(2))
                            if len(self.E4timex) > 0 and len(self.E4values) == len(self.E4timex):
                                pos = max(0,int(round((self.specialeventsvalue[E4_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E4_last]]):   #if cool exists and last event was earlier
                                    self.E4timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E4values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E4_last]]):   #if drop exists and last event was earlier
                                    self.E4timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E4values.append(pos) #repeat last event value
                                E4x = self.E4timex
                                E4y = self.E4values
                                if E4_CHARGE is not None and len(E4y)>1 and E4y[0] != E4_CHARGE:
                                    E4x = [self.timex[self.timeindex[0]]] + E4x
                                    E4y = [E4_CHARGE] + E4y
                                ds = 'steps-post'
                            else:
                                E4x = [None]
                                E4y = [None]
                                ds = 'steps-post'
                            try:
                                if self.l_eventtype4dots is not None:
                                    self.l_eventtype4dots.remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_eventtype4dots, = self.ax.plot(E4x, E4y, color=self.EvalueColor[3],
                                                                marker = (self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[3],
                                                                picker=True,
                                                                pickradius=2,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3],label=self.etypesf(3))
                        if Nevents:
                            if self.eventsGraphflag == 4:
                                # we prepare copies of the Evalues
                                evalues = [self.E1values[:],self.E2values[:],self.E3values[:],self.E4values[:]]
                            for i in range(Nevents):
                                event_idx = int(self.specialevents[i])
                                try:
                                    if self.specialeventstype[i] == 4 or self.eventsGraphflag in [0,3,4]:
                                        if self.specialeventstype[i] < 4 and (not aw.qmc.renderEventsDescr or len(self.specialeventsStrings[i].strip()) == 0):
                                            etype = self.etypesf(self.specialeventstype[i])
                                            firstletter = str(etype[0])
                                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                                            if aw.eventslidertemp[self.specialeventstype[i]]:
                                                thirdletter = self.mode # postfix
                                            else:
                                                thirdletter = aw.eventsliderunits[self.specialeventstype[i]] # postfix
                                        else:
                                            firstletter = self.specialeventsStrings[i].strip()[:aw.qmc.eventslabelschars]
                                            if firstletter == '':
                                                firstletter = 'E'
                                            secondletter = ''
                                            thirdletter = ''
                                        if self.mode == 'F':
                                            height = 50
                                        else:
                                            height = 20

                                        #some times ET is not drawn (ET = 0) when using device NONE
                                        # plot events on BT when showeventsonbt is true
                                        if not aw.qmc.showeventsonbt and self.temp1[event_idx] > self.temp2[event_idx] and aw.qmc.ETcurve:
                                            if aw.qmc.flagon:
                                                temp = self.temp1[event_idx]
                                            else:
                                                temp = self.stemp1[event_idx]
                                        elif aw.qmc.BTcurve:
                                            if aw.qmc.flagon:
                                                temp = self.temp2[event_idx]
                                            else:
                                                temp = self.stemp2[event_idx]
                                        else:
                                            temp = None

                                        # plot events on BT when showeventsonbt is true
                                        if aw.qmc.showeventsonbt and temp != None and aw.qmc.BTcurve:
                                            if aw.qmc.flagon:
                                                temp = self.temp2[event_idx]
                                            else:
                                                temp = self.stemp2[event_idx]

                                        if not self.flagstart and not self.foregroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < charge_idx) or event_idx > drop_idx):
                                            continue

                                        # combo events
                                        if self.eventsGraphflag == 4 and self.specialeventstype[i] < 4 and aw.qmc.showEtypes[self.specialeventstype[i]] and len(evalues[self.specialeventstype[i]])>0:
                                            temp = evalues[self.specialeventstype[i]][0]
                                            evalues[self.specialeventstype[i]] = evalues[self.specialeventstype[i]][1:]

                                        if temp != None and aw.qmc.showEtypes[self.specialeventstype[i]]:
                                            if self.specialeventstype[i] == 0:
                                                boxstyle = 'roundtooth,pad=0.4'
                                                boxcolor = self.EvalueColor[0]
                                                textcolor = self.EvalueTextColor[0]
                                            elif self.specialeventstype[i] == 1:
                                                boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                                boxcolor = self.EvalueColor[1]
                                                textcolor = self.EvalueTextColor[1]
                                            elif self.specialeventstype[i] == 2:
                                                boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                                boxcolor = self.EvalueColor[2]
                                                textcolor = self.EvalueTextColor[2]
                                            elif self.specialeventstype[i] == 3:
                                                boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                                boxcolor = self.EvalueColor[3]
                                                textcolor = self.EvalueTextColor[3]
                                            elif self.specialeventstype[i] == 4:
                                                boxstyle = 'square,pad=0.1'
                                                boxcolor = self.palette['specialeventbox']
                                                textcolor = self.palette['specialeventtext']
                                            if self.eventsGraphflag in [0,3] or self.specialeventstype[i] > 3:
                                                if i in self.l_event_flags_pos_dict:
                                                    xytext = self.l_event_flags_pos_dict[i]
                                                elif i in self.l_event_flags_dict:
                                                    xytext = self.l_event_flags_dict[i].xyann
                                                else:
                                                    xytext = (self.timex[event_idx],temp+height)
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[event_idx], temp),
                                                             xytext=xytext,
                                                             alpha=0.9,
                                                             color=textcolor,
                                                             va='center', ha='center',
                                                             arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=0.4), # ,relpos=(0,0)
                                                             bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                    anno.draggable(use_blit=True)
                                                    anno.set_picker(aw.draggable_text_box_picker)
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                # register draggable flag annotation to be re-created after re-positioning on redraw
                                                self.l_event_flags_dict[i] = anno
                                                if not aw.qmc.showeventsonbt and aw.qmc.ETcurve:
                                                    self.l_eteventannos.append(anno)
                                                else:
                                                    self.l_bteventannos.append(anno)
                                            elif self.eventsGraphflag == 4:
                                                if thirdletter != '':
                                                    firstletter = ''
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timex[event_idx], temp),
                                                             xytext=(self.timex[event_idx],temp),
                                                             alpha=0.9,
                                                             color=textcolor,
                                                             va='center', ha='center',
                                                             bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                if self.specialeventstype[i] == 0:
                                                    self.l_eventtype1annos.append(anno)
                                                elif self.specialeventstype[i] == 1:
                                                    self.l_eventtype2annos.append(anno)
                                                elif self.specialeventstype[i] == 2:
                                                    self.l_eventtype3annos.append(anno)
                                                elif self.specialeventstype[i] == 3:
                                                    self.l_eventtype4annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                except Exception as e:
                                    _log.exception(e) # pylint: disable=broad-except

                    #plot delta ET (self.delta1) and delta BT (self.delta2)
                    if self.DeltaETflag or self.DeltaBTflag:
                        ##### DeltaET,DeltaBT curves
                        if self.delta_ax:
                            trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                            # if not recording or if during recording CHARGE was set already
                            if ((not self.flagon or self.timeindex[0] > 1) and
                                    len(self.timex) == len(self.delta1) and len(self.timex) == len(self.delta2) and len(self.timex)>charge_idx+2):
                                # to avoid drawing of RoR artifacts directly after CHARGE we skip the first two samples after CHARGE before starting to draw
                                if aw.qmc.swapdeltalcds:
                                    self.drawDeltaET(trans,charge_idx+2,drop_idx)
                                    self.drawDeltaBT(trans,charge_idx+2,drop_idx)
                                else:
                                    self.drawDeltaBT(trans,charge_idx+2,drop_idx)
                                    self.drawDeltaET(trans,charge_idx+2,drop_idx)
                            else:
                                # instead of drawing we still have to establish the self.ax artists to keep the linecount correct!
                                self.drawDeltaET(trans,0,0)
                                self.drawDeltaBT(trans,0,0)

                    if self.delta_ax is not None and two_ax_mode:
                        aw.autoAdjustAxis(timex=False)
                        self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                        if self.zgrid > 0:
                            self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                            self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            for i in self.delta_ax.get_yticklines():
                                i.set_markersize(10)
                            for i in self.delta_ax.yaxis.get_minorticklines():
                                i.set_markersize(5)
                            for label in self.delta_ax.get_yticklabels() :
                                label.set_fontsize('small')
                            if not self.LCDdecimalplaces:
                                self.delta_ax.minorticks_off()

                    ##### Extra devices-curves
                    for l in self.extratemp1lines + self.extratemp2lines:
                        try:
                            if l is not None:
                                l.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                    self.extratemp1lines,self.extratemp2lines = [],[]
                    for i in range(min(
                            len(self.extratimex),
                            len(self.extratemp1),
                            len(self.extradevicecolor1),
                            len(self.extraname1),
                            len(self.extratemp2),
                            len(self.extradevicecolor2),
                            len(self.extraname2))):
                        if self.extratimex[i] is not None and self.extratimex[i] and len(self.extratimex[i])>1:
                            timexi_lin = numpy.linspace(self.extratimex[i][0],self.extratimex[i][-1],len(self.extratimex[i]))
                        else:
                            timexi_lin = None
                        try:
                            if aw.extraCurveVisibility1[i]:
                                if not aw.qmc.flagon and (smooth or len(self.extrastemp1[i]) != len(self.extratimex[i])):
                                    self.extrastemp1[i] = self.smooth_list(self.extratimex[i],fill_gaps(self.extratemp1[i]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timexi_lin)
                                else: # we don't smooth, but remove the dropouts
                                    self.extrastemp1[i] = fill_gaps(self.extratemp1[i])
                                if aw.extraDelta1[i]:
                                    trans = self.delta_ax.transData
                                else:
                                    trans = self.ax.transData
                                if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and len(self.extrastemp1[i]) > 0:
                                    visible_extratemp1 = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        self.extrastemp1[i][charge_idx:drop_idx+1],
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and len(self.extrastemp1[i]) > 0:
                                    visible_extratemp1 = numpy.concatenate((
                                        self.extrastemp1[i][0:drop_idx+1],
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    visible_extratemp1 = numpy.array(self.extrastemp1[i], dtype=numpy.double)
                                # first draw the fill if any, but not during recording!
                                if not aw.qmc.flagstart and aw.extraFill1[i] > 0:
                                    self.ax.fill_between(self.extratimex[i], 0, visible_extratemp1,transform=trans,color=self.extradevicecolor1[i],alpha=aw.extraFill1[i]/100.,sketch_params=None)
                                self.extratemp1lines.append(self.ax.plot(self.extratimex[i],visible_extratemp1,transform=trans,color=self.extradevicecolor1[i],
                                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths1[i]+aw.qmc.patheffects,foreground=self.palette['background'])],
                                    markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],
                                    drawstyle=self.extradrawstyles1[i],label=extraname1_subst[i])[0])
                        except Exception as ex: # pylint: disable=broad-except
                            _log.exception(ex)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                        try:
                            if aw.extraCurveVisibility2[i]:
                                if not aw.qmc.flagon and (smooth or len(self.extrastemp2[i]) != len(self.extratimex[i])):
                                    self.extrastemp2[i] = self.smooth_list(self.extratimex[i],fill_gaps(self.extratemp2[i]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timexi_lin)
                                else:
                                    self.extrastemp2[i] = fill_gaps(self.extratemp2[i])
                                if aw.extraDelta2[i]:
                                    trans = self.delta_ax.transData
                                else:
                                    trans = self.ax.transData
                                if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and len(self.extrastemp2[i]) > 0:
                                    visible_extratemp2 = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        self.extrastemp2[i][charge_idx:drop_idx+1],
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and len(self.extrastemp2[i]) > 0:
                                    visible_extratemp2 = numpy.concatenate((
                                        self.extrastemp2[i][0:drop_idx+1],
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    visible_extratemp2 = self.extrastemp2[i]
                                    visible_extratemp2 = numpy.array(self.extrastemp2[i], dtype=numpy.double)
                                # first draw the fill if any
                                if not aw.qmc.flagstart and aw.extraFill2[i] > 0:
                                    self.ax.fill_between(self.extratimex[i], 0, visible_extratemp2,transform=trans,color=self.extradevicecolor2[i],alpha=aw.extraFill2[i]/100.,sketch_params=None)
                                self.extratemp2lines.append(self.ax.plot(self.extratimex[i],visible_extratemp2,transform=trans,color=self.extradevicecolor2[i],
                                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths2[i]+aw.qmc.patheffects,foreground=self.palette['background'])],
                                    markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= extraname2_subst[i])[0])
                        except Exception as ex: # pylint: disable=broad-except
                            _log.exception(ex)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                    ##### ET,BT curves
                    if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0):
                        visible_et = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        self.stemp1[charge_idx:drop_idx+1],
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                        visible_bt = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        self.stemp2[charge_idx:drop_idx+1],
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                    elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0:
                        visible_et = numpy.concatenate((
                                        self.stemp1[0:drop_idx+1],
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                        visible_bt = numpy.concatenate((
                                        self.stemp2[0:drop_idx+1],
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                    else:
                        visible_et = self.stemp1
                        visible_bt = self.stemp2

                    if aw.qmc.swaplcds:
                        self.drawET(visible_et)
                        self.drawBT(visible_bt)
                    else:
                        self.drawBT(visible_bt)
                        self.drawET(visible_et)

                    if aw.qmc.ETcurve:
                        self.handles.append(self.l_temp1)
                        self.labels.append(aw.arabicReshape(aw.ETname))
                    if aw.qmc.BTcurve:
                        self.handles.append(self.l_temp2)
                        self.labels.append(aw.arabicReshape(aw.BTname))

                    if self.DeltaETflag:
                        self.handles.append(self.l_delta1)
                        self.labels.append(aw.arabicReshape(f'{deltaLabelMathPrefix}{aw.ETname}'))
                    if self.DeltaBTflag:
                        self.handles.append(self.l_delta2)
                        self.labels.append(aw.arabicReshape(f'{deltaLabelMathPrefix}{aw.BTname}'))

                    nrdevices = len(self.extradevices)

                    if nrdevices and not self.designerflag:
                        xtmpl1idx = 0
                        xtmpl2idx = 0
                        for i in range(nrdevices):
                            if aw.extraCurveVisibility1[i]:
                                idx1 = xtmpl1idx
                                xtmpl1idx = xtmpl1idx + 1
                                l1 = extraname1_subst[i]
                                if not l1.startswith('_'):
                                    self.handles.append(self.extratemp1lines[idx1])
                                    try:
                                        self.labels.append(aw.arabicReshape(l1.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3])))
                                    except Exception: # pylint: disable=broad-except
                                        # a key error can occur triggered by the format if curley braces are used without reference
                                        self.labels.append(aw.arabicReshape(l1))
                            if aw.extraCurveVisibility2[i]:
                                idx2 = xtmpl2idx
                                xtmpl2idx = xtmpl2idx + 1
                                l2 = extraname2_subst[i]
                                if not l2.startswith('_'):
                                    self.handles.append(self.extratemp2lines[idx2])
                                    try:
                                        self.labels.append(aw.arabicReshape(l2.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3])))
                                    except Exception: # pylint: disable=broad-except
                                        # a key error can occur triggered by the format if curley braces are used without reference
                                        self.labels.append(aw.arabicReshape(l2))

                    if self.eventsshowflag and self.eventsGraphflag in [2,3,4] and Nevents:
                        if E1_nonempty and aw.qmc.showEtypes[0]:
                            self.handles.append(self.l_eventtype1dots)
                            self.labels.append(aw.arabicReshape(self.etypesf(0)))
                        if E2_nonempty and aw.qmc.showEtypes[1]:
                            self.handles.append(self.l_eventtype2dots)
                            self.labels.append(aw.arabicReshape(self.etypesf(1)))
                        if E3_nonempty and aw.qmc.showEtypes[2]:
                            self.handles.append(self.l_eventtype3dots)
                            self.labels.append(aw.arabicReshape(self.etypesf(2)))
                        if E4_nonempty and aw.qmc.showEtypes[3]:
                            self.handles.append(self.l_eventtype4dots)
                            self.labels.append(aw.arabicReshape(self.etypesf(3)))

                    if not self.designerflag:
                        if aw.qmc.BTcurve:
                            if self.flagstart: # no smoothed lines in this case, pass normal BT
                                aw.qmc.l_annotations = self.place_annotations(
                                    aw.qmc.TPalarmtimeindex,
                                    aw.qmc.ylimit - aw.qmc.ylimit_min,
                                    self.timex,self.timeindex,
                                    self.temp2,self.temp2)
                            else:
                                TP_index = aw.findTP()
                                if aw.qmc.annotationsflag:
                                    aw.qmc.l_annotations = self.place_annotations(
                                        TP_index,aw.qmc.ylimit - aw.qmc.ylimit_min,
                                        self.timex,
                                        self.timeindex,
                                        self.temp2,
                                        self.stemp2)
                                if self.timeindex[6]:
                                    self.writestatistics(TP_index)
                            #add the time and temp annotations to the bt list
                            for x in aw.qmc.l_annotations:
                                self.l_bteventannos.append(x)
                        elif self.timeindex[6]:
                            TP_index = aw.findTP()
                            self.writestatistics(TP_index)

                    if not sampling and not aw.qmc.flagon and self.timeindex[6] and aw.qmc.statssummary:
                        self.statsSummary()
                    else:
                        self.stats_summary_rect = None

                    if not sampling and not aw.qmc.flagon and self.timeindex[6] and aw.qmc.AUCshowFlag:
                        self.drawAUC()
                    #update label rotating_colors
                    for label in self.ax.xaxis.get_ticklabels():
                        label.set_color(self.palette['xlabel'])
                    for label in self.ax.yaxis.get_ticklabels():
                        label.set_color(self.palette['ylabel'])
                    if two_ax_mode and self.delta_ax:
                        for label in self.delta_ax.yaxis.get_ticklabels():
                            label.set_color(self.palette['ylabel'])

                    #write legend
                    if self.legendloc and not sampling and not aw.qmc.flagon and len(self.timex) > 2:
                        rcParams['path.effects'] = []
                        prop = aw.mpl_fontproperties.copy()
                        prop.set_size('x-small')
                        if len(self.handles) > 7:
                            ncol = int(math.ceil(len(self.handles)/4.))
                        elif len(self.handles) > 3:
                            ncol = int(math.ceil(len(self.handles)/2.))
                        else:
                            ncol = int(math.ceil(len(self.handles)))
                        if aw.qmc.graphfont == 1:
                            self.labels = [self.__to_ascii(l) for l in self.labels]
                        if self.legend is None:
                            if self.legendloc_pos is None:
                                loc = self.legendloc # a position selected in the axis dialog
                            else:
                                loc = self.legendloc_pos # a user define legend position set by drag-and-drop
                        else:
                            loc = self.legend._loc # pylint: disable=protected-access
                        try:
                            try:
                                leg = self.ax.legend(self.handles,self.labels,loc=loc,ncols=ncol,fancybox=True,prop=prop,shadow=False,frameon=True)
                            except Exception: # pylint: disable=broad-except
                                # ncol keyword argument to legend renamed to ncols in MPL 3.6, thus for older MPL versions we need to still use ncol
                                leg = self.ax.legend(self.handles,self.labels,loc=loc,ncol=ncol,fancybox=True,prop=prop,shadow=False,frameon=True)
                            try:
                                leg.set_in_layout(False) # remove legend from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                                pass
                            self.legend = leg
                            self.legend_lines = leg.get_lines()
                            for h in leg.legendHandles:
                                h.set_picker(False) # we disable the click to hide on the handles feature
                                #h.set_picker(aw.draggable_text_box_picker) # as setting this picker results in non-termination
                            for l in leg.texts:
                                #l.set_picker(5)
                                l.set_picker(aw.draggable_text_box_picker)
                            try:
                                leg.set_draggable(state=True,use_blit=True)  #,update='bbox')
                                leg.set_picker(aw.draggable_text_box_picker)
                            except Exception: # pylint: disable=broad-except # not available in mpl<3.x
                                leg.draggable(state=True) # for mpl 2.x
                            frame = leg.get_frame()
                            frame.set_facecolor(self.palette['legendbg'])
                            frame.set_alpha(self.alpha['legendbg'])
                            frame.set_edgecolor(self.palette['legendborder'])
                            frame.set_linewidth(0.5)
                            for line,text in zip(leg.get_lines(), leg.get_texts()):
                                text.set_color(line.get_color())
                        except Exception: # pylint: disable=broad-except
                            pass

                        if aw.qmc.patheffects:
                            rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette['background'])]
                    else:
                        self.legend = None

                    # we create here the project line plots to have the accurate time axis after CHARGE
                    dashes_setup = [0.4,0.8,0.1,0.8] # simulating matplotlib 1.5 default on 2.0

                    #watermark image
                    self.placelogoimage()
                finally:
                    if aw.qmc.updateBackgroundSemaphore.available() < 1:
                        aw.qmc.updateBackgroundSemaphore.release(1)

                ############  ready to plot ############
#                with warnings.catch_warnings():
#                    warnings.simplefilter("ignore")
#                    self.fig.canvas.draw() # done also by updateBackground(), but the title on ON is not update if not called here too (might be a MPL bug in v3.1.2)!
                self.updateBackground() # update bitlblit backgrounds
                #######################################

                # add projection and AUC guide lines last as those are removed by updategraphics for optimized redrawing and not cached
                if aw.qmc.projectFlag:
                    if aw.qmc.BTcurve:
                        self.l_BTprojection, = self.ax.plot([], [],color = self.palette['bt'],
                                                    dashes=dashes_setup,
                                                    label=aw.arabicReshape(QApplication.translate('Label', 'BTprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                    if aw.qmc.ETcurve:
                        self.l_ETprojection, = self.ax.plot([], [],color = self.palette['et'],
                                                    dashes=dashes_setup,
                                                    label=aw.arabicReshape(QApplication.translate('Label', 'ETprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])

                    if aw.qmc.projectDeltaFlag and (aw.qmc.DeltaBTflag or aw.qmc.DeltaETflag):
                        trans = self.delta_ax.transData
                        if aw.qmc.DeltaBTflag:
                            self.l_DeltaBTprojection, = self.ax.plot([], [],color = self.palette['deltabt'],
                                                        dashes=dashes_setup,
                                                        transform=trans,
                                                        label=aw.arabicReshape(QApplication.translate('Label', 'DeltaBTprojection')),
                                                        linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                        if aw.qmc.DeltaETflag:
                            self.l_DeltaETprojection, = self.ax.plot([], [],color = self.palette['deltaet'],
                                                        dashes=dashes_setup,
                                                        transform=trans,
                                                        label=aw.arabicReshape(QApplication.translate('Label', 'DeltaETprojection')),
                                                        linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])

                if aw.qmc.AUCguideFlag:
                    self.l_AUCguide = self.ax.axvline(0,visible=False,color = self.palette['aucguide'],
                                                label=aw.arabicReshape(QApplication.translate('Label', 'AUCguide')),
                                                linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])

                # if designer ON
                if self.designerflag:
#                    if self.background:
#                        self.ax.lines = self.ax.lines[2:] # this might be wrong as the background can also have deltas, 3rd curve and 4x event artists!!
                    if len(self.timex):
                        self.xaxistosm()
                        self.redrawdesigner()

                if aw.qmc.patheffects:
                    rcParams['path.effects'] = []

                # HACK
                # a bug in Qt/PyQt/mpl cause the canvas not to be repainted on load/switch/reset in fullscreen mode without this
                try:
                    if platf == 'Darwin' and app.allWindows()[0].visibility() == QWindow.Visibility.FullScreen or aw.full_screen_mode_active or aw.isFullScreen():
                        aw.qmc.repaint()
                except Exception: # pylint: disable=broad-except
                    pass

            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                # we initialize at the end of the redraw the event and flag annotation custom position loaded from a profile as those should have been consumed by now
                self.l_annotations_pos_dict = {}
                self.l_event_flags_pos_dict = {}
                self.legendloc_pos = None
                if takelock and aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)

                # to allow the fit_title to work on the proper value we ping the redraw explicitly again after processing events
                # we need to use draw_idle here to allow Qt for relayout event processing
                # calling QApplication.processEvents() is not an option here as the event loop might not have been started yet
                # alternatively one could call canvas.draw() using a QTimer.singleShot(self.fig.canvas.draw())
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw_idle()
                self.setProfileBackgroundTitle(titleB)

    def checkOverlap(self, anno): #, eventno, annotext):
        overlapallowed = max(0,min(aw.qmc.overlappct,100))/100  #the input is validated but this here to prevent any escapes
        overlap = False
        try:
            annocorners = self.annoboxCorners(anno)
            anno_x = anno.get_unitless_position()[0]
            ax_xlim = self.ax.get_xlim()
            # if annotation is off canvas, the display coordinates are not reliable thus we exclude this one from the check
            if anno_x < ax_xlim[0] or anno_x > ax_xlim[1]:
                _log.debug('Event annotation off canvas: %s, ax_xlim=%s', anno,ax_xlim)
                return False
            xl = annocorners[0]
            xr = annocorners[1]
            yl = annocorners[2]
            yu = annocorners[3]
            area = (xr - xl) * (yu - yl)
            for i in range(len(self.overlapList)):
                o_xl = self.overlapList[i][0]
                o_xr = self.overlapList[i][1]
                o_yl = self.overlapList[i][2]
                o_yu = self.overlapList[i][3]
                o_area = (o_xr - o_xl) * (o_yu - o_yl)
                dx = min(xr, o_xr) - max(xl, o_xl)
                dy = min(yu, o_yu) - max(yl, o_yl)
                if (dx>=0) and (dy>=0):
                    if dx*dy/min(area,o_area) > overlapallowed:
                        overlap = True
                        break
            if not overlap:
                # note to self, the eventno and annotext can be removed from the list.  Only here for debug prints
                self.overlapList.append((xl,xr,yl,yu)) #,eventno,annotext))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' checkOverlap() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return overlap

    def annoboxCorners(self,anno):
        f = self.ax.get_figure()
        r = f.canvas.get_renderer() # this can fail for PDF generation with 'FigureCanvasPdf' object has no attribute 'get_renderer'
        anno.update_bbox_position_size(renderer=r)
        bb = anno.get_window_extent(renderer=r) # bounding box in display space
        bbox_data = aw.qmc.ax.transData.inverted().transform(bb)
        bbox = Bbox(bbox_data) # x0, y0, width, height
        corners = (bbox.bounds[0],bbox.bounds[0]+bbox.bounds[2],bbox.bounds[1],bbox.bounds[1]+bbox.bounds[3])
        return corners  # x0, x1, y0, y1

    def parseSpecialeventannotation(self,eventanno, eventnum, applyto='foreground', postFCs=False):
        try:
            #background curve values
            if applyto == 'background':
                e = self.backgroundEvalues[eventnum]
                y1 = self.temp1B[self.backgroundEvents[eventnum]]
                y2 = self.temp2B[self.backgroundEvents[eventnum]]
                try:
                    delta1 = str(aw.float2float(self.delta1B[self.backgroundEvents[eventnum]])) if self.delta1B[self.backgroundEvents[eventnum]] != None else '--'
                except Exception: # pylint: disable=broad-except
                    delta1 = '\u03C5\u03c5'
                try:
                    delta2 = str(aw.float2float(self.delta2B[self.backgroundEvents[eventnum]])) if self.delta2B[self.backgroundEvents[eventnum]] != None else '--'
                except Exception: # pylint: disable=broad-except
                    delta2 = '\u03C5\u03c5'
                descr = str(self.backgroundEStrings[eventnum])
                etype = str(self.Betypes[self.backgroundEtypes[eventnum]])
                sliderunit = str(aw.eventsliderunits[self.backgroundEtypes[eventnum]])

                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] > self.timeB[self.timeindexB[2]]:
                    postFCs = True
                    dtr = str(aw.float2float(100 * (self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]]) / (self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[0]]),1))
                else:
                    postFCs = False
                    dtr = '0'
                if self.timeindexB[2] > 0:
                    _dfcs = aw.float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]],0)
                    dfcs = str(_dfcs)
                    dfcs_ms = stringfromseconds(_dfcs,False)
                else:
                    dfcs = '*'
                    dfcs_ms = '*'
                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] < self.timeB[self.timeindexB[2]]:
                    _prefcs = aw.float2float(self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]],0)
                    prefcs = str(_prefcs)
                    prefcs_ms = stringfromseconds(_prefcs,False)
                else:
                    prefcs = '*'
                    prefcs_ms = '*'
                if self.timeindexB[0] > -1:
                    _dcharge = aw.float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[0]],0)
                    dcharge = str(_dcharge)
                    dcharge_ms = stringfromseconds(_dcharge,False)
                else:
                    dcharge = '*'
                    dcharge_ms = '*'
                fcsWindow = not postFCs and (self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]]) < 90

            # plug values for the previews
            elif applyto == 'preview':
                if eventnum == 1:
                    e = 8.0  #70
                if eventnum == 2:
                    e = 8.0  #70
                if eventnum == 3:
                    e = 7.0  #60
                else:
                    e = 6.0  #50
                y1 = '420' if self.mode=='F' else '210'
                y2 = '340' if self.mode=='F' else '170'
                delta1 = '18.2' if self.mode=='F' else '9.1'
                delta2 = '33.4' if self.mode=='F' else '16.2'
                descr = 'Full'
                etype = 'Air'
                sliderunit = 'kPa'
                dcharge = '340' if self.mode=='F' else '170'
                dcharge_ms = stringfromseconds(int(dcharge))
                dfcs = '47'
                dfcs_ms = stringfromseconds(int(dfcs))
                prefcs = '50'
                prefcs_ms = stringfromseconds(int(prefcs))
                dtr = '12'
                fcsWindow = not bool(postFCs)
                #postFCs supplied in the parseSpecialeventannotation() call

            # foreground curve values
            else:
                e = self.specialeventsvalue[eventnum]
                y1 = self.temp1[self.specialevents[eventnum]]
                y2 = self.temp2[self.specialevents[eventnum]]
                try:
                    delta1 = str(aw.float2float(self.delta1[self.specialevents[eventnum]])) if self.delta1[self.specialevents[eventnum]] != None else '--'
                except Exception: # pylint: disable=broad-except
                    delta1 = '\u03C5\u03c5'
                try:
                    delta2 = str(aw.float2float(self.delta2[self.specialevents[eventnum]])) if self.delta2[self.specialevents[eventnum]] != None else '--'
                except Exception: # pylint: disable=broad-except
                    delta2 = '\u03C5\u03c5'
                descr = str(self.specialeventsStrings[eventnum])
                etype = str(self.etypes[self.specialeventstype[eventnum]])
                sliderunit = str(aw.eventsliderunits[self.specialeventstype[eventnum]])

                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] > self.timex[self.timeindex[2]]:
                    postFCs = True
                    dtr = str(aw.float2float(100 * (self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]]) / (self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[0]]),1))
                else:
                    postFCs = False
                    dtr = '0'
                if self.timeindex[2] > 0:
                    _dfcs = aw.float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]],0)
                    dfcs = str(_dfcs)
                    dfcs_ms = stringfromseconds(_dfcs,False)
#                    print(f'{dfcs_ms=}')
                else:
                    dfcs = '*'
                    dfcs_ms = '*'
                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] < self.timex[self.timeindex[2]]:
                    _prefcs = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]],0)
                    prefcs = str(_prefcs)
                    prefcs_ms = stringfromseconds(_prefcs,False)
                else:
                    prefcs = '*'
                    prefcs_ms = '*'
                if self.timeindex[0] > -1:
                    _dcharge = aw.float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[0]],0)
                    dcharge = str(_dcharge)
                    dcharge_ms = stringfromseconds(_dcharge,False)
                else:
                    dcharge = '*'
                    dcharge_ms = '*'
                fcsWindow = not postFCs and self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]] < 90

            # Caution - the event field "E" is position dependent and must be the first entry in the fields list
            fields = [
                ('E', str(aw.qmc.eventsInternal2ExternalValue(e))),
                ('Y1', str(aw.float2float(y1,aw.qmc.LCDdecimalplaces))),
                ('Y2', str(aw.float2float(y2,aw.qmc.LCDdecimalplaces))),
                ('descr', descr),
                ('type', etype),
                ('sldrunit', sliderunit),
                ('dCHARGE_ms', dcharge_ms),
                ('dFCs_ms', dfcs_ms),
                ('dCHARGE', dcharge),
                ('dFCs', dfcs),
                ('preFCs_ms', prefcs_ms),
                ('preFCs', prefcs),
                ('DTR', dtr),
                ('mode', self.mode),
                ('degmode', f'\u00b0{self.mode}'),
                ('degmin', f'\u00b0{self.mode}/min'),
                ('deg', '\u00b0'),
                ('R1degmin', f'{delta1}\u00b0{self.mode}/min'),
                ('R2degmin', f'{delta2}\u00b0{self.mode}/min'),
                ('R1', delta1),
                ('R2', delta2),
                ('squot', "'"),
                ('quot', '"'),
                ]

            fieldDelim = '~'
            #delimiter to show before FCs only
            preFCsDelim = "'"
            #delimiter to show after FCs only
            postFCsDelim = '"'
            #delimiter to show within a window before FCs only
            fcsWindowDelim = '`'
            #delimiter for explicit value substitutions
            nominalDelimopen = '{'
            nominalDelimclose = '}'
            nominalstringDelim = '|'
            _ignorecase = re.IGNORECASE  # @UndefinedVariable

            #newlines can sneak in from cut and paste from help page
            eventanno = eventanno.replace('\n', '')

            #text between single quotes ' will show only before FCs
            eventanno = re.sub(r'{pd}([^{pd}]+){pd}'.format(pd=preFCsDelim),
                r'\1',eventanno) if not postFCs else re.sub(r'{pd}([^{pd}]+){pd}'.format(pd=preFCsDelim),
                r'',eventanno)
            #text between double quotes " will show only after FCs
            eventanno = re.sub(r'{pd}([^{pd}]+){pd}'.format(pd=postFCsDelim),
                r'\1',eventanno) if postFCs else re.sub(r'{pd}([^{pd}]+){pd}'.format(pd=postFCsDelim),
                r'',eventanno)

            #text between back ticks ` will show only within 90 seconds before FCs
            eventanno = re.sub(r'{wd}([^{wd}]+){wd}'.format(wd=fcsWindowDelim),
                r'\1',eventanno) if (fcsWindow) else re.sub(r'{wd}([^{wd}]+){wd}'.format(wd=fcsWindowDelim),
                r'',eventanno)

            # substitute numeric to nominal values if in the annotationstring
            #
            # Caution - the event field "E" is position dependent and must be the first entry in the fields list
            # The event field E is implied in the Annotation string which should take the following form.  Enclosed by
            #    curly brackets, entries consist of a value followed immediately (no space) by a text string.  Entries are
            #    separated by a vertical bar '|'.
            #   {20Fresh Cut Grass|50Hay|80Baking Bread|100A Point}
            # Event values that do not match any value in the Annotation string return an empty string ''.
            #
            ##debug - things to watch out for in testing:
            # does the matchedgroup(4) always persist after the pattern.sub() above?
            # does the pattern.split always result in the same list pattern?  ex:
            #     ['', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '|', '100', 'A Point', '']
            pattern = re.compile(r'.*{ndo}(?P<nominalstr>[^{ndc}]+){ndc}'.format(ndo=nominalDelimopen,ndc=nominalDelimclose),_ignorecase)
            matched = pattern.match(eventanno)
            if matched != None:
                pattern = re.compile(r'([0-9]+)([A-Za-z]+[A-Za-z 0-9]+)',_ignorecase)
                matches = pattern.split(matched.group('nominalstr'))
                #example form of the matches list ['', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '']
                replacestring = ''
                j = 1
                while (j < len(matches)):
                    if fields[0][1] == matches[j]:
                        replacestring = matches[j+1]
                        break
                    j += 3
                pattern = re.compile(r'({ndo}[^{ndc}]+{ndc})'.format(ndo=nominalDelimopen,ndc=nominalDelimclose))
                eventanno = pattern.sub(replacestring,eventanno)

            # make all the remaining substitutions
            for i in range(len(fields)):
                pattern = re.compile(r'(.*{})({})(?P<mathop>[/*+-][0-9.]+)?(({}[0-9]+[A-Za-z]+[A-Za-z 0-9]+)+)?'.format(
                    fieldDelim,fields[i][0],nominalstringDelim),_ignorecase)
                matched = pattern.match(eventanno)
                if matched != None:

                    # get the value associated with the field
                    replacestring = str(fields[i][1])
                    # do simple math if an operator is in the string
                    if matched.group('mathop') != None:
                        replacestring += matched.group('mathop')
                        replacestring = str(aw.float2float(eval(replacestring),1)) # pylint: disable=eval-used

                    pattern = re.compile(fr'{fieldDelim}{fields[i][0]}([/*+-][0-9.]+)?',_ignorecase)
                    eventanno = pattern.sub(replacestring,eventanno)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' parseSpecialeventannotation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            eventanno = ''

        return eventanno

    #watermark image
    def placelogoimage(self):
        if self.flagon and aw.logoimgflag:  #if hide during roast
            return
        try:
            if len(aw.logofilename) == 0 or self.logoimg is None:
                return
            img_height_pixels, img_width_pixels, _ = self.logoimg.shape
            img_aspect = img_height_pixels / img_width_pixels
            coord_axes_middle_Display = self.ax.transAxes.transform((.5,.5))
            coord_axes_upperright_Display = self.ax.transAxes.transform((1.,1.))
            coord_axes_lowerleft_Display = self.ax.transAxes.transform((0.,0.))
            coord_axes_height_pixels = coord_axes_upperright_Display[1] - coord_axes_lowerleft_Display[1]
            coord_axes_width_pixels = coord_axes_upperright_Display[0] - coord_axes_lowerleft_Display[0]
            coord_axes_aspect = coord_axes_height_pixels / coord_axes_width_pixels
            if img_aspect >= coord_axes_aspect:
                scale = min(1., coord_axes_height_pixels / img_height_pixels)
            else:
                scale = min(1., coord_axes_width_pixels / img_width_pixels)

            corner_pixels = [0.,0.,0.,0.]
            corner_pixels[0] = coord_axes_middle_Display[0] - (scale * img_width_pixels / 2)
            corner_pixels[1] = coord_axes_middle_Display[1] - (scale * img_height_pixels / 2)
            corner_pixels[2] = corner_pixels[0] + scale * img_width_pixels
            corner_pixels[3] = corner_pixels[1] + scale * img_height_pixels
            ll_corner_axes = self.ax.transData.inverted().transform_point((corner_pixels[0],corner_pixels[1]))
            ur_corner_axes = self.ax.transData.inverted().transform_point((corner_pixels[2],corner_pixels[3]))
            extent = [ll_corner_axes[0], ur_corner_axes[0], ll_corner_axes[1], ur_corner_axes[1]]
            if self.ai is not None:
                try:
                    self.ai.remove()
                except Exception: # pylint: disable=broad-except
                    pass
            self.ai = self.ax.imshow(self.logoimg, zorder=0, extent=extent, alpha=aw.logoimgalpha/10, aspect='auto', resample=False)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' placelogoimage() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # Convert QImage to numpy array
    @staticmethod
    def convertQImageToNumpyArray(img):
        img = img.convertToFormat(QImage.Format.Format_RGBA8888)
        width = img.width()
        height = img.height()
        imgsize = img.bits()
        try:
            imgsize.setsize(img.sizeInBytes())
        except Exception: # pylint: disable=broad-except
            imgsize.setsize(img.byteCount()) # byteCount() is deprecated, but kept here for compatibility with older Qt versions
        arr = numpy.array(imgsize).reshape((height, width, int(32/8)))
        return arr

    #watermark image
    def logoloadfile(self,filename=None):
        try:
            if not filename:
                filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Image File'),ext='*.png *.jpg')
            if len(filename) == 0:
                return
            newImage = QImage()
            if newImage.load(filename):
                aw.qmc.logoimg = self.convertQImageToNumpyArray(newImage)
                aw.logofilename = filename
                aw.sendmessage(QApplication.translate('Message','Loaded watermark image {0}').format(filename))
                QTimer.singleShot(500, lambda : self.redraw(recomputeAllDeltas=False)) #some time needed before the redraw on artisan start with no profile loaded.  processevents() does not work here.
            else:
                aw.sendmessage(QApplication.translate('Message','Unable to load watermark image {0}').format(filename))
                _log.info('Unable to load watermark image %s', filename)
                aw.logofilename = ''
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' logoloadfile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            aw.logofilename = ''

    #return a 'roast of the day' string with ordinals when english
    def roastOfTheDay(self,roastbatchpos):
        rotd_str = ''  #return an empty string if roastbatchpos is None
        if roastbatchpos != None:
            #add an ordinal suffix for english
            if self.locale_str == 'en':
                prefix = ''
                ordinal_suffix = lambda x: f'{dict([(1, "st"),(2, "nd"),(3, "rd")]).get(0 if x % 100 in [11,12,13] else x % 10, "th")}'
                suffix = ordinal_suffix(roastbatchpos)
            else:
                prefix = '#'
                suffix = ''
            rotd_str = f'{prefix}{roastbatchpos}{suffix} {QApplication.translate("AddlInfo", "Roast of the Day")}'
        return rotd_str

    #add stats summary to graph
    def statsSummary(self):
        import textwrap
        try:
            skipline = '\n'
            statstr_segments = []
            if self.statssummary:
                cp = aw.computedProfileInformation()  # get all the computed profile information

                #Admin Info Section
                if aw.qmc.roastbatchnr > 0:
                    statstr_segments += [aw.qmc.roastbatchprefix, str(aw.qmc.roastbatchnr)]
                if aw.qmc.title != QApplication.translate('Scope Title', 'Roaster Scope'):
                    if statstr_segments != []:
                        statstr_segments.append(' ')
                    statstr_segments.append(aw.qmc.title)
                statstr_segments += [
                    skipline,
                    aw.qmc.roastdate.date().toString(),
                    ' ',
                    aw.qmc.roastdate.time().toString()]

                # build roast of the day string
                if aw.qmc.roastbatchpos != None and aw.qmc.roastbatchpos != 0:
                    statstr_segments += [f'\n{self.roastOfTheDay(aw.qmc.roastbatchpos)}']

                if aw.qmc.ambientTemp not in [None,0] or aw.qmc.ambient_humidity not in [None,0] or aw.qmc.ambient_pressure not in [None,0]:
                    statstr_segments.append(skipline)
                    if aw.qmc.ambientTemp not in [None,0]:
                        statstr_segments += [str(int(round(aw.qmc.ambientTemp))), '\u00b0', aw.qmc.mode, '  ']
                    if aw.qmc.ambient_humidity not in [None,0]:
                        statstr_segments += [str(int(round(aw.qmc.ambient_humidity))), '%  ']
                    if aw.qmc.ambient_pressure not in [None,0]:
                        statstr_segments += [str(aw.float2float(aw.qmc.ambient_pressure,2)), 'hPa']
                if aw.qmc.roastertype or aw.qmc.drumspeed:
                    statstr_segments.append(skipline)
                    if aw.qmc.roastertype:
                        statstr_segments += [aw.qmc.roastertype, ' ']
                    if aw.qmc.drumspeed:
                        statstr_segments += ['(', aw.qmc.drumspeed, QApplication.translate('Label', 'RPM'), ')']

                #Green Beans Info Section
                statstr_segments.append(skipline)
                if aw.qmc.beans is not None and len(aw.qmc.beans)>0:
                    statstr_segments.append(skipline)
                    beans_lines = textwrap.wrap(aw.qmc.beans, width=aw.qmc.statsmaxchrperline)
                    statstr_segments.append(beans_lines[0])
                    if len(beans_lines)>1:
                        statstr_segments += [skipline, ' ', beans_lines[1]]
                        if len(beans_lines)>2:
                            statstr_segments.append('..')

                if aw.qmc.beansize_min or aw.qmc.beansize_max:
                    statstr_segments += ['\n',  QApplication.translate('AddlInfo', 'Screen Size'), ': ']
                    if aw.qmc.beansize_min:
                        statstr_segments.append(str(int(round(aw.qmc.beansize_min))))
                    if aw.qmc.beansize_max:
                        if aw.qmc.beansize_min:
                            statstr_segments.append('/')
                        statstr_segments.append(str(int(round(aw.qmc.beansize_max))))

                if aw.qmc.density[0] and aw.qmc.density[2] != 0:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Density Green'), ': ',
                        str(aw.float2float(aw.qmc.density[0]/aw.qmc.density[2],2)), ' ', encodeLocal(aw.qmc.density[1]), '/', encodeLocal(aw.qmc.density[3])]
                if aw.qmc.moisture_greens:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Moisture Green'), ': ', str(aw.float2float(aw.qmc.moisture_greens,1)), '%']
                if aw.qmc.weight[0]:
                    if aw.qmc.weight[2] == 'g':
                        w =str(aw.float2float(aw.qmc.weight[0],0))
                    else:
                        w = str(aw.float2float(aw.qmc.weight[0],2))
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Batch Size') , ': ', w, aw.qmc.weight[2], ' ']
                    if aw.qmc.weight[1]:
                        statstr_segments += ['(-', str(aw.float2float(aw.weight_loss(aw.qmc.weight[0],aw.qmc.weight[1]),1)), '%)']

                # Roast Info Section
                statstr_segments.append(skipline)
                if 'roasted_density' in cp:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Density Roasted'), ': ', str(cp['roasted_density']),
                        ' ', encodeLocal(aw.qmc.density[1]), '/', encodeLocal(aw.qmc.density[3])]
                if aw.qmc.moisture_roasted:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Moisture Roasted'), ': ', str(aw.float2float(aw.qmc.moisture_roasted,1)), '%']
                if aw.qmc.whole_color > 0:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Whole Color'), ': #', str(aw.qmc.whole_color), ' ',
                        str(aw.qmc.color_systems[aw.qmc.color_system_idx])]
                if aw.qmc.ground_color > 0:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Ground Color'), ': #', str(aw.qmc.ground_color), ' ',
                        str(aw.qmc.color_systems[aw.qmc.color_system_idx])]
                if 'BTU_batch' in cp and cp['BTU_batch']:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'Energy'), ': ',
                        str(aw.float2float(aw.qmc.convertHeat(cp['BTU_batch'],0,3),2)), 'kWh']
                    if 'BTU_batch_per_green_kg' in cp and cp['BTU_batch_per_green_kg']:
                        statstr_segments += [' (', str(aw.float2float(aw.qmc.convertHeat(cp['BTU_batch_per_green_kg'], 0,3), 2)), 'kWh/kg)']
                if 'CO2_batch' in cp and cp['CO2_batch']:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'CO2'), ': ', str(aw.float2float(cp['CO2_batch'],0)),'g']
                    if 'CO2_batch_per_green_kg' in cp and cp['CO2_batch_per_green_kg']:
                        statstr_segments += [' (', str(aw.float2float(cp['CO2_batch_per_green_kg'],0)), 'g/kg)']
                if cp['AUC']:
                    statstr_segments += ['\n', QApplication.translate('AddlInfo', 'AUC'), ': ', str(cp['AUC']), 'C*min [', str(cp['AUCbase']), '\u00b0', aw.qmc.mode, ']']

                def render_notes(notes,statstr_segments):
                    if notes is not None and len(notes)>0:
                        notes_lines = textwrap.wrap(notes, width=aw.qmc.statsmaxchrperline)
                        if len(notes_lines)>0:
                            statstr_segments += [skipline, notes_lines[0]]
                            if len(notes_lines)>1:
                                statstr_segments += [skipline, '  ', notes_lines[1]]
                                if len(notes_lines)>2:
                                    statstr_segments.append('..')

                render_notes(aw.qmc.roastingnotes,statstr_segments)

                cupping_score, cupping_all_default = aw.cuppingSum(self.flavors)
                if not cupping_all_default:
                    statstr_segments += ['\n', QApplication.translate('HTML Report Template', 'Cupping:'), ' ', str(aw.float2float(cupping_score))]

                render_notes(aw.qmc.cuppingnotes,statstr_segments)

                # Trim the long lines
                trimmedstatstr_segments = []
                for l in ''.join(statstr_segments).split('\n'):
                    if trimmedstatstr_segments != []:
                        trimmedstatstr_segments.append('\n')
                    trimmedstatstr_segments.append(l[:aw.qmc.statsmaxchrperline])
                    if len(l) > aw.qmc.statsmaxchrperline:
                        trimmedstatstr_segments.append('..')
                statstr = ''.join(trimmedstatstr_segments)

                #defaults appropriate for default font
                prop = aw.mpl_fontproperties.copy()
                prop_size = 'small'
                prop.set_size(prop_size)
                fc = aw.qmc.palette['statsanalysisbkgnd']  #fill color
                tc = aw.labelBorW(fc)                   #text color
                a = aw.qmc.alpha['statsanalysisbkgnd']     #alpha
                ls = 1.7                     #linespacing
                if aw.qmc.graphfont == 9:   #Dijkstra
                    ls = 1.2
                border = 10                  #space around outside of text box (in seconds)
                margin = 4                   #text to edge of text box

                #adjust for other fonts
                if aw.qmc.graphfont == 1:   #Humor
                    prop_size = 'x-small'
                    prop.set_size(prop_size)
                if aw.qmc.graphfont == 2:   #Comic
                    ls = 1.2
                if aw.qmc.graphfont == 9:   #Dijkstra
                    ls = 1.2

                if aw.qmc.legendloc != 1:
                    # legend not in upper right
                    statsheight = aw.qmc.ylimit - (0.08 * (aw.qmc.ylimit - aw.qmc.ylimit_min)) # standard positioning
                else:
                    # legend in upper right
                    statsheight = aw.qmc.ylimit - (0.13 * (aw.qmc.ylimit - aw.qmc.ylimit_min))

                if aw.qmc.timeindex[0] != -1:
                    start = aw.qmc.timex[aw.qmc.timeindex[0]]
                else:
                    start = 0

                # position the stats summary relative to the right hand edge of the graph
                # when in BBP mode the graph will end at CHARGE, so we must look for the CHARGE annotation instead of DROP.
                if not aw.qmc.autotimex or aw.qmc.autotimexMode != 2:
                    event_label = QApplication.translate('Scope Annotation','DROP {0}').replace(' {0}','')
                else:
                    event_label = QApplication.translate('Scope Annotation','CHARGE')
                _,_,eventtext_end = self.eventtextBounds(event_label,start,statsheight,ls,prop,fc)
                stats_textbox_bounds = self.statstextboxBounds(self.ax.get_xlim()[1]+border,statsheight,statstr,ls,prop,fc)
                stats_textbox_width = stats_textbox_bounds[2]
                stats_textbox_height = stats_textbox_bounds[3]
                pos_x = self.ax.get_xlim()[1]-stats_textbox_width-border

                if (aw.qmc.autotimex):
                    aw.qmc.endofx = eventtext_end + stats_textbox_width + 2*border # provide room for the stats
                    self.xaxistosm(redraw=False)  # recalculate the x axis

                    prev_stats_textbox_width = 0
                    #set the maximum number of iterations
                    for _ in range(2, 20):
                        _,_,eventtext_end = self.eventtextBounds(event_label,start,statsheight,ls,prop,fc)
                        stats_textbox_bounds = self.statstextboxBounds(self.ax.get_xlim()[1]+border,statsheight,statstr,ls,prop,fc)
                        stats_textbox_width = stats_textbox_bounds[2]
                        stats_textbox_height = stats_textbox_bounds[3]

                        # position the stats summary relative to the right edge of the drop text
                        aw.qmc.endofx = eventtext_end + stats_textbox_width + 2*border #provide room for the stats
                        self.xaxistosm(redraw=False)
                        #break the loop if it looks like stats_textbox_width has converged
                        if abs(prev_stats_textbox_width - stats_textbox_width) < .2:
                            break
                        prev_stats_textbox_width = stats_textbox_width

                    pos_x = eventtext_end + border + start

                pos_y = statsheight
#               self.stats_summary_rect = patches.Rectangle((pos_x-margin,pos_y+margin),stats_textbox_width+2*margin,-stats_textbox_height-2*margin,linewidth=0.5,edgecolor=aw.qmc.palette["grid"],facecolor=fc,fill=True,alpha=a,zorder=10)
                self.stats_summary_rect = patches.Rectangle((pos_x-margin,pos_y - (stats_textbox_height + 2*margin)),stats_textbox_width+2*margin,stats_textbox_height+3*margin,linewidth=0.5,edgecolor=aw.qmc.palette['grid'],facecolor=fc,fill=True,alpha=a,zorder=10)
                self.ax.add_patch(self.stats_summary_rect)

                text = self.ax.text(pos_x, pos_y, statstr, verticalalignment='top',linespacing=ls,
                    fontsize=prop_size,
                    color=tc,zorder=11,path_effects=[])
                text.set_in_layout(False)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' statsSummary() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def statstextboxBounds(self,x_pos,y_pos,textstr,ls,prop,fc):

        with warnings.catch_warnings():
            # MPL will generate warnings for missing glyphs in some fonts
            warnings.simplefilter('ignore')
            t = self.ax.text(x_pos, y_pos, textstr, verticalalignment='top',linespacing=ls,fontproperties=prop,color=fc,path_effects=[])
            f = self.ax.get_figure()
            r = None
            try:
                r = f.canvas.get_renderer() # this might fail with 'FigureCanvasPdf' object has no attribute 'get_renderer' for PDF generation
            except Exception: # pylint: disable=broad-except
                pass
            if r is None:
                t.update_bbox_position_size()
            else:
                t.update_bbox_position_size(renderer=r)
            bb = t.get_window_extent(renderer=r) # bounding box in display space
            bbox_data = aw.qmc.ax.transData.inverted().transform(bb)
            bbox = Bbox(bbox_data)
            t.remove()
            return bbox.bounds


    def eventtextBounds(self,event_label,x_pos,y_pos,ls,prop,fc):
        try:
            eventtext_width = 0
            eventtextstart = 0
            eventtext_end = aw.qmc.timex[-1] - x_pos #default for when Events Annotations is unchecked
            for child in self.ax.get_children():
                if isinstance(child, mpl.text.Annotation):
                    eventtext = re.search(fr'.*\((.*?),.*({event_label}[ 0-9:]*)',str(child))
                    if eventtext:
                        eventtextstart = int(float(eventtext.group(1))) - x_pos
                        eventtext_width = self.statstextboxBounds(x_pos,y_pos,eventtext.group(2),ls,prop,fc)[2]
                        eventtext_end = eventtextstart + eventtext_width
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        return eventtext_width,eventtextstart,eventtext_end

    # adjusts height of annotations
    #supporting function for self.redraw() used to find best height of annotations in graph to avoid annotating over previous annotations (unreadable) when close to each other
    @staticmethod
    def findtextgap(ystep_down, ystep_up, height1, height2, dd=0):
        if dd <= 0:
            d = aw.qmc.ylimit - aw.qmc.ylimit_min
        else:
            d = dd
        init = int(d/12.0)
        gap = int(d/20.0)
        maxx = int(d/3.6)
        for i in range(init,maxx):
            if abs((height1 + ystep_up) - (height2+i)) > gap:
                break
        for j in range(init,maxx):
            if abs((height1 - ystep_down) - (height2 - j)) > gap:
                break
        return j,i  #return height of arm

    # adjust min/max limits of temperature sliders to the actual temperature mode
    def adjustTempSliders(self):
        if self.mode != self.mode_tempsliders:
            for i in range(4):
                if aw.eventslidertemp[i]:
                    if self.mode == 'C':
                        aw.eventslidermin[i] = int(round(fromFtoC(aw.eventslidermin[i])))
                        aw.eventslidermax[i] = int(round(fromFtoC(aw.eventslidermax[i])))
                    else:
                        aw.eventslidermin[i] = int(round(fromCtoF(aw.eventslidermin[i])))
                        aw.eventslidermax[i] = int(round(fromCtoF(aw.eventslidermax[i])))
            aw.updateSliderMinMax()
            self.mode_tempsliders = self.mode

    #sets the graph display in Fahrenheit mode
    def fahrenheitMode(self,setdefaultaxes=True):
        if setdefaultaxes:
            # just set it to the defaults to avoid strange conversion issues
            self.ylimit = self.ylimit_F_default
            self.ylimit_min = self.ylimit_min_F_default
            self.ygrid = self.ygrid_F_default
            self.zlimit = self.zlimit_F_default
            self.zlimit_min = self.zlimit_min_F_default
            self.zgrid = self.zgrid_F_default
        if self.mode == 'C':
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(fromCtoF(self.phases[i])))
            if self.step100temp is not None:
                self.step100temp = int(round(fromCtoF(self.step100temp)))
            self.AUCbase = int(round(fromCtoF(self.AUCbase)))
            self.alarmtemperature = [(fromCtoF(t) if t != 500 else t) for t in self.alarmtemperature]
            # conv Arduino mode
            if aw:
                aw.pidcontrol.conv2fahrenheit()
        self.ax.set_ylabel('F',size=16,color = self.palette['ylabel']) #Write "F" on Y axis
        self.mode = 'F'
        if aw: # during initialization aw is still None!
            aw.FahrenheitAction.setDisabled(True)
            aw.CelsiusAction.setEnabled(True)
            aw.ConvertToFahrenheitAction.setDisabled(True)
            aw.ConvertToCelsiusAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_F_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_F_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_F_default
            self.adjustTempSliders()

    #sets the graph display in Celsius mode
    def celsiusMode(self,setdefaultaxes=True):
        if setdefaultaxes:
            self.ylimit = self.ylimit_C_default
            self.ylimit_min = self.ylimit_min_C_default
            self.ygrid = self.ygrid_C_default
            self.zlimit = self.zlimit_C_default
            self.zlimit_min = self.zlimit_min_C_default
            self.zgrid = self.zgrid_C_default
        if self.mode == 'F':
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(fromFtoC(self.phases[i])))
            if self.step100temp is not None:
                self.step100temp = int(round(fromFtoC(self.step100temp)))
            self.AUCbase = int(round(fromFtoC(self.AUCbase)))
            self.alarmtemperature = [(fromFtoC(t) if t != 500 else t) for t in self.alarmtemperature]
            # conv Arduino mode
            if aw:
                aw.pidcontrol.conv2celsius()
        self.ax.set_ylabel('C',size=16,color = self.palette['ylabel']) #Write "C" on Y axis
        self.mode = 'C'
        if aw: # during initialization aw is still None
            aw.CelsiusAction.setDisabled(True)
            aw.FahrenheitAction.setEnabled(True)
            aw.ConvertToCelsiusAction.setDisabled(True)
            aw.ConvertToFahrenheitAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_C_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_C_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_C_default
            self.adjustTempSliders()

    @pyqtSlot()
    @pyqtSlot(bool)
    def fahrenheitModeRedraw(self,_=False):
        self.fahrenheitMode()
        self.redraw()

    @pyqtSlot()
    @pyqtSlot(bool)
    def celsiusModeRedraw(self,_=False):
        self.celsiusMode()
        self.redraw()

    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureF(self,_=False):
        self.convertTemperature('F')

    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureC(self,_=False):
        self.convertTemperature('C')

    #converts a loaded profile to a different temperature scale. t input is the requested mode (F or C).
    def convertTemperature(self,t,silent=False,setdefaultaxes=True):
        #verify there is a loaded profile
        profilelength = len(self.timex)
        if profilelength > 0 or self.background:
            if t == 'F':
                if silent:
                    reply = QMessageBox.StandardButton.Yes
                else:
                    string = QApplication.translate('Message', 'Convert profile data to Fahrenheit?')
                    reply = QMessageBox.question(aw,QApplication.translate('Message', 'Convert Profile Temperature'),string,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                if reply == QMessageBox.StandardButton.Yes:
                    if self.mode == 'C':
                        aw.CelsiusAction.setDisabled(True)
                        aw.FahrenheitAction.setEnabled(True)
                        aw.ConvertToCelsiusAction.setDisabled(True)
                        aw.ConvertToFahrenheitAction.setEnabled(True)
                        aw.qmc.l_annotations_dict = {}
                        aw.qmc.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = fromCtoF(self.temp1[i])    #ET
                            self.temp2[i] = fromCtoF(self.temp2[i])    #BT
                            if len(self.delta1):
                                self.delta1[i] = RoRfromCtoF(self.delta1[i])  #Delta ET
                            if len(self.delta2):
                                self.delta2[i] = RoRfromCtoF(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                                            aw.qmc.extratemp1[e][i] = fromCtoF(aw.qmc.extratemp1[e][i])
                                        if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                                            aw.qmc.extratemp2[e][i] = fromCtoF(aw.qmc.extratemp2[e][i])
                                    except Exception: # pylint: disable=broad-except
                                        pass
                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = fromCtoF(self.ambientTemp)  #ambient temperature
                        if self.greens_temp is not None and self.greens_temp != 0:
                            self.greens_temp = fromCtoF(self.greens_temp)

                        #prevents accidentally deleting a modified profile.
                        self.fileDirtySignal.emit()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = fromCtoF(self.temp1B[i])
                            self.temp2B[i] = fromCtoF(self.temp2B[i])
                            self.stemp1B[i] = fromCtoF(self.stemp1B[i])
                            self.stemp2B[i] = fromCtoF(self.stemp2B[i])

                        self.fahrenheitMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            aw.sendmessage(QApplication.translate('Message','Profile changed to Fahrenheit'))

                    elif not silent:
                        QMessageBox.information(aw,QApplication.translate('Message', 'Convert Profile Temperature'),
                                                QApplication.translate('Message', 'Unable to comply. You already are in Fahrenheit'))
                        aw.sendmessage(QApplication.translate('Message','Profile not changed'))
                        return

            elif t == 'C':
                if silent:
                    reply = QMessageBox.StandardButton.Yes
                else:
                    string = QApplication.translate('Message', 'Convert profile data to Celsius?')
                    reply = QMessageBox.question(aw,QApplication.translate('Message', 'Convert Profile Temperature'),string,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                if reply == QMessageBox.StandardButton.Yes:
                    if self.mode == 'F':
                        aw.ConvertToFahrenheitAction.setDisabled(True)
                        aw.ConvertToCelsiusAction.setEnabled(True)
                        aw.FahrenheitAction.setDisabled(True)
                        aw.CelsiusAction.setEnabled(True)
                        aw.qmc.l_annotations_dict = {}
                        aw.qmc.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = fromFtoC(self.temp1[i])    #ET
                            self.temp2[i] = fromFtoC(self.temp2[i])    #BT
                            if self.device != 18 or aw.simulator is not None:
                                if len(self.delta1):
                                    self.delta1[i] = RoRfromFtoC(self.delta1[i])  #Delta ET
                                if len(self.delta2):
                                    self.delta2[i] = RoRfromFtoC(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                                            aw.qmc.extratemp1[e][i] = fromFtoC(aw.qmc.extratemp1[e][i])
                                        if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                                            aw.qmc.extratemp2[e][i] = fromFtoC(aw.qmc.extratemp2[e][i])
                                    except Exception: # pylint: disable=broad-except
                                        pass

                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = fromFtoC(self.ambientTemp)  #ambient temperature
                        if self.greens_temp is not None and self.greens_temp != 0:
                            self.greens_temp = fromFtoC(self.greens_temp)

                        #prevents accidentally deleting a modified profile.
                        self.fileDirtySignal.emit()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = fromFtoC(self.temp1B[i]) #ET B
                            self.temp2B[i] = fromFtoC(self.temp2B[i]) #BT B
                            self.stemp1B[i] = fromFtoC(self.stemp1B[i])
                            self.stemp2B[i] = fromFtoC(self.stemp2B[i])

                        self.celsiusMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            aw.sendmessage(QApplication.translate('Message','Profile changed to Celsius'))

                    elif not silent:
                        QMessageBox.information(aw,QApplication.translate('Message', 'Convert Profile Temperature'),
                                                QApplication.translate('Message', 'Unable to comply. You already are in Celsius'))
                        aw.sendmessage(QApplication.translate('Message','Profile not changed'))
                        return

            if not silent:
                self.redraw(recomputeAllDeltas=True,smooth=True)

        elif not silent:
            QMessageBox.information(aw,QApplication.translate('Message', 'Convert Profile Scale'),
                                          QApplication.translate('Message', 'No profile data found'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def changeGColor3(self,_=False):
        self.changeGColor(3)

    #selects color mode: input 1=color mode; input 2=black and white mode (printing); input 3 = customize colors
    def changeGColor(self,color):
        #load selected dictionary
        if color == 1:
            aw.sendmessage(QApplication.translate('Message','Colors set to defaults'))
            fname = os.path.join(getResourcePath(), 'Themes', application_name, 'Default.athm')
            if os.path.isfile(fname) and not self.flagon:
                aw.loadSettings_theme(fn=fname,remember=False,reset=False)
                aw.sendmessage(QApplication.translate('Message','Colors set to Default Theme'))
            else:
                for k in list(self.palette1.keys()):
                    self.palette[k] = self.palette1[k]
                self.backgroundmetcolor     = self.palette['et']
                self.backgroundbtcolor      = self.palette['bt']
                self.backgrounddeltaetcolor = self.palette['deltaet']
                self.backgrounddeltabtcolor = self.palette['deltabt']
                self.backgroundxtcolor      = self.palette['xt']
                self.backgroundytcolor      = self.palette['yt']
                self.EvalueColor = self.EvalueColor_default.copy()
                self.EvalueTextColor = self.EvalueTextColor_default.copy()
                aw.sendmessage(QApplication.translate('Message','Colors set to defaults'))
                aw.closeEventSettings()

        elif color == 2:
            aw.sendmessage(QApplication.translate('Message','Colors set to grey'))
            for k in list(aw.qmc.palette.keys()):
                c = aw.qmc.palette[k]
                nc = aw.convertToGreyscale(c)
                self.palette[k] = nc
            for i in range(len(aw.qmc.extradevices)):
                c = aw.qmc.extradevicecolor1[i]
                aw.qmc.extradevicecolor1[i] = aw.convertToGreyscale(c)
                c = aw.qmc.extradevicecolor2[i]
                aw.qmc.extradevicecolor2[i] = aw.convertToGreyscale(c)
            for i in range(len(aw.qmc.EvalueColor)):
                c = aw.qmc.EvalueColor[i]
                aw.qmc.EvalueColor[i] = aw.convertToGreyscale(c)
            aw.qmc.backgroundmetcolor     = aw.convertToGreyscale(aw.qmc.backgroundmetcolor)
            aw.qmc.backgroundbtcolor      = aw.convertToGreyscale(aw.qmc.backgroundbtcolor)
            aw.qmc.backgrounddeltaetcolor = aw.convertToGreyscale(aw.qmc.backgrounddeltaetcolor)
            aw.qmc.backgrounddeltabtcolor = aw.convertToGreyscale(aw.qmc.backgrounddeltabtcolor)
            aw.qmc.backgroundxtcolor      = aw.convertToGreyscale(aw.qmc.backgroundxtcolor)
            aw.qmc.backgroundytcolor      = aw.convertToGreyscale(aw.qmc.backgroundytcolor)
            aw.setLCDsBW()
            aw.closeEventSettings()

        elif color == 3:
            from artisanlib.colors import graphColorDlg
            dialog = graphColorDlg(aw,aw,aw.graphColorDlg_activeTab)
            if dialog.exec():
                aw.graphColorDlg_activeTab = dialog.TabWidget.currentIndex()
                #
                self.palette['background'] = str(dialog.backgroundButton.text())
                self.palette['grid'] = str(dialog.gridButton.text())
                self.palette['ylabel'] = str(dialog.yButton.text())
                self.palette['xlabel'] = str(dialog.xButton.text())
                self.palette['title'] = str(dialog.titleButton.text())
                self.palette['rect1'] = str(dialog.rect1Button.text())
                self.palette['rect2'] = str(dialog.rect2Button.text())
                self.palette['rect3'] = str(dialog.rect3Button.text())
                self.palette['rect4'] = str(dialog.rect4Button.text())
                self.palette['rect5'] = str(dialog.rect5Button.text())
                self.palette['et'] = str(dialog.metButton.text())
                self.palette['bt'] = str(dialog.btButton.text())
                self.palette['deltaet'] = str(dialog.deltametButton.text())
                self.palette['deltabt'] = str(dialog.deltabtButton.text())
                self.palette['markers'] = str(dialog.markersButton.text())
                self.palette['text'] = str(dialog.textButton.text())
                self.palette['watermarks'] = str(dialog.watermarksButton.text())
                self.palette['timeguide'] = str(dialog.timeguideButton.text())
                self.palette['aucguide'] = str(dialog.aucguideButton.text())
                self.palette['aucarea'] = str(dialog.aucareaButton.text())
                self.palette['canvas'] = str(dialog.canvasButton.text())
                self.palette['legendbg'] = str(dialog.legendbgButton.text())
#                self.palette["legendbgalpha"] = str(dialog.legendbgalphaButton.text())
                self.palette['legendborder'] = str(dialog.legendborderButton.text())
                self.palette['specialeventbox'] = str(dialog.specialeventboxButton.text())
                self.palette['specialeventtext'] = str(dialog.specialeventtextButton.text())
                self.palette['bgeventmarker'] = str(dialog.bgeventmarkerButton.text())
                self.palette['bgeventtext'] = str(dialog.bgeventtextButton.text())
                self.palette['mettext'] = str(dialog.mettextButton.text())
                self.palette['metbox'] = str(dialog.metboxButton.text())
                self.backgroundmetcolor = str(dialog.bgmetButton.text())
                self.backgroundbtcolor  = str(dialog.bgbtButton.text())
                self.backgrounddeltaetcolor = str(dialog.bgdeltametButton.text())
                self.backgrounddeltabtcolor = str(dialog.bgdeltabtButton.text())
                self.backgroundxtcolor = str(dialog.bgextraButton.text())
                self.backgroundytcolor = str(dialog.bgextra2Button.text())
                aw.closeEventSettings()
            #deleteLater() will not work here as the dialog is still bound via the parent
            #dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
            # the following will immediately release the memory despite this parent link
            QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
            try: # sip not supported on older PyQt versions (RPi!)
                sip.delete(dialog)
                #print(sip.isdeleted(dialog))
            except Exception:  # pylint: disable=broad-except
                pass

        #update screen with new colors
        aw.updateCanvasColors()
        aw.applyStandardButtonVisibility()
        aw.update_extraeventbuttons_visibility()
        self.fig.canvas.redraw()

    def clearFlavorChart(self):
        self.flavorchart_plotf = None
        self.flavorchart_angles = None
        self.flavorchart_plot = None
        self.flavorchart_fill = None
        self.flavorchart_labels = None
        self.flavorchart_total = None

    #draws a polar star graph to score cupping. It does not delete any profile data.
    def flavorchart(self):
        try:
            pi = math.pi

            # to trigger a recreation of the standard axis in redraw() we remove them completely
            self.ax = None
            self.delta_ax = None

            self.fig.clf()

            #create a new name ax1 instead of ax (ax is used when plotting profiles)

            if self.ax1 is not None:
                try:
                    self.fig.delaxes(self.ax1)
                except Exception: # pylint: disable=broad-except
                    pass
            self.ax1 = self.fig.add_subplot(111,projection='polar',facecolor='None') #) radar green facecolor='#d5de9c'

            # fixing yticks with matplotlib.ticker "FixedLocator"
            try:
                ticks_loc = self.ax1.get_yticks()
                self.ax1.yaxis.set_major_locator(ticker.FixedLocator(ticks_loc))
            except Exception: # pylint: disable=broad-except
                pass

            self.ax1.set_aspect(self.flavoraspect)

            aw.setFonts(redraw=False)

            #find number of divisions
            nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])


            sa = self.flavorstartangle % (360./nflavors)
            g_angle = numpy.arange(sa,(360.+sa),(360./nflavors))  #angles in degree
            self.ax1.set_thetagrids(g_angle)
            self.ax1.set_rmax(1.)
            self.ax1.set_autoscale_on(False)
            self.ax1.grid(True,linewidth=1.,color='#212121', linestyle = '-',alpha=.3)
            # hack to make flavor labels visible also on top and bottom
            xlabel_artist = self.ax1.set_xlabel(' -\n ', alpha=0.0)
            title_artist = self.ax1.set_title(' -\n ', alpha=0.0)
            try:
                xlabel_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass
            try:
                title_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass

            #create water marks 6-7 anf 8-9
            self.ax1.bar(.1, .1, width=2.*pi, bottom=.6,color='#0c6aa6',linewidth=0.,alpha = .1)
            self.ax1.bar(.1, .1, width=2.*pi, bottom=.8,color='#0c6aa6',linewidth=0.,alpha = .1)

            #delete degrees ticks to anotate flavor characteristics
            for tick in self.ax1.xaxis.get_major_ticks():
                #tick.label1On = False
                tick.label1.set_visible(False)

            fontprop_small = aw.mpl_fontproperties.copy()
            fontprop_small.set_size('x-small')

            #rename yaxis
            locs = self.ax1.get_yticks()
            labels = []
            for i in range(len(locs)):
                stringlabel = str(int(locs[i]*10))
                labels.append(stringlabel)
            self.ax1.set_yticklabels(labels,color=self.palette['xlabel'],fontproperties=fontprop_small)
            self.updateFlavorChartData()

            #anotate labels
            self.flavorchart_labels = []
            for i in range(len(self.flavorlabels)):
                if self.flavorchart_angles[i] > 2.*pi or self.flavorchart_angles[i] < 0.:
                    _,self.flavorchart_angles[i] = divmod(self.flavorchart_angles[i],(2.*pi))
                if self.flavorchart_angles[i] <= (pi/2.) or self.flavorchart_angles[i] >= (1.5*pi): #if < 90 or smaller than 270 degrees
                    ha = 'left'
                else:
                    ha = 'right'
                anno = self.ax1.annotate(self.flavorChartLabelText(i),xy =(self.flavorchart_angles[i],.9),
                                    fontproperties=fontprop_small,
                                    xytext=(self.flavorchart_angles[i],1.1),horizontalalignment=ha,verticalalignment='center')
                try:
                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                    pass
                self.flavorchart_labels.append(anno)

            # total score
            score = self.calcFlavorChartScore()
            txt = '%.2f' %score
            self.flavorchart_total = self.ax1.text(0.,0.,txt,fontsize='x-large',fontproperties=aw.mpl_fontproperties,color='#FFFFFF',horizontalalignment='center',bbox={'facecolor':'#212121', 'alpha':0.5, 'pad':10})

            #add background to plot if found
            if self.background:
                if self.flavorbackgroundflag:
                    if len(aw.qmc.backgroundFlavors) != len(aw.qmc.flavors):
                        message = QApplication.translate('Message','Background does not match number of labels')
                        aw.sendmessage(message)
                        self.flavorbackgroundflag = False
                    else:
                        backgroundplotf = self.backgroundFlavors[:]
                        backgroundplotf.append(self.backgroundFlavors[0])
                        #normalize flavor values to 0-1 range
                        for i in range(len(backgroundplotf)):
                            backgroundplotf[i] /= 10.

                        self.ax1.plot(self.flavorchart_angles,backgroundplotf,color='#cc0f50',marker='o',alpha=.5)
                        #needs matplotlib 1.0.0+
                        self.ax1.fill_between(self.flavorchart_angles,0,backgroundplotf, facecolor='#ff5871', alpha=0.1, interpolate=True)

            #add to plot
            self.flavorchart_plot, = self.ax1.plot(self.flavorchart_angles,self.flavorchart_plotf,color='#0c6aa6',marker='o')

            self.flavorchart_fill = self.ax1.fill_between(self.flavorchart_angles,0,self.flavorchart_plotf, facecolor='#1985ba', alpha=0.1, interpolate=True)

            #self.fig.canvas.draw()
            self.fig.canvas.draw_idle()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def flavorChartLabelText(self,i):
        return aw.arabicReshape(self.flavorlabels[i]) + '\n' + str('%.2f'%self.flavors[i])

    #To close circle we need one more element. angle and values need same dimension in order to plot.
    def updateFlavorChartData(self):
        # update angles
        nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])
        step = 2.*math.pi/nflavors
        startradian = math.radians(self.flavorstartangle)
        self.flavorchart_angles = [startradian]   #angles in radians
        for i in range(nflavors-1): self.flavorchart_angles.append(self.flavorchart_angles[-1] + step)
        self.flavorchart_angles.append(self.flavorchart_angles[-1]+step)
        # update values
        self.flavorchart_plotf = self.flavors[:]
        self.flavorchart_plotf.append(self.flavors[0])
        #normalize flavor values to 0-1 range
        for i in range(len(self.flavorchart_plotf)):
            self.flavorchart_plotf[i] /= 10.

    def calcFlavorChartScore(self):
        score = 0.
        nflavors = len(self.flavors)
        for i in range(nflavors):
            score += self.flavors[i]
        score /= (nflavors)
        score *= 10.
        return score

    # an incremental redraw of the existing flavorchart
    def updateFlavorchartValues(self):
        # update data
        self.updateFlavorChartData()
        self.flavorchart_plot.set_xdata(self.flavorchart_angles)
        self.flavorchart_plot.set_ydata(self.flavorchart_plotf)

        # collections need to be redrawn completely
        try:
            self.flavorchart_fill.remove()
        except Exception: # pylint: disable=broad-except
            pass
        self.flavorchart_fill = self.ax1.fill_between(self.flavorchart_angles,0,self.flavorchart_plotf, facecolor='#1985ba', alpha=0.1, interpolate=True)

        # total score
        score = self.calcFlavorChartScore()
        txt = '%.2f' %score
        self.flavorchart_total.set_text(txt)

        # update canvas
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def updateFlavorchartLabel(self,i):
        label_anno = self.flavorchart_labels[i]
        label_anno.set_text(self.flavorChartLabelText(i))

        # update canvas
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    @staticmethod
    def samplingAction():
        try:
            ###  lock resources ##
            aw.qmc.profileDataSemaphore.acquire(1)
            if aw.qmc.extra_event_sampling_delay != 0:
                aw.eventactionx(aw.qmc.extrabuttonactions[2],aw.qmc.extrabuttonactionstrings[2])
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)

    def AsyncSamplingActionTrigger(self):
        if aw.AsyncSamplingAction and aw.qmc.extra_event_sampling_delay and aw.qmc.extrabuttonactions[2]:
            self.samplingAction()
            QTimer.singleShot(int(round(aw.qmc.extra_event_sampling_delay)),self.AsyncSamplingActionTrigger)

    def StartAsyncSamplingAction(self):
        if aw.qmc.flagon and aw.qmc.extra_event_sampling_delay != 0:
            aw.AsyncSamplingAction = True
            self.AsyncSamplingActionTrigger()

    @staticmethod
    def StopAsyncSamplingAction():
        aw.AsyncSamplingAction = False

    # fill the self.extraNoneTempHint1 and self.extraNoneTempHint2 lists
    # indicating which curves should not be temperature converted
    # True indicates a non-temperature device (data should not be converted)
    # False indicates a temperature device (data should be converted if temperature unit changes)
    def generateNoneTempHints(self):
        self.extraNoneTempHint1 = []
        self.extraNoneTempHint2 = []
        for d in self.extradevices:
            if d in self.nonTempDevices:
                self.extraNoneTempHint1.append(True)
                self.extraNoneTempHint2.append(True)
            elif d == 29: # MODBUS
                self.extraNoneTempHint1.append(aw.modbus.inputModes[0] == '')
                self.extraNoneTempHint2.append(aw.modbus.inputModes[1] == '')
            elif d == 33: # +MODBUS 34
                self.extraNoneTempHint1.append(aw.modbus.inputModes[2] == '')
                self.extraNoneTempHint2.append(aw.modbus.inputModes[3] == '')
            elif d == 55: # +MODBUS 56
                self.extraNoneTempHint1.append(aw.modbus.inputModes[4] == '')
                self.extraNoneTempHint2.append(aw.modbus.inputModes[5] == '')
            elif d == 109: # +MODBUS 78
                self.extraNoneTempHint1.append(aw.modbus.inputModes[6] == '')
                self.extraNoneTempHint2.append(aw.modbus.inputModes[7] == '')
            elif d == 79: # S7
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[0]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[1]))
            elif d == 80: # +S7 34
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[2]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[3]))
            elif d == 81: # +S7 56
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[4]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[5]))
            elif d == 82: # +S7 78
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[6]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[7]))
            elif d == 110: # +S7 910
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[8]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[9]))
            elif d == 111: # WebSocket
                self.extraNoneTempHint1.append(not bool(aw.ws.channel_modes[0]))
                self.extraNoneTempHint2.append(not bool(aw.ws.channel_modes[1]))
            elif d == 112: # +S7 34
                self.extraNoneTempHint1.append(not bool(aw.ws.channel_modes[2]))
                self.extraNoneTempHint2.append(not bool(aw.ws.channel_modes[3]))
            elif d == 113: # +S7 56
                self.extraNoneTempHint1.append(not bool(aw.ws.channel_modes[4]))
                self.extraNoneTempHint2.append(not bool(aw.ws.channel_modes[5]))
            elif d == 118: # +S7 78
                self.extraNoneTempHint1.append(not bool(aw.ws.channel_modes[6]))
                self.extraNoneTempHint2.append(not bool(aw.ws.channel_modes[7]))
            elif d == 119: # +S7 910
                self.extraNoneTempHint1.append(not bool(aw.ws.channel_modes[8]))
                self.extraNoneTempHint2.append(not bool(aw.ws.channel_modes[9]))
            else:
                self.extraNoneTempHint1.append(False)
                self.extraNoneTempHint2.append(False)

    def addPhidgetServer(self):
        if not self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            if self.phidgetServerID == '' and not self.phidgetServiceDiscoveryStarted:
                try:
                    # we enable the automatic service discovery if no server host is given
                    from Phidget22.PhidgetServerType import PhidgetServerType
                    PhidgetNetwork.enableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = True
                    aw.sendmessage(QApplication.translate('Message','Phidget service discovery started...'))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            else:
                PhidgetNetwork.addServer('PhidgetServer',self.phidgetServerID,self.phidgetPort,self.phidgetPassword,0)
                self.phidgetServerAdded = True

    def removePhidgetServer(self):
        if self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            try:
                PhidgetNetwork.removeServer('PhidgetServer')
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.phidgetServerAdded = False
            if self.phidgetServiceDiscoveryStarted:
                try:
                    from Phidget22.PhidgetServerType import PhidgetServerType
                    PhidgetNetwork.disableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = False
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    @staticmethod
    def deviceLogDEBUG():
        from Phidget22.Devices.Log import Log as PhidgetLog
        from Phidget22.LogLevel import LogLevel as PhidgetLogLevel
        PhidgetLog.setLevel(PhidgetLogLevel.PHIDGET_LOG_VERBOSE)

    @staticmethod
    def deviceLLogINFO():
        from Phidget22.Devices.Log import Log as PhidgetLog
        from Phidget22.LogLevel import LogLevel as PhidgetLogLevel
        PhidgetLog.setLevel(PhidgetLogLevel.PHIDGET_LOG_INFO)

    # returns True if any device (main or extra) is a Phidget, ambient sensor or button/slider actions contain Phidget commands
    # the PhidgetManager which makes Phidgets accessible is only started if PhdigetsConfigured returns True
    def PhidgetsConfigured(self):

        # searching sets is faster than lists
        phidget_device_ids = set(self.phidgetDevices)

        # collecting all device ids in use (from main or extra)
        device_ids_in_use = self.extradevices[:]
        device_ids_in_use.append(self.device)

        # collecting ambient device ids in use (ids 1 and 3 indicate Phidgets modules)
        ambient_device_ids = [
            self.ambient_temperature_device,
            self.ambient_humidity_device,
            self.ambient_pressure_device]

        # IO Command, PWM Command, VOUT Command, RC Command
        # Note that those commands could also trigger Yoctopuce actions
        main_button_phidget_action_ids = { 5, 11, 12, 19 }

        # Note that the ids for the same Command types are different here:
        custom_button_phidget_action_ids = { 6, 13, 14, 21 }

        # Note that the ids for the same Command types are different here:
        slider_phidget_action_ids = { 9, 10, 11, 17 }

        return (
            any(i in phidget_device_ids for i in device_ids_in_use) or                    # phidget main/extra device
            any(i in [1, 3] for i in ambient_device_ids) or                               # phidget ambient device
            any(i in main_button_phidget_action_ids for i in self.buttonactions) or       # phidget actions in event button commands (CHARGE, .., COOL)
            any(i in main_button_phidget_action_ids for i in self.extrabuttonactions) or  # phidget actions in main event button commandss (ON, OFF, SAMPLE)
            any(i in main_button_phidget_action_ids for i in self.xextrabuttonactions) or # phidget actions in special event commands (RESET, START)
            any(i in custom_button_phidget_action_ids for i in aw.extraeventsactions) or  # phidget actions in custom event buttons commands
            any(i in slider_phidget_action_ids for i in aw.eventslideractions))           # phidget actions in slider commands


    # the PhidgetManager needs to run to allow Phidgets to attach
    # the PhidgetManager is only started if self.PhidgetsConfigured() returns True signaling
    # that Phidget modules are configured as main/extra devices, ambient devices, or in button/slider actions
    def startPhidgetManager(self):
        # this is needed to suppress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/suppress_error.py fails to suppress this)
        _stderr = sys.stderr
        sys.stderr = object
        try:
            if not app.artisanviewerMode and self.PhidgetsConfigured():
                # Phidget server is only started if any device or action addressing Phidgets is configured
                if self.phidgetManager is None:
                    try:
                        from Phidget22.Devices.Log import Log as PhidgetLog
                        from Phidget22.LogLevel import LogLevel as PhidgetLogLevel
                        PhidgetLog.enable(PhidgetLogLevel.PHIDGET_LOG_DEBUG, self.device_log_file)
                        PhidgetLog.enableRotating()
                        _log.info('phidgetLog started')
                    except Exception: # pylint: disable=broad-except
                        pass # logging might already be enabled
                if self.phidgetRemoteFlag:
                    try:
                        self.addPhidgetServer()
                        _log.info('phidgetServer started')
                    except Exception: # pylint: disable=broad-except
                        if aw.qmc.device in aw.qmc.phidgetDevices:
                            aw.qmc.adderror(QApplication.translate('Error Message',"Exception: PhidgetManager couldn't be started. Verify that the Phidget driver is correctly installed!"))
                if self.phidgetManager is None:
                    try:
                        self.phidgetManager = PhidgetManager()
                        _log.info('phidgetManager started')
                    except Exception: # pylint: disable=broad-except
                        if aw.qmc.device in aw.qmc.phidgetDevices:
                            aw.qmc.adderror(QApplication.translate('Error Message',"Exception: PhidgetManager couldn't be started. Verify that the Phidget driver is correctly installed!"))
        finally:
            sys.stderr = _stderr

    def stopPhidgetManager(self):
        if self.phidgetManager is not None:
            self.phidgetManager.close()
            self.phidgetManager = None
        self.removePhidgetServer()
        try:
            from Phidget22.Devices.Log import Log as PhidgetLog
            PhidgetLog.disable()
        except Exception: # pylint: disable=broad-except
            pass

    def restartPhidgetManager(self):
        self.stopPhidgetManager()
        self.startPhidgetManager()

    # this one is protected by the sampleSemaphore not to mess up with the timex during sampling
    def resetTimer(self):
        try:
            self.samplingSemaphore.acquire(1)
            self.timeclock.start()
        finally:
            if self.samplingSemaphore.available() < 1:
                self.samplingSemaphore.release(1)

    def OnMonitor(self):
        try:
            if aw.simulator is None:
                self.startPhidgetManager()
                # collect ambient data if any
                if self.ambient_pressure_device or self.ambient_humidity_device or self.ambient_temperature_device:
                    self.ambiThread = QThread()
                    self.ambiWorker = AmbientWorker()
                    self.ambiWorker.moveToThread(self.ambiThread)
                    self.ambiThread.started.connect(self.ambiWorker.run)
                    self.ambiWorker.finished.connect(self.ambiThread.quit)
                    self.ambiWorker.finished.connect(self.ambiWorker.deleteLater)
                    self.ambiThread.finished.connect(self.ambiThread.deleteLater)
                    self.ambiThread.start()

            # warm up software PID (write current p-i-d settings,..)
            aw.pidcontrol.confSoftwarePID()

            self.generateNoneTempHints()
            self.block_update = True # block the updating of the bitblit canvas (unblocked at the end of this function to avoid multiple redraws)
            res = aw.qmc.reset(False,False,sampling=True,keepProperties=True)
            if not res: # reset canceled
                self.OffMonitor()
                return

            if not bool(aw.simulator) and aw.qmc.device == 53:
                from artisanlib.hottop import startHottop
                startHottop(0.6,aw.ser.comport,aw.ser.baudrate,aw.ser.bytesize,aw.ser.parity,aw.ser.stopbits,aw.ser.timeout)

            aw.initializedMonitoringExtraDeviceStructures()

            #reset alarms
            self.silent_alarms = False
            self.temporaryalarmflag = -3
            self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
            #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
            self.TPalarmtimeindex = None

            self.flagon = True
            self.redraw(True,sampling=True,smooth=self.optimalSmoothing) # we need to re-smooth with standard smoothing if ON and optimal-smoothing is ticked

            if self.designerflag: return
            aw.sendmessage(QApplication.translate('Message','Scope monitoring...'))
            #disable RESET button:
            aw.buttonRESET.setEnabled(False)
            aw.buttonRESET.setVisible(False)

            # disable "green flag" menu:
            try:
                aw.ntb.disable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            QApplication.processEvents()
            if aw.simulator:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles_simulator['ON'])
            else:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles['ON'])
#            QApplication.processEvents()

            aw.buttonONOFF.setText(QApplication.translate('Button', 'OFF')) # text means click to turn OFF (it is ON)
            aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Stop monitoring'))
            aw.buttonSTARTSTOP.setEnabled(True) # ensure that the START button is enabled
            aw.disableEditMenus()
            aw.update_extraeventbuttons_visibility()
            aw.updateExtraButtonsVisibility()
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.update_minieventline_visibility()
            aw.pidcontrol.activateONOFFeasySV(aw.pidcontrol.svButtons and aw.buttonONOFF.isVisible())
            aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider and aw.buttonONOFF.isVisible())
            self.block_update = False # unblock the updating of the bitblit canvas
            aw.updateReadingsLCDsVisibility() # this one triggers the resize and the recreation of the bitblit canvas
            self.threadserver.createSampleThread()
            if not bool(aw.simulator):
                self.StartAsyncSamplingAction()
            try:
                aw.eventactionx(self.extrabuttonactions[0],self.extrabuttonactionstrings[0])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            _log.info('ON MONITOR')
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OnMonitor() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def OffMonitor(self):
        _log.info('OFF MONITOR')
        try:
            # first activate "Stopping Mode" to ensure that sample() is not resetting the timer now (independent of the flagstart state)

            # stop Recorder if still running
            recording = self.flagstart
            if recording:
                self.OffRecorder(autosave=False) # we autosave after the monitor is turned off to get all the data in the generated PDF!
            self.flagon = False
            # now wait until the current sampling round is done
            while self.flagsampling:
                libtime.sleep(0.05)
                QApplication.processEvents()
            if len(self.timex) < 3:
                # clear data from monitoring-only mode
                aw.qmc.clearMeasurements()
            else:
                # we only reset the LCDs, but keep the readings
                aw.qmc.clearLCDs()

            aw.pidcontrol.pidOff()
#            if aw.qmc.device == 53:
#                aw.HottopControlOff()
            # at OFF we stop the follow-background on FujiPIDs and set the SV to 0
            if self.device == 0 and aw.fujipid.followBackground:
                if aw.fujipid.sv and aw.fujipid.sv > 0:
                    try:
                        aw.fujipid.setsv(0,silent=True)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    aw.fujipid.sv = 0
            QTimer.singleShot(5,self.disconnectProbes)
            # reset the canvas color when it was set by an alarm but never reset
            if 'canvas_alt' in aw.qmc.palette:
                self.palette['canvas'] = self.palette['canvas_alt']
                aw.updateCanvasColors(checkColors=False)
            #enable RESET button:
            aw.buttonRESET.setStyleSheet(aw.pushbuttonstyles['RESET'])
            aw.buttonRESET.setEnabled(True)
            aw.buttonRESET.setVisible(True)

            # reset a stopped simulator
            aw.sample_loop_running = True
            aw.time_stopped = 0

            # enable "green flag" menu:
            try:
                aw.ntb.enable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            if aw.simulator:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles_simulator['OFF'])
            else:
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles['OFF'])
            aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Start monitoring'))
            aw.sendmessage(QApplication.translate('Message','Scope stopped'))
            aw.buttonONOFF.setText(QApplication.translate('Button', 'ON')) # text means click to turn OFF (it is ON)
            # reset time LCD color to the default (might have been changed to red due to long cooling!)
            aw.updateReadingsLCDsVisibility()
            # reset WebLCDs
            if aw.qmc.LCDdecimalplaces:
                resLCD = '-.-'
            else:
                resLCD = '--'
            if aw.WebLCDs:
                self.updateWebLCDs(bt=resLCD,et=resLCD)
            if not aw.HottopControlActive:
                aw.hideExtraButtons(changeDefault=False)
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.update_minieventline_visibility()
            aw.updateExtraButtonsVisibility()
            aw.pidcontrol.activateONOFFeasySV(False)
            self.StopAsyncSamplingAction()
            aw.enableEditMenus()

            aw.autoAdjustAxis()
            aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
            # HACK:
            # with visible (draggable) legend a click (or several) on the canvas makes the extra lines disappear
            # this happens after real recordings or simlator runs and also if signals onclick/onpick/ondraw are disconnected
            # solutions are to run an updateBackground() or another redraw() about in 100s using a QTimer
            # also a call  to self.fig.canvas.flush_events() or QApplication.processEvents() here resolves it. A libtime.sleep(1) does not solve the issue
#            QTimer.singleShot(100,self.updateBackground) # solves the issue
#            self.fig.canvas.flush_events() # solves the issue
            QApplication.processEvents()  # solves the issue

            if len(self.timex) > 2:
                # we autosave after full redraw after OFF to have the optional generated PDF containing all information
                if aw.qmc.autosaveflag and aw.qmc.autosavepath:
                    try:
                        aw.automaticsave()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
            aw.eventactionx(aw.qmc.extrabuttonactions[1],aw.qmc.extrabuttonactionstrings[1])

            # update error dlg
            if aw.error_dlg:
                aw.error_dlg.update()
            #update serial_dlg
            if aw.serial_dlg:
                try:
                    aw.serial_dlg.update()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

            if recording and self.flagKeepON and len(self.timex) > 10:
                self.OnMonitor()

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' OffMonitor() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def getAmbientData(self):
        _log.debug('getAmbientData()')
        # this is needed to suppress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/suppresss_error.py fails to suppress this)
        _stderr = sys.stderr
        sys.stderr = object
        try:
            humidity = None
            temp = None # assumed to be gathered in C (not F!)
            pressure = None

            #--- humidity
            if self.ambient_humidity_device == 1: # Phidget HUM1000
                humidity = aw.ser.PhidgetHUM1000humidity()
            elif self.ambient_humidity_device == 2: # Yocto Meteo
                humidity = aw.ser.YoctoMeteoHUM()

            #--- temperature
            if self.ambient_temperature_device == 1: # Phidget HUM1000
                temp = aw.ser.PhidgetHUM1000temperature()
            elif self.ambient_temperature_device == 2: # Yocto Meteo
                temp = aw.ser.YoctoMeteoTEMP()
            elif self.ambient_temperature_device == 3: # Phidget TMP1000
                temp = aw.ser.PhidgetTMP1000temperature()

            #--- pressure
            if self.ambient_pressure_device == 1: # Phidget PRE1000
                pressure = aw.ser.PhidgetPRE1000pressure()
                if pressure is not None:
                    pressure = pressure * 10 # convert to hPa/mbar
            elif self.ambient_pressure_device == 2: # Yocto Meteo
                pressure = aw.ser.YoctoMeteoPRESS()

            # calc final values
            if pressure is not None:
                if temp is None or temp<-20 or temp>40:
                    t = 23 # we just assume 23C room temperature if no ambient temperature is given or ambient temperature is out of range
                else:
                    t = temp
                pressure = self.barometricPressure(pressure,t,self.elevation)

            # set and report
            if humidity is not None:
                self.ambient_humidity = aw.float2float(humidity,1)
                self.ambient_humidity_sampled = self.ambient_humidity
                aw.sendmessage(QApplication.translate('Message','Humidity: {}%').format(self.ambient_humidity))
                libtime.sleep(1)

            if temp is not None:
                if self.mode == 'F':
                    temp = fromCtoF(temp)
                self.ambientTemp = aw.float2float(temp,1)
                self.ambientTemp_sampled = self.ambientTemp
                aw.sendmessage(QApplication.translate('Message','Temperature: {}{}').format(self.ambientTemp,self.mode))
                libtime.sleep(1)

            if pressure is not None:
                self.ambient_pressure = aw.float2float(pressure,1)
                self.ambient_pressure_sampled = self.ambient_pressure
                aw.sendmessage(QApplication.translate('Message','Pressure: {}hPa').format(self.ambient_pressure))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        finally:
            sys.stderr = _stderr

    # computes the barometric pressure from
    #   aap:  atmospheric pressure in hPa
    #   atc:  temperature in Celsius
    #   hasl: height above sea level in m
    # see https://www.wmo.int/pages/prog/www/IMOP/meetings/SI/ET-Stand-1/Doc-10_Pressure-red.pdf
    @staticmethod
    def barometricPressure(aap, atc, hasl):
        return aap * pow((1 - ((0.0065*hasl) / (atc + (0.0065*hasl) + 273.15))),-5.257)

    # close serial port, Phidgets and Yocto ports
    def disconnectProbesFromSerialDevice(self, ser):
        try:
            self.samplingSemaphore.acquire(1)
            # close main serial port
            try:
                ser.closeport()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # disconnect phidgets
            if ser.PhidgetTemperatureSensor is not None:
                try:
                    if ser.PhidgetTemperatureSensor[0].getAttached():
                        serial = ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber()
                        port = ser.PhidgetTemperatureSensor[0].getHubPort()  # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetTemperatureSensor[0].getDeviceID()
                        ser.PhidgetTemperatureSensor[0].close()
                        ser.phidget1048detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetTemperatureSensor) > 1 and ser.PhidgetTemperatureSensor[1].getAttached():
                        serial = ser.PhidgetTemperatureSensor[1].getDeviceSerialNumber()
                        port = ser.PhidgetTemperatureSensor[1].getHubPort()  # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetTemperatureSensor[1].getDeviceID()
                        ser.PhidgetTemperatureSensor[1].close()
                        ser.phidget1048detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.Phidget1048values = [[],[],[],[]]
                ser.Phidget1048lastvalues = [-1]*4
                ser.PhidgetTemperatureSensor = None
            if ser.PhidgetIRSensor is not None:
                try:
                    if ser.PhidgetIRSensor.getAttached():
                        serial = ser.PhidgetIRSensor.getDeviceSerialNumber()
                        port = ser.PhidgetIRSensor.getHubPort() # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetIRSensor.getDeviceID()
                        ser.PhidgetIRSensor.close()
                        ser.phidget1045detached(serial,port,deviceType) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if ser.PhidgetIRSensorIC is not None and ser.PhidgetIRSensorIC.getAttached():
                        ser.PhidgetIRSensorIC.close()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.PhidgetIRSensor = None
                ser.Phidget1045values = [] # async values of the one channel
                ser.Phidget1045lastvalue = -1
                ser.Phidget1045tempIRavg = None
                ser.PhidgetIRSensorIC = None
            if ser.PhidgetBridgeSensor is not None:
                try:
                    if ser.PhidgetBridgeSensor[0].getAttached():
                        serial = ser.PhidgetBridgeSensor[0].getDeviceSerialNumber()
                        port = ser.PhidgetBridgeSensor[0].getHubPort()   # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetBridgeSensor[0].getDeviceID()
                        ser.PhidgetBridgeSensor[0].close()
                        ser.phidget1046detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetBridgeSensor) > 1 and ser.PhidgetBridgeSensor[1].getAttached():
                        serial = ser.PhidgetBridgeSensor[1].getDeviceSerialNumber()
                        port = ser.PhidgetBridgeSensor[1].getHubPort()   # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetBridgeSensor[1].getDeviceID()
                        ser.PhidgetBridgeSensor[1].close()
                        ser.phidget1046detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.Phidget1046values = [[],[],[],[]]
                ser.Phidget1046lastvalues = [-1]*4
                ser.PhidgetBridgeSensor = None
            if ser.PhidgetIO is not None:
                try:
                    if ser.PhidgetIO[0].getAttached():
                        serial = ser.PhidgetIO[0].getDeviceSerialNumber()
                        port = ser.PhidgetIO[0].getHubPort()   # returns 0 for USB Phidgets!
                        className = ser.PhidgetIO[0].getChannelClassName()
                        deviceType = ser.PhidgetIO[0].getDeviceID()
                        ser.PhidgetIO[0].close()
                        ser.phidget1018detached(serial,port,className,deviceType,0)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetIO) > 1 and ser.PhidgetIO[1].getAttached():
                        serial = ser.PhidgetIO[1].getDeviceSerialNumber()
                        port = ser.PhidgetIO[1].getHubPort()   # returns 0 for USB Phidgets!
                        className = ser.PhidgetIO[1].getChannelClassName()
                        deviceType = ser.PhidgetIO[1].getDeviceID()
                        ser.PhidgetIO[1].close()
                        ser.phidget1018detached(serial,port,className,deviceType,1)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.PhidgetIO = None
                ser.PhidgetIOvalues = [[],[],[],[],[],[],[],[]]
                ser.PhidgetIOlastvalues = [-1]*8
            if ser.YOCTOsensor is not None:
                try:
                    ser.YOCTOsensor = None
                    ser.YOCTOchan1 = None
                    ser.YOCTOchan2 = None
                    ser.YOCTOtempIRavg = None
                    if ser.YOCTOthread is not None:
                        ser.YOCTOthread.join()
                        ser.YOCTOthread = None
                    ser.YOCTOvalues = [[],[]]
                    ser.YOCTOlastvalues = [-1]*2
                    YAPI.FreeAPI()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        finally:
            if self.samplingSemaphore.available() < 1:
                self.samplingSemaphore.release(1)

    # close Phidget and and Yocto outputs
    @staticmethod
    def closePhidgetOUTPUTs():
        # close Phidget Digital Outputs
        aw.ser.phidgetOUTclose()
        # close Phidget Digital Outputs on Hub
        aw.ser.phidgetOUTcloseHub()
        # close Phidget IO Outputs
        aw.ser.phidgetBinaryOUTclose()
        # close Phidget Analog Outputs
        aw.ser.phidgetVOUTclose()
        # close Phidget DCMotors
        aw.ser.phidgetDCMotorClose()
        # close Phidget RC Servos
        aw.ser.phidgetRCclose()
        # close Yocto Voltage Outputs
        aw.ser.yoctoVOUTclose()
        # close Yocto Current Outputs
        aw.ser.yoctoCOUTclose()
        # close Yocto Relay Outputs
        aw.ser.yoctoRELclose()
        # close Yocto Servo Outputs
        aw.ser.yoctoSERVOclose()
        # close Yocto PWM Outputs
        aw.ser.yoctoPWMclose()

    @staticmethod
    def closePhidgetAMBIENTs():
        # note that we do not unregister this detach in the aw.qmc.phidgetManager as we only support one of those devices
        try:
            if aw.ser.TMP1000temp is not None and aw.ser.TMP1000temp.getAttached():
                aw.ser.TMP1000temp.close()
                _log.debug('Phidget TMP1000 temperature channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if aw.ser.PhidgetHUMtemp is not None and aw.ser.PhidgetHUMtemp.getAttached():
                aw.ser.PhidgetHUMtemp.close()
                _log.debug('Phidget HUM100x temperature channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if aw.ser.PhidgetHUMhum is not None and aw.ser.PhidgetHUMhum.getAttached():
                aw.ser.PhidgetHUMhum.close()
                _log.debug('Phidget HUM100x humidity channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if aw.ser.PhidgetPREpre is not None and aw.ser.PhidgetPREpre.getAttached():
                aw.ser.PhidgetPREpre.close()
                _log.debug('Phidget PRE1000 pressure channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)


    def disconnectProbes(self):
        # close ports of main device
        self.disconnectProbesFromSerialDevice(aw.ser)
        # close (serial) port of Modbus device
        aw.modbus.disconnect()
        # close port of S7 device
        aw.s7.disconnect()
        # close WebSocket connection
        aw.ws.disconnect()
        # close ports of extra devices
        for i in range(len(aw.extraser)):
            self.disconnectProbesFromSerialDevice(aw.extraser[i])

    @pyqtSlot()
    def toggleMonitorTigger(self):
        self.ToggleMonitor()

    #Turns ON/OFF flag self.flagon to read and print values. Called from push buttonONOFF.
    @pyqtSlot(bool)
    def ToggleMonitor(self,_=False):
        #turn ON
        if not self.flagon:
            QApplication.processEvents()
            # the sample thread might still run, but should terminate soon. We do nothing and ignore this click on ON
            if not aw.qmc.flagsamplingthreadrunning:
                if not self.checkSaved():
                    return
                aw.soundpopSignal.emit()
                self.OnMonitor()
        #turn OFF
        else:
            try:
                aw.soundpopSignal.emit()
            except Exception: # pylint: disable=broad-except
                pass
            self.OffMonitor()

    def fireChargeTimer(self):
        self.autoChargeIdx = max(1,len(self.timex))

    def OnRecorder(self):
        try:

            # if on turn mouse crosslines off
            if self.crossmarker:
                self.togglecrosslines()
            self.set_xlabel('')
            self.ax.set_ylabel('')
            if not self.title_show_always:
                self.setProfileTitle('')

            aw.cacheCurveVisibilities()

            # disable "green flag" menu:
            try:
                aw.ntb.disable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # reset LCD timer color that might have been reset by the RS PID in monitoring mode:
            aw.setTimerColor('timer')
            if self.delta_ax:
                y_label = self.delta_ax.set_ylabel('')
                try:
                    y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass

            self.resetTimer() #reset time, otherwise the recorded timestamps append to the time on START after ON!

            self.flagstart = True

            self.timealign(redraw=True)

            # start Monitor if not yet running
            if not self.flagon:
                self.OnMonitor()
            try:
                aw.eventactionx(self.xextrabuttonactions[1],self.xextrabuttonactionstrings[1])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # update the roasts start time
            self.roastdate = QDateTime.currentDateTime()
            self.roastepoch = self.roastdate.toSecsSinceEpoch()
            self.roasttzoffset = libtime.timezone

            self.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
            self.roastbatchpos = 1 # initialized to 1, set to increased batchsequence on DROP
            if not self.title_show_always:
                self.fig.suptitle('')
            self.profile_sampling_interval = self.delay / 1000.
            self.updateDeltaSamples()
            aw.disableSaveActions()
            aw.sendmessage(QApplication.translate('Message','Scope recording...'))
            aw.buttonSTARTSTOP.setEnabled(False)
            aw.buttonSTARTSTOP.setGraphicsEffect(None)
            aw.buttonONOFF.setText(QApplication.translate('Button', 'OFF')) # text means click to turn OFF (it is ON)
            aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Stop recording'))
            aw.buttonONOFF.setEnabled(True) # ensure that the OFF button is enabled
            #disable RESET button:
            aw.buttonRESET.setEnabled(False)
            self.updateLCDtime()
            aw.lowerbuttondialog.setVisible(True)
            aw.applyStandardButtonVisibility()
            if aw.keyboardmoveflag:
                aw.keyboardmoveflag = 0
                aw.moveKbutton('enter', force=True)

            aw.update_extraeventbuttons_visibility()
            aw.updateExtraButtonsVisibility()

            if aw.qmc.buttonvisibility[0]: # if CHARGE button is visible we let it blink on START
                aw.buttonCHARGE.startAnimation()

            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.update_minieventline_visibility()
            aw.updateReadingsLCDsVisibility() # update visibility of reading LCDs based on the user preference
            if aw.qmc.phasesLCDflag:
                aw.phasesLCDs.show()
                aw.TP2DRYlabel.setStyleSheet("background-color:'transparent'; color: " + aw.qmc.palette['messages'] + ';')
                aw.DRY2FCslabel.setStyleSheet("background-color:'transparent'; color: " + aw.qmc.palette['messages'] + ';')
            if aw.qmc.AUClcdFlag:
                aw.AUCLCD.show()

            aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[0]

            aw.update_minieventline_visibility()

            # set CHARGEtimer
            if self.chargeTimerFlag:
                if self.chargeTimerPeriod > 0:
                    aw.setTimerColor('slowcoolingtimer')
                QTimer.singleShot(self.chargeTimerPeriod*1000, self.fireChargeTimer)


            _log.info('START RECORDING')
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' OnRecorder() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def OffRecorder(self, autosave=True):
        _log.info('STOP RECORDING')
        try:
            # mark DROP if not yet set, at least 7min roast time and CHARGE is set and either autoDROP is active or DROP button is hidden
            if self.timeindex[6] == 0 and aw.qmc.timeindex[0] != -1 and (self.autoDropFlag or not self.buttonvisibility[6]):
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
                if (len(self.timex)>0 and self.timex[-1] - start) > 7*60: # only after 7min into the roast
                    self.markDrop()
            aw.enableSaveActions()
            aw.resetCurveVisibilities()
            self.flagstart = False
            if aw.simulator:
                aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles_simulator['STOP'])
            else:
                aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles['STOP'])
            aw.buttonSTARTSTOP.setEnabled(True)
            aw.buttonSTARTSTOP.setGraphicsEffect(aw.makeShadow())
            #enable RESET button:
            aw.buttonRESET.setStyleSheet(aw.pushbuttonstyles['RESET'])
            aw.buttonRESET.setEnabled(True)
            self.updateLCDtime()
            #prevents accidentally deleting a modified profile:
            if len(self.timex) > 2:
                self.fileDirtySignal.emit()
                aw.autoAdjustAxis() # automatic adjust axis after roast if auto axis is enabled
            try:
                if aw.clusterEventsFlag:
                    aw.clusterEvents()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            if autosave and aw.qmc.autosaveflag and aw.qmc.autosavepath:
                try:
                    aw.automaticsave()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            aw.sendmessage(QApplication.translate('Message','Scope recording stopped'))
            aw.buttonSTARTSTOP.setText(QApplication.translate('Button', 'START'))
            aw.lowerbuttondialog.setVisible(False)
            aw.messagelabel.setVisible(True)
            aw.phasesLCDs.hide()
            aw.AUCLCD.hide()
            aw.hideEventsMinieditor()

            # enable "green flag" menu:
            try:
                aw.ntb.enable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' OffRecorder() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    def toggleRecorderTigger(self):
        if self.flagstart:
            self.ToggleMonitor()
        else:
            self.ToggleRecorder()

    #Turns START/STOP flag self.flagon to read and plot. Called from push buttonSTARTSTOP.
    @pyqtSlot(bool)
    def ToggleRecorder(self,_=False):
        #turn START
        if not self.flagstart:
            if not self.checkSaved():
                return
            aw.soundpopSignal.emit()
            if self.flagon and len(self.timex) == 1:
                # we are already in monitoring mode, we just clear this first measurement and go
                aw.qmc.clearMeasurements(andLCDs=False)
            elif self.timex != []: # there is a profile loaded, we have to reset
                aw.qmc.reset(True,False,keepProperties=True)
            try:
                settings = QSettings()
                starts = 0
                if settings.contains('starts'):
                    starts = toInt(settings.value('starts'))
                settings.setValue('starts',starts+1)
                settings.sync()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.OnRecorder()
        #turn STOP
        else:
            aw.soundpopSignal.emit()
            self.OffRecorder()

    # trigger to be called by the markChargeSignal
    # if delay is not 0, the markCharge is issues after n milliseconds
    @pyqtSlot(int)
    def markChargeDelay(self,delay):
        if delay == 0:
            self.markCharge()
        else:
            QTimer.singleShot(delay,self.markChargeTrigger)

    def markChargeTrigger(self):
        self.markCharge()

    #Records charge (put beans in) marker. called from push button 'Charge'
    @pyqtSlot(bool)
    def markCharge(self,_=False):
        try:
            aw.qmc.profileDataSemaphore.acquire(1)
            if self.flagstart:
                removed = False
                try:
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()
                    if aw.buttonCHARGE.isFlat() and self.timeindex[0] > -1:
                        # undo wrongly set CHARGE
                        ## deactivate autoCHARGE
                        ##aw.qmc.autoCHARGEenabled = False
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 0 in self.l_annotations_dict:
                                del self.l_annotations_dict[0]
                            self.timeindex[0] = -1
                            removed = True
                            self.xaxistosm(redraw=False)
                    elif not aw.buttonCHARGE.isFlat():
                        if self.device == 18 and aw.simulator is None: #manual mode
                            tx,et,bt = aw.ser.NONE()
                            if bt != 1 and et != -1:  #cancel
                                self.drawmanual(et,bt,tx)
                                self.timeindex[0] = len(self.timex)-1
                            else:
                                return
                        else:
                            if self.autoChargeIdx:
                                # prevent CHARGE outofindex:
                                if len(self.timex) > self.autoChargeIdx:
                                    self.timeindex[0] = self.autoChargeIdx
                                elif len(self.timex) > self.autoChargeIdx - 1:
                                    # not yet enough readings
                                    self.timeindex[0] = self.autoChargeIdx - 1
                                else:
                                    return
                            else:
                                if len(self.timex) > 0:
                                    self.timeindex[0] = len(self.timex)-1
                                else:
                                    self.autoChargeIdx = 1 # set CHARGE on next (first) reading
                                    message = QApplication.translate('Message','Not enough data collected yet. Try again in a few seconds')
                                    aw.sendmessage(message)
                                    return
                            if aw.pidcontrol.pidOnCHARGE and not aw.pidcontrol.pidActive: # Arduino/TC4, Hottop, MODBUS
                                aw.pidcontrol.pidOn()
                        if self.chargeTimerPeriod > 0:
                            aw.setTimerColor('timer')
                        try:
                            # adjust startofx to the new timeindex[0] as it depends on timeindex[0]
                            if self.locktimex:
                                self.startofx = self.locktimex_start + self.timex[self.timeindex[0]]
                            else:
                                self.startofx = self.chargemintime + self.timex[self.timeindex[0]] # we set the min x-axis limit to the CHARGE Min time
                        except Exception: # pylint: disable=broad-except
                            pass

                        self.xaxistosm(redraw=False) # need to fix uneven x-axis labels like -0:13

                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                            t2 = self.temp2[self.timeindex[0]]
                            tx = self.timex[self.timeindex[0]]
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,t2,t2,d)
                            self.l_annotations += self.annotate(t2,st1,tx,t2,self.ystep_up,self.ystep_down,draggable_anno_key=0)

                        # mark active slider values that are not zero
                        for slidernr in range(4):
                            if aw.eventslidervisibilities[slidernr]:
                                # we record also for inactive sliders as some button press actions might have changed the event values also for those
                                if slidernr == 0:
                                    slidervalue = aw.slider1.value()
                                elif slidernr == 1:
                                    slidervalue = aw.slider2.value()
                                elif slidernr == 2:
                                    slidervalue = aw.slider3.value()
                                elif slidernr == 3:
                                    slidervalue = aw.slider4.value()
                                # only mark events that are non-zero # and have not been marked before not to duplicate the event values
                                if slidervalue != 0: #  and slidernr not in self.specialeventstype:
                                    value = aw.float2float((slidervalue + 10.0) / 10.0)
                                    # note that EventRecordAction avoids to generate events were type and value matches to the previously recorded one
                                    aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,takeLock=False,doupdategraphics=False)
                                    # we don't take another lock in EventRecordAction as we already hold that lock!
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            else:
                message = QApplication.translate('Message','CHARGE: Scope is not recording')
                aw.sendmessage(message)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' markCharge() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
            aw.qmc.timealign(redraw=True,recompute=False,force=True) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            if aw.buttonCHARGE.isFlat():
                if removed:
                    aw.buttonCHARGE.setFlat(False)
                    aw.buttonCHARGE.startAnimation()
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.eventactionx(aw.qmc.buttonactions[0],aw.qmc.buttonactionstrings[0])
                aw.buttonCHARGE.setFlat(True)
                aw.buttonCHARGE.stopAnimation()
                try:
                    if aw.qmc.LCDdecimalplaces:
                        fmt = '%.1f'
                    else:
                        fmt = '%.0f'
                    bt = fmt%self.temp2[self.timeindex[0]] + aw.qmc.mode
                    message = QApplication.translate('Message','Roast time starts now 00:00 BT = {0}').format(bt)
                    aw.sendmessage(message)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                if aw.qmc.roastpropertiesAutoOpenFlag:
                    aw.openPropertiesSignal.emit()
                if not(self.autoChargeIdx and aw.qmc.timeindex[0] < 0):
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            aw.onMarkMoveToNext(aw.buttonCHARGE)


    # called from sample() and marks the autodetected TP visually on the graph
    def markTP(self):
        try:
            self.profileDataSemaphore.acquire(1)
            if self.flagstart and self.markTPflag:
                if aw.qmc.TPalarmtimeindex and self.timeindex[0] != -1 and len(self.timex) > aw.qmc.TPalarmtimeindex:
                    st = stringfromseconds(self.timex[aw.qmc.TPalarmtimeindex]-self.timex[self.timeindex[0]],False)
                    st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}').format(st))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[aw.qmc.TPalarmtimeindex],d)
                    self.l_annotations += self.annotate(self.temp2[aw.qmc.TPalarmtimeindex],st1,self.timex[aw.qmc.TPalarmtimeindex],self.temp2[aw.qmc.TPalarmtimeindex],self.ystep_up,self.ystep_down,0,1.,draggable_anno_key=-1)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need to update the background cache with the new annotation
                    st2 = '%.1f '%self.temp2[aw.qmc.TPalarmtimeindex] + self.mode
                    message = QApplication.translate('Message','[TP] recorded at {0} BT = {1}').format(st,st2)
                    #set message at bottom
                    aw.sendmessage(message)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' markTP() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        self.autoTPIdx = 0 # avoid a loop on auto marking

    # trigger to be called by the markDRYSignal
    @pyqtSlot()
    def markDRYTrigger(self):
        self.markDryEnd()

    @pyqtSlot(bool)
    def markDryEnd(self,_=False):
        if len(self.timex) > 1:
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonDRY.isFlat() and self.timeindex[1] > 0:
                        # undo wrongly set DRY
                        # deactivate autoDRY
                        aw.qmc.autoDRYenabled = False
                        st = stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                        DE_str = aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}').format(st))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == DE_str:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 1 in self.l_annotations_dict:
                                del self.l_annotations_dict[1]
                            self.timeindex[1] = 0
                            removed = True
                    elif not aw.buttonDRY.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[1] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[1] = max(0,len(self.timex)-1)
                            else:
                                return
                        if aw.qmc.phasesbuttonflag:
                            self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            #calculate time elapsed since charge time
                            st = stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}').format(st))
                            #anotate temperature
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[1]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[1]],st1,self.timex[self.timeindex[1]],self.temp2[self.timeindex[1]],self.ystep_up,self.ystep_down,draggable_anno_key=1)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need

                        aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[1]

                else:
                    message = QApplication.translate('Message','DRY END: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' markDryEnd() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [1,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonDRY.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonDRY.setFlat(False)
                        if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                            aw.buttonCHARGE.setFlat(False)
                            if aw.qmc.buttonvisibility[0]:
                                aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit()
                else:
                    aw.buttonDRY.setFlat(True) # deactivate DRY button
                    aw.buttonCHARGE.setFlat(True) # also deactivate CHARGE button
                    aw.buttonCHARGE.stopAnimation()
                    try:
                        aw.eventactionx(aw.qmc.buttonactions[1],aw.qmc.buttonactionstrings[1])
                        if self.timeindex[0] > -1:
                            start = self.timex[self.timeindex[0]]
                        else:
                            start = 0
                        st = stringfromseconds(self.timex[self.timeindex[1]]-start)
                        st2 = '%.1f '%self.temp2[self.timeindex[1]] + self.mode
                        message = QApplication.translate('Message','[DRY END] recorded at {0} BT = {1}').format(st,st2)
                        #set message at bottom
                        aw.sendmessage(message)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    if self.autoDryIdx == 0:
                        # only if markDryEnd() is not anyhow triggered within updategraphics()
                        self.updategraphicsSignal.emit()
                aw.onMarkMoveToNext(aw.buttonDRY)

    # trigger to be called by the markFCsSignal
    @pyqtSlot()
    def markFCsTrigger(self):
        self.mark1Cstart()

    #record 1C start markers of BT. called from push buttonFCs of application window
    @pyqtSlot(bool)
    def mark1Cstart(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonFCs.isFlat() and self.timeindex[2] > 0:
                        # undo wrongly set FCs
                        # deactivate autoFCs
                        aw.qmc.autoFCsenabled = False
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}').format(stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 2 in self.l_annotations_dict:
                                del self.l_annotations_dict[2]
                            self.timeindex[2] = 0
                            removed = True
                    elif not aw.buttonFCs.isFlat():
                        # record 1Cs only if Charge mark has been done
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[2] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[2] = max(0,len(self.timex)-1)
                            else:
                                return
                        if aw.qmc.phasesbuttonflag:
                            self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            #calculate time elapsed since charge time
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}').format(stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            if self.timeindex[1]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[2]],d)
                            else:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[2]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[2]],st1,self.timex[self.timeindex[2]],self.temp2[self.timeindex[2]],self.ystep_up,self.ystep_down,draggable_anno_key=2)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need

                        aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[2]
                else:
                    message = QApplication.translate('Message','FC START: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark1Cstart() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [2,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonFCs.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonFCs.setFlat(False)
                        if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                            aw.buttonDRY.setFlat(False)
                            if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                aw.buttonCHARGE.setFlat(False)
                                if aw.qmc.buttonvisibility[0]:
                                    aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:
                    aw.buttonFCs.setFlat(True)
                    aw.buttonCHARGE.setFlat(True)
                    aw.buttonCHARGE.stopAnimation()
                    aw.buttonDRY.setFlat(True)
                    aw.eventactionx(aw.qmc.buttonactions[2],aw.qmc.buttonactionstrings[2])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[2]]-start)
                    st2 = '%.1f '%self.temp2[self.timeindex[2]] + self.mode
                    message = QApplication.translate('Message','[FC START] recorded at {0} BT = {1}').format(st1,st2)
                    aw.sendmessage(message)
                    if self.autoFCsIdx == 0:
                        # only if mark1Cstart() is not triggered from within updategraphics() and the canvas is anyhow updated
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                aw.onMarkMoveToNext(aw.buttonFCs)

    # trigger to be called by the markFCeSignal
    @pyqtSlot()
    def markFCeTrigger(self):
        self.mark1Cend()

    #record 1C end markers of BT. called from buttonFCe of application window
    @pyqtSlot(bool)
    def mark1Cend(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonFCe.isFlat() and self.timeindex[3] > 0:
                        # undo wrongly set FCe
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}').format(stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 3 in self.l_annotations_dict:
                                del self.l_annotations_dict[3]
                            self.timeindex[3] = 0
                            removed = True
                    elif not aw.buttonFCe.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[3] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[3] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            #calculate time elapsed since charge time
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}').format(stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[3]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[3]],st1,self.timex[self.timeindex[3]],self.temp2[self.timeindex[3]],self.ystep_up,self.ystep_down,draggable_anno_key=3)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','FC END: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark1Cend() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [3,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonFCe.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonFCe.setFlat(False)
                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                            aw.buttonFCs.setFlat(False)
                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                aw.buttonDRY.setFlat(False)
                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                    aw.buttonCHARGE.setFlat(False)
                                    if aw.qmc.buttonvisibility[0]:
                                        aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:
                    aw.buttonFCe.setFlat(True)
                    aw.buttonCHARGE.setFlat(True)
                    aw.buttonCHARGE.stopAnimation()
                    aw.buttonDRY.setFlat(True)
                    aw.buttonFCs.setFlat(True)
                    aw.eventactionx(aw.qmc.buttonactions[3],aw.qmc.buttonactionstrings[3])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[3]]-start)
                    st2 = '%.1f '%self.temp2[self.timeindex[3]] + self.mode
                    message = QApplication.translate('Message','[FC END] recorded at {0} BT = {1}').format(st1,st2)
                    aw.sendmessage(message)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                aw.onMarkMoveToNext(aw.buttonFCe)


    # trigger to be called by the markSCsSignal
    @pyqtSlot()
    def markSCsTrigger(self):
        self.mark2Cstart()

    #record 2C start markers of BT. Called from buttonSCs of application window
    @pyqtSlot(bool)
    def mark2Cstart(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonSCs.isFlat() and self.timeindex[4] > 0:
                        # undo wrongly set FCs
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}').format(stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 4 in self.l_annotations_dict:
                                del self.l_annotations_dict[4]
                            self.timeindex[4] = 0
                            removed = True
                    elif not aw.buttonSCs.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[4] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[4] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}').format(stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            if self.timeindex[3]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[4]],d)
                            else:
                                self.ystep_down,self.ystep_up = self.findtextgap(0,0,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[4]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[4]],st1,self.timex[self.timeindex[4]],self.temp2[self.timeindex[4]],self.ystep_up,self.ystep_down,draggable_anno_key=4)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','SC START: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark2Cstart() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [4,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonSCs.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonSCs.setFlat(False)
                        if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                            aw.buttonFCe.setFlat(False)
                            if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                aw.buttonFCs.setFlat(False)
                                if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                    aw.buttonDRY.setFlat(False)
                                    if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                        aw.buttonCHARGE.setFlat(False)
                                        if aw.qmc.buttonvisibility[0]:
                                            aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:
                    aw.buttonSCs.setFlat(True)
                    aw.buttonCHARGE.setFlat(True)
                    aw.buttonCHARGE.stopAnimation()
                    aw.buttonDRY.setFlat(True)
                    aw.buttonFCs.setFlat(True)
                    aw.buttonFCe.setFlat(True)
                    try:
                        aw.eventactionx(aw.qmc.buttonactions[4],aw.qmc.buttonactionstrings[4])
                        if self.timeindex[0] > -1:
                            start = self.timex[self.timeindex[0]]
                        else:
                            start = 0
                        try:
                            st1 = stringfromseconds(self.timex[self.timeindex[4]]-start)
                            st2 = '%.1f '%self.temp2[self.timeindex[4]] + self.mode
                        except Exception: # pylint: disable=broad-except
                            pass
                        message = QApplication.translate('Message','[SC START] recorded at {0} BT = {1}').format(st1,st2)
                        aw.sendmessage(message)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                aw.onMarkMoveToNext(aw.buttonSCs)

    # trigger to be called by the markSCeSignal
    @pyqtSlot()
    def markSCeTrigger(self):
        self.mark2Cend()

    #record 2C end markers of BT. Called from buttonSCe of application window
    @pyqtSlot(bool)
    def mark2Cend(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonSCe.isFlat() and self.timeindex[5] > 0:
                        # undo wrongly set FCs
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}').format(stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 5 in self.l_annotations_dict:
                                del self.l_annotations_dict[5]
                            self.timeindex[5] = 0
                            removed = True
                    elif not aw.buttonSCe.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[5] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[5] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}').format(stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[5]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[5]],st1,self.timex[self.timeindex[5]],self.temp2[self.timeindex[5]],self.ystep_up,self.ystep_down,draggable_anno_key=5)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','SC END: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark2Cend() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart and len(self.timex) > 0:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [5,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonSCe.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonSCe.setFlat(False)
                        if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                            aw.buttonSCs.setFlat(False)
                            if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                aw.buttonFCe.setFlat(False)
                                if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                    aw.buttonFCs.setFlat(False)
                                    if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                        aw.buttonDRY.setFlat(False)
                                        if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                            aw.buttonCHARGE.setFlat(False)
                                            if aw.qmc.buttonvisibility[0]:
                                                aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:
                    aw.buttonSCe.setFlat(True)
                    aw.buttonCHARGE.setFlat(True)
                    aw.buttonCHARGE.stopAnimation()
                    aw.buttonDRY.setFlat(True)
                    aw.buttonFCs.setFlat(True)
                    aw.buttonFCe.setFlat(True)
                    aw.buttonSCs.setFlat(True)
                    aw.eventactionx(aw.qmc.buttonactions[5],aw.qmc.buttonactionstrings[5])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[5]]-start)
                    st2 = '%.1f '%self.temp2[self.timeindex[5]] + self.mode
                    message = QApplication.translate('Message','[SC END] recorded at {0} BT = {1}').format(st1,st2)
                    aw.sendmessage(message)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                aw.onMarkMoveToNext(aw.buttonSCe)

    # trigger to be called by the markDropSignal
    @pyqtSlot()
    def markDropTrigger(self):
        self.markDrop()

    #record end of roast (drop of beans). Called from push button 'Drop'
    @pyqtSlot(bool)
    def markDrop(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    # we check if this is the first DROP mark on this roast
                    firstDROP = self.timeindex[6] == 0 # on UNDO DROP we do not send the record to plus
                    if aw.buttonDROP.isFlat() and self.timeindex[6] > 0:
                        # undo wrongly set FCs
                        # deactivate autoDROP
                        aw.qmc.autoDROPenabled = False
                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}').format(stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 6 in self.l_annotations_dict:
                                del self.l_annotations_dict[6]
                            self.timeindex[6] = 0
                            #decrease BatchCounter again
                            self.decBatchCounter()
                            removed = True
                    elif not aw.buttonDROP.isFlat():
                        self.incBatchCounter()
                        # generate UUID
                        if self.roastUUID is None: # there might be already one assigned by undo and redo the markDROP!
                            import uuid
                            self.roastUUID = uuid.uuid4().hex
                        if self.device != 18 or aw.simulator is not None:
                            if self.autoDropIdx:
                                self.timeindex[6] = max(0,self.autoDropIdx)
                            else:
                                self.timeindex[6] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[6] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}').format(stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            if self.timeindex[5]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[5]],self.temp2[self.timeindex[6]],d)
                            elif self.timeindex[4]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[6]],d)
                            elif self.timeindex[3]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[6]],d)
                            elif self.timeindex[2]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[6]],d)
                            elif self.timeindex[1]:
                                self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[6]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[6]],st1,self.timex[self.timeindex[6]],self.temp2[self.timeindex[6]],19,19,draggable_anno_key=6)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need

                        try:
                            # update ambient temperature if a ambient temperature source is configured and no value yet established
                            aw.qmc.updateAmbientTempFromPhidgetModulesOrCurve()
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
    #PLUS
                        # only on first setting the DROP event (not set yet and no previous DROP undone) and if not in simulator modus, we upload to PLUS
                        if firstDROP and aw.qmc.autoDROPenabled and aw.plus_account is not None and not bool(aw.simulator):
                            try:
                                aw.updatePlusStatus()
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                                # add to out-queue
                            try:
                                plus.queue.addRoast()
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                else:
                    message = QApplication.translate('Message','DROP: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' markDrop() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.qmc.alignEvent in [6,7]:
                    aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                try:
                    if aw.buttonDROP.isFlat():
                        if removed:
                            self.updateBackground()
                            aw.buttonDROP.setFlat(False)
                            if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                                aw.buttonSCe.setFlat(False)
                                if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                    aw.buttonSCs.setFlat(False)
                                    if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                        aw.buttonFCe.setFlat(False)
                                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                            aw.buttonFCs.setFlat(False)
                                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                                aw.buttonDRY.setFlat(False)
                                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                    aw.buttonCHARGE.setFlat(False)
                                                    if aw.qmc.buttonvisibility[0]:
                                                        aw.buttonCHARGE.startAnimation()
                            self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                    else:
                        aw.buttonDROP.setFlat(True)
                        aw.buttonCHARGE.setFlat(True)
                        aw.buttonCHARGE.stopAnimation()
                        aw.buttonDRY.setFlat(True)
                        aw.buttonFCs.setFlat(True)
                        aw.buttonFCe.setFlat(True)
                        aw.buttonSCs.setFlat(True)
                        aw.buttonSCe.setFlat(True)

                        try:
                            aw.eventactionx(aw.qmc.buttonactions[6],aw.qmc.buttonactionstrings[6])
                            if self.timeindex[0] > -1:
                                start = self.timex[self.timeindex[0]]
                            else:
                                start = 0
                            st1 = stringfromseconds(self.timex[self.timeindex[6]]-start)
                            st2 = '%.1f '%self.temp2[self.timeindex[6]] + self.mode
                            message = QApplication.translate('Message','Roast ended at {0} BT = {1}').format(st1,st2)
                            aw.sendmessage(message)
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                        # at DROP we stop the follow background on FujiPIDs and set the SV to 0
                        if aw.qmc.device == 0 and aw.fujipid.followBackground:
                            if aw.fujipid.sv and aw.fujipid.sv > 0:
                                try:
                                    aw.fujipid.setsv(0,silent=True)
                                    aw.fujipid.sv = 0
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                        if aw.qmc.roastpropertiesAutoOpenDropFlag:
                            aw.openPropertiesSignal.emit()
                        if not (self.autoDropIdx > 0 and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6]):
                            # only if not anyhow markDrop() is triggered from within updategraphic() which guarantees an immediate redraw
                            self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                    aw.onMarkMoveToNext(aw.buttonDROP)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    # trigger to be called by the markCoolSignal
    @pyqtSlot()
    def markCoolTrigger(self):
        self.markCoolEnd()

    @pyqtSlot(bool)
    def markCoolEnd(self,_=False):
        if len(self.timex) > 1:
            try:
                aw.qmc.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    removed = False
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.buttonCOOL.isFlat() and self.timeindex[7] > 0:
                        # undo wrongly set COOL

                        st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','CE {0}').format(stringfromseconds(self.timex[self.timeindex[7]] - start)))

                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 7 in self.l_annotations_dict:
                                del self.l_annotations_dict[7]
                            self.timeindex[7] = 0
                            removed = True

                    elif not aw.buttonCOOL.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[7] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[7] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve:
                            # only if BT is shown we place the annotation:
                            #calculate time elapsed since charge time
                            st1 = aw.arabicReshape(QApplication.translate('Scope Annotation','CE {0}').format(stringfromseconds(self.timex[self.timeindex[7]] - start)))
                            #anotate temperature
                            d = aw.qmc.ylimit - aw.qmc.ylimit_min
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[6]],self.temp2[self.timeindex[7]],d)
                            self.l_annotations += self.annotate(self.temp2[self.timeindex[7]],st1,self.timex[self.timeindex[7]],self.temp2[self.timeindex[7]],self.ystep_up,self.ystep_down,draggable_anno_key=7)
                            #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                            self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','COOL: Scope is not recording')
                    aw.sendmessage(message)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' markCoolEnd() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)
            if self.flagstart:
                # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
                if aw.buttonCOOL.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.buttonCOOL.setFlat(False)
                        if self.timeindex[6] == 0: # reactivate the DROP button if not yet set
                            aw.buttonDROP.setFlat(False)
                            if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                                aw.buttonSCe.setFlat(False)
                                if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                    aw.buttonSCs.setFlat(False)
                                    if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                        aw.buttonFCe.setFlat(False)
                                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                            aw.buttonFCs.setFlat(False)
                                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                                aw.buttonDRY.setFlat(False)
                                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                    aw.buttonCHARGE.setFlat(False)
                                                    if aw.qmc.buttonvisibility[0]:
                                                        aw.buttonCHARGE.startAnimation()
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:
                    aw.buttonCOOL.setFlat(True)
                    aw.buttonCHARGE.setFlat(True)
                    aw.buttonCHARGE.stopAnimation()
                    aw.buttonDRY.setFlat(True)
                    aw.buttonFCs.setFlat(True)
                    aw.buttonFCe.setFlat(True)
                    aw.buttonSCs.setFlat(True)
                    aw.buttonSCe.setFlat(True)
                    aw.buttonDROP.setFlat(True)
                    aw.eventactionx(aw.qmc.buttonactions[7],aw.qmc.buttonactionstrings[7])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[7]]-start)
                    st2 = '%.1f '%self.temp2[self.timeindex[7]] + self.mode
                    message = QApplication.translate('Message','[COOL END] recorded at {0} BT = {1}').format(st1,st2)
                    #set message at bottom
                    aw.sendmessage(message)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                aw.onMarkMoveToNext(aw.buttonCOOL)

    @staticmethod
    def decBatchCounter():
        if not bool(aw.simulator):
            if aw.qmc.lastroastepoch + 5400 < aw.qmc.roastepoch:
                # reset the sequence counter
                aw.qmc.batchsequence = 1
            elif aw.qmc.batchsequence > 1:
                aw.qmc.batchsequence -= 1
            aw.qmc.roastbatchpos = aw.qmc.batchsequence
        if aw.qmc.batchcounter > -1 and not bool(aw.simulator):
            aw.qmc.batchcounter -= 1 # we decrease the batch counter
            # set the batchcounter of the current profile
            aw.qmc.roastbatchnr = 0
            # store updated batchcounter immediately in the app settings
            try:
                app_settings = QSettings()
                app_settings.beginGroup('Batch')
                app_settings.setValue('batchcounter',aw.qmc.batchcounter)
                app_settings.setValue('batchsequence',aw.qmc.batchsequence)
                app_settings.endGroup()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # decr. the batchcounter of the loaded app settings
            if aw.settingspath and aw.settingspath != '':
                try:
                    settings = QSettings(aw.settingspath,QSettings.Format.IniFormat)
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        bc = toInt(settings.value('batchcounter',aw.qmc.batchcounter))
                        bprefix = toString(settings.value('batchprefix',aw.qmc.batchprefix))
                        if bc > -1 and bc == aw.qmc.batchcounter+1 and aw.qmc.batchprefix == bprefix:
                            settings.setValue('batchcounter',bc - 1)
                            settings.setValue('batchsequence',aw.qmc.batchsequence)
                    settings.endGroup()
                except Exception: # pylint: disable=broad-except
                    aw.settingspath = ''

    @staticmethod
    def incBatchCounter():
        if not bool(aw.simulator):
            # update batchsequence by estimating batch sequence (roastbatchpos) from lastroastepoch and roastepoch
            # if this roasts DROP is more than 1.5h after the last registered DROP, we assume a new session starts
            if aw.qmc.lastroastepoch + 5400 < aw.qmc.roastepoch:
                # reset the sequence counter
                aw.qmc.batchsequence = 1
            else:
                aw.qmc.batchsequence += 1
            aw.qmc.roastbatchpos = aw.qmc.batchsequence
        # update lastroastepoch to time of roastdate
        aw.qmc.lastroastepoch = aw.qmc.roastepoch
        # set roastbatchpos
        if aw.qmc.batchcounter > -1 and not bool(aw.simulator):
            aw.qmc.batchcounter += 1 # we increase the batch counter
            # set the batchcounter of the current profile
            aw.qmc.roastbatchnr = aw.qmc.batchcounter
            # set the batchprefix of the current profile
            aw.qmc.roastbatchprefix = aw.qmc.batchprefix
            # store updated batchcounter immediately in the app settings
            try:
                app_settings = QSettings()
                app_settings.beginGroup('Batch')
                app_settings.setValue('batchcounter',aw.qmc.batchcounter)
                app_settings.setValue('batchsequence',aw.qmc.batchsequence)
                app_settings.setValue('lastroastepoch',aw.qmc.lastroastepoch)
                app_settings.endGroup()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # incr. the batchcounter of the loaded app settings
            if aw.settingspath and aw.settingspath != '':
                try:
                    settings = QSettings(aw.settingspath,QSettings.Format.IniFormat)
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        bc = toInt(settings.value('batchcounter',aw.qmc.batchcounter))
                        bprefix = toString(settings.value('batchprefix',aw.qmc.batchprefix))
                        if bc > -1 and aw.qmc.batchprefix == bprefix:
                            settings.setValue('batchcounter',aw.qmc.batchcounter)
                            settings.setValue('batchsequence',aw.qmc.batchsequence)
                            settings.setValue('lastroastepoch',aw.qmc.lastroastepoch)
                    settings.endGroup()
                except Exception: # pylint: disable=broad-except
                    aw.settingspath = ''
        else: # batch counter system inactive
            # set the batchcounter of the current profiles
            aw.qmc.roastbatchnr = 0

    # action of the EVENT button
    @pyqtSlot(bool)
    def EventRecord_action(self,_=False):
        self.EventRecord()

    @pyqtSlot(int)
    def EventRecordSlot(self,ee):
        self.EventRecord(ee)

    def EventRecord(self,extraevent=None,takeLock=True,doupdategraphics=True,doupdatebackground=True):
        try:
            if extraevent!=None:
                if aw.extraeventstypes[extraevent] <= 4:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=aw.extraeventstypes[extraevent],
                        eventvalue=aw.extraeventsvalues[extraevent],
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
                elif aw.extraeventstypes[extraevent] == 9:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=4,  # we map back to the untyped event type
                        eventvalue=aw.extraeventsvalues[extraevent],
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
                else: # on "relative" event values, we take the last value set per event via the recordextraevent call before
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=aw.extraeventstypes[extraevent]-5,
                        eventvalue=aw.qmc.eventsExternal2InternalValue(aw.extraeventsactionslastvalue[aw.extraeventstypes[extraevent]-5]),
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
            else:
                self.EventRecordAction(extraevent=extraevent,takeLock=takeLock,
                doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' EventRecord() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    #Marks location in graph of special events. For example change a fan setting.
    #Uses the position of the time index (variable self.timex) as location in time
    # extraevent is given when called from aw.recordextraevent() from an extra Event Button
    def EventRecordAction(self,extraevent=None,eventtype=None,eventvalue=None,eventdescription='',takeLock=True,doupdategraphics=True,doupdatebackground=True):
        try:
            if takeLock:
                aw.qmc.profileDataSemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0 or (self.device == 18 and aw.simulator is None):
                    aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()
                    Nevents = len(self.specialevents)
                    #if in manual mode record first the last point in self.timex[]
                    if self.device == 18 and aw.simulator is None:
                        if not doupdategraphics and not doupdatebackground: # a call from a multiple event action
                            tx,et,bt = self.timeclock.elapsed()/1000.,-1,-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                        if bt != -1 or et != -1:
                            self.drawmanual(et,bt,tx)
                        elif bt==-1 and et==-1:
                            return
                    #i = index number of the event (current length of the time list)
                    i = len(self.timex)-1
                    # if Description, Type and Value of the new event equals the last recorded one, we do not record this again!
                    if not(self.specialeventstype) or not(self.specialeventsvalue) or not(self.specialeventsStrings) or not(eventtype != 4 and self.specialeventstype[-1] == eventtype and self.specialeventsvalue[-1] == eventvalue and self.specialeventsStrings[-1] == eventdescription):
                        fontprop_small = aw.mpl_fontproperties.copy()
                        fontsize = 'xx-small'
                        fontprop_small.set_size(fontsize)
                        self.specialevents.append(i)
                        self.specialeventstype.append(4)
                        self.specialeventsStrings.append(str(Nevents+1))
                        self.specialeventsvalue.append(0)
                        #if event was initiated by an Extra Event Button then change the type,value,and string
                        if extraevent is not None:
                            self.specialeventstype[-1] = eventtype
                            self.specialeventsvalue[-1] = eventvalue
                            self.specialeventsStrings[-1] = eventdescription
                        etype = self.specialeventstype[-1]
                        tx = self.timex[self.specialevents[-1]]
                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                            val = int(round((self.specialeventsvalue[-1]-1)*10))
                        else:
                            event_pos_offset = (self.eventpositionbars[0])
                            event_pos_factor = (self.eventpositionbars[1] - self.eventpositionbars[0])
                            pos = max(0,int(round((self.specialeventsvalue[-1]-1)*10)))
                            val = int((pos*event_pos_factor)+event_pos_offset)
                        if etype == 0:
                            self.E1timex.append(tx)
                            self.E1values.append(val)
                        elif etype == 1:
                            self.E2timex.append(tx)
                            self.E2values.append(val)
                        elif etype == 2:
                            self.E3timex.append(tx)
                            self.E3values.append(val)
                        elif etype == 3:
                            self.E4timex.append(tx)
                            self.E4values.append(val)
                        #if Event show flag
                        if self.eventsshowflag and aw.qmc.showEtypes[etype]:
                            index = self.specialevents[-1]
                            if etype < 4  and (not aw.qmc.renderEventsDescr or len(self.specialeventsStrings[-1].strip()) == 0):
                                firstletter = self.etypesf(self.specialeventstype[-1])[0]
                                secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                                if aw.eventslidertemp[self.specialeventstype[-1]]:
                                    thirdletter = self.mode # postfix
                                else:
                                    thirdletter = aw.eventsliderunits[self.specialeventstype[-1]] # postfix
                            else:
                                firstletter = self.specialeventsStrings[-1].strip()[:aw.qmc.eventslabelschars]
                                if firstletter == '':
                                    firstletter = 'E'
                                secondletter = ''
                                thirdletter = ''
                            #if Event Type-Bars flag
                            if self.eventsGraphflag == 1 and etype < 4:
                                if self.mode == 'F':
                                    row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                                else:
                                    row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] >= self.temp2[index]:
                                    anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                        xy=(self.timex[index],
                                        self.temp1[index]),
                                        xytext=(self.timex[index],row[etype]),
                                        alpha=1.,
                                        bbox=dict(boxstyle='square,pad=0.1', fc=self.EvalueColor[etype], ec='none'),
                                        path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                        color=self.EvalueTextColor[etype],
                                        arrowprops=dict(arrowstyle='-',color=self.palette['et'],alpha=0.4,relpos=(0,0)),
                                        fontsize=fontsize,
                                        fontproperties=fontprop_small)
                                elif aw.qmc.BTcurve:
                                    anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                            xy=(self.timex[index],
                                            self.temp2[index]),
                                            xytext=(self.timex[index],row[etype]),
                                            alpha=1.,
                                            bbox=dict(boxstyle='square,pad=0.1', fc=self.EvalueColor[etype], ec='none'),
                                            path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                            color=self.EvalueTextColor[etype],
                                            arrowprops=dict(arrowstyle='-',color=self.palette['bt'],alpha=0.4,relpos=(0,0)),
                                            fontsize=fontsize,
                                            fontproperties=fontprop_small)
                                try:
                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                    pass
                            elif self.eventsGraphflag in [2,3,4] and etype < 4:
                                # update lines data using the lists with new data
                                if etype == 0 and aw.qmc.showEtypes[0]:
                                    self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                                elif etype == 1 and aw.qmc.showEtypes[1]:
                                    self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                                elif etype == 2 and aw.qmc.showEtypes[2]:
                                    self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                                elif etype == 3 and aw.qmc.showEtypes[3]:
                                    self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                            if self.specialeventstype[-1] == 4 or ( self.eventsGraphflag in [0,3,4] and aw.qmc.showEtypes[self.specialeventstype[-1]] ):
                                if self.mode == 'F':
                                    height = 50
                                else:
                                    height = 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] > self.temp2[index]:
                                    temp = self.temp1[index]
                                elif aw.qmc.BTcurve:
                                    temp = self.temp2[index]
                                else:
                                    temp = None

                                if self.eventsGraphflag == 4:
                                    if self.specialeventstype[-1] == 0:
                                        temp = self.E1values[-1]
                                    elif self.specialeventstype[-1] == 1:
                                        temp = self.E2values[-1]
                                    elif self.specialeventstype[-1] == 2:
                                        temp = self.E3values[-1]
                                    elif self.specialeventstype[-1] == 3:
                                        temp = self.E4values[-1]

                                if temp != None:
                                    if self.specialeventstype[-1] == 0:
                                        boxstyle = 'roundtooth,pad=0.4'
                                        boxcolor = self.EvalueColor[0]
                                        textcolor = self.EvalueTextColor[0]
                                    elif self.specialeventstype[-1] == 1:
                                        boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                        boxcolor = self.EvalueColor[1]
                                        textcolor = self.EvalueTextColor[1]
                                    elif self.specialeventstype[-1] == 2:
                                        boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                        boxcolor = self.EvalueColor[2]
                                        textcolor = self.EvalueTextColor[2]
                                    elif self.specialeventstype[-1] == 3:
                                        boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                        boxcolor = self.EvalueColor[3]
                                        textcolor = self.EvalueTextColor[3]
                                    else: # self.specialeventstype[-1] == 4:
                                        boxstyle = 'square,pad=0.1'
                                        boxcolor = self.palette['specialeventbox']
                                        textcolor = self.palette['specialeventtext']
                                    if self.eventsGraphflag in [0,3] or self.specialeventstype[-1] > 3:
                                        anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                                         color=textcolor,
                                                         va='center', ha='center',
                                                         arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=0.4), #,relpos=(0,0)),
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                         backgroundcolor=boxcolor)
                                    elif self.eventsGraphflag == 4:
                                        if thirdletter != '':
                                            firstletter = ''
                                        anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp),alpha=0.9,
                                                         color=textcolor,
                                                         va='center', ha='center',
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                         backgroundcolor=boxcolor)

                                    try:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                        pass
                        if doupdatebackground:
                            self.updateBackground() # call to canvas.draw() not needed as self.annotate does the (partial) redraw, but updateBackground() is needed
                        temp = '%.1f '%self.temp2[i]
                        if aw.qmc.timeindex[0] != -1:
                            start = aw.qmc.timex[aw.qmc.timeindex[0]]
                        else:
                            start = 0
                        timed = stringfromseconds(self.timex[i] - start)
                        message = QApplication.translate('Message','Event # {0} recorded at BT = {1} Time = {2}').format(str(Nevents+1),temp,timed)
                        aw.sendmessage(message)
                        #write label in mini recorder if flag checked
                        aw.eventlabel.setText(QApplication.translate('Label', 'Event #<b>{0} </b>').format(Nevents+1))
                        aw.eNumberSpinBox.blockSignals(True)
                        try:
                            aw.eNumberSpinBox.setValue(Nevents+1)
                        except Exception: # pylint: disable=broad-except
                            pass
                        finally:
                            aw.eNumberSpinBox.blockSignals(False)
                        if aw.qmc.timeindex[0] > -1:
                            timez = stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Nevents]]-aw.qmc.timex[aw.qmc.timeindex[0]])
                        else:
                            timez = stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Nevents]])
                        aw.etimeline.setText(timez)
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents]))
                        aw.lineEvent.setText(self.specialeventsStrings[Nevents])
            else:
                aw.sendmessage(QApplication.translate('Message','Timer is OFF'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' EventRecordAction() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if takeLock and aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)
        if self.flagstart and doupdategraphics:
            self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #called from controlling devices when roasting to record steps (commands) and produce a profile later
    def DeviceEventRecord(self,command):
        try:
            aw.qmc.profileDataSemaphore.acquire(1)
            if self.flagstart:
                #prevents accidentally deleting a modified profile.
                self.fileDirtySignal.emit()
                #number of events
                Nevents = len(self.specialevents)
                #index number
                i = len(self.timex)-1
                if i > 0:
                    self.specialevents.append(i)                                     # store absolute time index
                    self.specialeventstype.append(0)                                 # set type (to the first index 0)
                    self.specialeventsStrings.append(command)                        # store the command in the string section of events (not a binary string)
                    self.specialeventsvalue.append(0)                                # empty
                    temp = str(self.temp2[i])
                    if self.timeindex[0] != -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    timed = stringfromseconds(self.timex[i]-start)
                    message = QApplication.translate('Message','Computer Event # {0} recorded at BT = {1} Time = {2}').format(str(Nevents+1),temp,timed)
                    aw.sendmessage(message)
                    #write label in mini recorder if flag checked
                    aw.eNumberSpinBox.setValue(Nevents+1)
                    aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                    aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                    aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                #if Event show flag
                if self.eventsshowflag:
                    index = self.specialevents[-1]
                    if self.specialeventstype[-1] < 4 and aw.qmc.showEtypes[self.specialeventstype[-1]]:
                        fontprop_small = aw.mpl_fontproperties.copy()
                        fontsize = 'xx-small'
                        fontprop_small.set_size(fontsize)
                        firstletter = self.etypesf(self.specialeventstype[-1])[0]
                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                        if self.eventsGraphflag == 0:
                            if self.mode == 'F':
                                height = 50
                            else:
                                height = 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] > self.temp2[index]:
                                temp = self.temp1[index]
                            else:
                                temp = self.temp2[index]
                            anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                             color=self.palette['specialeventtext'],arrowprops=dict(arrowstyle='-',color=self.palette['bt'],alpha=0.4,relpos=(0,0)),
                                             fontsize=fontsize,fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette['specialeventbox'])
                            try:
                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        #if Event Type-Bars flag
                        if self.eventsGraphflag == 1:
                            if self.mode == 'F':
                                row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                            else:
                                row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] >= self.temp2[index]:
                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette['specialeventtext'],arrowprops=dict(arrowstyle='-',
                                                 color=self.palette['et'],alpha=0.4,relpos=(0,0)),fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette['specialeventbox'])
                            elif aw.qmc.BTcurve:
                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette['specialeventtext'],arrowprops=dict(arrowstyle='-',
                                                 color=self.palette['et'],alpha=0.4,relpos=(0,0)),fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette['specialeventbox'])
                            try:
                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        if self.eventsGraphflag in [2,3,4]:
                            # update lines data using the lists with new data
                            etype = self.specialeventstype[-1]
                            if etype == 0:
                                self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                            elif etype == 1:
                                self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                            elif etype == 2:
                                self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                            elif etype == 3:
                                self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' DeviceEventRecord() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)

    def writecharacteristics(self,TP_index=None,LP=None):
        try:
            # Display MET marker
            if self.showmet and aw.qmc.ETcurve and self.timeindex[0] > -1 and self.timeindex[6] > 0:
                if TP_index is None:
                    TP_index = aw.findTP()
                met_temp = max(self.temp1[TP_index:self.timeindex[6]])
                self.idx_met = TP_index + self.temp1[TP_index:self.timeindex[6]].index(met_temp)
                if self.idx_met and self.timeindex[2]:
                    # time between MET and FCs
                    met_delta = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.idx_met],0)
                else:
                    met_delta = None
                self.met_timex_temp1_delta = [(self.timex[self.idx_met]-self.timex[self.timeindex[0]]), met_temp, met_delta ] #used in onpick() to display the MET temp and time
                # plot a MET marker
                if self.showmet and aw.qmc.ETcurve:
                    if self.mode == 'F':
                        height = 0
                    else:
                        height = 0
                    boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                    boxcolor = aw.qmc.palette['metbox'] #match the ET color
                    textcolor = self.palette['mettext']
                    fontprop_small = aw.mpl_fontproperties.copy()
                    fontprop_small.set_size('xx-small')
                    self.met_annotate = self.ax.annotate('MET', xy=(self.timex[self.idx_met], met_temp),
                                 xytext=(self.timex[self.idx_met], met_temp + height),
                                 ha = 'center',
                                 alpha=0.9,
                                 color=textcolor,
                                 bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                 fontproperties=fontprop_small,
                                 path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                 picker=True,
                                 zorder=2,
                                 )
                    try:
                        self.met_annotate.set_in_layout(False) # remove suptitle from tight_layout calculation
                    except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                        pass

            if self.statisticsflags[3] and self.timeindex[0]>-1:
                statsprop = aw.mpl_fontproperties.copy()
                statsprop.set_size('small')
                if aw.qmc.statisticsmode == 0:
                    if TP_index is None:
                        TP_index = aw.findTP()
                    if LP is None:
                        #find Lowest Point in BT
                        LP = 1000
                        if TP_index >= 0:
                            LP = self.temp2[TP_index]
                    # compute max ET between TP and DROP
                    ETmax = '--'
                    try:
                        if TP_index is not None:
                            if self.timeindex[6] > 0 and TP_index<self.timeindex[6]:
                                temp1_values = self.temp1[TP_index:self.timeindex[6]]
                            else:
                                temp1_values = self.temp1[TP_index:]
                            if self.LCDdecimalplaces:
                                lcdformat = '%.1f'
                            else:
                                lcdformat = '%.0f'
                            temp1_values_max = max(temp1_values)
                            ETmax = lcdformat%temp1_values_max + aw.qmc.mode
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    FCperiod = None
                    try:
                        if self.timeindex[2] > 0 and self.timeindex[3] > 0:
                            FCperiod = stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[2]])[1:]
                        elif self.timeindex[2] > 0 and self.timeindex[6] > 0:
                            FCperiod = stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])[1:]
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    ror = '%.1f'%(((self.temp2[self.timeindex[6]]-LP)/(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))*60.)
                    _,_,tsb,_ = aw.ts(tp=TP_index)

                    #curveSimilarity
                    det,dbt = aw.curveSimilarity() # we analyze from DRY-END as specified in the phases dialog to DROP

                    #end temperature
                    if det in [None, -1] or numpy.isnan(det):
                        det_txt = ''
                    else:
                        det_txt = '%.1f' % det
                    if dbt in [None, -1] or numpy.isnan(dbt):
                        dbt_txt = ''
                    else:
                        dbt_txt = '%.1f' % dbt
                    if self.locale_str == 'ar':
                        strline = (
                                    f'C*min{int(tsb)}={aw.arabicReshape(QApplication.translate("Label", "AUC"))}   '
                                    f'{aw.arabicReshape(aw.qmc.mode + "/min")}'
                                    f'{ror}=aw.arabicReshape(QApplication.translate("Label", "RoR"))   '
                                    f'{ETmax}=aw.arabicReshape(QApplication.translate("Label", "MET"))'
                                   )
                        if det is not None:
                            strline = (f'{det_txt}/{dbt_txt}') + self.mode + '=' + QApplication.translate('Label', 'CM') + ' ' + strline
                        if FCperiod is not None:
                            strline = 'min%s=' % FCperiod + QApplication.translate('Label', 'FC') + '   ' + strline
                    else:
                        strline = ''
                        if temp1_values_max and temp1_values_max > 0:
                            strline = (QApplication.translate('Label', 'MET') + '={0}   ').format(ETmax)
                        strline += (QApplication.translate('Label', 'RoR') + '={0}' \
                                    + aw.qmc.mode + '/min' + '   ' \
                                    + QApplication.translate('Label', 'AUC') + '={1}C*min') \
                                    .format(str(ror), \
                                    str(int(tsb)))
                        if det is not None or dbt is not None:
                            strline = strline + '   ' + QApplication.translate('Label', 'CM') + (f'={det_txt}/{dbt_txt}') + self.mode
                        if FCperiod is not None:
                            strline = strline + '   ' + QApplication.translate('Label', 'FC') + '=%smin' % FCperiod
                    self.set_xlabel(strline)
                else:
                    sep = '   '
                    msg = aw.qmc.roastdate.date().toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))
                    tm = aw.qmc.roastdate.time().toString()[:-3]
                    if tm != '00:00':
                        msg = f'{msg}, {tm}'
                    if aw.qmc.beans and aw.qmc.beans != '':
                        msg = f'{msg} {abbrevString(aw.qmc.beans,25)}'
                    if aw.qmc.weight[0]:
                        if aw.qmc.weight[2] in ['g','oz']:
                            msg += sep + str(aw.float2float(aw.qmc.weight[0],0)) + aw.qmc.weight[2]
                        else:
                            msg += sep + str(aw.float2float(aw.qmc.weight[0],1)) + aw.qmc.weight[2]
                        if aw.qmc.weight[1]:
                            msg += sep + str(-1*aw.float2float(aw.weight_loss(aw.qmc.weight[0],aw.qmc.weight[1]),1)) + '%'
                    if aw.qmc.volume[0] and aw.qmc.volume[1]:
                        msg += sep + str(aw.float2float(aw.volume_increase(aw.qmc.volume[0],aw.qmc.volume[1]),1)) + '%'
                    if aw.qmc.whole_color and aw.qmc.ground_color:
                        msg += sep + '#' + str(aw.qmc.whole_color) + '/' +  str(aw.qmc.ground_color)
                    elif aw.qmc.ground_color:
                        msg += sep + '#' + str(aw.qmc.ground_color)
                    self.set_xlabel(msg)
            else:
                if aw.qmc.flagstart or self.xgrid == 0:
                    self.set_xlabel('')
                else:
                    self.set_xlabel(aw.arabicReshape(QApplication.translate('Label', 'min','abbrev. of minutes')))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' writecharacteristics() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # calculates self.statisticstimes values and returns dryEndIndex as well as the calculated statisticstimes array of length 5
    def calcStatistics(self,TP_index):
        statisticstimes = [0,0,0,0,0]
        try:
            if self.timeindex[1]:
                #manual dryend available
                dryEndIndex = self.timeindex[1]
            else:
                #find when dry phase ends
                dryEndIndex = aw.findDryEnd(TP_index)
            if len(self.timex) > dryEndIndex:
                dryEndTime = self.timex[dryEndIndex]

                #if DROP
                if self.timeindex[6] and self.timeindex[2]:
                    totaltime = self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]
                    if totaltime == 0:
                        return dryEndIndex, statisticstimes

                    statisticstimes[0] = totaltime
                    dryphasetime = dryEndTime - self.timex[self.timeindex[0]] # aw.float2float(dryEndTime - self.timex[self.timeindex[0]])
                    midphasetime = self.timex[self.timeindex[2]] - dryEndTime # aw.float2float(self.timex[self.timeindex[2]] - dryEndTime)
                    finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]] # aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                    if self.timeindex[7]:
                        coolphasetime = self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]] # int(round(self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]]))
                    else:
                        coolphasetime = 0

                    statisticstimes[1] = dryphasetime
                    statisticstimes[2] = midphasetime
                    statisticstimes[3] = finishphasetime
                    statisticstimes[4] = coolphasetime
                return dryEndIndex, statisticstimes
            return self.timeindex[1], statisticstimes
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            return self.timeindex[1], statisticstimes

    # Writes information about the finished profile in the graph
    # TP_index is the TP index calculated by findTP and might be -1 if no TP could be detected
    def writestatistics(self,TP_index):
        try:
            LP = None

            dryEndIndex, statisticstimes = self.calcStatistics(TP_index)

            if statisticstimes[0] == 0:
                self.writecharacteristics(TP_index,LP)
                return
            self.statisticstimes = statisticstimes

            #if DROP
            if self.timeindex[6] and self.timeindex[2]:

                #dry time string
                st1 = stringfromseconds(self.statisticstimes[1],False)

                #mid time string
                st2 = stringfromseconds(self.statisticstimes[2],False)

                #finish time string
                st3 = stringfromseconds(self.statisticstimes[3],False)

                if self.statisticstimes[4]:
                    st4 = stringfromseconds(self.statisticstimes[4],False)
                else:
                    st4 = ''

                #calculate the positions for the statistics elements
                ydist = self.ylimit - self.ylimit_min
                statisticsbarheight = ydist/70

                if aw.qmc.legendloc in [1,2,9]:
                    # legend on top
                    statisticsheight = self.ylimit - (0.13 * ydist) # standard positioning
                else:
                    # legend not on top
                    statisticsheight = self.ylimit - (0.08 * ydist)

                if aw.qmc.mode == 'C':
                    statisticsupper = statisticsheight + statisticsbarheight + 4
                    statisticslower = statisticsheight - 3.5*statisticsbarheight
                else:
                    statisticsupper = statisticsheight + statisticsbarheight + 10
                    statisticslower = statisticsheight - 2.5*statisticsbarheight

                if self.statisticsflags[1]:

                    #Draw cool phase rectangle
                    if self.timeindex[7]:
                        rect = patches.Rectangle((self.timex[self.timeindex[6]], statisticsheight), width = self.statisticstimes[4], height = statisticsbarheight,
                                                color = self.palette['rect4'],alpha=0.5)
                        self.ax.add_patch(rect)

                    if self.timeindex[2]: # only if FCs exists
                        #Draw finish phase rectangle
                        #check to see if end of 1C exists. If so, use half between start of 1C and end of 1C. Otherwise use only the start of 1C
                        rect = patches.Rectangle((self.timex[self.timeindex[2]], statisticsheight), width = self.statisticstimes[3], height = statisticsbarheight,
                                                color = self.palette['rect3'],alpha=0.5)
                        self.ax.add_patch(rect)

                        # Draw mid phase rectangle
                        rect = patches.Rectangle((self.timex[self.timeindex[0]]+self.statisticstimes[1], statisticsheight), width = self.statisticstimes[2], height = statisticsbarheight,
                                              color = self.palette['rect2'],alpha=0.5)
                        self.ax.add_patch(rect)

                    # Draw dry phase rectangle
                    rect = patches.Rectangle((self.timex[self.timeindex[0]], statisticsheight), width = self.statisticstimes[1], height = statisticsbarheight,
                                              color = self.palette['rect1'],alpha=0.5)
                    self.ax.add_patch(rect)

                if aw.qmc.LCDdecimalplaces:
                    fmtstr = '{0:.1f}'
                else:
                    fmtstr = '{0:.0f}'
                if self.statisticstimes[0]:
                    dryphaseP = fmtstr.format(self.statisticstimes[1]*100./self.statisticstimes[0])
                    midphaseP = fmtstr.format(self.statisticstimes[2]*100./self.statisticstimes[0])
                    finishphaseP = fmtstr.format(self.statisticstimes[3]*100./self.statisticstimes[0])
                else:
                    dryphaseP = ' --- '
                    midphaseP = ' --- '
                    finishphaseP = ' --- '

                #find Lowest Point in BT
                LP = 1000
                if TP_index >= 0:
                    LP = self.temp2[TP_index]

                if self.statisticsflags[0]:
                    text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]/2.,statisticsupper,st1 + '  '+ dryphaseP+'%',color=self.palette['text'],ha='center',
                        fontsize='medium'
                        )
                    try:
                        text.set_in_layout(False)
                    except Exception: # pylint: disable=broad-except
                        pass
                    if self.timeindex[2]: # only if FCs exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticsupper,st2+ '  ' + midphaseP+'%',color=self.palette['text'],ha='center',
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticsupper,st3 + '  ' + finishphaseP+ '%',color=self.palette['text'],ha='center',
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception:  # pylint: disable=broad-except
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+self.statisticstimes[4]/2.,statisticsupper,st4,color=self.palette['text'],ha='center',
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass

                st1 = st2 = st3 = st4 = ''

                if self.statisticsflags[4] or self.statisticsflags[6]:
                    rates_of_changes = aw.RoR(TP_index,dryEndIndex)
                    d = str(aw.qmc.LCDdecimalplaces)
                    if self.statisticsflags[6]:
                        fmtstr = '{0:.' + d + 'f}{1}'
                        if self.statisticsflags[4]:
                            fmtstr += '  {2:.' + d + 'f}{3}'
                    else:
                        fmtstr = '{2:.' + d + 'f}{3}'

                    unit = aw.arabicReshape(aw.qmc.mode + '/min')
                    st1 = st1 + fmtstr.format(rates_of_changes[3], aw.qmc.mode, rates_of_changes[0], unit)
                    st2 = st2 + fmtstr.format(rates_of_changes[4], aw.qmc.mode, rates_of_changes[1], unit)
                    st3 = st3 + fmtstr.format(rates_of_changes[5], aw.qmc.mode, rates_of_changes[2], unit)

                    text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]/2.,statisticslower,st1,
                        color=self.palette['text'],
                        ha='center',
                        fontsize='medium')
                    try:
                        text.set_in_layout(False)
                    except Exception: # pylint: disable=broad-except
                        pass
                    if self.timeindex[2]: # only if FCs exists
                        text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticslower,st2,color=self.palette['text'],ha='center',
                            #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                        text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticslower,st3,color=self.palette['text'],ha='center',
                            #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+max(self.statisticstimes[4]/2.,self.statisticstimes[4]/3.),statisticslower,st4,color=self.palette['text'],ha='center',
                            #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
            self.writecharacteristics(TP_index,LP)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' writestatistics() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def convertHeat(value, fromUnit, toUnit=0):
        if value in [-1,None]:
            return value
        conversion = {#     BTU            kJ             kCal           kWh            hph
                       0:{0:1.,          1:1.0551E+00,  2:2.5200E-01,  3:2.9307E-04,  4:3.9301E-04 }, # = 1 btu
                       1:{0:9.4782E-01,  1:1.,          2:2.3885E-01,  3:2.7778E-04,  4:3.7251E-04 }, # = 1 kj
                       2:{0:3.9683E+00,  1:4.1868E+00,  2:1.,          3:1.1630E-03,  4:1.5596E-03 }, # = 1 kcal
                       3:{0:3.4121E+03,  1:3.6000E+03,  2:8.5985E+02,  3:1.,          4:1.3410E+00 }, # = 1 kwh
                       4:{0:2.5444E+03,  1:2.6845E+03,  2:6.4119E+02,  3:7.4570E-01,  4:1.         }} # = 1 hph

        return value * conversion[fromUnit][toUnit]

    def calcEnergyuse(self,beanweightstr=''):
        try:
            energymetrics = {}
            btu_list = []
            if len(self.timex) == 0:
                #aw.sendmessage(QApplication.translate("Message","No profile data"),append=False)
                return energymetrics, btu_list

            # helping function
            def formatLoadLabel(i):
                if len(self.loadlabels[i]) > 0:
                    return  self.loadlabels[i]
                return chr(ord('A')+i)

            # get the valid green weight
            if beanweightstr != '':
                w = toFloat(beanweightstr)
            else:
                w = aw.qmc.weight[0]
            bean_weight = aw.convertWeight(w,aw.qmc.weight_units.index(aw.qmc.weight[2]),1) # to kg

            #reference: https://www.eia.gov/environment/emissions/co2_vol_mass.php (dated Nov-18-2021, accessed Jan-02-2022)
            #           https://www.eia.gov/tools/faqs/faq.php?id=74&t=11 (referencing data from 2020, accessed Jan-02-2022)
            # entries must match those in self.sourcenames
            CO2kg_per_BTU = {0:6.288e-05, 1:5.291e-05, 2:2.964e-04}  # "LPG", "NG", "Elec"

            eTypes = [''] + self.etypes[:][:4]

            # init the prev_loadtime to drop if it exists or to the end of profile time
            if self.timeindex[6] > 0:
                prev_loadtime = [self.timex[self.timeindex[6]]]*4
            else:
                prev_loadtime = [self.timex[-1]]*4
                #aw.sendmessage(QApplication.translate("Message","Profile has no DROP event"),append=False)

            for i in range(0,4):
                # iterate specialevents in reverse from DROP to the first event
                for j in range(len(self.specialevents) - 1, -1, -1):
                    if self.load_etypes[i] != 0 and self.specialeventstype[j] == self.load_etypes[i]-1:
                        # skip if loadrating is zero
                        if self.loadratings[i] == 0:
                            break
                        loadtime = self.timex[self.specialevents[j]]
                        # exclude heat before charge event
                        if self.timeindex[0] > -1 and loadtime <= self.timex[self.timeindex[0]]:
                            if prev_loadtime[i] <= self.timex[self.timeindex[0]]:
                                break
                            loadtime = self.timex[self.timeindex[0]]
                        duration = prev_loadtime[i] - loadtime

                        # exclude heat after drop event
                        if duration < 0:
                            continue
                        prev_loadtime[i] = loadtime
                        # scale the burner setting for 0-100%
                        val = (self.specialeventsvalue[j] - 1) * 10
                        emin = toInt(self.loadevent_zeropcts[i])
                        emax = toInt(self.loadevent_hundpcts[i])
                        scaled = (val - emin) / (emax - emin)  #emax > emin enforced by energy.py
                        load_pct = min(1,max(0,scaled)) * 100
                        if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = (load_pct / 100)

                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.ratingunits[i],0)
                        if BTUs > 0:
                            loadlabel = f'{formatLoadLabel(i)}-{eTypes[self.load_etypes[i]]}'
                            kind = 7  #Roast Event
                            sortorder = (2000 * (i + 1)) + j
                            CO2g = BTUs * CO2kg_per_BTU[self.sourcetypes[i]] * 1000
                            if self.sourcetypes[i] in [2]:  #electicity
                                CO2g = CO2g * (1 - self.electricEnergyMix/100)
                            btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})
                ### end of loop: for j in range(len(self.specialevents) - 1, -1, -1)

                # calculate Continuous event type
                if self.load_etypes[i] == 0:
                    if self.timeindex[0] > -1 and self.timeindex[6] > 0:
                        duration = self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]]
                    else:
                        duration = 0
                        #aw.sendmessage(QApplication.translate("Message","Missing CHARGE or DROP event"),append=False)
                    load_pct = toInt(self.loadevent_hundpcts[i])  #needed only for the btu_list and outmsg
                    if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                        # convert pressure to heat
                        factor = math.sqrt(load_pct / 100)
                    else:
                        factor = (load_pct / 100)

                    loadlabel = formatLoadLabel(i)
                    kind = 6  #Roast Continuous
                    fueltype = self.sourcetypes[i]
                    sortorder = 2000 - i
                    BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.ratingunits[i],0)
                    CO2g = BTUs * CO2kg_per_BTU[fueltype] * 1000
                    if self.sourcetypes[i] in [2]:  #electicity
                        CO2g = CO2g * (1 - self.electricEnergyMix/100)
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate preheat
                if self.preheatenergies[i] != 0 and aw.qmc.roastbatchpos == 1:
                    if self.preheatenergies[i] < 0 < self.preheatDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.preheatenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = (load_pct / 100)
                        duration = self.preheatDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 1  #Preheat Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.preheatenergies[i] * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 0  #Preheat Measured

                    loadlabel = formatLoadLabel(i)
                    sortorder = 100 + i
                    CO2g = BTUs * CO2kg_per_BTU[self.sourcetypes[i]] * 1000
                    if self.sourcetypes[i] in [2]:  #electicity
                        CO2g = CO2g * (1 - self.electricEnergyMix/100)
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate betweenbatch
                if self.betweenbatchenergies[i] != 0 and (aw.qmc.roastbatchpos > 1 or aw.qmc.betweenbatch_after_preheat or aw.qmc.roastbatchpos==0):
                    if self.betweenbatchenergies[i] < 0 < self.betweenbatchDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.betweenbatchenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = (load_pct / 100)
                        duration = self.betweenbatchDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 3  #BBP Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.betweenbatchenergies[i] * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 2  #BBP Measured

                    loadlabel = formatLoadLabel(i)
                    sortorder = 400 + i
                    CO2g = BTUs * CO2kg_per_BTU[self.sourcetypes[i]] * 1000
                    if self.sourcetypes[i] in [2]:  #electicity
                        CO2g = CO2g * (1 - self.electricEnergyMix/100)
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate cooling
                if self.coolingenergies[i] != 0 and aw.qmc.roastbatchpos == 1:
                    if self.coolingenergies[i] < 0 < self.coolingDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.coolingenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = (load_pct / 100)
                        duration = self.coolingDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 5  #Cooling Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.coolingenergies[i] * self.convertHeat(1,self.ratingunits[i],0)
                        kind = 4  #Cooling Measured

                    loadlabel = formatLoadLabel(i)
                    sortorder = 800 + i
                    CO2g = BTUs * CO2kg_per_BTU[self.sourcetypes[i]] * 1000
                    if self.sourcetypes[i] in [2]:  #electicity
                        CO2g = CO2g * (1 - self.electricEnergyMix/100)
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})
            #### end of loop: for i in range(0,4)

            btu_list.sort(key=lambda k : k['SortOrder'] )

            # summarize the batch metrics
            btu_batch = btu_preheat = btu_bbp = btu_cooling = btu_roast = 0
            co2_batch = co2_preheat = co2_bbp = co2_cooling = co2_roast = 0
            btu_elec = btu_lpg = btu_ng = 0
            for item in btu_list:
                btu_batch += item['BTUs']
                btu_preheat += item['BTUs'] if item['Kind'] in [0,1] else 0
                btu_bbp += item['BTUs'] if item['Kind'] in [2,3] else 0
                btu_cooling += item['BTUs'] if item['Kind'] in [4,5] else 0
                btu_roast += item['BTUs'] if item['Kind'] in [6,7] else 0
                co2_batch += item['CO2g']
                co2_preheat += item['CO2g'] if item['Kind'] in [0,1] else 0
                co2_bbp += item['CO2g'] if item['Kind'] in [2,3] else 0
                co2_cooling += item['CO2g'] if item['Kind'] in [4,5] else 0
                co2_roast += item['CO2g'] if item['Kind'] in [6,7] else 0
                btu_lpg += item['BTUs'] if item['SourceType'] in [0] else 0
                btu_ng += item['BTUs'] if item['SourceType'] in [1] else 0
                btu_elec += item['BTUs'] if item['SourceType'] in [2] else 0
            btu_batch = aw.float2float(btu_batch,3)
            btu_preheat = aw.float2float(btu_preheat,3)
            btu_bbp = aw.float2float(btu_bbp,3)
            btu_cooling = aw.float2float(btu_cooling,3)
            btu_roast = aw.float2float(btu_roast,3)
            co2_batch = aw.float2float(co2_batch,3)
            co2_preheat = aw.float2float(co2_preheat,3)
            co2_bbp = aw.float2float(co2_bbp,3)
            co2_cooling = aw.float2float(co2_cooling,3)
            co2_roast = aw.float2float(co2_roast,3)
            btu_lpg = aw.float2float(btu_lpg,3)
            btu_ng = aw.float2float(btu_ng,3)
            btu_elec = aw.float2float(btu_elec,3)
            if bean_weight > 0:
                co2_batch_per_green_kg = co2_batch / bean_weight
                co2_roast_per_green_kg = co2_roast / bean_weight
                btu_batch_per_green_kg = btu_batch / bean_weight
                btu_roast_per_green_kg = btu_roast / bean_weight
            else:
                co2_batch_per_green_kg = 0
                co2_roast_per_green_kg = 0
                btu_batch_per_green_kg = 0
                btu_roast_per_green_kg = 0
            co2_batch_per_green_kg = aw.float2float(co2_batch_per_green_kg,3)
            co2_roast_per_green_kg = aw.float2float(co2_roast_per_green_kg,3)
            btu_batch_per_green_kg = aw.float2float(btu_batch_per_green_kg,3)
            btu_roast_per_green_kg = aw.float2float(btu_roast_per_green_kg,3)
            kwh_batch_per_green_kg = aw.float2float(self.convertHeat(btu_batch_per_green_kg,0,3),3)
            kwh_roast_per_green_kg = aw.float2float(self.convertHeat(btu_roast_per_green_kg,0,3),3)


            # energymetrics
            energymetrics['BTU_batch'] = btu_batch
            energymetrics['BTU_batch_per_green_kg'] = btu_batch_per_green_kg
            energymetrics['CO2_batch'] = co2_batch
            energymetrics['BTU_preheat'] = btu_preheat
            energymetrics['CO2_preheat'] = co2_preheat
            energymetrics['BTU_bbp'] = btu_bbp
            energymetrics['CO2_bbp'] = co2_bbp
            energymetrics['BTU_cooling'] = btu_cooling
            energymetrics['CO2_cooling'] = co2_cooling
            energymetrics['BTU_roast'] = btu_roast
            energymetrics['BTU_roast_per_green_kg'] = btu_roast_per_green_kg
            energymetrics['CO2_roast'] = co2_roast
            energymetrics['CO2_batch_per_green_kg'] = co2_batch_per_green_kg
            energymetrics['CO2_roast_per_green_kg'] = co2_roast_per_green_kg
            energymetrics['BTU_LPG'] = btu_lpg
            energymetrics['BTU_NG'] = btu_ng
            energymetrics['BTU_ELEC'] = btu_elec
            energymetrics['KWH_batch_per_green_kg'] = kwh_batch_per_green_kg
            energymetrics['KWH_roast_per_green_kg'] = kwh_roast_per_green_kg

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' calcEnergyuse() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return energymetrics,btu_list

    def measureFromprofile(self):
        coolEnergy = [0]*4
        heatEnergy = [0]*4
        heatDuration = 0
        coolDuration = 0
        try:
            if len(self.timex) == 0:
                #aw.sendmessage(QApplication.translate("Message","No profile data"),append=False)
                return [-1]*4, [-1]*4, 0, 0

            def getEnergy(i,j,duration):
                try:
                    # scale the burner setting for 0-100%
                    val = (self.specialeventsvalue[j] - 1) * 10
                    emin = toInt(self.loadevent_zeropcts[i])
                    emax = toInt(self.loadevent_hundpcts[i])
                    scaled = (val - emin) / (emax - emin)  #emax > emin enforced by energy.py
                    load_pct = min(1,max(0,scaled)) * 100
                    if self.presssure_percents[i] and self.sourcetypes[i] in [0,1]:   # gas loads only
                        # convert pressure to heat
                        factor = math.sqrt(load_pct / 100)
                    else:
                        factor = (load_pct / 100)
                    energy = self.loadratings[i] * factor * (duration / 3600) #* self.convertHeat(1,self.ratingunits[i],0)
                except Exception as ex: # pylint: disable=broad-except
                    _log.exception(ex)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' measureFromprofile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                return energy

            # if there is a DROP event use that for coolstart
            if self.timeindex[6] > 0:
                coolstart = self.timex[self.timeindex[6]]
            # else if there is a CHARGE event use that for coolstart
            elif self.timeindex[0] > -1:
                coolstart = self.timex[self.timeindex[0]]
            # else use the start of time for coolstart
            else:
                coolstart = self.timex[0]

            # if there is a CHARGE event use that for heatend
            if self.timeindex[0] > -1:
                heatend = self.timex[self.timeindex[0]]
            # else use the end of time for heatend
            else:
                heatend = self.timex[-1]

            prev_loadtime = [self.timex[-1]]*4

            for i in range(0,4):
                # iterate specialevents in reverse from end of profile to start
                if self.load_etypes[i] == 0:
                    heatEnergy[i] = -1
                    coolEnergy[i] = -1
                elif self.loadratings[i] > 0:
                    for j in range(len(self.specialevents) - 1, -1, -1):
                        if self.specialeventstype[j] == self.load_etypes[i]-1:
                            loadtime = self.timex[self.specialevents[j]]

                            if coolstart <= loadtime < prev_loadtime[i]:
                                duration = prev_loadtime[i] - loadtime
                                coolEnergy[i] += getEnergy(i,j,duration)
                            elif loadtime < coolstart <= prev_loadtime[i]:
                                duration = prev_loadtime[i] - coolstart
                                coolEnergy[i] += getEnergy(i,j,duration)

                            if loadtime < heatend <= prev_loadtime[i]:
                                duration = heatend - loadtime
                                heatEnergy[i] += getEnergy(i,j,duration)
                            elif loadtime < heatend and prev_loadtime[i] < heatend:
                                duration = prev_loadtime[i] - loadtime
                                heatEnergy[i] += getEnergy(i,j,duration)

                            prev_loadtime[i] = loadtime

                    ### end of loop: for j in range(len(self.specialevents) - 1, -1, -1)
            #### end of loop: for i in range(0,4)

            heatDuration = self.timex[self.timeindex[0]]
            coolDuration = self.timex[-1] - self.timex[self.timeindex[6]]

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' measureFromprofile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return heatEnergy, coolEnergy, heatDuration, coolDuration

    #called from markdryend(), markcharge(), mark1Cstart(),  etc when using device 18 (manual mode)
    def drawmanual(self,et,bt,tx):
        self.timex.append(tx)
        self.temp1.append(et)
        if aw.qmc.ETcurve:
            self.l_temp1.set_data(self.timex, self.temp1)
        self.temp2.append(bt)
        if aw.qmc.BTcurve:
            self.l_temp2.set_data(self.timex, self.temp2)

    def movebackground(self,direction,step):
        lt = len(self.timeB)
        le = len(self.temp1B)
        lb = len(self.temp2B)
        #all background curves must have same dimension in order to plot. Check just in case.
        if lt > 1 and lt == le and lb == le:
            if  direction == 'up':
                for i in range(lt):
                    self.temp1B[i] += step
                    self.temp2B[i] += step
                    self.stemp1B[i] += step
                    self.stemp2B[i] += step
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.stemp1BX[i][j] += step
                        self.stemp2BX[i][j] += step
                self.backgroundprofile_moved_y += step
                self.moveBackgroundAnnoPositionsY(step)

            elif direction == 'left':
                for i in range(lt):
                    self.timeB[i] -= step
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.extratimexB[i][j] -= step
                self.backgroundprofile_moved_x -= step
                self.moveBackgroundAnnoPositionsX(-step)

            elif direction == 'right':
                for i in range(lt):
                    self.timeB[i] += step
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.extratimexB[i][j] += step
                self.backgroundprofile_moved_x += step
                self.moveBackgroundAnnoPositionsX(step)

            elif direction == 'down':
                for i in range(lt):
                    self.temp1B[i] -= step
                    self.temp2B[i] -= step
                    self.stemp1B[i] -= step
                    self.stemp2B[i] -= step

                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.stemp1BX[i][j] -= step
                        self.stemp2BX[i][j] -= step
                self.backgroundprofile_moved_y -= step
                self.moveBackgroundAnnoPositionsY(-step)
        else:
            aw.sendmessage(QApplication.translate('Message','Unable to move background'))
            return

    #points are used to draw interpolation
    def findpoints(self):
        #if profile found
        if self.timeindex[0] != -1:
            Xpoints = []                        #make temporary lists to hold the values to return
            Ypoints = []

            #start point from beginning of time
            Xpoints.append(self.timex[0])
            Ypoints.append(self.temp2[0])
            #input beans (CHARGE)
            Xpoints.append(self.timex[self.timeindex[0]])
            Ypoints.append(self.temp2[self.timeindex[0]])

            #find indexes of lowest point and dryend
            LPind = aw.findTP()
            DE = aw.findDryEnd()

            if LPind < DE:
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
            else:
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])

            if self.temp2[self.timeindex[1]] > self.timex[DE] and self.temp2[self.timeindex[1]] > self.timex[LPind]:
                Xpoints.append(self.timex[self.timeindex[1]])
                Ypoints.append(self.temp2[self.timeindex[1]])
            if self.timeindex[2]:
                Xpoints.append(self.timex[self.timeindex[2]])
                Ypoints.append(self.temp2[self.timeindex[2]])
            if self.timeindex[3]:
                Xpoints.append(self.timex[self.timeindex[3]])
                Ypoints.append(self.temp2[self.timeindex[3]])
            if self.timeindex[4]:
                Xpoints.append(self.timex[self.timeindex[4]])
                Ypoints.append(self.temp2[self.timeindex[4]])
            if self.timeindex[5]:
                Xpoints.append(self.timex[self.timeindex[5]])
                Ypoints.append(self.temp2[self.timeindex[5]])
            if self.timeindex[6]:
                Xpoints.append(self.timex[self.timeindex[6]])
                Ypoints.append(self.temp2[self.timeindex[6]])

            #end point
            if self.timex[self.timeindex[6]] != self.timex[-1]:
                Xpoints.append(self.timex[-1])
                Ypoints.append(self.temp2[-1])

            return Xpoints,Ypoints

        aw.sendmessage(QApplication.translate('Message','No finished profile found'))
        return [],[]

    #collects info about the univariate interpolation
    def univariateinfo(self):
        try:
            from scipy.interpolate import UnivariateSpline
            #pylint: disable=E0611
            Xpoints,Ypoints = self.findpoints()  #from lowest point to avoid many coefficients
            equ = UnivariateSpline(Xpoints, Ypoints)
            coeffs = equ.get_coeffs().tolist()
            knots = equ.get_knots().tolist()
            resid = equ.get_residual()
            roots = equ.roots().tolist()

            #interpretation of coefficients: http://www.sagenb.org/home/pub/1708/

            string = '<b>' + QApplication.translate('Message','Polynomial coefficients (Horner form):') + '</b><br><br>'
            string += str(coeffs) + '<br><br>'
            string += '<b>' + QApplication.translate('Message','Knots:') + '</b><br><br>'
            string += str(knots) + '<br><br>'
            string += '<b>' + QApplication.translate('Message','Residual:') + '</b><br><br>'
            string += str(resid) + '<br><br>'
            string += '<b>' + QApplication.translate('Message','Roots:') + '</b><br><br>'
            string += str(roots)

            QMessageBox.information(aw,QApplication.translate('Message','Profile information'),string)

        except ValueError as e:
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' univariateinfo() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' univariateinfo() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

#    def test(self):
##        p = 120 # period in seconds
##        k = int(round(p / self.delay * 1000)) # number of past readings to consider
#        k = 70
#        if len(self.timex)>k:
#            try:
#                ET = numpy.array([numpy.nan if x == -1 else x for x in self.temp1[-k:]], dtype='float64')
#                BT = numpy.array([numpy.nan if x == -1 else x for x in self.temp2[-k:]], dtype='float64')
#                ET_BT = ET - BT
##                delta = numpy.array([numpy.nan if x == -1 else x for x in self.delta2[-k:]], dtype='float64')
#                delta = numpy.array([numpy.nan if x == -1 else x for x in self.unfiltereddelta2[-k:]], dtype='float64')
#                idx = numpy.isfinite(ET_BT) & numpy.isfinite(delta)
#                z, residuals, _, _, _ = numpy.polyfit(ET_BT[idx],delta[idx], 2, full=True)
#                print("z",z)
#                f = numpy.poly1d(z)
#                v = f(ET_BT[-1])
##                v = (f(ET_BT[-2]) + f(ET_BT[-1])) / 2 # this smoothing seems to delay too much
#                print("res",residuals, f(0), abs(delta[-1] - v))
#                if abs(delta[-1] - v) > 10:
#                    return -1, -1
#                else:
#                    return f(0), v
##                    return residuals, v
#
##                    if residuals > 280:
##                        return -1, -1
##                    elif residuals > 50:
##                        return v, -1
##                    else:
##                        return -1, v
#            except Exception as e: # pylint: disable=broad-except
#                print(e)
#                _log.exception(e)
#                return -1, -1
#        else:
#            return -1, -1

    def polyfit(self,xarray,yarray,deg,startindex,endindex,_=False,onDeltaAxis=False):
        xa = xarray[startindex:endindex]
        ya = yarray[startindex:endindex]
        if len(xa) > 0 and len(xa) == len(ya) and not all(x == 0 for x in xa) and not all(x == 0 for x in ya):
            try:
                # polyfit only over proper values (not -1, infinite or NaN)
                c1 = [numpy.nan if x == -1 else x for x in xa]
                c1 = numpy.array(c1,dtype='float64')
                c2 = [numpy.nan if x == -1 else x for x in ya]
                c2 = numpy.array(c2,dtype='float64')
                idx = numpy.isfinite(c1) & numpy.isfinite(c2)
                z = numpy.polyfit(c1[idx],c2[idx],deg)
                p = numpy.poly1d(z)
                x = p(xarray[startindex:endindex])
                pad = max(0,len(self.timex) - startindex - len(x))
                xx = numpy.append(numpy.append([None]*max(0,startindex), x), [None]*pad)
                if onDeltaAxis:
                    trans = self.delta_ax.transData
                else:
                    trans = self.ax.transData
                self.ax.plot(self.timex, xx, linestyle = '--', linewidth=3,transform=trans)
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()
                return z
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                return None
        else:
            return None

    #ln() regression. ln() will be used when power does not equal 2 (quadratic) or 3 (cubic).
    def lnRegression(self,power=0, curvefit_starttime=0, curvefit_endtime=0, plot=True):
        res = ''
        try:
            from scipy.optimize import curve_fit
            if self.timeindex[0] > -1 and self.timeindex[6] > -1:  #CHARGE and DROP events exist
                charge = self.timex[self.timeindex[0]]
                if curvefit_starttime != None and curvefit_starttime > charge:
                    begin = self.time2index(curvefit_starttime)
                    time_l = []
                    temp_l = []
                else:
                    #a = [charge] # not used!?
                    # find the DRY END point
                    if self.timeindex[1]: # take DRY if available
                        begin = self.timeindex[1]
                    else: # take DRY as specified in phases
                        pi = aw.findDryEnd(phasesindex=1)
                        begin = self.time2index(self.timex[pi])
                    # initial bean temp set to greens_temp or ambient or a fixed temp
                    if aw.qmc.greens_temp > 0:
                        time_l = [charge]
                        temp_l = [aw.qmc.greens_temp]
                    elif aw.qmc.ambientTemp != None and aw.qmc.ambientTemp > 0:
                        time_l = [charge]
                        temp_l = [aw.qmc.ambientTemp]
                    else:
                        time_l = [charge]
                        if aw.qmc.mode == 'F':
                            roomTemp = 70.0
                        else:
                            roomTemp = 21.0
                        temp_l = [roomTemp]
                if curvefit_endtime > 0:
                    end = self.time2index(curvefit_endtime)
                else:
                    end = self.timeindex[6]
                time_l = time_l + self.timex[begin:end]
                temp_l = temp_l + self.temp2[begin:end]

                xa = numpy.array(time_l) - charge
                yn = numpy.array(temp_l)
                if power == 2:
                    func = lambda x,a,b,c: a*x*x + b*x + c
                elif power == 3:
                    func = lambda x,a,b,c,d: a*x*x*x + b*x*x + c*x + d
                else:
                    func = lambda x,a,b,c: a * numpy.log(b*x+c)
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    hint = [0.01,0.01,1]
                    if power == 2:
                        hint = [-0.001, 0.5, 10]
                    elif power == 3:
                        hint =     [-0.00001, -0.0001, 0.5, 10]
                    popt,_ = curve_fit(func, xa, yn, p0=hint, maxfev=3000) # pylint: disable=unbalanced-tuple-unpacking
                #perr = numpy.sqrt(numpy.diag(pcov))
                if plot:
                    xb = numpy.array(self.timex)
                    xxb = xb + charge
                    xxa = xa + charge
                    self.ax.plot(xxb, func(xb, *popt),  color='black', linestyle = '-.', linewidth=3)
                    self.ax.plot(xxa, yn, 'ro')
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.fig.canvas.draw()
                if len(popt)>2:
                    if power == 2:
                        res = '{:.8f} * t*t {} {:.8f} * t {} {:.8f}'.format(popt[0],('+' if popt[1] > 0 else ''),popt[1],('+' if popt[2] > 0 else ''),popt[2])
                    elif power ==3:
                        res = '{:.8f} * t*t*t {} {:.8f} * t*t {} {:.8f} * t {} {:.8f}'.format(popt[0],('+' if popt[1] > 0 else ''),popt[1],('+' if popt[2] > 0 else ''),popt[2],('+' if popt[3] > 0 else ''),popt[3])
                    else:
                        res = '{:.8f} * log({:.8f} * t {} {:.8f}, e)'.format(popt[0],popt[1],('+' if popt[2] > 0 else ''),popt[2])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate('Error Message','Error in lnRegression:') + ' lnRegression() ' + str(e),getattr(exc_tb, 'tb_lineno', '?'))
            if power == 2:
                fit = 'x\u00b2'
            elif power == 3:
                fit = 'x\u00b3'
            else:
                fit = QApplication.translate('Label','ln()')
            msg = (QApplication.translate('Message','Cannot fit this curve to ' + fit))
            QApplication.processEvents() #this is here to be sure the adderror gets wrtten to the log before the sendmessage
            aw.sendmessage(msg)
            #QMessageBox.warning(aw,QApplication.translate("Message","Curve fit problem"), msg)

        return res

    #interpolation type
    def univariate(self):
        try:
            from scipy.interpolate import UnivariateSpline
            #pylint: disable=E0611
            Xpoints,Ypoints = self.findpoints()

            func = UnivariateSpline(Xpoints, Ypoints)

            xa = numpy.array(self.timex)
            newX = func(xa).tolist()

            self.ax.plot(self.timex, newX, color='black', linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, 'ro')

            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.fig.canvas.draw()

        except ValueError:
            aw.qmc.adderror(QApplication.translate('Error Message','Value Error:') + ' univariate()')

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate('Error Message','Exception:') + ' univariate() ' + str(e),getattr(exc_tb, 'tb_lineno', '?'))
            return

    def drawinterp(self,mode):
        try:
            #pylint: disable=E1101
            from scipy import interpolate as inter
            Xpoints,Ypoints = self.findpoints() #from 0 origin
            func = inter.interp1d(Xpoints, Ypoints, kind=mode)
            newY = func(self.timex)
            self.ax.plot(self.timex, newY, color='black', linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, 'ro')

            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' drawinterp() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' drawinterp() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    # calculates the (interpolated) temperature from the given time/temp arrays at timepoint "seconds"
    @staticmethod
    def timetemparray2temp(timearray, temparray, seconds):
        if timearray is not None and temparray is not None and len(timearray) and len(temparray) and len(timearray) == len(temparray):
            if seconds > timearray[-1] or seconds < timearray[0]:
                # requested timepoint out of bonds
                return -1
            # compute the closest index (left sided)
            i = numpy.searchsorted(timearray,seconds,side='left')
            ti = timearray[i]
            tempi = temparray[i]
            if i < len(timearray) - 1:
                j = i - 1
                tj = timearray[j]
                tempj = temparray[j]
                s = (tempi - tempj) / (ti - tj)
                return tempj + s*(seconds - tj)
            # should not be reached (guarded by the outer if)
            return tempi
        return -1

    # if smoothed=True, the smoothed data is taken if available
    # if relative=True, the given time in seconds is interpreted relative to CHARGE, otherwise absolute from the first mesasurement
    def BTat(self,seconds,smoothed=True,relative=False):
        if smoothed and self.stemp2 is not None and len(self.stemp2) != 0:
            temp = self.stemp2
        else:
            temp = self.temp2
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)

    def ETat(self,seconds,smoothed=True,relative=False):
        if smoothed and self.stemp1 is not None and len(self.stemp1) != 0:
            temp = self.stemp1
        else:
            temp = self.temp1
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)

    def backgroundBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp2B,seconds + offset)

    def backgroundSmoothedBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.stemp2B,seconds + offset)

    def backgroundETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp1B,seconds + offset)

    def backgroundSmoothedETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.stemp1B,seconds + offset)

    def backgroundDBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta2B,seconds + offset)

    def backgroundDETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta1B,seconds + offset)

    # fast variant based on binary search on lists using bisect (using numpy.searchsorted is slower)
    # side-condition: values in self.qmc.timex in linear order
    # time: time in seconds
    # nearest: if nearest is True the closest index is returned (slower), otherwise the previous (faster)
    # returns
    #   -1 on empty timex
    #    0 if time smaller than first entry of timex
    #  len(timex)-1 if time larger than last entry of timex (last index)
    @staticmethod
    def timearray2index(timearray, time, nearest:bool=True):
        i = bisect_right(timearray, time)
        if i:
            if nearest and i>0 and (i == len(timearray) or abs(time - timearray[i]) > abs(time - timearray[i-1])):
                return i-1
            return i
        return -1

    #selects closest time INDEX in self.timex from a given input float seconds
    def time2index(self,seconds, nearest:bool=True):
        #find where given seconds crosses self.timex
        return self.timearray2index(self.timex, seconds, nearest)

    #selects closest time INDEX in self.timeB from a given input float seconds
    def backgroundtime2index(self,seconds, nearest:bool=True):
        #find where given seconds crosses self.timeB
        return self.timearray2index(self.timeB, seconds, nearest)

    #updates list self.timeindex when found an _OLD_ profile without self.timeindex (new version)
    def timeindexupdate(self,times):
##        #          START            DRYEND          FCs             FCe         SCs         SCe         DROP
##        times = [self.startend[0],self.dryend[0],self.varC[0],self.varC[2],self.varC[4],self.varC[6],self.startend[2]]
        for i in range(len(times)):
            if times[i]:
                self.timeindex[i] = max(0,self.time2index(times[i]))
            else:
                self.timeindex[i] = 0

    #updates list self.timeindexB when found an _OLD_ profile without self.timeindexB
    def timebackgroundindexupdate(self,times):
##        #          STARTB            DRYENDB          FCsB       FCeB         SCsB         SCeB               DROPB
##        times = [self.startendB[0],self.dryendB[0],self.varCB[0],self.varCB[2],self.varCB[4],self.varCB[6],self.startendB[2]]
        for i in range(len(times)):
            if times[i]:
                self.timeindexB[i] = max(0,self.backgroundtime2index(times[i]))
            else:
                self.timeindexB[i] = 0


    #adds errors (can be called also outside the GUI thread, eg. from the sampling thread as actual message is written by updategraphics in the GUI thread)
    def adderror(self,error,line=None):
        try:
            #### lock shared resources #####
            aw.qmc.errorsemaphore.acquire(1)
            timez = str(QDateTime.currentDateTime().toString('hh:mm:ss.zzz'))    #zzz = milliseconds
            #keep a max of 500 errors
            if len(self.errorlog) > 499:
                self.errorlog = self.errorlog[1:]
            if line:
                error = error + '@line ' + str(line)
            self.errorlog.append(timez + ' ' + error)
            # truncate to first line for window message line
            try:
                # only show first line in
                error = error.splitlines()[0]
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            if self.flagon: # don't send message here, but cache it and send it from updategraphics from within the GUI thread
                self.temporary_error = error
            else:
                aw.sendmessage(error)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        finally:
            if aw.qmc.errorsemaphore.available() < 1:
                aw.qmc.errorsemaphore.release(1)

    ####################  PROFILE DESIGNER   ###################################################################################
    #launches designer
    def designer(self):
        #disconnect mouse cross if ON
        if self.crossmarker:
            self.togglecrosslines()
        #clear background if it came from analysis
        if len(aw.qmc.analysisresultsstr) > 0:
            aw.deleteBackground()

        if len(self.timex):
            reply = QMessageBox.question(aw,QApplication.translate('Message','Designer Start'),
                                         QApplication.translate('Message','Importing a profile in to Designer will decimate all data except the main [points].\nContinue?'),
                                         QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Yes:
                res = self.initfromprofile()
                if res:
                    self.connect_designer()
                    aw.disableEditMenus(designer=True)
                    self.redraw(True)
                else:
                    aw.designerAction.setChecked(False)
            elif reply == QMessageBox.StandardButton.Cancel:
                aw.designerAction.setChecked(False)
        else:
            #if no profile found
            #
            # reset also the special event copy held for the designer
            self.eventtimecopy = []
            self.specialeventsStringscopy = []
            self.specialeventsvaluecopy = []
            self.specialeventstypecopy = []
            #
            self.reset(redraw=False,soundOn=False)
            self.connect_designer()
            self.designerinit()
            aw.disableEditMenus(designer=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def savepoints(self,_=False):
        try:
            filename = aw.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Points'),ext='*.adsg')
            if filename:
                obj = {}
                obj['timex'] = self.timex
                obj['temp1'] = self.temp1
                obj['temp2'] = self.temp2
                obj['timeindex'] = self.timeindex
                import codecs # @Reimport
                with codecs.open(filename, 'w+', encoding='utf-8') as f:
                    f.write(repr(obj))
                aw.sendmessage(QApplication.translate('Message','Points saved'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' savepoints() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def loadpoints(self,_=False):
        try:
            filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Load Points'),ext='*.adsg')
            obj = None
            if os.path.exists(filename):
                import codecs # @Reimport
                with codecs.open(filename, 'rb', encoding='utf-8') as f:
                    obj=ast.literal_eval(f.read())
            if obj and 'timex' in obj and 'temp1' in obj and 'temp2' in obj:
                self.timex = obj['timex']
                self.temp1 = obj['temp1']
                self.temp2 = obj['temp2']
                self.timeindex = obj['timeindex']
                self.xaxistosm(redraw=False)
                self.redrawdesigner()
                aw.sendmessage(QApplication.translate('Message','Points loaded'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadpoints() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))


    #used to start designer from scratch (not from a loaded profile)
    def designerinit(self):
        #init start vars        #CH, DE,      FCs,      FCe,       SCs,         SCe,         Drop,      COOL
        self.designertimeinit = [0,(4*60),(9*60),(11*60),(12*60),(12.5*60),(13*60),(17*60)]
        if self.mode == 'C':
            self.designertemp1init = [230.,230.,230.,230.,225.,220.,215.,150.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP,COOL
            self.designertemp2init = [210.,150.,198.,207.,212.,213.,215.,150.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP,COOL
        elif self.mode == 'F':
            self.designertemp1init = [446.,446.,446.,446.,437.,428.,419.,302.]
            self.designertemp2init = [410.,300.,388.,404.,413.,415.5,419.,302.]

        #check x limits
        #if self.endofx < 960:
        #    self.endofx = 960
        #    self.redraw()

        idx = 0
        self.timex,self.temp1,self.temp2 = [],[],[]
        for i in range(len(self.timeindex)):
            # add SCe and COOL END only if corresponding button is enabled
            if (i != 5 or aw.qmc.buttonvisibility[5]) and (i != 7 or aw.qmc.buttonvisibility[7]):
                self.timex.append(self.designertimeinit[i])
                self.temp1.append(self.designertemp1init[i])
                self.temp2.append(self.designertemp2init[i])
                self.timeindex[i] = idx
                idx += 1
        # add TP
        if self.mode == 'C':
            self.timex.insert(1,1.5*60)
            self.temp1.insert(1,230)
            self.temp2.insert(1,110)
            # add one intermediate point between DRY and FCs
            self.timex.insert(3,6*60)
            self.temp1.insert(3,230)
            self.temp2.insert(3,174)
        elif self.mode == 'F':
            self.timex.insert(1,1.5*60)
            self.temp1.insert(1,446)
            self.temp2.insert(1,230)
            # add one intermediate point between DRY and FCs
            self.timex.insert(3,6*60)
            self.temp1.insert(3,446)
            self.temp2.insert(3,345)
        for x in range(len(self.timeindex)):
            if self.timeindex[x] >= 2:
                self.timeindex[x] += 2
            elif self.timeindex[x] >= 1:
                self.timeindex[x] += 1

        if not self.locktimex:
            self.xaxistosm(redraw=False)
        self.redrawdesigner()

    #loads main points from a profile so that they can be edited
    def initfromprofile(self):
        if self.timeindex[0] == -1 or self.timeindex[6] == 0:
            QMessageBox.information(aw,QApplication.translate('Message','Designer Init'),
                                    QApplication.translate('Message','Unable to start designer.\nProfile missing [CHARGE] or [DROP]'))
            self.disconnect_designer()
            return False

        #save events. They will be deleted on qmc.reset()
        self.specialeventsStringscopy = self.specialeventsStrings[:]
        self.specialeventsvaluecopy = self.specialeventsvalue[:]
        self.specialeventstypecopy = self.specialeventstype[:]
        self.eventtimecopy = []
        for i in range(len(self.specialevents)):
            #save relative time of events
            self.eventtimecopy.append(self.timex[self.specialevents[i]]-self.timex[self.timeindex[0]])

        #find lowest point from profile to be converted
        lpindex = aw.findTP()
        if lpindex != -1 and not lpindex in self.timeindex:
            lptime = self.timex[lpindex]
            lptemp2 = self.temp2[lpindex]
            # we only consider TP if its BT is at least 20 degrees lower than the CHARGE temperature
            if self.temp2[self.timeindex[0]] < (lptemp2 + 20):
                lpindex = -1
        else:
            lpindex = -1

        timeindexhold = [self.timex[self.timeindex[0]],0,0,0,0,0,0,0]
        timez,t1,t2 = [self.timex[self.timeindex[0]]],[self.temp1[self.timeindex[0]]],[self.temp2[self.timeindex[0]]]    #first CHARGE point
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:                           # fill up empty lists with main points (FCs, etc). match from timeindex
                timez.append(self.timex[self.timeindex[i]])  #add time
                t1.append(self.temp1[self.timeindex[i]])    #add temp1
                t2.append(self.temp2[self.timeindex[i]])    #add temp2
                timeindexhold[i] =  self.timex[self.timeindex[i]]

        res = self.reset()  #erase screen
        if not res:
            return False

        self.timex,self.temp1,self.temp2 = timez[:],t1[:],t2[:]  #copy lists back after reset() with the main points

        self.timeindexupdate(timeindexhold) #create new timeindex[]

        #add lowest point as extra point
        if lpindex != -1:
            self.currentx = lptime
            self.currenty = lptemp2
            self.addpoint(manual=False)

        if not self.locktimex:
            self.xaxistosm(redraw=False)
        self.redrawdesigner()                                   #redraw the designer screen
        return True

    #redraws designer
    def redrawdesigner(self):
        if aw.qmc.designerflag:
            #pylint: disable=E0611
            #reset (clear) plot
            self.ax_lines_clear()
            # remove logo image while in Designer
            if self.ai is not None:
                try:
                    self.ai.remove()
                except Exception: # pylint: disable=broad-except
                    pass

            fontprop_medium = aw.mpl_fontproperties.copy()
            fontprop_medium.set_size('medium')
            self.set_xlabel(aw.arabicReshape(QApplication.translate('Label', 'Designer')))

            #draw background
            if self.background:
                self.ax.plot(self.timeB, self.stemp1B,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                sketch_params=None,path_effects=[],
                                                linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundET')))
                self.ax.plot(self.timeB, self.stemp2B,markersize=self.BTbackmarkersize,marker=self.BTbackmarker,
                                                linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                sketch_params=None,path_effects=[],
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate('Label', 'BackgroundBT')))

            #create statistics bar
            #calculate the positions for the statistics elements
            ydist = self.ylimit - self.ylimit_min
            statisticsheight = self.ylimit - (0.13 * ydist)

            #add statistics bar
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[1]]],[statisticsheight,statisticsheight],color = self.palette['rect1'],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[2]]],[statisticsheight,statisticsheight],color = self.palette['rect2'],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[6]]],[statisticsheight,statisticsheight],color = self.palette['rect3'],alpha=.5,linewidth=5)

            #add phase division lines
            ylist = [self.ylimit,0]
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[0]]],ylist,color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[1]]],ylist,color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[2]]],ylist,color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
            self.ax.plot([self.timex[self.timeindex[6]],self.timex[self.timeindex[6]]],ylist,color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')

            if not self.locktimex and self.timex[-1] > self.endofx:
                self.endofx = self.timex[-1] + 120
                self.xaxistosm()

            if self.BTsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.BTsplinedegree = len(self.timex)-1

            if self.ETsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.ETsplinedegree = len(self.timex)-1

            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            try:
                from scipy.interpolate import UnivariateSpline
                func = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
                btvals = func(timez).tolist()
                func2 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
                etvals = func2(timez).tolist()
            except Exception: # pylint: disable=broad-except
                aw.qmc.adderror(QApplication.translate('Error Message', 'Exception: redrawdesigner() Roast events may be out of order. Restting Designer.'))
                self.reset_designer()
                return

            #convert all time values to temperature

            rcParams['path.sketch'] = (0,0,0)

            if (self.DeltaBTflag or self.DeltaETflag) and self.delta_ax is not None:
                trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
            if self.DeltaBTflag:
                funcDelta = func.derivative()
                deltabtvals = [x*60 for x in funcDelta(timez).tolist()]
                self.ax.plot(timez,deltabtvals,transform=trans,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                    linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette['deltabt'],
                    label=aw.arabicReshape(deltaLabelPrefix + QApplication.translate('Label', 'BT')))

            if self.DeltaETflag:
                funcDelta2 = func2.derivative()
                deltaetvals = [x*60 for x in funcDelta2(timez).tolist()]
                self.ax.plot(timez,deltaetvals,transform=trans,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground=self.palette['background'])],
                    linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette['deltaet'],
                    label=aw.arabicReshape(deltaLabelPrefix + QApplication.translate('Label', 'ET')))

            #add curves
            if self.ETcurve:
                self.ax.plot(timez, etvals,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,
                    linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette['et'],
                        label=QApplication.translate('Label', 'ET'))
            if self.BTcurve:
                self.ax.plot(timez, btvals, markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,
                    linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette['bt'],
                        label=QApplication.translate('Label', 'BT'))

            #add markers (big circles) '0'
            if self.ETcurve:
                self.ax.plot(self.timex,self.temp1,color = self.palette['et'],marker = 'o',picker=10,linestyle='',markersize=8)
            if self.BTcurve:
                self.ax.plot(self.timex,self.temp2,color = self.palette['bt'],marker = 'o',picker=10,linestyle='',markersize=8)     #picker = 10 means 10 points tolerance


            #plot
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.fig.canvas.draw()

    #CONTEXT MENU  = Right click
    def on_press(self,event):
        try:
            if event.inaxes != self.ax: return
            if event.button != 3: return   #select right click only


            self.releaseMouse()
            self.mousepress = False
            # reset the zoom rectangles
            aw.ntb.release_pan(event)
            aw.ntb.release_zoom(event)
            # set cursor
            self.setCursor(Qt.CursorShape.OpenHandCursor)

            self.currentx = event.xdata
            self.currenty = event.ydata

            designermenu = QMenu(aw)  # if we bind this to self, we inherit the background-color: transparent from self.fig

            designermenu.addSeparator()

            addpointAction = QAction(QApplication.translate('Contextual Menu', 'Add point'),self)
            addpointAction.triggered.connect(self.addpoint_action)
            designermenu.addAction(addpointAction)

            removepointAction = QAction(QApplication.translate('Contextual Menu', 'Remove point'),self)
            removepointAction.triggered.connect(self.removepoint)
            designermenu.addAction(removepointAction)

            designermenu.addSeparator()

            loadpointsAction = QAction(QApplication.translate('Contextual Menu', 'Load points'),self)
            loadpointsAction.triggered.connect(self.loadpoints)
            designermenu.addAction(loadpointsAction)

            savepointsAction = QAction(QApplication.translate('Contextual Menu', 'Save points'),self)
            savepointsAction.triggered.connect(self.savepoints)
            designermenu.addAction(savepointsAction)

            designermenu.addSeparator()

            resetAction = QAction(QApplication.translate('Contextual Menu', 'Reset Designer'),self)
            resetAction.triggered.connect(self.reset_designer)
            designermenu.addAction(resetAction)

            configAction = QAction(QApplication.translate('Contextual Menu', 'Config...'),self)
            configAction.triggered.connect(self.desconfig)
            designermenu.addAction(configAction)

            designermenu.exec(QCursor.pos())
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def on_pick(self,event):
        if self.currentx or self.currenty:
            self.currentx = 0
            self.currenty = 0
            return

        self.setCursor(Qt.CursorShape.ClosedHandCursor)

        if hasattr(event, 'ind'):
            if isinstance(event.ind, (int)):
                self.indexpoint = event.ind
            else:
                N = len(event.ind)
                if not N: return
                self.indexpoint = event.ind[0]
        else:
            return

        self.mousepress = True

        line = event.artist
        #identify which line is being edited
        ydata = line.get_ydata()
        if ydata[1] == self.temp1[1]:
            self.workingline = 1
        else:
            self.workingline = 2

    #handles when releasing mouse
    def on_release(self,_):
        self.mousepress = False
        self.setCursor(Qt.CursorShape.OpenHandCursor)

    #handler for moving point
    def on_motion(self,event):
        if not event.inaxes: return

        ydata = event.ydata

        try:
            if self.mousepress:                                 #if mouse clicked

                self.timex[self.indexpoint] = event.xdata
                if self.workingline == 1:
                    self.temp1[self.indexpoint] = ydata
                else:
                    self.temp2[self.indexpoint] = ydata

                #check point going over point
                #check to the left
                if self.indexpoint > 0:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint - 1]) < 10.:
                        self.unrarefy_designer()
                        return
                #check to the right
                if self.indexpoint <= len(self.timex)-2:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint + 1]) < 10.:
                        self.unrarefy_designer()
                        return

                #check for possible CHARGE time moving
                if self.indexpoint == self.timeindex[0]:
                    self.xaxistosm(redraw=False)

                #redraw
                self.redrawdesigner()
                return

            if type(event.xdata):                       #outside graph type is None
                for i in range(len(self.timex)):
                    if abs(event.xdata - self.timex[i]) < 7.:
                        if i in self.timeindex:
                            if abs(self.temp2[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = 'orange',marker = 'o',alpha = .3,markersize=30)
                                with warnings.catch_warnings():
                                    warnings.simplefilter('ignore')
                                    self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = 'orange',marker = 'o',alpha = .3,markersize=30)
                                with warnings.catch_warnings():
                                    warnings.simplefilter('ignore')
                                    self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            index = self.timeindex.index(i)
                            if index == 0:
                                timez = stringfromseconds(0)
                                aw.sendmessage(QApplication.translate('Message', '[ CHARGE ]') + ' ' + timez, style="background-color:'#f07800';",append=False)
                            elif index == 1:
                                timez = stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ DRY END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 2:
                                timez = stringfromseconds(self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ FC START ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 3:
                                timez = stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ FC END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 4:
                                timez = stringfromseconds(self.timex[self.timeindex[4]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ SC START ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 5:
                                timez = stringfromseconds(self.timex[self.timeindex[5]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ SC END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 6:
                                timez = stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ DROP ]') + ' ' + timez, style="background-color:'#f07800';",append=False)
                            elif index == 7:
                                timez = stringfromseconds(self.timex[self.timeindex[7]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(QApplication.translate('Message', '[ COOL ]') + ' ' + timez, style="background-color:'#6FB5D1';",append=False)
                            break
                        if abs(self.temp2[i] - ydata) < 10:
                            self.ax.plot(self.timex[i],self.temp2[i],color = 'blue',marker = 'o',alpha = .3,markersize=30)
                            with warnings.catch_warnings():
                                warnings.simplefilter('ignore')
                                self.fig.canvas.draw()
                            QTimer.singleShot(600, self.redrawdesigner)
                        elif abs(self.temp1[i] - ydata) < 10:
                            self.ax.plot(self.timex[i],self.temp1[i],color = 'blue',marker = 'o',alpha = .3,markersize=30)
                            with warnings.catch_warnings():
                                warnings.simplefilter('ignore')
                                self.fig.canvas.draw()
                            QTimer.singleShot(600, self.redrawdesigner)
                        timez = stringfromseconds(self.timex[i] - self.timex[self.timeindex[0]])
                        aw.sendmessage(timez,style="background-color:'lightblue';",append=False)
                        break
                    totaltime = aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                    dryphasetime = aw.float2float(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                    midphasetime = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.timeindex[1]])
                    finishphasetime = aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                    if totaltime:
                        dryphaseP = int(round(dryphasetime*100./totaltime))
                        midphaseP = int(round(midphasetime*100./totaltime))
                        finishphaseP = int(round(finishphasetime*100./totaltime))
                    else:
                        return

                    #dryramp = self.temp2[self.timeindex[1]] - self.temp2[self.timeindex[0]] # ML: unused
                    midramp = self.temp2[self.timeindex[2]] - self.temp2[self.timeindex[1]]
                    finishramp = self.temp2[self.timeindex[6]] - self.temp2[self.timeindex[2]]

                    min_bt,time_min_bt = self.findTPdes()
                    dryrampTP = self.temp2[self.timeindex[1]] - min_bt
                    dryphasetimeTP = self.timex[self.timeindex[1]] - time_min_bt

                    if dryphasetimeTP:
                        dryroc = (' %.1f ' + aw.qmc.mode + '/min')%((dryrampTP/dryphasetimeTP)*60.)
                    else:
                        dryroc = ' 0 ' + aw.qmc.mode + '/min'

                    if midphasetime:
                        midroc = (' %.1f ' + aw.qmc.mode + '/min')%((midramp/midphasetime)*60.)
                    else:
                        midroc = ' 0 ' + aw.qmc.mode + '/min'

                    if finishphasetime:
                        finishroc = (' %.1f ' + aw.qmc.mode + '/min')%((finishramp/finishphasetime)*60.)
                    else:
                        finishroc = 0

                    margin = '&nbsp;&nbsp;&nbsp;'
                    string1 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s</font>"%(self.palette['rect1'],
                              margin,stringfromseconds(dryphasetime),margin, dryphaseP, margin,dryroc,margin)
                    string2 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s</font>"%(self.palette['rect2'],
                              margin,stringfromseconds(midphasetime),margin,midphaseP,margin,midroc,margin)
                    string3 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s</font>"%(self.palette['rect3'],
                              margin,stringfromseconds(finishphasetime),margin,finishphaseP,margin,finishroc,margin)
                    aw.sendmessage(string1+string2+string3,append=False)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' on_motion() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            self.unrarefy_designer()
            return

    def findTPdes(self):
        try:
            from scipy.interpolate import UnivariateSpline
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            btvals = funcBT(timez).tolist()
            min_bt = min(btvals)
            idx_min_bt = btvals.index(min_bt)
            time_min_bt = timez[idx_min_bt]
            return min_bt, time_min_bt

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' findTPdes() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return None

    #this is used in on_motion() to try to prevent points crossing over points
    def unrarefy_designer(self):
        for i in range(len(self.timex)-1):
            if abs(self.timex[i]-self.timex[i+1]) < 20:
                self.timex[i+1] = self.timex[i] + 20
            self.disconnect_designer()
            self.connect_designer()

    @pyqtSlot()
    @pyqtSlot(bool)
    def addpoint_action(self,_=False):
        self.addpoint()

    def addpoint(self,manual=True):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            if manual:
                # open a dialog to let the user correct the input
                offset = 0
                if self.timeindex[0] > -1:
                    offset = self.timex[self.timeindex[0]]
                values = [self.currentx-offset, self.currenty]
                from artisanlib.designer import pointDlg
                dlg = pointDlg(parent=aw, aw=aw, values=values)
                if dlg.exec():
                    self.currentx = values[0] + offset
                    self.currenty = values[1]
                else:
                    return


            if self.currentx > self.timex[-1]:       #if point is beyond max timex (all the way to the right)

                #find closest line
                d1 = abs(self.temp1[-1] - self.currenty)
                d2 = abs(self.temp2[-1] - self.currenty)
                if d2 < d1:
                    self.temp2.append(self.currenty)
                    self.temp1.append(self.temp1[-1])
                else:
                    self.temp2.append(self.temp2[-1])
                    self.temp1.append(self.currenty)

                self.timex.append(self.currentx)
                #no need to update time index

                self.redrawdesigner()
                return # 0

            if self.currentx < self.timex[0]:         #if point is below min timex (all the way to the left)
                #find closest line
                d1 = abs(self.temp1[0] - self.currenty)
                d2 = abs(self.temp2[0] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(0,self.currenty)
                    self.temp1.insert(0,self.temp1[0])
                else:
                    self.temp2.insert(0,self.temp2[0])
                    self.temp1.insert(0,self.currenty)

                self.timex.insert(0,self.currentx)

                #update timeindex
                if self.timeindex[0] != -1:   #we update timeindex[0] different
                    self.timeindex[0] += 1
                for u in range(1,len(self.timeindex)):
                    if self.timeindex[u]:
                        self.timeindex[u] += 1

                self.redrawdesigner()
                return # len(self.timex)-1   #return index received from Designer Dialog Config to assign index to timeindex)

            #mid range
            #find index
            for i in range(len(self.timex)):
                if self.timex[i] > self.currentx:
                    break
            #find closest line
            d1 = abs(self.temp1[i] - self.currenty)
            d2 = abs(self.temp2[i] - self.currenty)
            if (d2 < d1 or self.temp1[i] == -1) and self.temp2[i] != -1:
                self.temp2.insert(i,self.currenty)
                self.temp1.insert(i,self.temp1[i])
            elif self.temp1[i] != -1:
                self.temp2.insert(i,self.temp2[i])
                self.temp1.insert(i,self.currenty)
            if not (self.temp1[i] == -1 and self.temp2[i] == -1):
                self.timex.insert(i,self.currentx)

                #update timeindex
                for x in range(len(self.timeindex)):
                    if self.timeindex[x] >= i:
                        self.timeindex[x] += 1

            self.redrawdesigner()
            return # i

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' addpoint() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    #removes point
    @pyqtSlot()
    @pyqtSlot(bool)
    def removepoint(self,_=False):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            #find index
            for i in range(len(self.timex)):
                if self.timex[i] > self.currentx:
                    break
            #find closest point
            if abs(self.timex[i]- self.currentx) < abs(self.timex[i-1] - self.currentx):
                index = i
            else:
                index = i-1

            #check if if it is a landmark point
            if index in self.timeindex:
                whichone = self.timeindex.index(index)
                if whichone in [0, 6]:  #if charge or drop
                    return
                self.timeindex[whichone] = 0

            self.timex.pop(index)
            self.temp1.pop(index)
            self.temp2.pop(index)

            for x in range(len(self.timeindex)):
                if self.timeindex[x] > index: #decrease time index by one when above the index taken out
                    self.timeindex[x] = max(0,self.timeindex[x] - 1)

            self.redrawdesigner()

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' removepoint() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return


    #converts from a designer profile to a normal profile
    def convert_designer(self):
        try:
            from scipy.interpolate import UnivariateSpline
            #pylint: disable=E0611
            #prevents accidentally deleting a modified profile.
            self.fileDirtySignal.emit()
            #create functions
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            funcET = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)

            #create longer list of time values
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()

            #convert all time values to temperature
            btvals = funcBT(timez).tolist()
            etvals = funcET(timez).tolist()

            #find new indexes for events
            for i in range(len(self.specialevents)):
                for p in range(len(timez)):
                    if timez[p] > self.timex[self.specialevents[i]]:
                        self.specialevents[i] = p
                        break

            #save landmarks
            maintimes = []
            for i in range(len(self.timeindex)):
                maintimes.append(self.timex[self.timeindex[i]])

            self.timex = timez[:]
            self.temp1 = etvals[:]
            self.temp2 = btvals[:]

            self.timeindexupdate(maintimes)

            #check and restore carried over events
            if len(self.eventtimecopy):
                for i in range(len(self.eventtimecopy)):
                    self.specialevents.append(self.time2index(self.eventtimecopy[i] + self.timex[self.timeindex[0]]))
                self.specialeventsStrings = self.specialeventsStringscopy[:]
                self.specialeventsvalue = self.specialeventsvaluecopy[:]
                self.specialeventstype = self.specialeventstypecopy[:]

            #check for extra devices
            num = len(self.timex)
            for i in range(len(self.extradevices)):
                self.extratemp1[i] = [-1.]*num
                self.extratemp2[i] = [-1.]*num
                self.extratimex[i] = self.timex[:]

            if self.profile_sampling_interval is None:
                self.profile_sampling_interval = self.delay / 1000.

            self.disconnect_designer()

            #create playback events
            if self.reproducedesigner:
                functioncall = [0,
                                self.designer_create_BT_rateofchange,
                                self.designer_create_ET_rateofchange,
                                self.designer_create_sv_command,
                                self.designer_create_ramp_command]

                functioncall[self.reproducedesigner]() # pylint: disable=not-callable

            self.redraw()
            aw.sendmessage(QApplication.translate('Message', 'New profile created'))

        except ValueError:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate('Error Message', 'Value Error:') + ' createFromDesigner()',getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' createFromDesigner() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    #activates mouse events
    def connect_designer(self):
        if not self.designerflag:
            self.designerflag = True
            aw.designerAction.setChecked(True)
            self.setCursor(Qt.CursorShape.OpenHandCursor)
            self.mousepress = None
            #create mouse events. Note: keeping the ids inside a list helps protect against extrange python behaviour.
            self.designerconnections = [None,None,None,None]
            self.designerconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.on_pick)
            self.designerconnections[1] = self.fig.canvas.mpl_connect('button_release_event', self.on_release)
            self.designerconnections[2] = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
            self.designerconnections[3] = self.fig.canvas.mpl_connect('button_press_event', self.on_press) #right click
            #this is needed to prevent complaints from UnivariateSpline() -used in redraw()- in extreme cases of difficulty
            warnings.simplefilter('ignore', UserWarning)

    #deactivates mouse events
    def disconnect_designer(self):
        self.designerflag = False
        aw.designerAction.setChecked(False)
        for i in range(len(self.designerconnections)):
            if self.designerconnections[i] is not None:
                self.fig.canvas.mpl_disconnect(self.designerconnections[i])
        self.setCursor(Qt.CursorShape.ArrowCursor)
        warnings.simplefilter('default', UserWarning)

    #launches designer config Window
    @pyqtSlot()
    @pyqtSlot(bool)
    def desconfig(self, _=False): # pylint: disable=no-self-use # used as slot
        from artisanlib.designer import designerconfigDlg
        dialog = designerconfigDlg(aw,aw)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def reset_designer(self,_=False):
        self.reset()
        self.disconnect_designer()
        self.connect_designer()
        self.designerinit()

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_BT_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp2[self.timeindex[i]] - self.temp2[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = QApplication.translate('Label', 'BT {0} {1}/min for {2}').format('%.1f'%(difftemp/difftime),aw.qmc.mode,stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]]))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_ET_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp1[self.timeindex[i]] - self.temp1[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = QApplication.translate('Label', 'ET {0} {1}/min for {2}').format('%.1f'%(difftemp/difftime),aw.qmc.mode,stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]]))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    def deleteEvents(self):
        self.specialevents = []
        self.specialeventstype = []
        self.specialeventsStrings = []
        self.specialeventsvalue = []

    #this is used to create a string in pid language to reproduce the profile from Designer
    #NOTE: pid runs ET (temp1)
    def designer_create_ramp_command(self):
        tempinits = []
        minutes_segments = []

        #ramp times in minutes
        minsDryPhase = str(int(abs(self.timex[self.timeindex[0]] - self.timex[self.timeindex[1]])/60))
        minsMidPhase = str(int(abs(self.timex[self.timeindex[1]] - self.timex[self.timeindex[2]])/60))
        minsFinishPhase = str(int(abs(self.timex[self.timeindex[2]] - self.timex[self.timeindex[6]])/60))

        #target temps for ET
        tempinits.append('%.1f'%self.temp1[self.timeindex[1]])
        tempinits.append('%.1f'%self.temp1[self.timeindex[2]])
        tempinits.append('%.1f'%self.temp1[self.timeindex[6]])

        minutes_segments.append(minsDryPhase)
        minutes_segments.append(minsMidPhase)
        minutes_segments.append(minsFinishPhase)

        command = ''
        for i in range(3):
            command += 'SETRS::' + tempinits[i] + '::' + minutes_segments[i] + '::0::'
        command += 'SETRS::' + tempinits[-1] + '::0::0'

        self.clean_old_pid_commands()

        #do only one event but with all segments
        self.specialevents.append(0)
        self.specialeventstype.append(0)
        self.specialeventsStrings.append(command)
        self.specialeventsvalue.append(0)

    #this is used to create a string in ET temp language to reproduce the profile from Designer
    def designer_create_sv_command(self):
        self.clean_old_pid_commands()
        for i in range(len(self.timeindex)-1):
            command = 'SETSV::%.1f'%self.temp1[self.timeindex[i+1]]
            if i > 0 and self.timeindex[i]:
                self.specialevents.append(self.timeindex[i])
                self.specialeventstype.append(0)
                self.specialeventsStrings.append(command)
                self.specialeventsvalue.append(0)

    #verifies there are no previous machine commands on events
    def clean_old_pid_commands(self):
        #check for possible preloaded machine commands
        target = 0
        if len(self.specialevents):
            for i in range(len(self.specialevents)):
                if '::' in self.specialeventsStrings[i]:
                    self.specialevents.pop(i)
                    self.specialeventstype.pop(i)
                    self.specialeventsStrings.pop(i)
                    self.specialeventsvalue.pop(i)
                    target = 1
                    break     #break or the index i can become larger than the new shorted length of specialevents
        if target:
            self.clean_old_pid_commands()

    ###################################      WHEEL GRAPH  ####################################################

    @staticmethod
    def findCenterWheelTextAngle(t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if t in [0.,360.]:
            return 270.
        #check cuadrants
        if 0. < t < 90 or t > 360:        #quadrant 1
            return 270.+t
        if 90 <= t <= 180:                #quadrant 2
            return t - 90.
        if 180 < t < 270:                 #quadrant 3
            return t + 90
        return t - 270                    #quadrant 4

    @staticmethod
    def findRadialWheelTextAngle(t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if 0 < t <= 90 or t > 270:
            return t
        return 180 + t

    def loadselectorwheel(self,path):
        s = 'Wheels' + '\\' + path
        direct = QDir()
        pathDir = direct.toNativeSeparators(s)
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Open Wheel Graph'),path=pathDir,ext='*.wg')
        if filename:
            self.connectWheel()
            aw.loadWheel(filename)
            self.drawWheel()

    @pyqtSlot()
    @pyqtSlot(bool)
    def addTocuppingnotes(self,_=False):
        descriptor = str(self.wheelnames[self.wheelx][self.wheelz])
        if self.cuppingnotes == '':
            self.cuppingnotes = descriptor
        else:
            self.cuppingnotes += '\n' + descriptor
        s = QApplication.translate('Message', ' added to cupping notes')
        aw.sendmessage(descriptor + s)

    @pyqtSlot()
    @pyqtSlot(bool)
    def addToroastingnotes(self,_=False):
        descriptor =  str(self.wheelnames[self.wheelx][self.wheelz]) + ' '
        if self.roastingnotes == '':
            self.roastingnotes = descriptor
        else:
            self.roastingnotes +=  '\n' + descriptor
        string = QApplication.translate('Message', ' added to roasting notes')
        aw.sendmessage(descriptor + string)

    def wheel_pick(self,event):
        rect =  event.artist
        loc = rect.get_url().split('-')
        x = int(loc[0])
        z = int(loc[1])
        aw.sendmessage(self.wheelnames[x][z])
        self.wheelx = x
        self.wheelz = z

    def wheel_release(self,event):
        newlocz = event.xdata
        if newlocz:
            if newlocz != self.wheellocationz:
                diff = math.degrees(self.wheellocationx - newlocz)
                for i in range(len(self.startangle)):
                    self.startangle[i] -= diff
                self.drawWheel()

    def wheel_menu(self,event):
        if str(event.inaxes) != str(self.ax2): return
        if event.button == 1:
            self.wheellocationx = event.xdata
            self.wheellocationz = event.ydata

        elif event.button == 3:
            designermenu = QMenu(aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
            cuppingAction = QAction(QApplication.translate('Contextual Menu', 'Add to Cupping Notes'),self)
            cuppingAction.triggered.connect(self.addTocuppingnotes)
            designermenu.addAction(cuppingAction)

            roastingAction = QAction(QApplication.translate('Contextual Menu', 'Add to Roasting Notes'),self)
            roastingAction.triggered.connect(self.addToroastingnotes)
            designermenu.addAction(roastingAction)

            designermenu.addSeparator()

            editAction = QAction(QApplication.translate('Contextual Menu', 'Edit'),self)
            editAction.triggered.connect(self.editmode)
            designermenu.addAction(editAction)

            designermenu.exec(QCursor.pos())

    @pyqtSlot()
    @pyqtSlot(bool)
    def editmode(self,_=False):
        self.disconnectWheel()
        aw.wheeldialog.show()

    def exitviewmode(self):
        self.disconnectWheel()
        if self.ax2 is not None:
            try:
                self.fig.delaxes(self.ax2)
            except Exception: # pylint: disable=broad-except
                pass
        self.redraw(recomputeAllDeltas=False,forceRenewAxis=True)

    def connectWheel(self):
        self.wheelflag = True
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.wheelconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.wheel_pick)
        self.wheelconnections[1] = self.fig.canvas.mpl_connect('button_press_event', self.wheel_menu)           #right click menu context
        self.wheelconnections[2] = self.fig.canvas.mpl_connect('button_release_event', self.wheel_release)

    def disconnectWheel(self):
        self.wheelflag = False
        self.setCursor(Qt.CursorShape.ArrowCursor)
        self.fig.canvas.mpl_disconnect(self.wheelconnections[0])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[1])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[2])

    def drawWheel(self):
        try:
            ### var constants  #####
            pi = numpy.pi
            threesixty = 2.*pi
            div = threesixty/100.
            rad = 360./threesixty
            ########################
            # same as redraw but using different axes
            self.fig.clf()
            #create a new name ax1 instead of ax
            if self.ax2 is not None:
                try:
                    self.fig.delaxes(self.ax2)
                except Exception: # pylint: disable=broad-except
                    pass
            self.ax2 = self.fig.add_subplot(111, projection='polar',facecolor='None')

            # fixing yticks with matplotlib.ticker "FixedLocator"
            try:
                ticks_loc = self.ax2.get_yticks()
                self.ax2.yaxis.set_major_locator(ticker.FixedLocator(ticks_loc))
            except Exception: # pylint: disable=broad-except
                pass

            self.ax2.set_rmax(1.)
            self.ax2.set_aspect(self.wheelaspect)
            self.ax2.grid(False)

            #delete degrees ticks
            for tick in self.ax2.xaxis.get_major_ticks():
                #tick.label1On = False
                tick.label1.set_visible(False)
            #delete yaxis
            locs = self.ax2.get_yticks()
            labels = ['']*len(locs)
            self.ax2.set_yticklabels(labels)

            names = self.wheelnames[:]
            Wradii = self.wradii[:]
            startangle = self.startangle[:]
            projection = self.projection[:]

            #calculate text orientation
            wheels = len(names)

            if not wheels:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()
                return

            n,textangles,textloc = [],[],[] # nr of names, text angles, text locations
            for i in range(wheels):
                l,tloc = [],[]
                count = self.startangle[i]
                #calculate text orientation
                for p in range(len(names[i])):
                    if projection[i] == 0:
                        l.append(0)
                    elif projection[i] == 1:
                        l.append(self.findCenterWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    elif projection[i] == 2:
                        l.append(self.findRadialWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    tloc.append((3.6*self.segmentlengths[i][p]/2. + count)/rad)
                    count += self.segmentlengths[i][p]*3.6

                textloc.append(tloc)
                textangles.append(l)
                Wradii[i] = float(Wradii[i])/100.                   #convert radii to float between 0-1 range
                startangle[i] = startangle[i]/rad                   #convert angles to radians
                n.append(len(names[i]))                             #store the number of names for each wheel

            #store the absolute len-radius origin of each circle
            lbottom = [0.]
            count = 0.
            for i in range(wheels-1):
                count += Wradii[i]
                lbottom.append(count)

            Wradiitext = [Wradii[0]/2.]
            for i in range(wheels-1):
                Wradiitext.append(lbottom[i+1] + Wradii[i+1]/2.)     #store absolute len-radius for text in each circle
                Wradii[i] += self.wheeledge                          #create extra color edge between wheels by overlapping wheels
            #Generate Wheel graph
            bar = []                                                 #holds bar-graphs (wheels)
            for z in range(len(n)):
                #create wheel
                theta,segmentwidth,radii = [],[],[]
                count = startangle[z]
                for i in range(n[z]):
                    #negative number affect eventpicker
                    if count > threesixty:
                        count %= threesixty
                    elif count < 0.:
                        count += threesixty
                    theta.append(count + div*self.segmentlengths[z][i] / 2.)
                    count += div*self.segmentlengths[z][i]
                    segmentwidth.append(div*self.segmentlengths[z][i])
                    radii.append(Wradii[z])

                bar.append(self.ax2.bar(theta, radii, width=segmentwidth, bottom=lbottom[z],edgecolor=self.wheellinecolor,
                                        linewidth=self.wheellinewidth,picker=3))
                count = 0
                #set color, alpha, and text
                for _,bar[z] in zip(radii, bar[z]):
                    bar[z].set_facecolor(self.wheelcolor[z][count])
                    bar[z].set_alpha(max(min(self.segmentsalpha[z][count],1),0))
                    bar[z].set_url(str(z) + '-' + str(count))
                    fontprop = aw.mpl_fontproperties.copy()
                    fontprop.set_size(self.wheeltextsize[z])
                    anno = self.ax2.annotate(names[z][count],xy=(textloc[z][count],Wradiitext[z]),xytext=(textloc[z][count],Wradiitext[z]),
                        rotation=textangles[z][count],
                        horizontalalignment='center',
                        verticalalignment='center',
                        color=aw.qmc.wheeltextcolor,
                        fontproperties=fontprop)
                    try:
                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                        pass
                    count += 1
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Value Error:') + ' drawWheel() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' drawWheel() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    def makewheelcolorpattern(self):
        for x in range(len(self.wheelcolor)):
            wlen = len(self.wheelcolor[x])
            for i in range(wlen):
                color = QColor()
                color.setHsv((360/wlen)*i*self.wheelcolorpattern,255,255,255)
                self.wheelcolor[x][i] = str(color.name())

    # sets parent and corrects segment lengths so that child fits inside parent (multiple children can be set to same parent)
    # input: z = index of parent in previous wheel    # wn = wheel number    # idx = index of element in wheel x
    def setwheelchild(self,z,wn,idx):
        #set same start angle
        self.startangle[wn] = self.startangle[wn-1]
        self.wheellabelparent[wn][idx] = z

        #adjust lengths
        for x in range(1,len(self.segmentlengths)):
            nsegments = len(self.segmentlengths[x])
            parentanglecount = 0
            for i in range(nsegments):
                if self.wheellabelparent[x][i]:                                                   #if parent selected (otherwise 0)
                    parentindex = self.wheellabelparent[x][i]                                     #parent index
                    if self.wheellabelparent[x][i] == parentindex:                                #if match
                        parentangle = self.segmentlengths[x-1][self.wheellabelparent[x][i]-1]     #find parent angle (in %)
                        #find number of labels with same parent
                        count = self.wheellabelparent[x].count(parentindex)                       #count number of labels with same parent
                        self.segmentlengths[x][i] = parentangle/count                             #divide parent angle between children

                        #calculate last total angle
                        if i < nsegments-1:
                            parentanglecount += self.segmentlengths[x][i]

                        #adjust rest of angles to get 100 % coverage
                        for a in range(i+1,nsegments):
                            self.segmentlengths[x][a] = (100-parentanglecount)/(nsegments-(i+1))

#############################     MOUSE CROSS     #############################

    def togglecrosslines(self):
        if self.crossmarker == False and not self.designerflag and not self.flagstart:  #if not projection flag
            #turn ON
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None
            self.updateBackground() # update bitlblit backgrounds
            self.crossmarker = True
            message = QApplication.translate('Message', 'Mouse Cross ON: move mouse around')
            aw.sendmessage(message)
            self.crossmouseid = self.fig.canvas.mpl_connect('motion_notify_event', self.drawcross)
            self.onreleaseid = self.fig.canvas.mpl_connect('button_release_event', self.onrelease)  #mouse cross lines measurement
        else:
            #turn OFF
            self.crossmarker = False
            if self.crossmouseid is not None:
                try:
                    self.fig.canvas.mpl_disconnect(self.crossmouseid)
                except Exception: # pylint: disable=broad-except
                    pass
            if self.onreleaseid is not None:
                try:
                    self.fig.canvas.mpl_disconnect(self.onreleaseid)  #mouse cross lines measurement
                except Exception: # pylint: disable=broad-except
                    pass
            try:
                aw.qmc.ax.lines.remove(self.l_horizontalcrossline)
            except Exception: # pylint: disable=broad-except
                pass
            self.l_horizontalcrossline = None
            try:
                aw.qmc.ax.lines.remove(self.l_verticalcrossline)
            except Exception: # pylint: disable=broad-except
                pass
            self.l_verticalcrossline = None
            self.resetlines()
            message = QApplication.translate('Message', 'Mouse cross OFF')
            aw.sendmessage(message)
            self.updateBackground() # update bitlblit backgrounds

    def drawcross(self,event):
        # do not interleave with redraw()
        gotlock = aw.qmc.profileDataSemaphore.tryAcquire(1,0)
        if gotlock:
            try:
                if event.inaxes == self.ax:
                    x = event.xdata
                    y = event.ydata
                    if self.baseX and self.baseY:
                        deltaX = stringfromseconds(event.xdata - self.baseX)
                        deltaY = str(aw.float2float(event.ydata - self.baseY,1))
                        RoR = str(aw.float2float(60 * (event.ydata - self.baseY) / (event.xdata - self.baseX),1))
                        deltaRoR = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,event.ydata))[1]))[1]
                                    - self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,self.baseY))[1]))[1])
                        #RoRoR is always in C/min/min
                        if aw.qmc.mode == 'F':
                            deltaRoR = RoRfromFtoC(deltaRoR)
                        RoRoR = str(aw.float2float(60 * (deltaRoR)/(event.xdata - self.baseX),1))
                        message = f'delta Time= {deltaX},    delta Temp= {deltaY} {aw.qmc.mode},    RoR= {RoR} {aw.qmc.mode}/min,    RoRoR= {RoRoR} C/min/min'
                        aw.sendmessage(message)
                        self.base_messagevisible = True
                    elif self.base_messagevisible:
                        aw.clearMessageLine()
                        self.base_messagevisible = False
                    if x and y:
                        if self.l_horizontalcrossline is None:
                            self.l_horizontalcrossline = self.ax.axhline(y,color = self.palette['text'], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_horizontalcrossline.set_ydata(y)
                        if self.l_verticalcrossline is None:
                            self.l_verticalcrossline = self.ax.axvline(x,color = self.palette['text'], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_verticalcrossline.set_xdata(x)
                        if self.ax_background:
                            self.fig.canvas.restore_region(self.ax_background)
                            aw.qmc.ax.draw_artist(self.l_horizontalcrossline)
                            aw.qmc.ax.draw_artist(self.l_verticalcrossline)
                            if self.base_horizontalcrossline and self.base_verticalcrossline:
                                aw.qmc.ax.draw_artist(self.base_horizontalcrossline)
                                aw.qmc.ax.draw_artist(self.base_verticalcrossline)
                            try:
                                self.fig.canvas.blit(aw.qmc.ax.get_tightbbox(self.fig.canvas.get_renderer()))
                            except Exception: # pylint: disable=broad-except
                                pass
                        else:
                            self.updateBackground()
            finally:
                if aw.qmc.profileDataSemaphore.available() < 1:
                    aw.qmc.profileDataSemaphore.release(1)

    def __to_ascii(self, s):
        if s is None:
            return None
        utf8_string = str(s)
        if self.locale_str.startswith('de'):
            for k in self.umlaute_dict.keys():
                utf8_string = utf8_string.replace(k, self.umlaute_dict[k])
        from unidecode import unidecode
        return unidecode(utf8_string)


#######################################################################################
#######################  END OF MAIN APPLICATION   ####################################
#######################################################################################

#######################################################################################
#####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
#######################################################################################


def my_get_icon(name):
    basedir = os.path.join(mpl.rcParams['datapath'], 'images')
    p = os.path.join(basedir, name.replace('.svg','.png'))
    if os.path.exists(p):
        return QIcon(p)
    return None

def my_fedit(data, comment='', icon=None, parent=None, **kargs):
    del kargs

    axes = aw.qmc.ax
    figure = aw.qmc.fig
    orig_xlim = axes.get_xlim()
    orig_ylim = axes.get_ylim()
    linedict = {}
    for line in axes.get_lines():
        label = line.get_label()
        if label == '_nolegend_':
            continue
        linedict[label] = line

    if len(data) > 1:
        # just take the Curve Styles and drop the Axis settings
        data = data[1][0]
        # add translations
        trans = {
            'Label': QApplication.translate('Label', 'Label'),
            '<b>Line</b>': '<b>{}</b>'.format(QApplication.translate('Label', 'Line')),
            'Line style': QApplication.translate('Label', 'Line style'),
            'Draw style': QApplication.translate('Label', 'Draw style'),
            'Width': QApplication.translate('Label', 'Width'),
            'Color (RGBA)': QApplication.translate('Label', 'Color (RGBA)'),
            '<b>Marker</b>': '<b>{}</b>'.format(QApplication.translate('Label', 'Marker')),
            'Style': QApplication.translate('Label', 'Symbol'),
            'Size': QApplication.translate('Label', 'Size'),
            'Face color (RGBA)': QApplication.translate('Label', 'Face color (RGBA)'),
            'Edge color (RGBA)': QApplication.translate('Label', 'Edge color (RGBA)'),
        }
        try:
            for l in data:
                if isinstance(l, (list, tuple)) and len(l)>0:
                    translated_tpls = [] # translated tuples l[0]
                    for tpl in l[0]:
                        if isinstance(tpl, list) and len(tpl) > 0:
                            if tpl[0] in trans:
                                tpl[0] = trans[tpl[0]]
                            translated_tpls.append(tpl)
                        elif isinstance(tpl, tuple) and len(tpl) > 0:
                            if tpl[0] in trans:
                                tpl_list = list(tpl)
                                tpl_list[0] = trans[tpl[0]]
                                translated_tpls.append(tuple(tpl_list))
                            elif len(tpl)>1 and tpl[0] is None and tpl[1] is not None and tpl[1] in trans:
                                tpl_list = list(tpl)
                                tpl_list[1] = trans[tpl[1]]
                                translated_tpls.append(tuple(tpl_list))
                            else:
                                translated_tpls.append(tpl)
                    l[0] = translated_tpls
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        def my_apply(data):
            try:
                # Set / Curves
                for curve in data:
                    if curve[0] in linedict:
                        line = linedict[curve[0]]
                        (label, linestyle, drawstyle, linewidth, color, marker, markersize,
                         markerfacecolor, markeredgecolor) = curve
                        line.set_label(label)
                        line.set_linestyle(linestyle)
                        line.set_drawstyle(drawstyle)
                        line.set_linewidth(linewidth)
                        rgba = mcolors.to_rgba(color)
                        line.set_alpha(None)
                        line.set_color(rgba)
                        if marker != 'none':
                            line.set_marker(marker)
                            line.set_markersize(markersize)
                            line.set_markerfacecolor(markerfacecolor)
                            line.set_markeredgecolor(markeredgecolor)
                # Redraw
                figure.canvas.draw()
                if not (axes.get_xlim() == orig_xlim and axes.get_ylim() == orig_ylim):
                    figure.canvas.toolbar.push_current()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
    dialog = formlayout.FormDialog(data, QApplication.translate('Toolbar', 'Lines'), comment, icon, parent, my_apply)
    dialog.exec()
    return dialog.get()

#####

# monkey patching MPL 3.5.1 _formlayout.py:ColorButton to work on Qt6 (not relevant on Qt5)
# (see https://github.com/matplotlib/matplotlib/issues/22471)
# to be removed on upgrading to 3.5.2 which fixes this
class MPLColorButtonPatched(QPushButton):
    """
    Color choosing push button
    """
    colorChanged = pyqtSignal(QColor)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(20, 20)
        self.setIconSize(QSize(12, 12))
        self.clicked.connect(self.choose_color)
        self._color = QColor()

    def choose_color(self):
        color = QColorDialog.getColor(
            self._color, self.parentWidget(), '',
            QColorDialog.ColorDialogOption.ShowAlphaChannel)
        if color.isValid():
            self.set_color(color)

    def get_color(self):
        return self._color

    @pyqtSlot(QColor)
    def set_color(self, color):
        if color != self._color:
            self._color = color
            self.colorChanged.emit(self._color)
            pixmap = QPixmap(self.iconSize())
            pixmap.fill(color)
            self.setIcon(QIcon(pixmap))

    color = pyqtProperty(QColor, get_color, set_color)


class VMToolbar(NavigationToolbar): # pylint: disable=abstract-method
    def __init__(self, plotCanvas, parent,white_icons=False):
        # toolitem entries of the form (text, tooltip_text, image_file, callback)
        self.toolitems = (
                ('Plus', QApplication.translate('Tooltip', 'Connect to plus service'), 'plus', 'plus'),
                ('', QApplication.translate('Tooltip', 'Subscription'), 'plus-pro', 'subscription'),
                (QApplication.translate('Toolbar', 'Home'), QApplication.translate('Tooltip', 'Reset original view'), 'home', 'home'),
                (QApplication.translate('Toolbar', 'Back'), QApplication.translate('Tooltip', 'Back to  previous view'), 'back', 'back'),
                (QApplication.translate('Toolbar', 'Forward'), QApplication.translate('Tooltip', 'Forward to next view'), 'forward', 'forward'),
                (None, None, None, None),
                (QApplication.translate('Toolbar', 'Pan'), QApplication.translate('Tooltip', 'Pan axes with left mouse, zoom with right'), 'move', 'pan'),
                (QApplication.translate('Toolbar', 'Zoom'), QApplication.translate('Tooltip', 'Zoom to rectangle'), 'zoom_to_rect', 'zoom'),
        )

        # if true, we render Artisan-specific white versions of the icons
        self.white_icons = white_icons

        self.axis_ranges = [] # holds the ranges of all axis to detect if it is zoomed in

        # holds the last known cursor event while mouse pointer is in canvas, set by mouse_move()
        self._last_event = None

        NavigationToolbar.__init__(self, plotCanvas, parent)

        # lets make the font of the coordinates QLabel a little larger
        f = self.locLabel.font()
        if platf == 'Linux':
            f.setPointSize(f.pointSize()+2)
        else:
            f.setPointSize(f.pointSize()+4)
#        f.setStyleHint(QFont.StyleHint.TypeWriter) # not monospaced!
        f.setStyleHint(QFont.StyleHint.Monospace)
        f.setFamily('monospace')
#        f.setWeight(QFont.Bold)
#        f.setBold(True)
        self.locLabel.setFont(f)


# add green flag menu on matplotlib v2.0 and later
        self.edit_curve_parameters_action = None
        if len(self.actions()) > 0:
            # insert the "Green Flag" menu item before the last one (which is the x/y coordinate display)
            self.edit_curve_parameters_action = QAction(self._icon('qt4_editor_options.png'),QApplication.translate('Toolbar', 'Lines'),self)
            self.edit_curve_parameters_action.triggered.connect(self.my_edit_parameters)
            self.edit_curve_parameters_action.setToolTip(QApplication.translate('Tooltip', 'Line styles'))
            self.insertAction(self.actions()[-1], self.edit_curve_parameters_action)

        # adjust for dark or light canvas and set hover/selection style
        for a in self.actions():
            if aw is not None:
                if aw.qmc.palette['canvas'] is None or aw.qmc.palette['canvas'] == 'None':
                    canvas_color = QColor('#ECECEC')
                else:
                    canvas_color = QColor(aw.qmc.palette['canvas'])
                if canvas_color.name() == '#000000': # on black we start with (1,1,1) for lighter
                    canvas_color = QColor('#222222')

                if self.white_icons:
                    selected_canvas_color = canvas_color.lighter(250)
                    border_color = 'white'
                else:
                    selected_canvas_color = canvas_color.darker(120)
                    border_color = 'black'
                self.widgetForAction(a).setStyleSheet(' \
                        QToolButton:checked {border:1px solid transparent; margin: 1px; padding: 2px; background-color:' + selected_canvas_color.name() + ';border-radius: 3px;} \
                        QToolButton:hover {border:1px solid ' + border_color + '; margin: 2px; padding: 2px; background-color:transparent;border-radius: 3px;} \
                        QToolButton:checked:hover {border:1px solid ' + border_color + '; margin: 2px; padding: 2px; background-color:' + selected_canvas_color.name() + ';border-radius: 3px;} \
                        QToolButton {border:1px solid transparent; margin: 2px; padding: 2px; background-color: transparent;border-radius: 3px;}')

        if aw is not None:
            aw.updatePlusStatus(self)


        self.update_view_org = self._update_view
        self._update_view = self.update_view_new

        self.release_pan_org = self.release_pan
        self.release_pan = self.release_pan_new
        self.release_zoom_org = self.release_zoom
        self.release_zoom = self.release_zoom_new

        # monkey patch matplotlib figureoptions that links to svg icon by default (crashes Windows Qt4 builds!)
        if not svgsupport:
            figureoptions.get_icon = my_get_icon
        # monkey patch _formlayout
        try:
            formlayout.fedit_org #@UndefinedVariable
        except Exception: # pylint: disable=broad-except
            # not yet monkey patched
            formlayout.fedit_org = formlayout.fedit
            formlayout.fedit = my_fedit
        # monkey patch _formlayout to work around a MPL3.5.1 issue on Qt6
        # (see https://github.com/matplotlib/matplotlib/issues/22471)
        if mpl_version in [[3,5,0], [3,5,1]]:
            formlayout.ColorButton = MPLColorButtonPatched

    def enable_edit_curve_parameters(self):
        if self.edit_curve_parameters_action is not None:
            self.edit_curve_parameters_action.setEnabled(True)

    def disable_edit_curve_parameters(self):
        if self.edit_curve_parameters_action is not None:
            self.edit_curve_parameters_action.setEnabled(False)

    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def release_pan_new(self, event):
        self.release_pan_org(event)
        # as since MPL 3.5 release_pan calls self.canvas.draw_idle() instead of _draw() we just invalidate the background here instead of
        # updating it
        aw.qmc.updateBackground()
        #aw.qmc.ax_background = None
    def release_zoom_new(self, event):
        self.release_zoom_org(event)
        # as since MPL 3.5 release_pan calls self.canvas.draw_idle() instead of _draw() we just invalidate the background here instead of
        # updating it
        aw.qmc.updateBackground()
        #aw.qmc.ax_background = None

    # monkey patch matplotlib navigationbar zoom (release_zoom) and pan (release_pan) to update background cache
    def update_view_new(self):
        self.update_view_org()
        aw.qmc.updateBackground()

    def getAxisRanges(self):
        res = []
        for ax in self.canvas.figure.axes:
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            res.append(xlim[1]-xlim[0])
            res.append(ylim[1]-ylim[0])
        return res

    def press_pan(self, event):
        if aw.qmc.ai is not None:
            # we remember the axis ranges before the pan-zoom to detect if it was zoomed
            self.axis_ranges = self.getAxisRanges()
        super().press_pan(event)

    def release_pan(self, event):
        if aw.qmc.ai is not None and [round(r) for r in self.axis_ranges] != [round(r) for r in self.getAxisRanges()]:
            # only hide the background image if the axis ratio changed
            aw.qmc.ai.set_visible(False)
        super().release_pan(event)

    def release_zoom(self, event):
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(False)
        super().release_zoom(event)

    def forward(self, *args):
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(False)  # whenever forward is pressed the image will be hidden
        super().forward(*args)

    def back(self, *args):
        if aw.qmc.ai is not None:
            if self._nav_stack._pos == 1: # pylint: disable=protected-access
                aw.qmc.ai.set_visible(True)
        super().back(*args)

    def home(self, *args):
        """Restore the original view"""
        # show the background image again that was hidden on zoom-in
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(True)
        super().home(*args)

        # toggle zoom_follow if recording
        if aw.qmc.flagstart:
            aw.qmc.zoom_follow = not aw.qmc.zoom_follow
            if aw.qmc.zoom_follow:
                aw.sendmessage(QApplication.translate('Message','follow on'))
            else:
                aw.sendmessage(QApplication.translate('Message','follow off'))
        else:
            aw.qmc.zoom_follow = False
        if aw.qmc.zoom_follow:
            self.push_current()

    def _icon(self, name):
        if aw is not None and name.startswith('plus'):
            basedir = os.path.join(getResourcePath(),'Icons')
        else:
            basedir = os.path.join(mpl.get_data_path(), 'images')
        if name.startswith('plus') and not self.white_icons:
            name = 'white_' + name
        #dirty hack to prefer .svg over .png Toolbar icons
        if not svgsupport:
            name = name.replace('.svg','.png')
        else:
            name = name.replace('.png','.svg')
        # large png icons introduced in MPL 2.1 for Qt5
        name = name.replace('.png', '_large.png')
        p = os.path.join(basedir, name)
        pm = QPixmap(p)
        if not name.startswith('plus') and not name.startswith('white_plus'):
            if self.white_icons:
                pm = self.recolorIcon(pm,QColor('#dfdfdf'))
            else:
                pm = self.recolorIcon(pm,QColor('#424242'))
        if hasattr(pm, 'setDevicePixelRatio'):
            if mpl_version[0] > 2 and mpl_version[1] > 2:
                if mpl_version[1] > 3:
                    _setDevicePixelRatio(pm, _devicePixelRatioF(self)) # pylint: disable=protected-access
                else:
                    _setDevicePixelRatioF(pm, _devicePixelRatioF(self)) # pylint: disable=protected-access
            else:
                pm.setDevicePixelRatio(self.canvas._dpi_ratio) # pylint: disable=protected-access
        return QIcon(pm)

    @staticmethod
    def recolorIcon(pixmap, color):
        tmp = pixmap.toImage()
        for y in range(tmp.height()):
            for x in range(tmp.width()):
                color.setAlpha(tmp.pixelColor(x,y).alpha())
                tmp.setPixelColor(x,y,color)
        return QPixmap.fromImage(tmp)

    def update_message(self):
        if not aw.qmc.twoAxisMode():
            aw.qmc.fmt_data_RoR = False
        xs = None
        timeindex = None # caches the foreground timex index computed at x cursor position
        backgroundtimeindex = None # caches the background timex index computed at x cursor position
        # update xy cursor position widget
        if self._last_event is None:
            self.set_message(self.mode)
        else:
            if not aw.qmc.fmt_data_ON:
                self.set_message(self.mode)
            else:
                try:
                    channel = ''
                    xs = self._last_event.inaxes.format_xdata(self._last_event.xdata)
                    if aw.qmc.fmt_data_curve == 0 or aw.qmc.designerflag:
                        ys = self._last_event.inaxes.format_ydata(self._last_event.ydata)
                    else:
                        try:
                            if aw.qmc.fmt_data_curve == 1: # BT
                                timeindex = aw.qmc.time2index(self._last_event.xdata, nearest=False)
                                if aw.qmc.fmt_data_RoR:
                                    ys = aw.qmc.delta2[timeindex]
                                else:
                                    ys = aw.qmc.temp2[timeindex]
                                channel = aw.BTname
                            elif aw.qmc.fmt_data_curve == 2: # ET
                                timeindex = aw.qmc.time2index(self._last_event.xdata, nearest=False)
                                if aw.qmc.fmt_data_RoR:
                                    ys = aw.qmc.delta1[timeindex]
                                else:
                                    ys = aw.qmc.temp1[timeindex]
                                channel = aw.ETname
                            elif aw.qmc.fmt_data_curve == 3 and aw.qmc.backgroundprofile is not None: # BTB
                                backgroundtimeindex = aw.qmc.backgroundtime2index(self._last_event.xdata, nearest=False)
                                if aw.qmc.fmt_data_RoR:
                                    ys = aw.qmc.delta2B[backgroundtimeindex]
                                else:
                                    ys = aw.qmc.temp2B[backgroundtimeindex]
                                channel = 'BTB'
                            elif aw.qmc.fmt_data_curve == 4 and aw.qmc.backgroundprofile is not None: # ETB
                                backgroundtimeindex = aw.qmc.backgroundtime2index(self._last_event.xdata, nearest=False)
                                if aw.qmc.fmt_data_RoR:
                                    ys = aw.qmc.delta1B[backgroundtimeindex]
                                else:
                                    ys = aw.qmc.temp1B[backgroundtimeindex]
                                channel = 'ETB'
                            else:
                                ys = self._last_event.inaxes.format_ydata(self._last_event.ydata)
                            if ys is not None:
                                if aw.qmc.LCDdecimalplaces:
                                    ys = aw.float2float(ys)
                                else:
                                    ys = int(round(ys))
                        except Exception: # pylint: disable=broad-except
                            ys = self._last_event.inaxes.format_ydata(self._last_event.ydata)
                except Exception: # pylint: disable=broad-except
                    self.set_message(self.mode)
                else:
                    if aw.qmc.LCDdecimalplaces:
                        min_temp_digits = 5
                    else:
                        min_temp_digits = 3
                    if aw.qmc.fmt_data_RoR:
                        min_temp_digits -= 1
                    if len(self.mode):
                        self.set_message(f"{self.mode}  {xs: >5}\n{channel}{'' if ys is None else ys: >{min_temp_digits}}\u00B0{aw.qmc.mode}{'/min' if aw.qmc.fmt_data_RoR else ''}")
                    else:
                        self.set_message(f"{xs: >5}\n{channel}{'' if ys is None else ys: >{min_temp_digits}}\u00B0{aw.qmc.mode}{'/min' if aw.qmc.fmt_data_RoR else ''}")
            # update running LCDs
            if not aw.qmc.flagon and not bool(aw.comparator):
                if aw.qmc.running_LCDs == 1: # show foreground profile readings at cursor position in LCDs
                    if timeindex is None:
                        timeindex = aw.qmc.time2index(self._last_event.xdata, nearest=False)
                    time = self._last_event.xdata
                    if aw.qmc.timeindex[0] != -1 and aw.qmc.timeindex[0] < len(aw.qmc.timex):
                        time -= aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.updateLCDs(
                        time,
                        aw.qmc.temp1,
                        aw.qmc.temp2,
                        aw.qmc.delta1,
                        aw.qmc.delta2,
                        aw.qmc.extratemp1,
                        aw.qmc.extratemp2,
                        idx=(None if timeindex < 0 else timeindex))
                elif aw.qmc.running_LCDs == 2:  # show background profile readings at cursor position in LCDs
                    try:
                        if backgroundtimeindex is None:
                            backgroundtimeindex = aw.qmc.backgroundtime2index(self._last_event.xdata, nearest=False)
                        time = self._last_event.xdata
                        if aw.qmc.timeindexB[0] != -1 and aw.qmc.timeindexB[0] < len(aw.qmc.timeB):
                            time -= aw.qmc.timeB[aw.qmc.timeindexB[0]]
                        aw.qmc.updateLCDs(
                            time,
                            aw.qmc.temp1B,
                            aw.qmc.temp2B,
                            aw.qmc.delta1B,
                            aw.qmc.delta2B,
                            aw.qmc.temp1BX,
                            aw.qmc.temp2BX,
                            idx=(None if backgroundtimeindex < 0 else backgroundtimeindex))
                    except Exception as e:
                        _log.exception(e)

    # overwritten from MPL v3.2.2 to get rid of that extra data printed
    def mouse_move(self, event):
        try:
            self._update_cursor(event) # not available in MPL v3.0.3 on Python3.5 for the RPi Stretch builds
        except Exception: # pylint: disable=broad-except
            pass
        if event.inaxes and event.inaxes.get_navigate():
            self._last_event = event
        else:
            self._last_event = None
        self.update_message()

#PLUS
    @staticmethod
    def plus():
        modifiers = QApplication.keyboardModifiers()
        if modifiers in [(Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ControlModifier), (Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ShiftModifier)]:
            # ALT+CTR-CLICK (OPTION+COMMAND on macOS) toggles  or alternatively ALT-SHIFT-CLICK
            # toggle debug logging
            debug_level = debugLogLevelToggle()
            aw.sendmessage(
                    QApplication.translate('Plus', 'debug logging ON') if debug_level else
                    QApplication.translate('Plus', 'debug logging OFF')
            )
        elif modifiers == Qt.KeyboardModifier.AltModifier:
            # ALT-click (OPTION on macOS) sends the log file by email
            aw.sendLog()
        else:
            plus.controller.toggle(aw)

    @staticmethod
    def subscription():
        if aw.plus_paidUntil != None: # after reset and authentication, it might still take a moment until the paidUntil is set via its signal
            try:
                remaining_days = max(0,(aw.plus_paidUntil.date() - datetime.datetime.now().date()).days)
                if remaining_days == 1:
                    days = QApplication.translate('Plus','1 day left')
                else:
                    days = QApplication.translate('Plus','{} days left').format(remaining_days)
                pu = aw.plus_paidUntil.date()
                message = f'{QApplication.translate("Plus","Paid until")} {QDate(pu.year,pu.month,pu.day).toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))}'
                reminder_message = ''
                if aw.plus_rlimit > 0:
                    percent_used = aw.plus_used/(aw.plus_rlimit/100)
                    unit = 1 # 1: kg, 2: lb
                    if aw.qmc.weight[2] in ['lb', 'oz']:
                        unit = 2
                    rlimit = plus.stock.renderAmount(aw.plus_rlimit, target_unit_idx=unit)
                    used = plus.stock.renderAmount(aw.plus_used, target_unit_idx=unit)
                    percent_used_formatted = f'{percent_used:.0f}% {QApplication.translate("Label","roasted")} ({used} / {rlimit})'
                    # if 90% of quota is used, render usage in red
                    if percent_used >= 90:
                        style = 'background-color:#cc0f50;color:white;'
                    else:
                        style = ''
                    reminder_message += f'<blockquote><b><span style="{style}">{percent_used_formatted}</span></b></blockquote>'
                if remaining_days <31:
                    if remaining_days <= 3:
                        style = 'background-color:#cc0f50;color:white;'
                    else:
                        style = ''
                    reminder_message += f'<blockquote><b><span style="{style}">{days}</span></b></blockquote>'
                if reminder_message == '':
                    message += '<br><br>'
                else:
                    message += reminder_message
                message += QApplication.translate('Plus','Please visit our {0}shop{1} to extend your subscription').format('<a href="' + plus.config.shop_base_url + '">','</a>')
                #
                # if less then 31 days:
                # n days left <= red if <=3
                #  3 days, 2 days, 1 day, 0 days left
                #
                subscription_message_box = ArtisanMessageBox(aw,QApplication.translate('Message', 'Subscription'),message)
                subscription_message_box.show()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def my_edit_parameters(self,_=False):
        try:
            if not aw.qmc.designerflag: # deactivate figure_options in designer mode due to all kind of side effects
                allaxes = self.canvas.figure.get_axes()
                if len(allaxes) == 1:
                    pass
                else:
                    if aw.qmc.flagstart:
                        # temporary set the axis to get proper menu items (same code as in redraw)
                        aw.qmc.set_xlabel(aw.arabicReshape(QApplication.translate('Label', 'Time')))
                        y_label = aw.qmc.ax.set_ylabel(aw.qmc.mode)
                        try:
                            y_label.set_in_layout(False) # remove x-axis labels from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                        two_ax_mode = aw.qmc.twoAxisMode() and not aw.qmc.designerflag
                        if two_ax_mode and aw.qmc.delta_ax:
                            y_label = aw.qmc.delta_ax.set_ylabel(aw.qmc.mode + '/min')
                            try:
                                y_label.set_in_layout(False) # remove x-axis labels from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                                pass

                axes = allaxes[0]

                try:

                    with warnings.catch_warnings():
                        warnings.filterwarnings('ignore') # , category=numpy.VisibleDeprecationWarning)
                        figureoptions.figure_edit(axes)
#                        for line in steps_post_lines:
#                            line.set_drawstyle("steps-post")

                except Exception: # pylint: disable=broad-except
#                    import traceback
#                    traceback.print_exc(file=sys.stdout)
                    pass
                aw.fetchCurveStyles()
                # the redraw is mostly necessary to force a redraw of the legend to reflect the changed colors/styles/labels
                aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' edit_parameters() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))


########################################################################################
###     Sample thread
########################################################################################

class SampleThread(QThread):
    sample_processingSignal = pyqtSignal(bool,list,list,list)

    def __init__(self, parent=None):
        super().__init__(parent)

        if str(platform.system()).startswith('Windows'):
            self.accurate_delay_cutoff = 10e-3
        else:
            self.accurate_delay_cutoff = 5e-3

    @staticmethod
    def sample_main_device():
        #read time, ET (t1) and BT (t2) TEMPERATURE
        try:
            if aw.simulator is None:
                tx,t1,t2 = aw.ser.devicefunctionlist[aw.qmc.device]() # Note that not all device functions feature the force parameter!!
                if aw.qmc.swapETBT:
                    return tx,float(t2),float(t1)
                return tx,float(t1),float(t2)
            tx = aw.qmc.timeclock.elapsedMilli()
            t1,t2 = aw.simulator.read(tx if aw.qmc.flagstart else 0)
            return tx,float(t1),float(t2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            tx = aw.qmc.timeclock.elapsedMilli()
            return tx,-1.0,-1.0

    @staticmethod
    def sample_extra_device(i):
        try:
            if aw.simulator is None or aw.qmc.extradevices[i] == 22: # the PID SV/DUTY we show from the computed readings
                tx,t1,t2 = aw.extraser[i].devicefunctionlist[aw.qmc.extradevices[i]]()
            else:
                tx = aw.qmc.timeclock.elapsedMilli()
                t1,t2 = aw.simulator.readextra(i,(tx if aw.qmc.flagstart else 0))
            return tx,float(t1),float(t2)
        except Exception: # pylint: disable=broad-except
#            _log.exception(e)
            tx = aw.qmc.timeclock.elapsedMilli()
            return tx,-1.0,-1.0

    # fetch the raw samples from the main and all extra devices once per interval
    def sample(self):
        gotlock = aw.qmc.samplingSemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        if gotlock:
            try:
                temp1_readings = []
                temp2_readings = []
                timex_readings = []

                if aw.qmc.device != 18 or aw.simulator is not None: # not NONE device
                    ##### send sampling action if any interval is set to "sync" (extra_event_sampling_delay = 0)
                    try:
                        if aw.qmc.extra_event_sampling_delay == 0 and aw.qmc.extrabuttonactions[2]:
                            aw.eventactionx(aw.qmc.extrabuttonactions[2],aw.qmc.extrabuttonactionstrings[2])
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    #### first retrieve readings from the main device
#                    timeBeforeETBT = libtime.perf_counter() # the time before sending the request to the main device
#                    #read time, ET (t1) and BT (t2) TEMPERATURE
#                    tx_org,t1,t2 = self.sample_main_device()
#                    etbt_time = libtime.perf_counter() - timeBeforeETBT
#                    tx = tx_org + (etbt_time / 2.0) # we take the average between before and after
# instead of estimating the real time of the sample, let the device implementation decide (mostly, the time the request was send should be accurate enough)
                    tx,t1,t2 = self.sample_main_device()
                    #etbt_time = libtime.perf_counter() - timeBeforeETBT
                    temp1_readings.append(t1)
                    temp2_readings.append(t2)
                    timex_readings.append(tx)

                    ##############  if using Extra devices
                    for i in range(len(aw.qmc.extradevices)):
                        extratx, extrat2, extrat1 = self.sample_extra_device(i)
                        temp1_readings.append(extrat1)
                        temp2_readings.append(extrat2)
                        timex_readings.append(extratx)
#                    total_time = libtime.perf_counter() - timeBeforeETBT

#                    _log.debug("sample(): ET/BT time => %.4f", etbt_time)
#                    _log.debug("sample(): total time => %.4f", total_time)

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                local_flagstart = aw.qmc.flagstart # this need to be caught within the samplingSemaphore and forwarded to the sample_processing()
                if aw.qmc.samplingSemaphore.available() < 1:
                    aw.qmc.samplingSemaphore.release(1)
                self.sample_processingSignal.emit(local_flagstart, temp1_readings, temp2_readings, timex_readings)
        else:
            _log.debug('sample() timeout')

    # libtime.sleep is accurate only up to 0-5ms
    # using a hyprid approach using sleep() and busy-wait based on the time.perf_counter()
    def accurate_delay(self, delay):
        ''' Function to provide accurate time delay in seconds
        '''
        _ = libtime.perf_counter() + delay
        # use the standard sleep until one 5ms before the timeout (Windows <10 might need a limit of 5.5ms)
        if delay > self.accurate_delay_cutoff:
            libtime.sleep(delay - self.accurate_delay_cutoff)
        # continuous with a busy sleep
        while libtime.perf_counter() < _:
            pass # this raises CPU to 100%
#            libtime.sleep(1/100000) # this is a compromise with increased accuracy vs time.sleep() avoiding a 100% CPU load

    def run(self):
        try:
            aw.qmc.flagsamplingthreadrunning = True
            if sys.platform.startswith('darwin'):
                from Foundation import NSAutoreleasePool  # @UnresolvedImport  # pylint: disable=import-error
                pool = NSAutoreleasePool.alloc().init()  # @UndefinedVariable # pylint: disable=maybe-no-member
            aw.qmc.afterTP = False
            if not aw.qmc.flagon:
                return

            # initialize digitizer
            aw.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
            aw.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier

            interval = aw.qmc.delay/aw.qmc.timeclock.getBase()
            next_time = None
            while True:
                if aw.qmc.flagon:
                    if next_time is None:
                        next_time = libtime.perf_counter() + interval
                    else:
                        #libtime.sleep(max(0, next_time - libtime.time())) # sleep is not very accurate
                        self.accurate_delay(max(0, next_time - libtime.perf_counter())) # more accurate, but keeps the CPU busy

                    #_log.info(datetime.datetime.now()) # use this to check for drifts

                    #collect information
                    if aw.sample_loop_running and aw.qmc.flagon:
                        try:
                            aw.qmc.flagsampling = True # we signal that we are sampling
                            self.sample()
                        finally:
                            aw.qmc.flagsampling = False # we signal that we are done with sampling
                else:
                    aw.qmc.flagsampling = False # we signal that we are done with sampling
                    try:
                        if aw.ser.SP.isOpen():
                            aw.ser.closeport()
                        QApplication.processEvents()
                    except Exception: # pylint: disable=broad-except
                        pass
                    self.quit()
                    break  #thread ends
                # skip tasks if we are behind schedule:
                next_time += (libtime.perf_counter() - next_time) // interval * interval + interval
        finally:
            aw.qmc.flagsampling = False # we signal that we are done with sampling
            aw.qmc.flagsamplingthreadrunning = False
            if sys.platform.startswith('darwin'):
                # disable undefined variable warning:
                del pool # pylint: disable=E0602


#########################################################################################################
###     Artisan thread Server
#########################################################################################################

class Athreadserver(QWidget): # pylint: disable=too-few-public-methods

    def createSampleThread(self):
        if not aw.qmc.flagsamplingthreadrunning: # we only start a new sampling thread if none is running yet
            sthread = SampleThread(self)

            #connect graphics to GUI thread
            sthread.sample_processingSignal.connect(aw.qmc.sample_processing)
            sthread.start(QThread.Priority.TimeCriticalPriority) # TimeCriticalPriority > HighestPriority > HighPriority > NormalPriority > LowPriority
            sthread.wait(300)    #needed in some Win OS


#########################################################################################################
###     Event Action Thread
#########################################################################################################

class EventActionThread(QThread): # pylint: disable=too-few-public-methods

    def __init__(self, action, command):
        QThread.__init__(self)
        self.action = action
        self.command = command

    def run(self):
        # as eventaction_internal is not running in the GUI thread we avoid doing graphic updates and run them instead after thread termination within
        # the GUI thread
        aw.eventaction_internal(self.action,self.command)


#########################################################################################################

# applies comma2dot as fixup to automatically turn numbers like "1,2" into valid numbers like "1.0" and the empty entry into "0.0"
class MyQDoubleValidator(QDoubleValidator): # pylint: disable=too-few-public-methods

    def __init__(self, bottom, top, decimals, lineedit):
        super().__init__(bottom, top, decimals, lineedit)
        self.lineedit = lineedit

    def fixup(self, input_value):
        try:
            if input_value is None or input_value == '':
                input_value = '0'
            else:
                input_value = aw.comma2dot(input_value)
            self.lineedit.setText(input_value)
#            super().fixup(input_value)
        except Exception: # pylint: disable=broad-except
            pass

########################################################################################
#################### MAIN APPLICATION WINDOW ###########################################
########################################################################################

aw = None # assigned to the single instance of ApplicationWindow on creation
artisanviewerFirstStart = False

# NOTE: to have pylint to verify proper __slot__ definitions one has to remove the super class QMainWindow here temporarily
#   as this does not has __slot__ definitions and thus __dict__ is contained which suppresses the warnings
class ApplicationWindow(QMainWindow):

    singleShotPhidgetsPulseOFF = pyqtSignal(int,int,str) # signal to be called from the eventaction thread to realise Phidgets pulse via QTimer in the main thread
    singleShotPhidgetsPulseOFFSerial = pyqtSignal(int,int,str,str)
#PLUS
    updatePlusStatusSignal = pyqtSignal() # can be called from another thread or a QTimer to trigger to update the plus icon status
    setTitleSignal = pyqtSignal(str,bool) # can be called from another thread or a QTimer to set the profile title in the main GUI thread
    sendmessageSignal = pyqtSignal(str,bool,str)
    openPropertiesSignal = pyqtSignal()
    soundpopSignal = pyqtSignal()
    setCanvasColorSignal = pyqtSignal(str)
    resetCanvasColorSignal = pyqtSignal()
    setbuttonsfromSignal = pyqtSignal(int)
    loadBackgroundSignal = pyqtSignal(str)
    clearBackgroundSignal = pyqtSignal()
    adjustSVSignal = pyqtSignal(int)
    updateSerialLogSignal = pyqtSignal()
    fireslideractionSignal = pyqtSignal(int)
    moveButtonSignal = pyqtSignal(str)
    sendnotificationMessageSignal = pyqtSignal(str,str,NotificationType)
    updateSubscriptionSignal = pyqtSignal(str)
    updateLimitsSignal = pyqtSignal(float, float, str, int, list) # rlimit:float, rused:float, pu:str, notifications:int
    updatePlaybackIndicatorSignal = pyqtSignal()
    pidOnSignal = pyqtSignal()
    pidOffSignal = pyqtSignal()

    __slots__ = [ 'locale_str', 'app', 'superusermode', 'sample_loop_running', 'time_stopped', 'plus_account', 'plus_remember_credentials', 'plus_email', 'plus_language', 'plus_subscription',
        'plus_paidUntil', 'plus_rlimit', 'plus_used', 'plus_readonly', 'appearance', 'mpl_fontproperties', 'full_screen_mode_active', 'processingKeyEvent', 'quickEventShortCut',
        'eventaction_running_threads', 'qtbase_additional_locales', 'qtbase_locales', 'curFile', 'MaxRecentFiles', 'recentFileActs', 'recentSettingActs',
        'recentThemeActs', 'applicationDirectory', 'helpdialog', 'redrawTimer', 'lastLoadedProfile', 'lastLoadedBackground', 'LargeScaleLCDsFlag', 'largeScaleLCDs_dialog',
        'analysisresultsanno', 'segmentresultsanno', 'largeLCDs_dialog', 'LargeLCDsFlag', 'largeDeltaLCDs_dialog', 'LargeDeltaLCDsFlag', 'largePIDLCDs_dialog',
        'LargePIDLCDsFlag', 'largeExtraLCDs_dialog', 'LargeExtraLCDsFlag', 'largePhasesLCDs_dialog', 'LargePhasesLCDsFlag', 'WebLCDs', 'WebLCDsPort',
        'WebLCDsAlerts', 'EventsDlg_activeTab', 'graphColorDlg_activeTab', 'PID_DlgControl_activeTab', 'CurveDlg_activeTab', 'editGraphDlg_activeTab',
        'backgroundDlg_activeTab', 'DeviceAssignmentDlg_activeTab', 'AlarmDlg_activeTab', 'resetqsettings', 'settingspath', 'wheelpath', 'profilepath',
        'userprofilepath', 'printer', 'main_widget', 'defaultdpi', 'dpi', 'qmc', 'HottopControlActive', 'AsyncSamplingAction', 'wheeldialog',
        'simulator', 'simulatorpath', 'comparator', 'stack', 'eventsbuttonflag', 'minieventsflags', 'seriallogflag',
        'seriallog', 'ser', 'modbus', 'extraMODBUStemps', 'extraMODBUStx', 's7', 'ws', 'scale', 'color', 'extraser', 'extracomport', 'extrabaudrate',
        'extrabytesize', 'extraparity', 'extrastopbits', 'extratimeout', 'fujipid', 'dtapid', 'pidcontrol', 'soundflag', 'recentRoasts', 'maxRecentRoasts',
        'lcdpaletteB', 'lcdpaletteF', 'extraeventsbuttonsflags', 'extraeventslabels', 'extraeventbuttoncolor', 'extraeventsactionstrings',
        'extraeventbuttonround', 'block_quantification_sampling_ticks', 'sampling_ticks_to_block_quantifiction', 'extraeventsactionslastvalue',
        'org_extradevicesettings', 'eventslidervalues', 'eventslidervisibilities', 'eventslideractions', 'eventslidercommands', 'eventslideroffsets',
        'eventsliderfactors', 'eventslidermin', 'eventsMaxValue', 'eventslidermax', 'eventslidersflags', 'eventsliderBernoulli', 'eventslidercoarse',
        'eventslidertemp', 'eventsliderunits', 'eventslidermoved', 'SVslidermoved', 'eventquantifieractive', 'eventquantifiersource', 'eventquantifierSV',
        'eventquantifiermin', 'eventquantifiermax', 'eventquantifiercoarse', 'eventquantifieraction', 'clusterEventsFlag', 'eventquantifierlinspaces',
        'eventquantifiersteps', 'eventquantifierthresholdfine', 'eventquantifierthresholdcoarse', 'lastdigitizedvalue', 'lastdigitizedtemp',
        'readingslcdsflags', 'logoimgalpha', 'logoimgflag', 'logofilename', 'redrawOnResize', 'searchtextartisansettings', 'fileMenu', 'editMenu',
        'RoastMenu', 'ConfMenu', 'ToolkitMenu', 'viewMenu', 'helpMenu', 'newRoastMenu', 'fileLoadAction', 'openRecentMenu', 'importMenu',
        'fileSaveAction', 'fileSaveCopyAsAction', 'exportMenu', 'convMenu', 'saveGraphMenu', 'reportMenu', 'htmlAction', 'productionMenu',
        'productionWebAction', 'productionCsvAction', 'productionExcelAction', 'rankingMenu', 'rankingWebAction', 'rankingCsvAction', 'rankingExcelAction',
        'savestatisticsAction', 'printAction', 'quitAction', 'cutAction', 'copyAction', 'pasteAction', 'editGraphAction', 'backgroundAction',
        'flavorAction', 'switchAction', 'switchETBTAction', 'machineMenu', 'deviceAction', 'commportAction', 'calibrateDelayAction', 'curvesAction',
        'eventsAction', 'alarmAction', 'phasesGraphAction', 'StatisticsAction', 'WindowconfigAction', 'colorsAction', 'themeMenu', 'autosaveAction',
        'batchAction', 'temperatureConfMenu', 'FahrenheitAction', 'CelsiusAction', 'languageMenu', 'analyzeMenu', 'fitIdealautoAction',
        'analyzeMenu', 'fitIdealx2Action', 'fitIdealx3Action', 'fitIdealx0Action', 'fitBkgndAction', 'clearresultsAction', 'roastCompareAction',
        'designerAction', 'simulatorAction', 'wheeleditorAction', 'transformAction', 'temperatureMenu', 'ConvertToFahrenheitAction',
        'ConvertToCelsiusAction', 'controlsAction', 'readingsAction', 'eventsEditorAction', 'buttonsAction', 'slidersAction', 'lcdsAction', 'deltalcdsAction',
        'pidlcdsAction', 'scalelcdsAction', 'extralcdsAction', 'phaseslcdsAction', 'fullscreenAction', 'loadSettingsAction', 'openRecentSettingMenu',
        'saveAsSettingsAction', 'resetAction', 'messagelabel', 'button_font_size_pt', 'button_font_size', 'button_font_size_small', 'button_font_size_small_selected',
        'button_font_size_tiny', 'button_font_size_micro', 'main_button_min_width', 'standard_button_min_width', 'small_button_min_width', 'tiny_button_min_width',
        'pushbuttonstyles_simulator', 'pushbuttonstyles', 'standard_button_tiny_height', 'standard_button_small_height', 'standard_button_height',
        'buttonONOFF', 'buttonSTARTSTOP', 'buttonFCs', 'buttonFCe', 'buttonSCs', 'buttonSCe', 'buttonRESET', 'buttonCHARGE', 'buttonDROP',
        'buttonCONTROL', 'buttonEVENT', 'buttonSVp5', 'buttonSVp10', 'buttonSVp20', 'buttonSVm20', 'buttonSVm10', 'buttonSVm5', 'buttonDRY',
        'buttonCOOL', 'lcd1', 'lcd2', 'lcd3', 'lcd4', 'lcd5',
        'lcd6', 'lcd7', 'label2', 'label3', 'label4', 'label5', 'label6', 'label7', 'nLCDs', 'extraLCD1', 'extraLCD2', 'extraLCDlabel1', 'extraLCDlabel2',
        'extraLCDframe1', 'extraLCDframe2', 'extraLCDvisibility1', 'extraLCDvisibility2', 'extraCurveVisibility1', 'extraCurveVisibility2',
        'extraDelta1', 'extraDelta2', 'extraFill1', 'extraFill2', 'channel_tare_values', 'messagehist', 'eventlabel', 'eNumberSpinBox',
        'lineEvent', 'etypeComboBox', 'valueEdit', 'etimeline', 'buttonminiEvent', 'buttonlist', 'buttonStates', 'lastbuttonpressed', 'buttonlistmaxlen',
        'buttonpalette_default_label', 'buttonpalette_label', 'buttonpalettemaxlen', 'buttonpalette_shortcuts', 'buttonsize', 'eventbuttontablecolumnwidths',
        'lowerbuttondialogLayout', 'lowerbuttondialog', 'lowerbuttondialogLayout', 'e1buttonbarLayout', 'e1buttondialog', 'e2buttonbarLayout', 'e2buttondialog',
        'e3buttonbarLayout', 'e3buttondialog', 'e4buttonbarLayout', 'e4buttondialog', 'keyboardmove', 'keyboardButtonList', 'keyboardmoveindex',
        'keyboardmoveflag', 'lastkeyboardcmd', 'error_dlg', 'serial_dlg', 'message_dlg', 'ETname', 'BTname', 'level1frame', 'level1layout', 'EventsGroupLayout',
        'LCD2frame', 'LCD3frame', 'LCD4frame', 'LCD5frame', 'LCD6frame', 'LCD7frame', 'TPlabel', 'TPlcd', 'TPlcdFrame', 'TP2DRYlabel', 'TP2DRYframe',
        'DRYlabel', 'DRYlcd', 'DRYlcdFrame', 'DRY2FCslabel', 'DRY2FCsframe', 'FCslabel', 'FCslcd', 'FCslcdFrame', 'AUClabel', 'AUClcd', 'AUClcdFrame',
        'AUCLCD', 'phasesLCDs', 'extrabuttonsLayout', 'extrabuttondialogs', 'slider1', 'slider2', 'slider3', 'slider4', 'sliderLCD1', 'sliderLCD2', 'sliderLCD3',
        'sliderLCD4', 'sliderGrpBox1', 'sliderGrpBox2', 'sliderGrpBox3', 'sliderGrpBox4', 'sliderSV', 'sliderLCDSV', 'sliderGrpBoxSV', 'leftlayout',
        'sliderFrame', 'lcdFrame', 'midlayout', 'editgraphdialog', 'html_loader', 'QtWebEngineSupport',
        'buttonpalette', 'extraeventbuttontextcolor', 'extraeventsactions', 'extraeventsdescriptions', 'extraeventstypes', 'extraeventsvalues',
        'extraeventsvisibility', 'fileSaveAction', 'fileSaveAsAction', 'keyboardButtonStyles', 'language_menu_actions', 'loadThemeAction', 'main_button_min_width_str',
        'minieventleft', 'minieventright', 'nLCDS', 'notificationManager', 'notificationsflag', 'ntb', 'pdf_page_layout', 'pdf_rendering', 'productionPDFAction',
        'rankingPDFAction', 'roastReportMenu', 'roastReportPDFAction', 'saveAsThemeAction', 'sliderGrpBox1x', 'sliderGrpBox2x', 'sliderGrpBox3x', 'sliderGrpBox4x',
        'small_button_min_width_str', 'standard_button_min_width_px', 'tiny_button_min_width_str' ]



    def __init__(self, parent = None, *, locale, WebEngineSupport):

        self.locale_str = locale
        self.app = app
        self.superusermode = False

        self.sample_loop_running = True
        self.time_stopped = 0

        self.QtWebEngineSupport = WebEngineSupport

#PLUS
        self.plus_account = None # if set to a login string, Artisan plus features are enabled
        self.plus_remember_credentials = True # store plus account credentials in systems keychain
        self.plus_email = None # if self.plus_remember_credentials is ticked, we remember here the login to be pre-set as plus_account in the dialog
        self.plus_language = 'en' # one of ["en", "de", "it", ..] indicates the language setting of the plus_account used on the artisan.plus platform,
                # used in links back to objects on the platform (see plus/util.py#storeLink() and similars)
        self.plus_subscription = None # one of [None, "HOME", "PRO"]
        self.plus_paidUntil : Optional[datetime.datetime] = None # either None if unknown or otherwise a datetime.datetime object with indicating the expiration date of the account
        self.plus_rlimit : float = 0 # account amount limit (kg); if 0 then considered as not valid
        self.plus_used : float = 0   # account amount greens roasted within rlimit (kg); if 0 then considered as not valid
        self.plus_readonly : bool = False # True if the plus user has only read rights to the plus account (account might be deactivated, or user might be a read-only user)

        self.appearance = ''

        # matplotlib font properties:
        self.mpl_fontproperties = mpl.font_manager.FontProperties()
        self.full_screen_mode_active = False

        self.processingKeyEvent = False

        self.quickEventShortCut = None
        # this is None if inactive, or holds a tuple (n,s) with n a number {-1,..,4} indicating the custom event number (0-3), 4 for SV, or -1 for custom event buttons to be addressed
        # and s a string of length 0 (no digit yet), length 1 (if first digit is typed) or 2 (both digits are typed) indicating the value (00-99)

        # html2pdf() state:
        self.html_loader = None # holds the QWebEngineView during HTML2PDF generation in self.html2pdf()
        self.pdf_page_layout = None # holds the QPageLayout used during HTML2PDF generation in self.html2pdf()
        self.pdf_rendering = False # True while PDF is rendered by QWebEngineView

        self.eventaction_running_threads = []

        # locales that come with a standard qtbase translation for standard elements/buttons
        # for other locales standard OK/Cancel buttons created in dialogs via QDialogButtonBoxes should be
        # renamed via setText to link them to artisan translations (which hopefully provides those translations)

        self.qtbase_additional_locales = ['da','el','fa','gd','lv','nl','pt_BR','pt','sk','sv','zh_CN'] # additionally added to /translations
        self.qtbase_locales = ['ar','de','en','es','fi','fr','he','hu','it','ja','ko','pl','uk','tr','zh_TW'] # from Qt distribution

        #############################  Define variables that need to exist before calling settingsload()
        self.curFile = None
        self.MaxRecentFiles = 20
        self.recentFileActs = []
        self.recentSettingActs = []
        self.recentThemeActs = []
        self.applicationDirectory =  QDir().current().absolutePath()

        super().__init__(parent)
        self.helpdialog = None

        self.setAcceptDrops(True) # enable drag-and-drop

        # a timer that is triggered by resizing the main window
        self.redrawTimer = QTimer()
        self.redrawTimer.setSingleShot(True)
        self.redrawTimer.timeout.connect(self.redraw_action)

        # used on startup to reload previous loaded profiles
        self.lastLoadedProfile = ''
        self.lastLoadedBackground = ''

        # analyzer
        self.analysisresultsanno = None
        self.segmentresultsanno = None

        # large LCDs
        self.largeLCDs_dialog = None
        self.LargeLCDsFlag = False
        self.largeDeltaLCDs_dialog = None
        self.LargeDeltaLCDsFlag = False
        self.largePIDLCDs_dialog = None
        self.LargePIDLCDsFlag = False
        self.largeScaleLCDs_dialog = None
        self.LargeScaleLCDsFlag = False
        self.largeExtraLCDs_dialog = None
        self.LargeExtraLCDsFlag = False
        self.largePhasesLCDs_dialog = None
        self.LargePhasesLCDsFlag = False
        self.WebLCDs = False
        self.WebLCDsPort = 8080
        self.WebLCDsAlerts = False

        # active tab
        self.EventsDlg_activeTab = 0
        self.graphColorDlg_activeTab = 0
        self.PID_DlgControl_activeTab = 0
        self.CurveDlg_activeTab = 0 # curves dialog
        self.editGraphDlg_activeTab = 0 # roast properties dialog
        self.backgroundDlg_activeTab = 0
        self.DeviceAssignmentDlg_activeTab = 0
        self.AlarmDlg_activeTab = 0

        #flag to reset Qsettings
        self.resetqsettings = 0
        #path of last loadded QSettings
        self.settingspath = '' # if empty string, the settingspath will be ignored, otherwise it will be used to update the batchcounter of those settings

        # path of last loaded WheelGraph
        self.wheelpath = ''

        # self.profilepath is obteined at dirstruct() and points to profiles/year/month file-open/save will point to profilepath
        self.profilepath = ''
        if platf in ['Darwin', 'Linux']:
            self.profilepath = QDir().homePath() + '/Documents/'
        else:
            self.profilepath = QDir().homePath()

        # on the Mac preferences should be stored outside of applications in the users ~/Library/Preferences path
        if platf == 'Darwin':
            preference_path = QDir().homePath() + '/Library/Preferences//'
            preference_dir = QDir()
            preference_dir.setPath(preference_path)
            if not preference_dir.exists():
                QDir().mkpath(preference_path)
            QDir().setCurrent(preference_path)


        #defaults the users profile path to the standard profilepath (incl. month/year subdirectories)
        self.userprofilepath = self.profilepath

        self.printer = None

        self.main_widget = QWidget(self)
        #set a minimum size (main window can be bigger but never smaller)
        self.main_widget.setMinimumWidth(800)
        self.main_widget.setMinimumHeight(400)

        ####      create Matplotlib canvas widget
        #resolution
        self.defaultdpi = 100
        self.dpi = self.defaultdpi

        #mpl.rc_context({'toolbar': None}) # this does not work to remove the default toolbar
        #mpl.rcParams['toolbar'] is None # this does not work to remove the default toolbar

        settings = QSettings()
        if settings.contains('dpi') and (not settings.contains('resetqsettings') or toInt(settings.value('resetqsettings',self.resetqsettings)) == 0):
            try:
                self.dpi = toInt(settings.value('dpi',self.dpi))
            except Exception: # pylint: disable=broad-except
                pass

        self.qmc = tgraphcanvas(self.main_widget, self.dpi, locale=locale)
        self.qmc.setMinimumHeight(150)

        #self.qmc.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground)

        #### Hottop Control
        self.HottopControlActive = False

        #### Async Sampling Action
        self.AsyncSamplingAction = False

        self.wheeldialog = None

        self.simulator = None # holds the simulator in simulation mode
        self.simulatorpath = None # points to the last profile used by the simulator

        self.comparator = None # holds the profile comparator dialog

        self.qmc.setContentsMargins(0,0,0,0)
        #events config
        self.eventsbuttonflag = 0
        self.minieventsflags = [0,0,0] # minieditor visibility per state OFF, ON, START

        #records serial comm (Help menu)
        self.seriallogflag = False
        self.seriallog = []

        #create a serial port object (main ET BT device)
        self.ser = serialport(self)
        #create a modbus port object (main modbus device)
        self.modbus = modbusport(self)
        #temporary storage to pass values. Holds the MODBUS channels T1 and T2 as well as the extra channels T3, T4, T5 and T6 values for MODBUS connected devices
        self.extraMODBUStemps = [-1]*self.modbus.channels
        self.extraMODBUStx = 0.

        #create an s7 port object (main s7 device)
        self.s7 = s7port(self)
        #create an WebSocket port object (main device eg Probat Sample)
        self.ws = wsport(self)
        #create scale port object
        self.scale = scaleport(self)
        #create color port object
        self.color = colorport(self)
        #list with extra serial ports (extra devices)
        self.extraser = []
        #extra comm port settings
        self.extracomport,self.extrabaudrate,self.extrabytesize,self.extraparity,self.extrastopbits,self.extratimeout = [],[],[],[],[],[]

        # create a ET control objects
        self.fujipid = FujiPID(self)
        self.dtapid = DtaPID(self)
        # PID control for Arduino, Hottop and generic MODBUS devices
        self.pidcontrol = PIDcontrol(self)

        self.soundflag = 0

        self.notificationsflag = True # enable/disable notifications

        # recent roasts, an ordered list (first-in, first-out) of dictionaries holding partial roast-properties and a link to the background profile if any
        self.recentRoasts = []
        self.maxRecentRoasts = 25 # the maximum number of recent roasts held

        #lcd1 = time, lcd2 = met, lcd3 = bt, lcd4 = roc et, lcd5 = roc bt, lcd6 = sv (extra devices lcd same as sv seetings)
        self.lcdpaletteB = {
            'timer':'#F8F8F8',
            'et':'#cc0f50', #'black',
            'bt':'#0A5C90', #'black',
            'deltaet':'#EBEBEB', #'black',
            'deltabt':'#EBEBEB', #'black',
            'sv':'#F8F8F8', #'black'
            'rstimer':'#F8F8F8',
            'slowcoolingtimer':'#F8F8F8',
            }
        self.lcdpaletteF = {
            'timer':'#262626',
            'et':'white', #'white',
            'bt':'white', #'white',
            'deltaet':'#cc0f50', #'white',
            'deltabt':'#0A5C90', #'white',
            'sv':'#4C4C4C',
            'rstimer':'#187AB3',
            'slowcoolingtimer':'#CC0D50',
            }

        #user defined event buttons
        self.extraeventsbuttonsflags = [0,1,1] # extra button visibility per state OFF, ON, START
        self.extraeventslabels,self.extraeventsdescriptions, self.extraeventstypes,self.extraeventsvalues = [],[],[],[]  #hold string,string,index,index
        # extraeventtypes:
        #  0-3: custom event types (absolute value assignments)
        #  4: no event type assigned
        #  5-8: custom event types (relative value assignments; +/- steps)
        self.extraeventbuttoncolor,self.extraeventbuttontextcolor = [],[]
        self.extraeventsactionstrings,self.extraeventsactions,self.extraeventsvisibility = [],[],[] #hold string,index,index

        # indicates if the button is
        #   0: square
        #   1: left rounded
        #   2: right rounded
        #   3: rounded on both sides
        self.extraeventbuttonround = [] # set by realignbuttons on rendering the button rows and read by setExtraEventButtonStyle to update the style

        # quantification is blocked if lock_quantification_sampling_ticks is not 0
        # (eg. after a change of the event value by button or slider actions)
        self.block_quantification_sampling_ticks = [0,0,0,0]
        # by default we block quantification for sampling_ticks_to_block_quantifiction sampling intervals after
        # a button/slider event
        self.sampling_ticks_to_block_quantifiction = 15

        self.extraeventsactionslastvalue = [None,None,None,None]
        self.org_extradevicesettings = [{},{}]

        #event sliders
        self.eventslidervalues = [0,0,0,0]
        self.eventslidervisibilities = [0,0,0,0]
        self.eventslideractions = [0,0,0,0] # 0: None, 1: Serial Command, 2: Modbus Command, 3: DTA Command, 4: Call Program, 5: Hottop Heater, 6: Hottop Fan
        self.eventslidercommands = ['','','','']
        self.eventslideroffsets = [0,0,0,0]
        self.eventsliderfactors = [1.0,1.0,1.0,1.0]
        self.eventslidermin = [0,0,0,0]
        self.eventsMaxValue = 999
        self.eventslidermax = [100,100,100,100]
        self.eventslidersflags = [0,1,1] # slider visibility per state OFF, ON, START
        self.eventsliderBernoulli = [0,0,0,0] # if 1, sliders step in multiples of 10, otherwise 1
        self.eventslidercoarse = [0,0,0,0] # if 1, sliders step in multiples of 10, otherwise 1
        self.eventslidertemp = [0,0,0,0] # if 1, slider values are interpreted as temperatures and min/max limit are converted with the temp mode
        self.eventsliderunits = ['','','','']
        self.eventslidermoved = [0,0,0,0] # just set on move and reset on release to avoid imprecise slider moves
        self.SVslidermoved = 0

        #event quantifiers
        self.eventquantifieractive = [0,0,0,0]
        self.eventquantifiersource = [0,0,0,0]
        self.eventquantifierSV = [0,0,0,0]
        self.eventquantifiermin = [0,0,0,0]
        self.eventquantifiermax = [100,100,100,100]
        self.eventquantifiercoarse = [0,0,0,0]
        self.eventquantifieraction = [0,0,0,0]
        self.clusterEventsFlag = False
        self.eventquantifierlinspaces = [self.computeLinespace(0),self.computeLinespace(1),self.computeLinespace(2),self.computeLinespace(3)]
        self.eventquantifiersteps = 10
        self.eventquantifierthresholdfine = .5 # original: 1.5, changed to 0.5 for Probat Probatone
        self.eventquantifierthresholdcoarse = .5
        self.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
        self.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier

        self.readingslcdsflags = [0,1,1] # readings LCD visibility per state OFF, ON, START

        #watermark image
        self.logoimgalpha = 2.0
        self.logoimgflag = False # display during OnMonitor?
        self.logofilename = ''

        self.redrawOnResize = True # if a logofilename is set and redrawOnResize is True a redraw is triggered; usually set to True!

        self.updateWindowTitle()

        # populate recent file menu
        for i in range(self.MaxRecentFiles):
            self.recentFileActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentFile))
        # populate recent settings menu
        for i in range(self.MaxRecentFiles):
            self.recentSettingActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentSetting))
        # populate recent themes menu
        for i in range(self.MaxRecentFiles):
            self.recentThemeActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentTheme))


        #temp variable for text searches in Help menu artisan seetings
        self.searchtextartisansettings = ''

        #######################    MENUS SECTION ##################################################
        ###############  create Top MENUS

        #Fake entries to get translations for the Mac Application Menu
        _mac_services = QApplication.translate('MAC_APPLICATION_MENU', 'Services')
        _mac_hide = QApplication.translate('MAC_APPLICATION_MENU', 'Hide {0}')
        _mac_hideothers = QApplication.translate('MAC_APPLICATION_MENU', 'Hide Others')
        _mac_showall = QApplication.translate('MAC_APPLICATION_MENU', 'Show All')
        _mac_preferences = QApplication.translate('MAC_APPLICATION_MENU', 'Preferences...')
        _mac_quit = QApplication.translate('MAC_APPLICATION_MENU', 'Quit {0}')
        _mac_about = QApplication.translate('MAC_APPLICATION_MENU', 'About {0}')

        # the & adds a short cut automatically
        self.fileMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'File'))
        self.editMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'Edit'))
        self.RoastMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'Roast'))
        self.ConfMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'Config'))
        self.ToolkitMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'Tools'))
        self.viewMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'View'))
        self.helpMenu = self.menuBar().addMenu('&' + QApplication.translate('Menu', 'Help'))

        #FILE menu
        self.newRoastMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'New'))

        self.fileLoadAction = QAction(QApplication.translate('Menu', 'Open...'),self)
        self.fileLoadAction.setShortcut(QKeySequence.StandardKey.Open)
        self.fileLoadAction.triggered.connect(self.fileLoad)
        self.fileMenu.addAction(self.fileLoadAction)

        self.openRecentMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Open Recent'))
        for i in range(self.MaxRecentFiles):
            self.openRecentMenu.addAction(self.recentFileActs[i])
        self.updateRecentFileActions()

        self.importMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Import'))

        urlImportAction = QAction('Artisan URL...', self)
        urlImportAction.triggered.connect(self.urlImport)
        self.importMenu.addAction(urlImportAction)

        fileImportCSVAction = QAction('Artisan CSV...', self)
        fileImportCSVAction.triggered.connect(self.fileImportCSV)
        self.importMenu.addAction(fileImportCSVAction)

        fileImportJSONAction = QAction('Artisan JSON...', self)
        fileImportJSONAction.triggered.connect(self.fileImportJSON)
        self.importMenu.addAction(fileImportJSONAction)

        self.importMenu.addSeparator()

        importBulletAction = QAction('Aillio RoasTime...', self)
        importBulletAction.triggered.connect(self.importBullet)
        self.importMenu.addAction(importBulletAction)

        importBulletAction = QAction('Aillio Roast.World URL...', self)
        importBulletAction.triggered.connect(self.importBulletURL)
        self.importMenu.addAction(importBulletAction)

        importCropsterAction = QAction('Cropster XLS...', self)
        importCropsterAction.triggered.connect(self.importCropster)
        self.importMenu.addAction(importCropsterAction)

        importGiesenAction = QAction('Giesen CSV...', self)
        importGiesenAction.triggered.connect(self.importGiesen)
        self.importMenu.addAction(importGiesenAction)

        importHH506RAAction = QAction('HH506RA...', self)
        importHH506RAAction.triggered.connect(self.importHH506RA)
        self.importMenu.addAction(importHH506RAAction)

        importIkawaAction = QAction('IKAWA CSV...', self)
        importIkawaAction.triggered.connect(self.importIkawa)
        self.importMenu.addAction(importIkawaAction)

        importK202Action = QAction('K202...', self)
        importK202Action.triggered.connect(self.importK202)
        self.importMenu.addAction(importK202Action)

        importK204Action = QAction('K204...', self)
        importK204Action.triggered.connect(self.importK204)
        self.importMenu.addAction(importK204Action)

        importLoringAction = QAction('Loring CSV...', self)
        importLoringAction.triggered.connect(self.importLoring)
        self.importMenu.addAction(importLoringAction)

        importRubasseAction = QAction('Rubasse CSV...', self)
        importRubasseAction.triggered.connect(self.importRubasse)
        self.importMenu.addAction(importRubasseAction)

        importPetronciniAction = QAction('Petroncini CSV...', self)
        importPetronciniAction.triggered.connect(self.importPetroncini)
        self.importMenu.addAction(importPetronciniAction)

        importPilotAction = QAction('Probat Pilot...', self)
        importPilotAction.triggered.connect(self.importPilot)
        self.importMenu.addAction(importPilotAction)

        fileImportRoastLoggerAction = QAction('RoastLogger...', self)
        fileImportRoastLoggerAction.triggered.connect(self.fileImportRoastLogger)
        self.importMenu.addAction(fileImportRoastLoggerAction)

        importRoastLogAction = QAction('RoastLog URL...',self)
        importRoastLogAction.triggered.connect(self.importRoastLog)
        self.importMenu.addAction(importRoastLogAction)

        importRoastPathAction = QAction('RoastPATH URL...',self)
        importRoastPathAction.triggered.connect(self.importRoastPATH)
        self.importMenu.addAction(importRoastPathAction)


        self.fileMenu.addSeparator()

        self.fileSaveAction = QAction(QApplication.translate('Menu', 'Save'), self)
        self.fileSaveAction.setShortcut(QKeySequence.StandardKey.Save)
        self.fileSaveAction.triggered.connect(self.fileSave_current_action)
        self.fileMenu.addAction(self.fileSaveAction)

        self.fileSaveAsAction = QAction(QApplication.translate('Menu', 'Save As...'), self)
        self.fileSaveAsAction.setShortcut(QKeySequence.StandardKey.SaveAs)
        self.fileSaveAsAction.triggered.connect(self.fileSave_new_action)
        self.fileMenu.addAction(self.fileSaveAsAction)

        # same as SaveAs, just that the saved file gets a new roastUUID assigned
        self.fileSaveCopyAsAction = QAction(QApplication.translate('Menu', 'Save a Copy As...'), self)
        self.fileSaveCopyAsAction.triggered.connect(self.fileSave_copy_action)
        self.fileMenu.addAction(self.fileSaveCopyAsAction)

        self.fileMenu.addSeparator()

        self.exportMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Export'))

        fileExportCSVAction = QAction(QApplication.translate('Menu', 'Artisan CSV...'), self)
        fileExportCSVAction.triggered.connect(self.fileExportCSV)
        self.exportMenu.addAction(fileExportCSVAction)

        fileExportJSONAction = QAction(QApplication.translate('Menu', 'Artisan JSON...'), self)
        fileExportJSONAction.triggered.connect(self.fileExportJSON)
        self.exportMenu.addAction(fileExportJSONAction)

        self.exportMenu.addSeparator()

        fileExportExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
        fileExportExcelAction.triggered.connect(self.fileExportExcel)
        self.exportMenu.addAction(fileExportExcelAction)

        self.exportMenu.addSeparator()

        fileExportPilotAction = QAction(QApplication.translate('Menu', 'Probat Pilot...'), self)
        fileExportPilotAction.triggered.connect(self.fileExportPilot)
        self.exportMenu.addAction(fileExportPilotAction)

        fileExportRoastLoggerAction = QAction(QApplication.translate('Menu', 'RoastLogger...'), self)
        fileExportRoastLoggerAction.triggered.connect(self.fileExportRoastLogger)
        self.exportMenu.addAction(fileExportRoastLoggerAction)

        self.convMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Convert To'))

        fileConvertFahrenheitAction = QAction(QApplication.translate('Menu', 'Fahrenheit...'), self)
        fileConvertFahrenheitAction.triggered.connect(self.fileConvertToFahrenheit)
        self.convMenu.addAction(fileConvertFahrenheitAction)

        fileConvertCelsiusAction = QAction(QApplication.translate('Menu', 'Celsius...'), self)
        fileConvertCelsiusAction.triggered.connect(self.fileConvertToCelsius)
        self.convMenu.addAction(fileConvertCelsiusAction)

        self.convMenu.addSeparator()

        fileConvertExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
        fileConvertExcelAction.triggered.connect(self.fileConvertExcel)
        self.convMenu.addAction(fileConvertExcelAction)

        self.convMenu.addSeparator()

        fileConvertCSVAction = QAction(QApplication.translate('Menu', 'Artisan CSV...'), self)
        fileConvertCSVAction.triggered.connect(self.fileConvertCSV)
        self.convMenu.addAction(fileConvertCSVAction)

        fileConvertJSONAction = QAction(QApplication.translate('Menu', 'Artisan JSON...'), self)
        fileConvertJSONAction.triggered.connect(self.fileConvertJSON)
        self.convMenu.addAction(fileConvertJSONAction)

        self.convMenu.addSeparator()

        fileConvertProbatAction = QAction(QApplication.translate('Menu', 'Probat Pilot...'), self)
        fileConvertProbatAction.triggered.connect(self.fileConvertPilot)
        self.convMenu.addAction(fileConvertProbatAction)

        fileConvertRoastLoggerAction = QAction(QApplication.translate('Menu', 'RoastLogger...'), self)
        fileConvertRoastLoggerAction.triggered.connect(self.fileConvertRoastLogger)
        self.convMenu.addAction(fileConvertRoastLoggerAction)

        self.convMenu.addSeparator()

        fileConvertPNGAction = QAction(QApplication.translate('Menu', 'PNG...'), self)
        fileConvertPNGAction.triggered.connect(self.fileConvertPNG)
        self.convMenu.addAction(fileConvertPNGAction)

        fileConvertJPEGAction = QAction(QApplication.translate('Menu', 'JPEG...'), self)
        fileConvertJPEGAction.triggered.connect(self.fileConvertJPEG)
        self.convMenu.addAction(fileConvertJPEGAction)

        fileConvertBMPAction = QAction(QApplication.translate('Menu', 'BMP...'), self)
        fileConvertBMPAction.triggered.connect(self.fileConvertBMP)
        self.convMenu.addAction(fileConvertBMPAction)

        fileConvertSVGAction = QAction(QApplication.translate('Menu', 'SVG...'), self)
        fileConvertSVGAction.triggered.connect(self.fileConvertSVG)
        self.convMenu.addAction(fileConvertSVGAction)

        fileConvertPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
        fileConvertPDFAction.triggered.connect(self.fileConvertPDF)
        self.convMenu.addAction(fileConvertPDFAction)

        fileConvertReportPDFAction = QAction(QApplication.translate('Menu', 'Roast Report PDF...'), self)
        fileConvertReportPDFAction.triggered.connect(self.fileConvertReportPDF)
        self.convMenu.addAction(fileConvertReportPDFAction)
        if not self.QtWebEngineSupport:
            fileConvertReportPDFAction.setEnabled(False)

        self.fileMenu.addSeparator()

        self.saveGraphMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Save Graph'))

        PDFAction = QAction('PDF...', self)
        PDFAction.triggered.connect(self.saveVectorGraph_PDF)
        self.saveGraphMenu.addAction(PDFAction)

        SVGAction = QAction('SVG...',self)
        SVGAction.triggered.connect(self.saveVectorGraph_SVG)
        self.saveGraphMenu.addAction(SVGAction)

        fullsizeAction = QAction(QApplication.translate('Menu', 'PNG...'), self)
        fullsizeAction.triggered.connect(self.resizeImg_0_1)
        self.saveGraphMenu.addAction(fullsizeAction)

        JPEGAction = QAction('JPEG...',self)
        JPEGAction.triggered.connect(self.resizeImg_0_1_JPEG)
        self.saveGraphMenu.addAction(JPEGAction)

        BMPAction = QAction('BMP...',self)
        BMPAction.triggered.connect(self.resizeImg_0_1_BMP)
        self.saveGraphMenu.addAction(BMPAction)

        self.saveGraphMenu.addSeparator()

        HomeBaristaAction = QAction('Home-Barista.com (1200x?)...', self)
        HomeBaristaAction.triggered.connect(self.resizeImg_1200_1)
        self.saveGraphMenu.addAction(HomeBaristaAction)

        KaffeeNetzAction = QAction('Kaffee-Netz.de (800x?)...', self)
        KaffeeNetzAction.triggered.connect(self.resizeImg_800_1)
        self.saveGraphMenu.addAction(KaffeeNetzAction)

        RiktigtKaffeAction = QAction('RiktigtKaffe.se (620x?)...', self)
        RiktigtKaffeAction.triggered.connect(self.resizeImg_620_1)
        self.saveGraphMenu.addAction(RiktigtKaffeAction)

        PlanetCafeAction = QAction('PlanetCafe.fr (600x?)...', self)
        PlanetCafeAction.triggered.connect(self.resizeImg_600_1)
        self.saveGraphMenu.addAction(PlanetCafeAction)

        CoffeeGeekAction = QAction('CoffeeGeek.com (500x?)...', self)
        CoffeeGeekAction.triggered.connect(self.resizeImg_500_1)
        self.saveGraphMenu.addAction(CoffeeGeekAction)

        self.saveGraphMenu.addSeparator()

        facebookSizeAction = QAction('Facebook (1200x628)...',self)
        facebookSizeAction.triggered.connect(self.resizeImgSize_1200_628)
        self.saveGraphMenu.addAction(facebookSizeAction)

        instagramSizeAction = QAction('Instagram (1080x608)...', self)
        instagramSizeAction.triggered.connect(self.resizeImgSize_1080_608)
        self.saveGraphMenu.addAction(instagramSizeAction)

        self.reportMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Report'))


        self.roastReportMenu = self.reportMenu.addMenu(QApplication.translate('Menu', 'Roast'))

        self.roastReportPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
        self.roastReportPDFAction.triggered.connect(self.pdfReport)
        self.roastReportMenu.addAction(self.roastReportPDFAction)
        if not self.QtWebEngineSupport:
            self.roastReportPDFAction.setEnabled(False)

        self.htmlAction = QAction(QApplication.translate('Menu', 'Web...'), self)
        self.htmlAction.triggered.connect(self.htmlReport)
        self.htmlAction.setShortcut('Ctrl+R')
        self.roastReportMenu.addAction(self.htmlAction)

        self.productionMenu = self.reportMenu.addMenu(QApplication.translate('Menu', 'Batches'))

        self.productionPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
        self.productionPDFAction.triggered.connect(self.productionPDFReport)
        self.productionMenu.addAction(self.productionPDFAction)
        if not self.QtWebEngineSupport:
            self.productionPDFAction.setEnabled(False)

        self.productionWebAction = QAction(QApplication.translate('Menu', 'Web...'), self)
        self.productionWebAction.triggered.connect(self.productionHTMLReport)
        self.productionMenu.addAction(self.productionWebAction)

        self.productionCsvAction = QAction(QApplication.translate('Menu', 'CSV...'), self)
        self.productionCsvAction.triggered.connect(self.productionCSVReport)
        self.productionMenu.addAction(self.productionCsvAction)

        self.productionExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
        self.productionExcelAction.triggered.connect(self.productionExcelReport)
        self.productionMenu.addAction(self.productionExcelAction)

        self.rankingMenu = self.reportMenu.addMenu(QApplication.translate('Menu', 'Ranking'))

        self.rankingPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
        self.rankingPDFAction.triggered.connect(self.rankingPDFReport)
        self.rankingMenu.addAction(self.rankingPDFAction)
        if not self.QtWebEngineSupport:
            self.rankingPDFAction.setEnabled(False)

        self.rankingWebAction = QAction(QApplication.translate('Menu', 'Web...'), self)
        self.rankingWebAction.triggered.connect(self.rankingHTMLReport)
        self.rankingMenu.addAction(self.rankingWebAction)

        self.rankingCsvAction = QAction(QApplication.translate('Menu', 'CSV...'), self)
        self.rankingCsvAction.triggered.connect(self.rankingCSVReport)
        self.rankingMenu.addAction(self.rankingCsvAction)

        self.rankingExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
        self.rankingExcelAction.triggered.connect(self.rankingExcelReport)
        self.rankingMenu.addAction(self.rankingExcelAction)

        self.savestatisticsAction = QAction(QApplication.translate('Menu', 'Save Statistics...'), self)
        self.savestatisticsAction.triggered.connect(self.saveStatistics)
        self.fileMenu.addAction(self.savestatisticsAction)

        self.fileMenu.addSeparator()

        self.printAction = QAction(QApplication.translate('Menu', 'Print...'), self)
        self.printAction.setShortcut(QKeySequence.StandardKey.Print)
        self.printAction.triggered.connect(self.filePrint)
        self.fileMenu.addAction(self.printAction)

        if platf == 'Darwin':
            self.quitAction = QAction('Quit', self) # automatically translated by Qt Translators
        else:
            self.quitAction = QAction(QApplication.translate('MAC_APPLICATION_MENU', 'Quit {0}').format(application_name), self)
        self.quitAction.setMenuRole(QAction.MenuRole.QuitRole)
        self.quitAction.setShortcut(QKeySequence.StandardKey.Quit)
        self.quitAction.triggered.connect(self.fileQuit)
        self.fileMenu.addAction(self.quitAction)

        # EDIT menu
        self.cutAction = QAction(QApplication.translate('Menu', 'Cut'), self)
        self.cutAction.setShortcut(QKeySequence.StandardKey.Cut)
        self.editMenu.addAction(self.cutAction)
        self.cutAction.triggered.connect(self.on_actionCut_triggered)
        self.copyAction = QAction(QApplication.translate('Menu', 'Copy'), self)
        self.copyAction.setShortcut(QKeySequence.StandardKey.Copy)
        self.editMenu.addAction(self.copyAction)
        self.copyAction.triggered.connect(self.on_actionCopy_triggered)
        self.pasteAction = QAction(QApplication.translate('Menu', 'Paste'), self)
        self.pasteAction.setShortcut(QKeySequence.StandardKey.Paste)
        self.editMenu.addAction(self.pasteAction)
        self.pasteAction.triggered.connect(self.on_actionPaste_triggered)

        # ROAST menu
        self.editGraphAction = QAction(QApplication.translate('Menu', 'Properties...'), self)
        self.editGraphAction.setMenuRole(QAction.MenuRole.NoRole) # without this, this item is not shown in he
        self.editGraphAction.triggered.connect(self.editgraph)
        self.RoastMenu.addAction(self.editGraphAction)
        self.editGraphAction.setShortcut('Ctrl+T')

        self.backgroundAction = QAction(QApplication.translate('Menu', 'Background...'), self)
        self.backgroundAction.triggered.connect(self.background)
        self.RoastMenu.addAction(self.backgroundAction)
        self.backgroundAction.setShortcut('Ctrl+B')

        self.flavorAction = QAction(QApplication.translate('Menu', 'Cup Profile...'), self)
        self.flavorAction.triggered.connect(self.flavorchart)
        self.RoastMenu.addAction(self.flavorAction)

        self.RoastMenu.addSeparator()

        self.switchAction = QAction(QApplication.translate('Menu', 'Switch Profiles'), self)
        self.switchAction.setShortcut(QKeySequence.StandardKey.Close)
        self.switchAction.triggered.connect(self.switch)
        self.RoastMenu.addAction(self.switchAction)

        self.switchETBTAction = QAction(QApplication.translate('Menu', 'Switch ET<->BT'), self)
        self.switchETBTAction.triggered.connect(self.switchETBT)
        self.RoastMenu.addAction(self.switchETBTAction)

        # CONFIGURATION menu
        self.machineMenu = QMenu(QApplication.translate('Menu', 'Machine'))
        # populated in populateMachineMenu/populateListMenu if not empty
        self.populateMachineMenu()

        self.deviceAction = QAction(QApplication.translate('Menu', 'Device...'), self)
        self.deviceAction.triggered.connect(self.deviceassigment)
        self.ConfMenu.addAction(self.deviceAction)
        self.deviceAction.setShortcut('Ctrl+D')

        self.commportAction = QAction(QApplication.translate('Menu', 'Port...'), self)
        self.commportAction.triggered.connect(self.setcommport)
        self.ConfMenu.addAction(self.commportAction)

        self.ConfMenu.addSeparator()

        self.calibrateDelayAction = QAction(QApplication.translate('Menu', 'Sampling...'), self)
        self.calibrateDelayAction.triggered.connect(self.calibratedelay)
        self.ConfMenu.addAction(self.calibrateDelayAction)

        self.ConfMenu.addSeparator()

        self.curvesAction = QAction(QApplication.translate('Menu', 'Curves...'), self)
        self.curvesAction.triggered.connect(self.setCurves)
        self.curvesAction.setShortcut('Ctrl+U')
        self.ConfMenu.addAction(self.curvesAction)

        self.ConfMenu.addSeparator()

        self.eventsAction = QAction(QApplication.translate('Menu', 'Events...'), self)
        self.eventsAction.triggered.connect(self.eventsconf)
        self.ConfMenu.addAction(self.eventsAction)
        self.eventsAction.setShortcut('Ctrl+E')

        self.alarmAction = QAction(QApplication.translate('Menu', 'Alarms...'), self)
        self.alarmAction.triggered.connect(self.alarmconfig)
        self.alarmAction.setShortcut('Ctrl+A')
        self.ConfMenu.addAction(self.alarmAction)

        self.ConfMenu.addSeparator()

        self.phasesGraphAction = QAction(QApplication.translate('Menu', 'Phases...'), self)
        self.phasesGraphAction.triggered.connect(self.editphases)
        self.ConfMenu.addAction(self.phasesGraphAction)

        self.StatisticsAction = QAction(QApplication.translate('Menu', 'Statistics...'), self)
        self.StatisticsAction.triggered.connect(self.showstatistics)
        self.ConfMenu.addAction(self.StatisticsAction)

        self.WindowconfigAction = QAction(QApplication.translate('Menu', 'Axes...'), self)
        self.WindowconfigAction.triggered.connect(self.Windowconfig)
        self.WindowconfigAction.setShortcut('Ctrl+Shift+A')
        self.ConfMenu.addAction(self.WindowconfigAction)

        self.ConfMenu.addSeparator()

        self.colorsAction = QAction(QApplication.translate('Menu', 'Colors...'), self)
        self.colorsAction.triggered.connect(self.qmc.changeGColor3)
        self.ConfMenu.addAction(self.colorsAction)

        self.themeMenu = QMenu(QApplication.translate('Menu', 'Themes'))
        self.populateThemeMenu()
        self.ConfMenu.addMenu(self.themeMenu)
        self.updateRecentThemeActions()

        self.ConfMenu.addSeparator()

        self.autosaveAction = QAction(QApplication.translate('Menu', 'Autosave...'), self)
        self.autosaveAction.triggered.connect(self.autosaveconf)
        self.ConfMenu.addAction(self.autosaveAction)

        self.batchAction = QAction(QApplication.translate('Menu', 'Batch...'), self)
        self.batchAction.triggered.connect(self.batchconf)
        self.ConfMenu.addAction(self.batchAction)

        self.ConfMenu.addSeparator()

        self.temperatureConfMenu = self.ConfMenu.addMenu(QApplication.translate('Menu', 'Temperature'))

        self.FahrenheitAction = QAction(QApplication.translate('Menu', 'Fahrenheit Mode'), self)
        self.FahrenheitAction.triggered.connect(self.qmc.fahrenheitModeRedraw)
        self.temperatureConfMenu.addAction(self.FahrenheitAction)

        self.CelsiusAction = QAction(QApplication.translate('Menu', 'Celsius Mode'), self)
        self.CelsiusAction.triggered.connect(self.qmc.celsiusModeRedraw)
        self.temperatureConfMenu.addAction(self.CelsiusAction)

        self.languageMenu = self.ConfMenu.addMenu(QApplication.translate('Menu', 'Language'))

        # language_menu_actions holds a dict associating iso2 locale strings to language menu actions
        self.language_menu_actions = {}

        # use s.encode("ascii", 'backslashreplace').decode("utf-8") and remove the duplicate \\
        for iso, name in [
                ('ar', '\u0627\u0644\u0639\u0631\u0628\u064a\u0629'),
                ('da', 'Dansk'),
                ('de', 'Deutsch'),
                ('en', 'English'),
                ('es', 'Espa\u00f1ol'),
                ('fa', '\u0641\u0627\u0631\u0633\u06cc'),
                ('fi', 'Suomalainen'),
                ('fr', 'Fran\u00e7ais'),
                ('gd', 'G\u00e0idhlig na h-Alba'),
                ('el', '\u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac'),
                ('he', '\u05e2\u05d1\u05e8\u05d9\u05ea'),
                ('id', 'Indonesia'),
                ('it', 'Italiano'),
                ('ja', '\u65e5\u672c\u8a9e'),
                ('ko', '\ud55c\uad6d\uc758'),
                ('lv', 'Latviete'),
                ('hu', 'Magyar'),
                ('nl', 'Nederlands'),
                ('no', 'Norsk'),
                ('pl', 'Polski'),
                ('pt', 'Portugu\xeas'),
                ('pt_BR', 'Portugu\u00EAs do Brasil'),
                ('ru', '\u0420\u0443\u0441\u0441\u043a\u0438\u0439'),
                ('sk', 'Slov\u00e1k'),
                ('sv', 'Svenska'),
                ('uk', '\u0443\u043a\u0440\u0430\u0457\u043d\u0435\u0446\u044c'), #"\u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0438\u0439"),
                ('th', 'Thai'),
                ('tr', 'T\xfcrk\u00e7e'),
                ('vi', 'Ti\u1EBFng Vi\u1EC7t'),
                ('zh_CN', '\u7b80\u4f53\u4e2d\u6587'),
                ('zh_TW', '\u7e41\u9ad4\u4e2d\u6587')]:
            self.addLanguage(iso, name)


        # TOOLKIT menu

        self.analyzeMenu = self.ToolkitMenu.addMenu(QApplication.translate('Menu', 'Analyzer'))
        self.fitIdealautoAction = QAction(QApplication.translate('Menu','Auto All'),self)
        self.fitIdealautoAction.triggered.connect(self.analysisfitCurvesALL)
        self.fitIdealautoAction.setShortcut('Ctrl+K')
        self.analyzeMenu.addAction(self.fitIdealautoAction)
        self.analyzeMenu.addSeparator()
        self.fitIdealx2Action = QAction(QApplication.translate('Menu','Fit BT to') + ' x\xb2',self)
        self.fitIdealx2Action.triggered.connect(self.analysisfitCurvesX2)
        self.analyzeMenu.addAction(self.fitIdealx2Action)
        self.fitIdealx3Action = QAction(QApplication.translate('Menu','Fit BT to') + ' x\xb3',self)
        self.fitIdealx3Action.triggered.connect(self.analysisfitCurvesX3)
        self.analyzeMenu.addAction(self.fitIdealx3Action)
        self.fitIdealx0Action = QAction(QApplication.translate('Menu','Fit BT to') + ' ln()',self)
        self.fitIdealx0Action.triggered.connect(self.analysisfitCurvesLN)
        self.analyzeMenu.addAction(self.fitIdealx0Action)
        self.analyzeMenu.addSeparator()
        self.fitBkgndAction = QAction(QApplication.translate('Menu','Fit BT to Bkgnd'),self)
        self.fitBkgndAction.triggered.connect(self.analysisfitCurvesBkgnd)
        self.analyzeMenu.addAction(self.fitBkgndAction)
        self.analyzeMenu.addSeparator()
        self.clearresultsAction = QAction(QApplication.translate('Menu','Clear results'),self)
        self.clearresultsAction.triggered.connect(self.clearResults)
        self.clearresultsAction.setShortcut('Ctrl+Alt+K') # COMMAND+OPTION on macOS
        self.analyzeMenu.addAction(self.clearresultsAction)

        self.roastCompareAction = QAction(QApplication.translate('Menu', 'Comparator'), self)
        self.roastCompareAction.triggered.connect(self.roastCompare)
        self.roastCompareAction.setCheckable(True)
        self.roastCompareAction.setChecked(bool(self.comparator))
        self.ToolkitMenu.addAction(self.roastCompareAction)

        self.designerAction = QAction(QApplication.translate('Menu', 'Designer') , self)
        self.designerAction.triggered.connect(self.designerTriggered)
        self.designerAction.setCheckable(True)
        self.designerAction.setChecked(self.qmc.designerflag)
        self.ToolkitMenu.addAction(self.designerAction)

        self.simulatorAction = QAction(QApplication.translate('Menu', 'Simulator') , self)
        self.simulatorAction.triggered.connect(self.simulate)
        self.simulatorAction.setCheckable(True)
        self.simulatorAction.setChecked(bool(self.simulator))
        self.ToolkitMenu.addAction(self.simulatorAction)

        self.wheeleditorAction = QAction(QApplication.translate('Menu', 'Wheel Graph'), self)
        self.wheeleditorAction.triggered.connect(self.graphwheel)
        self.wheeleditorAction.setCheckable(True)
        self.wheeleditorAction.setChecked(self.qmc.wheelflag)
        self.ToolkitMenu.addAction(self.wheeleditorAction)

        self.ToolkitMenu.addSeparator()

        self.transformAction = QAction(QApplication.translate('Menu', 'Transposer'), self)
        self.transformAction.triggered.connect(self.transform)
        self.ToolkitMenu.addAction(self.transformAction)

        self.temperatureMenu = self.ToolkitMenu.addMenu(QApplication.translate('Menu', 'Convert Profile Temperature'))

        self.ConvertToFahrenheitAction = QAction(QApplication.translate('Menu', 'Convert to Fahrenheit'), self)
        self.ConvertToFahrenheitAction.triggered.connect(self.qmc.convertTemperatureF)
        self.temperatureMenu.addAction(self.ConvertToFahrenheitAction)

        self.ConvertToCelsiusAction = QAction(QApplication.translate('Menu', 'Convert to Celsius'), self)
        self.ConvertToCelsiusAction.triggered.connect(self.qmc.convertTemperatureC)
        self.temperatureMenu.addAction(self.ConvertToCelsiusAction)

        if self.qmc.mode == 'F':
            self.FahrenheitAction.setDisabled(True)
            self.ConvertToFahrenheitAction.setDisabled(True)
        else:
            self.CelsiusAction.setDisabled(True)
            self.ConvertToCelsiusAction.setDisabled(True)

        self.ToolkitMenu.addSeparator()

        calculatorAction = QAction(QApplication.translate('Menu', 'Calculator'), self)
        calculatorAction.triggered.connect(self.calculator)
        self.ToolkitMenu.addAction(calculatorAction)


        # VIEW menu

        self.controlsAction = QAction(QApplication.translate('Menu', 'Controls'), self)
        self.controlsAction.triggered.connect(self.toggleControls)
        self.controlsAction.setCheckable(True)
        self.controlsAction.setChecked(True)
        self.viewMenu.addAction(self.controlsAction)

        self.readingsAction = QAction(QApplication.translate('Menu', 'Readings'), self)
        self.readingsAction.triggered.connect(self.toggleReadings)
        self.readingsAction.setCheckable(True)
        self.readingsAction.setChecked(False)
        self.viewMenu.addAction(self.readingsAction)

        self.eventsEditorAction = QAction(QApplication.translate('Menu', 'Events Editor'), self)
        self.eventsEditorAction.triggered.connect(self.toggle_minieventline)
        self.eventsEditorAction.setCheckable(True)
        self.eventsEditorAction.setChecked(False)
        self.viewMenu.addAction(self.eventsEditorAction)

        self.buttonsAction = QAction(QApplication.translate('Menu', 'Buttons'), self)
        self.buttonsAction.triggered.connect(self.toggleExtraButtons)
        self.buttonsAction.setCheckable(True)
        self.buttonsAction.setChecked(False)
        self.viewMenu.addAction(self.buttonsAction)

        self.slidersAction = QAction(QApplication.translate('Menu', 'Sliders'), self)
        self.slidersAction.triggered.connect(self.toggleSliders)
        self.slidersAction.setCheckable(True)
        self.slidersAction.setChecked(False)
        self.viewMenu.addAction(self.slidersAction)

        self.viewMenu.addSeparator()

        self.lcdsAction = QAction(QApplication.translate('Menu', 'Main LCDs'), self)
        self.lcdsAction.triggered.connect(self.largeLCDs)
        self.lcdsAction.setCheckable(True)
        self.lcdsAction.setChecked(False)
        self.lcdsAction.setShortcut('Ctrl+L')
        self.viewMenu.addAction(self.lcdsAction)

        self.deltalcdsAction = QAction(QApplication.translate('Menu', 'Delta LCDs'), self)
        self.deltalcdsAction.triggered.connect(self.largeDeltaLCDs)
        self.deltalcdsAction.setCheckable(True)
        self.deltalcdsAction.setChecked(False)
        self.viewMenu.addAction(self.deltalcdsAction)

        self.pidlcdsAction = QAction(QApplication.translate('Menu', 'PID LCDs'), self)
        self.pidlcdsAction.triggered.connect(self.largePIDLCDs)
        self.pidlcdsAction.setCheckable(True)
        self.pidlcdsAction.setChecked(False)
        self.viewMenu.addAction(self.pidlcdsAction)

        self.extralcdsAction = QAction(QApplication.translate('Menu', 'Extra LCDs'), self)
        self.extralcdsAction.triggered.connect(self.largeExtraLCDs)
        self.extralcdsAction.setCheckable(True)
        self.extralcdsAction.setChecked(False)
        self.viewMenu.addAction(self.extralcdsAction)

        self.phaseslcdsAction = QAction(QApplication.translate('Menu', 'Phases LCDs'), self)
        self.phaseslcdsAction.triggered.connect(self.largePhasesLCDs)
        self.phaseslcdsAction.setCheckable(True)
        self.phaseslcdsAction.setChecked(False)
        self.viewMenu.addAction(self.phaseslcdsAction)

        self.scalelcdsAction = QAction(QApplication.translate('Menu', 'Scale LCDs'), self)
        self.scalelcdsAction.triggered.connect(self.largeScaleLCDs)
        self.scalelcdsAction.setCheckable(True)
        self.scalelcdsAction.setChecked(False)
        self.viewMenu.addAction(self.scalelcdsAction)

        self.viewMenu.addSeparator()

        if not (platf == 'Darwin' and self.qmc.locale_str == 'en'): # macOS automatically adds the fullscreen action to View menu
            self.fullscreenAction = QAction(QApplication.translate('Menu', 'Full Screen'), self)
            self.fullscreenAction.triggered.connect(self.toggleFullscreen)
            self.fullscreenAction.setCheckable(True)
            self.fullscreenAction.setChecked(False)
            self.fullscreenAction.setShortcut('Ctrl+F')
            self.fullscreenAction.setMenuRole(QAction.MenuRole.NoRole)
            self.viewMenu.addAction(self.fullscreenAction)

        # HELP menu
        if app.artisanviewerMode:
            helpAboutAction = QAction(QApplication.translate('MAC_APPLICATION_MENU', 'About {0}').format(application_viewer_name), self)
        else:
            helpAboutAction = QAction(QApplication.translate('MAC_APPLICATION_MENU', 'About {0}').format(application_name), self)
        helpAboutAction.setMenuRole(QAction.MenuRole.AboutRole)
        helpAboutAction.triggered.connect(self.helpAbout)
        self.helpMenu.addAction(helpAboutAction)

        aboutQtAction = QAction(QApplication.translate('Menu', 'About Qt'), self)
        aboutQtAction.setMenuRole(QAction.MenuRole.AboutQtRole)
        aboutQtAction.triggered.connect(self.showAboutQt)
        self.helpMenu.addAction(aboutQtAction)

        helpDocumentationAction = QAction(QApplication.translate('Menu', 'Documentation'), self)
        helpDocumentationAction.triggered.connect(self.helpHelp)
        helpDocumentationAction.setShortcut(QKeySequence.StandardKey.HelpContents)
        self.helpMenu.addAction(helpDocumentationAction)

        KshortCAction = QAction(QApplication.translate('Menu', 'Keyboard Shortcuts'), self)
        KshortCAction.triggered.connect(self.viewKshortcuts)
        self.helpMenu.addAction(KshortCAction)

        self.helpMenu.addSeparator()

        checkUpdateAction = QAction(QApplication.translate('Menu', 'Check for Updates'), self)
        checkUpdateAction.setMenuRole(QAction.MenuRole.NoRole)
        checkUpdateAction.triggered.connect(self.checkUpdate)
        self.helpMenu.addAction(checkUpdateAction)

        self.helpMenu.addSeparator()

        errorAction = QAction(QApplication.translate('Menu', 'Errors'), self)
        errorAction.triggered.connect(self.viewErrorLog)
        self.helpMenu.addAction(errorAction)

        messageAction = QAction(QApplication.translate('Menu', 'Messages'), self)
        messageAction.triggered.connect(self.viewMessageLog)
        self.helpMenu.addAction(messageAction)

        serialAction = QAction(QApplication.translate('Menu', 'Serial'), self)
        serialAction.triggered.connect(self.viewSerialLog)
        serialAction.setMenuRole(QAction.MenuRole.NoRole)
        self.helpMenu.addAction(serialAction)

        platformAction = QAction(QApplication.translate('Menu', 'Platform'), self)
        platformAction.triggered.connect(self.viewplatform)
        self.helpMenu.addAction(platformAction)


        # SETTINGS submenu
        self.helpMenu.addSeparator()

        self.loadSettingsAction = QAction(QApplication.translate('Menu', 'Load Settings...'), self)
        self.loadSettingsAction.triggered.connect(self.loadSettings_triggered)
        self.loadSettingsAction.setMenuRole(QAction.MenuRole.NoRole) # avoid specific handling of settings menu
        self.helpMenu.addAction(self.loadSettingsAction)

        self.openRecentSettingMenu = self.helpMenu.addMenu(QApplication.translate('Menu', 'Load Recent Settings'))
        for i in range(self.MaxRecentFiles):
            self.openRecentSettingMenu.addAction(self.recentSettingActs[i])
        self.updateRecentSettingActions()

        self.saveAsSettingsAction = QAction(QApplication.translate('Menu', 'Save Settings...'), self)
        self.saveAsSettingsAction.triggered.connect(self.saveSettings)
        self.saveAsSettingsAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu
        self.helpMenu.addAction(self.saveAsSettingsAction)

        self.helpMenu.addSeparator()

        self.resetAction = QAction(QApplication.translate('Menu', 'Factory Reset'), self)
        self.resetAction.triggered.connect(self.resetApplication)
        self.helpMenu.addAction(self.resetAction)

        self.displayonlymenus()


        ############################## WIDGETS SECTION ########################################

        #create a Label object to display program status information
        self.messagelabel = QLabel()
        f = self.messagelabel.font()
        f.setPointSize(self.messagelabel.font().pointSize()+1)
        self.messagelabel.setFont(f)

        self.messagelabel.setIndent(6)
        # set a few broad style parameters
        if platf == 'Linux':
            self.button_font_size_pt = 11
        else:
            self.button_font_size_pt = 13

        #TODO: delete # pylint: disable=fixme
        if platf == 'Windows':
            self.button_font_size = f'{self.button_font_size_pt - 2}pt'
        else:
            self.button_font_size = f'{self.button_font_size_pt}pt'
        self.button_font_size_small = f'{self.button_font_size_pt - 3}pt'
        self.button_font_size_small_selected = f'{self.button_font_size_pt - 2}pt'
        self.button_font_size_tiny = f'{self.button_font_size_pt - 4}pt'
        self.button_font_size_micro = f'{self.button_font_size_pt - 5}pt'

        #TODO: keep # pylint: disable=fixme
        button_font_size_small_pt = self.button_font_size_pt - 3
        button_font_size_small_selected_pt = self.button_font_size_pt - 2
#        button_font_size_tiny_pt = self.button_font_size_pt - 4
#        button_font_size_micro_pt = self.button_font_size_pt - 5
        if platf == 'Windows':
            self.button_font_size_pt = self.button_font_size_pt - 2

        # button width in px
        if platf == 'Windows':
            # TODO: remove # pylint: disable=fixme
            self.main_button_min_width_str = '110px'
            self.small_button_min_width_str = '75px'
            self.tiny_button_min_width_str = '60px'
            # TODO: keep # pylint: disable=fixme
#            self.main_button_min_width_px: Final = 110
            self.standard_button_min_width_px: Final = 90
#            self.small_button_min_width_px: Final = 75
            #self.tiny_button_min_width_px: Final = 60
        else:
            # TODO: remove # pylint: disable=fixme
            self.main_button_min_width_str = '100px'
            self.small_button_min_width_str = '60px'
            self.tiny_button_min_width_str = '50px'
            # TODO: keep # pylint: disable=fixme
#            self.main_button_min_width_px = 100
            self.standard_button_min_width_px = 75
#            self.small_button_min_width_px = 60
#            self.tiny_button_min_width_px = 50

        border_modern = 'border-style:solid; border-radius:4;border-color:grey; border-width:0;' # modernize

        self.pushbuttonstyles_simulator = {
            'OFF':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: '#147bb3';
                    background-color: white;
                }
                QPushButton:pressed {
                    color: 116D98;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background-color: #F5F5F5;
                }
            """,
            'ON':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #cc0f50;
                    background-color: white;

                }
                QPushButton:pressed {
                    color: #c70d49;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #d4336a;
                    background-color: #F5F5F5;
                }
            """,
            'STOP':     """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #147bb3;
                    background-color: white;
                }
                QPushButton:!enabled {
                    color: #EFEFEF;
                    background-color: darkgrey;
                }
                QPushButton:pressed {
                    color: #116999;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background-color: #F5F5F5;
                }
            """,
            'START':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background-color: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,
        }

        self.pushbuttonstyles = {
            'RESET':     """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #43a7cf;
                }
            """,
            'OFF':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #147bb3;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116D98;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #1985ba;
                }
            """,
            'ON':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #cc0f50;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #c70d49;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #d4336a;
                }
            """,
            'STOP':     """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #147bb3;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #1985ba;
                }
            """,
            'START':    """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background-color: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,
            'PID':     """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #43a7cf;
                }
            """,
            'PIDactive':     """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #cc0f50;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #c70d49;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #d4336a;
                }
            """,
            'SV +':     """
                QPushButton {
                    min-width: """ + str(self.standard_button_min_width_px) + """px;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background-color:""" + createGradient('#db5785') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color:""" + createGradient('#d4336a') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color:""" + createGradient('#e480a2') + """ ;
                                     }
            """,
            'SV -':     """
                QPushButton {
                    min-width: """ + str(self.standard_button_min_width_px) + """px;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background-color:""" + createGradient('#64b7d8') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color:""" + createGradient('#43a7cf') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color:""" + createGradient('#85cae1') + """ ;
                }
            """
            }
        # we use this high to dynamically adjust the button size to different font sizes (important for high-dpi displays on Windows)
        if platf == 'Windows':
            default_button_height = QPushButton('Test').sizeHint().height()
            self.standard_button_tiny_height = int(round(default_button_height * 1.1))
            self.standard_button_small_height = int(round(default_button_height * 1.5))
            self.standard_button_height = int(round(default_button_height * 2))
        else:
            self.standard_button_small_height = QPushButton('Test').sizeHint().height()
            self.standard_button_tiny_height = int(round(self.standard_button_small_height * 0.8))
            self.standard_button_height = int(round(self.standard_button_small_height * 1.3))

        #create ON/OFF buttons

        self.buttonONOFF = QPushButton(QApplication.translate('Button', 'ON'))
        self.buttonONOFF.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Start monitoring'))
        self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['OFF'])
        self.buttonONOFF.setGraphicsEffect(self.makeShadow())
#        self.buttonONOFF.pressed.connect(self.mainButtonPressed)
#        self.buttonONOFF.released.connect(self.mainButtonReleased)
        self.buttonONOFF.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonONOFF.setMinimumHeight(self.standard_button_height)
        self.buttonONOFF.clicked.connect(self.qmc.ToggleMonitor)
        if app.artisanviewerMode:
            self.buttonONOFF.setVisible(False)

        #create START/STOP buttons
        self.buttonSTARTSTOP = QPushButton(QApplication.translate('Button', 'START'))
        self.buttonSTARTSTOP.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSTARTSTOP.setToolTip(QApplication.translate('Tooltip', 'Start recording'))
        self.buttonSTARTSTOP.setStyleSheet(self.pushbuttonstyles['STOP'])
        self.buttonSTARTSTOP.setGraphicsEffect(self.makeShadow())
#        self.buttonSTARTSTOP.pressed.connect(self.mainButtonPressed)
#        self.buttonSTARTSTOP.released.connect(self.mainButtonReleased)
        self.buttonSTARTSTOP.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        self.buttonSTARTSTOP.setMinimumHeight(self.standard_button_height)
        self.buttonSTARTSTOP.clicked.connect(self.qmc.ToggleRecorder)
        if app.artisanviewerMode:
            self.buttonSTARTSTOP.setVisible(False)

        #create 1C START, 1C END, 2C START and 2C END buttons
        self.buttonFCs = MinorEventPushButton(QApplication.translate('Button', 'FC\nSTART'))
        self.buttonFCs.setToolTip(QApplication.translate('Tooltip', 'First Crack Start'))
        self.buttonFCs.clicked.connect(self.qmc.mark1Cstart)

        self.buttonFCe = MinorEventPushButton(QApplication.translate('Button', 'FC\nEND'))
        self.buttonFCe.setToolTip(QApplication.translate('Tooltip', 'First Crack End'))
        self.buttonFCe.clicked.connect(self.qmc.mark1Cend)

        self.buttonSCs = MinorEventPushButton(QApplication.translate('Button', 'SC\nSTART'))
        self.buttonSCs.setToolTip(QApplication.translate('Tooltip', 'Second Crack Start'))
        self.buttonSCs.clicked.connect(self.qmc.mark2Cstart)

        self.buttonSCe = MinorEventPushButton(QApplication.translate('Button', 'SC\nEND'))
        self.buttonSCe.setToolTip(QApplication.translate('Tooltip', 'Second Crack End'))
        self.buttonSCe.clicked.connect(self.qmc.mark2Cend)

        #create RESET button
        self.buttonRESET = QPushButton(QApplication.translate('Button', 'RESET'))
        self.buttonRESET.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonRESET.setStyleSheet(self.pushbuttonstyles['RESET'])
        self.buttonRESET.setGraphicsEffect(self.makeShadow())
#        self.buttonRESET.pressed.connect(self.mainButtonPressed)
#        self.buttonRESET.released.connect(self.mainButtonReleased)
        self.buttonRESET.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonRESET.setMinimumHeight(self.standard_button_height)
        self.buttonRESET.setToolTip(QApplication.translate('Tooltip', 'Reset'))
        self.buttonRESET.clicked.connect(self.qmc.resetButtonAction)

        #create CHARGE button
        self.buttonCHARGE = AnimatedMajorEventPushButton(QApplication.translate('Button', 'CHARGE'))
        self.buttonCHARGE.setToolTip(QApplication.translate('Tooltip', 'Charge'))
        self.buttonCHARGE.clicked.connect(self.qmc.markCharge)

        #create DROP button
        self.buttonDROP = MajorEventPushButton(QApplication.translate('Button', 'DROP'))
        self.buttonDROP.setToolTip(QApplication.translate('Tooltip', 'Drop'))
        self.buttonDROP.clicked.connect(self.qmc.markDrop)

        #create PID control button
        self.buttonCONTROL = QPushButton(QApplication.translate('Button', 'Control'))
        self.buttonCONTROL.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonCONTROL.setStyleSheet(self.pushbuttonstyles['PID'])
        self.buttonCONTROL.setGraphicsEffect(self.makeShadow())
#        self.buttonCONTROL.pressed.connect(self.mainButtonPressed)
#        self.buttonCONTROL.released.connect(self.mainButtonReleased)
        self.buttonCONTROL.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonCONTROL.setMinimumHeight(self.standard_button_height)
        self.buttonCONTROL.clicked.connect(self.PIDcontrol)
        if app.artisanviewerMode:
            self.buttonCONTROL.setVisible(False)

        #create EVENT record button
        self.buttonEVENT = AuxEventPushButton(QApplication.translate('Button', 'EVENT'))
        self.buttonEVENT.setToolTip(QApplication.translate('Tooltip', 'Event'))
        self.buttonEVENT.clicked.connect(self.qmc.EventRecord_action)

        #create PID+5 button
        self.buttonSVp5 = QPushButton(QApplication.translate('Button', 'SV +5'))
        self.buttonSVp5.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp5.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp5.setMinimumWidth(90)
        self.buttonSVp5.setMinimumHeight(self.standard_button_height)
        self.buttonSVp5.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 5'))
        self.buttonSVp5.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #create PID+10 button
        self.buttonSVp10 = QPushButton(QApplication.translate('Button', 'SV +10'))
        self.buttonSVp10.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp10.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp10.setMinimumWidth(90)
        self.buttonSVp10.setMinimumHeight(self.standard_button_height)
        self.buttonSVp10.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 10'))
        self.buttonSVp10.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #create PID+20 button
        self.buttonSVp20 = QPushButton(QApplication.translate('Button', 'SV +20'))
        self.buttonSVp20.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp20.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp20.setMinimumWidth(90)
        self.buttonSVp20.setMinimumHeight(self.standard_button_height)
        self.buttonSVp20.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 20'))
        self.buttonSVp20.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #create PID-20 button
        self.buttonSVm20 = QPushButton(QApplication.translate('Button', 'SV -20'))
        self.buttonSVm20.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm20.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm20.setMinimumWidth(90)
        self.buttonSVm20.setMinimumHeight(self.standard_button_height)
        self.buttonSVm20.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 20'))
        self.buttonSVm20.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #create PID-10 button
        self.buttonSVm10 = QPushButton(QApplication.translate('Button', 'SV -10'))
        self.buttonSVm10.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm10.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm10.setMinimumWidth(90)
        self.buttonSVm10.setMinimumHeight(self.standard_button_height)
        self.buttonSVm10.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 10'))
        self.buttonSVm10.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #create PID-5 button
        self.buttonSVm5 = QPushButton(QApplication.translate('Button', 'SV -5'))
        self.buttonSVm5.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm5.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm5.setMinimumWidth(90)
        self.buttonSVm5.setMinimumHeight(self.standard_button_height)
        self.buttonSVm5.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 5'))
        self.buttonSVm5.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        #HUD button (button_18 was removed)

        #create DRY button
        self.buttonDRY = MinorEventPushButton(QApplication.translate('Button', 'DRY\nEND'))
        self.buttonDRY.setToolTip(QApplication.translate('Tooltip', 'Dry End'))
        self.buttonDRY.clicked.connect(self.qmc.markDryEnd)

        #create COOLe button
        self.buttonCOOL = MinorEventPushButton(QApplication.translate('Button', 'COOL\nEND'))
        self.buttonCOOL.setToolTip(QApplication.translate('Tooltip', 'Cool End'))
        self.buttonCOOL.clicked.connect(self.qmc.markCoolEnd)

        #connect PID sv easy buttons
        self.buttonSVp5.clicked.connect(self.adjustPIDsv5)
        self.buttonSVp10.clicked.connect(self.adjustPIDsv10)
        self.buttonSVp20.clicked.connect(self.adjustPIDsv20)
        self.buttonSVm20.clicked.connect(self.adjustPIDsv20m)
        self.buttonSVm10.clicked.connect(self.adjustPIDsv10m)
        self.buttonSVm5.clicked.connect(self.adjustPIDsv5m)

        # NavigationToolbar VMToolbar
        self.ntb = VMToolbar(self.qmc, self.main_widget)
        #self.ntb.setMinimumHeight(50)

        #create LCD displays
        #RIGHT COLUMN
        self.lcd1 = MyQLCDNumber() # time
        self.lcd1.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        self.lcd1.setMinimumHeight(40)
        self.lcd1.setMinimumWidth(100)
        self.lcd1.setFrameStyle(QFrame.Shadow.Plain)
        # switch superusermode action:
        self.lcd1.clicked.connect(self.superusermodeLeftClicked)
        self.lcd1.setVisible(False)

        self.lcd2 = self.ArtisanLCD() # Temperature ET
        self.lcd3 = self.ArtisanLCD() # Temperature BT
        self.lcd4 = self.ArtisanLCD() # rate of change ET
        self.lcd5 = self.ArtisanLCD() # rate of change BT
        self.lcd6 = self.ArtisanLCD() # pid sv
        self.lcd7 = self.ArtisanLCD() # pid power % duty cycle

        self.lcd1.display('00:00')
        if self.qmc.LCDdecimalplaces:
            zz = '-.-'
        else:
            zz = '--'
        self.lcd2.display(zz)
        self.lcd3.display(zz)
        self.lcd4.display(zz)
        self.lcd5.display(zz)
        self.lcd6.display(zz)
        self.lcd7.display(zz)

        self.lcd1.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['timer'],self.lcdpaletteB['timer']))
        self.lcd2.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['et'],self.lcdpaletteB['et']))
        self.lcd3.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['bt'],self.lcdpaletteB['bt']))
        self.lcd4.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['deltaet'],self.lcdpaletteB['deltaet']))
        self.lcd5.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['deltabt'],self.lcdpaletteB['deltabt']))
        self.lcd6.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
        self.lcd7.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))

        self.lcd1.setToolTip(QApplication.translate('Tooltip', 'Timer'))
        self.lcd2.setToolTip(QApplication.translate('Tooltip', 'ET Temperature'))
        self.lcd3.setToolTip(QApplication.translate('Tooltip', 'BT Temperature'))
        self.lcd4.setToolTip(QApplication.translate('Tooltip', 'ET/time (degrees/min)'))
        self.lcd5.setToolTip(QApplication.translate('Tooltip', 'BT/time (degrees/min)'))
        self.lcd6.setToolTip(QApplication.translate('Tooltip', 'Value of SV in PID'))
        self.lcd7.setToolTip(QApplication.translate('Tooltip', 'PID power %'))

        #MET
        self.label2 = QLabel()
        self.label2.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label2.setText('<big><b>' + QApplication.translate('Label', 'ET') + '</b></big>')
        self.setLabelColor(self.label2,QColor(self.qmc.palette['et']))
        #BT
        self.label3 = QLabel()
        self.label3.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label3.setText('<big><b>' + QApplication.translate('Label', 'BT') + '</b></big>')
        self.setLabelColor(self.label3,QColor(self.qmc.palette['bt']))
        #DELTA MET
        self.label4 = QLabel()
        self.label4.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label4.setText(deltaLabelBigPrefix + QApplication.translate('Label', 'ET') + '</b></big>')
        self.setLabelColor(self.label4,QColor(self.qmc.palette['deltaet']))
        # DELTA BT
        self.label5 = QLabel()
        self.label5.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label5.setText(deltaLabelBigPrefix + QApplication.translate('Label', 'BT') + '</b></big>')
        self.setLabelColor(self.label5,QColor(self.qmc.palette['deltabt']))
        # pid sv
        self.label6 = QLabel()
        self.label6.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label6.setText('<big><b>' + QApplication.translate('Label', 'PID SV') + '</b></big>')
        # pid power % duty cycle
        self.label7 = QLabel()
        self.label7.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label7.setText('<big><b>' + QApplication.translate('Label', 'PID %') + '</b></big>')

        #extra LCDs
        self.nLCDS = 10 # maximum number of LCDs and extra devices
        self.extraLCD1,self.extraLCD2 = [],[]
        self.extraLCDlabel1,self.extraLCDlabel2 = [],[]
        self.extraLCDframe1,self.extraLCDframe2 = [],[]
        self.extraLCDvisibility1,self.extraLCDvisibility2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraCurveVisibility1,self.extraCurveVisibility2 = [True]*self.nLCDS,[True]*self.nLCDS
        self.extraDelta1,self.extraDelta2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraFill1,self.extraFill2 = [0]*self.nLCDS,[0]*self.nLCDS # alpha values 0-100 in % of fill between extra curve and x-axis
        for i in range(self.nLCDS):
            #configure LCDs
            self.extraLCDframe1.append(ClickableLCDFrame())
            self.extraLCD1.append(self.ArtisanLCD())
            self.extraLCDlabel1.append(QLabel())
            self.extraLCDframe2.append(ClickableLCDFrame())
            self.extraLCD2.append(self.ArtisanLCD())
            self.extraLCDlabel2.append(QLabel())
            self.extraLCDframe1[i].setVisible(False)
            if self.qmc.LCDdecimalplaces:
                if self.qmc.intChannel(i,0):
                    self.extraLCD1[i].display('--')
                else:
                    self.extraLCD1[i].display('-.-')
                if self.qmc.intChannel(i,1):
                    self.extraLCD2[i].display('--')
                else:
                    self.extraLCD2[i].display('-.-')
            else:
                self.extraLCD1[i].display('--')
                self.extraLCD2[i].display('--')
            self.extraLCDframe1[i].setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.extraLCDframe1[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCDframe1[i].left_clicked.connect(self.toggleExtraCurve1)
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.extraLCDframe2[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCDframe2[i].left_clicked.connect(self.toggleExtraCurve2)
            self.extraLCDframe2[i].setVisible(False)
            self.extraLCD1[i].setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
            self.extraLCD2[i].setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
            #configure Labels
            self.extraLCDlabel1[i].setSizePolicy(QSizePolicy.Policy.Preferred,QSizePolicy.Policy.Preferred)
            self.extraLCDlabel2[i].setSizePolicy(QSizePolicy.Policy.Preferred,QSizePolicy.Policy.Preferred)
            self.extraLCDlabel1[i].setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
            self.extraLCDlabel2[i].setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)

        # channel tare values (set by clicking on the corresponding LCDs)
        # for ET/BT and each extra channel (2x self.nLCDS)
        self.channel_tare_values = [0.0]*(2+self.nLCDS*2)

        # Stores messages up to 500
        self.messagehist = []

        #only leave operational the control button if the device is Fuji PID
        #the SV buttons are activated from the PID control panel
        self.buttonCONTROL.setVisible(False)

        self.buttonSVp5.setVisible(False)
        self.buttonSVp10.setVisible(False)
        self.buttonSVp20.setVisible(False)
        self.buttonSVm20.setVisible(False)
        self.buttonSVm10.setVisible(False)
        self.buttonSVm5.setVisible(False)

        #### EVENT MINI EDITOR: View&Edits events without opening roast properties Dlg.
        self.eventlabel = QLabel(f'{QApplication.translate("Form Caption", "Event")} #<b>0 </b>')

        self.eventlabel.setIndent(5)

        self.eNumberSpinBox = QSpinBox()
        self.eNumberSpinBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.eNumberSpinBox.setToolTip(QApplication.translate('Tooltip', 'Number of events found'))
        self.eNumberSpinBox.setRange(0,99)
        self.eNumberSpinBox.valueChanged.connect(self.changeEventNumber)
        self.eNumberSpinBox.setMaximumWidth(40)

        self.minieventleft = QPushButton('<')
        self.minieventleft.clicked.connect(self.decrEventNumber)
        self.minieventright = QPushButton('>')
        self.minieventright.clicked.connect(self.incrEventNumber)

        self.lineEvent = QLineEdit()
        self.lineEvent.setMinimumWidth(200)

        self.eventlabel.setStyleSheet("background-color:'#bdbdbd';")

        self.etypeComboBox = QComboBox()
        self.etypeComboBox.setToolTip(QApplication.translate('Tooltip', 'Type of event'))
        self.etypeComboBox.addItems(self.qmc.etypes)

        #regexvalue = QRegularExpression(r"^100|\d?\d?$") # allow event values 0-100 (%)
        regexvalue = QRegularExpression(r'^[1-9][0-9]{1,3}$|^\d$') # allow event values 0-9999
        self.valueEdit = QLineEdit()
        self.valueEdit.setValidator(QRegularExpressionValidator(regexvalue,self))
        self.valueEdit.setToolTip(QApplication.translate('Tooltip', 'Value of event'))
        self.valueEdit.setMaximumWidth(50)

        regextime = QRegularExpression(r'^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$')
        self.etimeline = QLineEdit()
        self.etimeline.setValidator(QRegularExpressionValidator(regextime,self))
        self.etimeline.setMaximumWidth(50)

        #create EVENT mini button
        self.buttonminiEvent = QPushButton(QApplication.translate('Button', 'Update'))
        self.buttonminiEvent.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.buttonminiEvent.clicked.connect(self.miniEventRecord)
        self.buttonminiEvent.setToolTip(QApplication.translate('Tooltip', 'Updates the event'))

        #### CUSTOM events buttons
        self.buttonlist = []
        self.buttonStates = []
        self.lastbuttonpressed = -1
        self.buttonlistmaxlen = 11
        self.buttonpalette_default_label = ''
        self.buttonpalette_label = self.buttonpalette_default_label
        #10 palettes of buttons
        self.buttonpalette = []
        for i in range(10):
            self.buttonpalette.append([
                self.extraeventstypes[:],
                self.extraeventsvalues[:],
                self.extraeventsactions[:],
                self.extraeventsvisibility[:],
                self.extraeventsactionstrings[:],
                self.extraeventslabels[:],
                self.extraeventsdescriptions[:],
                self.extraeventbuttoncolor[:],
                self.extraeventbuttontextcolor[:],

                self.eventslidervisibilities[:],
                self.eventslideractions[:],
                self.eventslidercommands[:],
                self.eventslideroffsets[:],
                self.eventsliderfactors[:],
                self.eventquantifieractive[:],
                self.eventquantifiersource[:],
                self.eventquantifiermin[:],
                self.eventquantifiermax[:],
                self.eventquantifiercoarse[:],
                self.eventslidermin[:],
                self.eventslidermax[:],
                self.eventslidercoarse[:],
                self.eventslidertemp[:],
                self.eventsliderunits[:],
                self.eventsliderBernoulli[:],
                self.buttonpalette_label,
                self.eventquantifieraction[:],
                self.eventquantifierSV[:]
                ])
        self.buttonpalettemaxlen = [14]*10  #keeps max number of buttons per row per palette
        self.buttonpalette_shortcuts = True # if True palettes can be changed via the number keys
        self.buttonsize = 1 # 0: tiny, 1: small (default), 2: large

        self.eventbuttontablecolumnwidths = [] # custom event button table column widths

        #Create LOWER BUTTONS Widget layout QDialogButtonBox to stack all lower buttons
        self.lowerbuttondialogLayout = QHBoxLayout()
        self.lowerbuttondialogLayout.setSpacing(5)
        self.lowerbuttondialogLayout.setContentsMargins(0, 0, 0, 10)

        self.lowerbuttondialog = QFrame()
        self.lowerbuttondialog.setLayout(self.lowerbuttondialogLayout)
        self.lowerbuttondialog.setVisible(False)
        # We set the styles of event buttons assigned to self.lowerbuttondialog here
        # All stylesheet of its children (the actual event buttons) needs to be non-conflicting.
        # Any conflict will turn off merging of parent styles and just rely on the child stylesheet.
        self.lowerbuttondialog.setStyleSheet(
            artisan_event_button_style.format(
                min_width=self.standard_button_min_width_px - 6,
                min_height=self.standard_button_height - 7,
                padding=3,
                default_font_size=button_font_size_small_pt,
                selected_font_size=button_font_size_small_selected_pt))

        #initiate configuration
        self.lowerbuttondialogLayout.addStretch()
        self.lowerbuttondialogLayout.addWidget(self.buttonCHARGE)
        self.lowerbuttondialogLayout.addWidget(self.buttonDRY)
        self.lowerbuttondialogLayout.addWidget(self.buttonFCs)
        self.lowerbuttondialogLayout.addWidget(self.buttonFCe)
        self.lowerbuttondialogLayout.addWidget(self.buttonSCs)
        self.lowerbuttondialogLayout.addWidget(self.buttonSCe)
        self.lowerbuttondialogLayout.addWidget(self.buttonDROP)
        self.lowerbuttondialogLayout.addWidget(self.buttonCOOL)
        self.lowerbuttondialogLayout.addWidget(self.buttonEVENT)
        self.lowerbuttondialogLayout.addStretch()

        self.e1buttonbarLayout = QHBoxLayout()
        self.e1buttonbarLayout.setSpacing(1)
        self.e1buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog = QFrame()
        self.e1buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog.setLayout(self.e1buttonbarLayout)

        self.e2buttonbarLayout = QHBoxLayout()
        self.e2buttonbarLayout.setSpacing(1)
        self.e2buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog = QFrame()
        self.e2buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog.setLayout(self.e2buttonbarLayout)

        self.e3buttonbarLayout = QHBoxLayout()
        self.e3buttonbarLayout.setSpacing(1)
        self.e3buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog = QFrame()
        self.e3buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog.setLayout(self.e3buttonbarLayout)

        self.e4buttonbarLayout = QHBoxLayout()
        self.e4buttonbarLayout.setSpacing(1)
        self.e4buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog = QFrame()
        self.e4buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog.setLayout(self.e4buttonbarLayout)

        # set the focus on the main widget
        self.main_widget.setFocus()

        # set the central widget of MainWindow to main_widget
        self.setCentralWidget(self.main_widget)

        #list of functions to choose from (using left-right keyboard arrow)
        #   sidecond: len(self.keyboardmove) = len(self.keyboardButtonList) # for each self.keyboardmoveindex we have a keyboardmove function
        self.keyboardmove = [self.qmc.markCharge,self.qmc.markDryEnd,self.qmc.mark1Cstart,self.qmc.mark1Cend,
                             self.qmc.mark2Cstart,self.qmc.mark2Cend,self.qmc.markDrop,self.qmc.markCoolEnd,self.qmc.EventRecord]
        # list of buttons that can be controlled via the keyboard
        # RESET -> ON/OFF -> .. -> EVENT (RESET at index 0 is never used)
        self.keyboardButtonList = [ # this list corresponds to the self.qmc.buttonvisibility, but has additionally the entry for the EVENT button
            self.buttonCHARGE,  # 0 CHARGE
            self.buttonDRY, # 1 DRY END
            self.buttonFCs,  # 2 FC START
            self.buttonFCe,  # 3 FC END
            self.buttonSCs,  # 4 SC START
            self.buttonSCe,  # 5 SC END
            self.buttonDROP,  # 6 DROP
            self.buttonCOOL, # 7 COOL END
            self.buttonEVENT  # 8 EVENT
        ]
        # 0:CHARGE,1:DRY,2:FCs,3:FCe,4:SCs,5:SCe,6:DROP,7:COOL,8:EVENT
        self.keyboardButtonStyles = [
            'CHARGE',
            'DRY END',
            'FC START',
            'FC END',
            'SC START',
            'SC END',
            'DROP',
            'COOL END',
            'EVENT']

        #current function above
        self.keyboardmoveindex = 0  # points to the last activated button; we start with the CHARGE button (see keyboardButtonList)
        #state flag for above. It is initialized by pressing SPACE or left-right arrows
        self.keyboardmoveflag = 0
        #time stamp of last keyboard event SPACE to prevent multiple recognitions
        self.lastkeyboardcmd = 0

        self.error_dlg = None # bound to the error message window instance if open, update by updategraphics
        self.serial_dlg = None # bound to the serial message window if open, update by updategraphics
        self.message_dlg = None # bound to the serial message window if open, update by updategraphics

        self.ETname = QApplication.translate('Label', 'ET')
        self.BTname = QApplication.translate('Label', 'BT')

        ####################   APPLICATION WINDOW (AW) LAYOUT  ##############################################

        self.level1frame = QFrame()
        self.level1layout = QHBoxLayout()   # matplotlib toolbox + RESET button + LCD Timer
        self.level1frame.setLayout(self.level1layout)

        level3layout = QHBoxLayout()   # PID buttons, graph, temperature LCDs

        pidbuttonLayout = QVBoxLayout()

        EventsLayout = QHBoxLayout()
        EventsLayout.setContentsMargins(1,1,1,1)
        EventsLayout.setSpacing(0)

        #EVENT MINIEDITOR layout
        EventsLayout.addWidget(self.eventlabel)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etimeline)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.lineEvent)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etypeComboBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.valueEdit)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.eNumberSpinBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.minieventleft)
        EventsLayout.addWidget(self.minieventright)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.buttonminiEvent)
        self.EventsGroupLayout = QGroupBox()
        self.EventsGroupLayout.setLayout(EventsLayout)
        self.EventsGroupLayout.setVisible(False)

        LCDlayout = QVBoxLayout()
        LCDlayout.setSpacing(0)
        LCDlayout.setContentsMargins(0,0,5,0)
        LCDlayout.setSizeConstraint(QLayout.SizeConstraint.SetMinimumSize)

        #place control buttons + LCDs inside vertical button layout manager
        self.LCD2frame = ClickableLCDFrame()
        self.LCD2frame.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.LCD2frame.customContextMenuRequested.connect(self.setTareET)
        self.LCD2frame.left_clicked.connect(self.toggleETCurve)
        w = self.makeLCDbox(self.label2,self.lcd2,self.LCD2frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)

        self.LCD3frame = ClickableLCDFrame()
        self.LCD3frame.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.LCD3frame.customContextMenuRequested.connect(self.setTareBT)
        self.LCD3frame.left_clicked.connect(self.toggleBTCurve)
        w = self.makeLCDbox(self.label3,self.lcd3,self.LCD3frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)

        self.LCD4frame = ClickableLCDFrame()
        self.LCD4frame.left_clicked.connect(self.toggleDeltaETCurve)
        w = self.makeLCDbox(self.label4,self.lcd4,self.LCD4frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)
        self.LCD4frame.setVisible(False) # by default this one is not visible

        self.LCD5frame = ClickableLCDFrame()
        self.LCD5frame.left_clicked.connect(self.toggleDeltaBTCurve)
        w = self.makeLCDbox(self.label5,self.lcd5,self.LCD5frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)

        self.LCD6frame = QFrame()
        w = self.makeLCDbox(self.label6,self.lcd6,self.LCD6frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)
        self.LCD6frame.setVisible(False)

        self.LCD7frame = QFrame()
        w = self.makeLCDbox(self.label7,self.lcd7,self.LCD7frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)
        self.LCD7frame.setVisible(False)

        #add extra LCDs
        for i in range(self.nLCDS):
            w = self.makeLCDbox(self.extraLCDlabel1[i],self.extraLCD1[i],self.extraLCDframe1[i])
            LCDlayout.addWidget(w)
            LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)
            w = self.makeLCDbox(self.extraLCDlabel2[i],self.extraLCD2[i],self.extraLCDframe2[i])
            LCDlayout.addWidget(w)
            LCDlayout.setAlignment(w,Qt.AlignmentFlag.AlignRight)
        LCDlayout.addStretch()
        del w

        #PID Buttons
        pidbuttonLayout.addWidget(self.buttonSVp20)
        pidbuttonLayout.addWidget(self.buttonSVp10)
        pidbuttonLayout.addWidget(self.buttonSVp5)
        pidbuttonLayout.addWidget(self.buttonSVm5)
        pidbuttonLayout.addWidget(self.buttonSVm10)
        pidbuttonLayout.addWidget(self.buttonSVm20)

        # phases LCDs

        # TP
        self.TPlabel = QLabel()
        self.TPlabel.setText('<small><b>' + QApplication.translate('Label', 'TP') + '&raquo;</b></small>')
        self.TPlcd = QLCDNumber()
        self.TPlcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.TPlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.TPlcd.display('--:--')
        self.TPlcdFrame = self.makePhasesLCDbox(self.TPlabel,self.TPlcd)

        # TP2DRY
        self.TP2DRYlabel = QLabel('')
        self.TP2DRYlabel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
        TP2DRYlayout = QHBoxLayout()
        TP2DRYlayout.addWidget(self.TP2DRYlabel)
        TP2DRYlayout.setContentsMargins(3,0,3,0)
        self.TP2DRYframe = QFrame()
        self.TP2DRYframe.setLayout(TP2DRYlayout)

        # DRY
        self.DRYlabel = QLabel()
        self.DRYlabel.setText('<small><b>&raquo;' + QApplication.translate('Label', 'DRY') + '</b></small>')
        self.DRYlcd = QLCDNumber()
        self.DRYlcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.DRYlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.DRYlcd.display('--:--')
        self.DRYlcdFrame = self.makePhasesLCDbox(self.DRYlabel,self.DRYlcd)

        # DRY2FCs
        self.DRY2FCslabel = QLabel('')
        self.DRY2FCslabel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
        DRY2FCslayout = QHBoxLayout()
        DRY2FCslayout.addWidget(self.DRY2FCslabel)
        DRY2FCslayout.setContentsMargins(3,0,3,0)
        self.DRY2FCsframe = QFrame()
        self.DRY2FCsframe.setLayout(DRY2FCslayout)

        # FCs
        self.FCslabel = QLabel()
        self.FCslabel.setText('<small><b>&raquo;' + QApplication.translate('Label', 'FCs') + '</b></small>')
        self.FCslcd = QLCDNumber()
        self.FCslcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.FCslcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.FCslcd.display('--:--')
        self.FCslcdFrame = self.makePhasesLCDbox(self.FCslabel,self.FCslcd)

        # AUC LCD
        self.AUClabel = QLabel()
        self.AUClabel.setText('<small><b>' + QApplication.translate('Label', 'AUC') + '</b></small>')
        self.AUClcd = QLCDNumber()
        self.AUClcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.AUClcd.customContextMenuRequested.connect(self.AUClcdClicked)
        self.AUClcd.display('--')
        self.AUClcdFrame = self.makePhasesLCDbox(self.AUClabel,self.AUClcd)
#        self.AUClcdFrame.setFrameStyle(QFrame.Shadow.Plain)
        self.AUClcd.setNumDigits(3)
        self.AUClcd.setMinimumWidth(65)
        self.AUClcdFrame.setStyleSheet('QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}')

        AUCLayout = QHBoxLayout()
        AUCLayout.addSpacing(20)
        AUCLayout.addWidget(self.AUClcdFrame)
        AUCLayout.setContentsMargins(0, 0, 0, 0)
        AUCLayout.setSpacing(0)

        self.AUCLCD = QFrame()
        self.AUCLCD.setContentsMargins(0, 0, 0, 0)
        self.AUCLCD.setLayout(AUCLayout)
        self.AUCLCD.hide()


        self.phasesLCDs = QFrame()
        self.phasesLCDs.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout = QHBoxLayout()
        phasesLCDlayout.addWidget(self.TPlcdFrame)
        phasesLCDlayout.addWidget(self.TP2DRYframe)
        phasesLCDlayout.addWidget(self.DRYlcdFrame)
        phasesLCDlayout.addWidget(self.DRY2FCsframe)
        phasesLCDlayout.addWidget(self.FCslcdFrame)
        phasesLCDlayout.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout.setSpacing(0)
        self.phasesLCDs.setLayout(phasesLCDlayout)
        self.phasesLCDs.hide()
        self.phasesLCDs.setToolTip(QApplication.translate('Tooltip','Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE'))

        #level 1
        self.level1layout.addStretch()
        self.level1layout.addWidget(self.phasesLCDs)
        self.level1layout.addWidget(self.AUCLCD)
        self.level1layout.addSpacing(20)
        self.level1layout.addWidget(self.buttonRESET)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.buttonONOFF)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.buttonSTARTSTOP)
        self.level1layout.addSpacing(15)
        self.level1layout.addWidget(self.buttonCONTROL)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.lcd1)
        self.level1layout.setSpacing(0)
        self.level1layout.setContentsMargins(0,7,7,12) # left, top, right, bottom

        #level 3
        level3layout.addLayout(pidbuttonLayout,0)

        self.qpc = tphasescanvas(self.dpi)
        self.qpc.mpl_connect('scroll_event', self.scrollingPhases)

        self.scroll = QScrollArea()
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scroll.setWidget(self.qpc)
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.Shape.NoFrame)
        self.scroll.setVisible(False)

        self.splitter = QSplitter(Qt.Orientation.Vertical)
        self.splitter.addWidget(self.qmc)
        self.splitter.addWidget(self.scroll)
        self.splitter.setSizes([100,0])
        self.splitter.setFrameShape(QFrame.Shape.NoFrame)
        #self.splitter.handle(0).setVisible(False)
        settings = QSettings()
        if settings.contains('MainSplitter'):
            self.splitter.restoreState(settings.value('MainSplitter'))

        self.splitter.setHandleWidth(7)
        #self.splitter.setStyleSheet("QSplitter::handle:vertical {background: lightGray; border-bottom: 1px solid grey; border-top: 1px solid grey;}")
        #self.splitter.setStyleSheet("QSplitter::handle:vertical {background: lightGray; border-bottom: 1px solid lightGray; border-top: 1px solid lightGray;}")
        #self.splitter.setStyleSheet("QSplitter::handle:vertical {background: lightGray; border-bottom: 0px; border-top: 0px;}")
        #self.splitter.setStyleSheet("QSplitter::handle:vertical {background: lightGray;}")

        self.splitter.setSizePolicy(QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)
        self.qpc.setSizePolicy(QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Fixed)
        level3layout.addWidget(self.splitter)

        level3layout.setSpacing(0)
        level3layout.setContentsMargins(0,0,0,0)

        self.extrabuttonsLayout = QVBoxLayout()
        self.extrabuttonsLayout.setContentsMargins(0,0,0,10)
        self.extrabuttonsLayout.setSpacing(5)
        self.extrabuttonsLayout.addWidget(self.e1buttondialog)
        self.extrabuttonsLayout.addWidget(self.e2buttondialog)
        self.extrabuttonsLayout.addWidget(self.e3buttondialog)
        self.extrabuttonsLayout.addWidget(self.e4buttondialog)

        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)

        self.extrabuttondialogs = QFrame()
        self.extrabuttondialogs.setLayout(self.extrabuttonsLayout)
        self.extrabuttondialogs.setVisible(False)

        midleftlayout = QVBoxLayout()
        midleftlayout.setSpacing(0)
        midleftlayout.setContentsMargins(0,0,0,0)
        midleftlayout.addWidget(self.messagelabel)
        midleftlayout.addLayout(level3layout)
        midleftlayout.addWidget(self.lowerbuttondialog)
        midleftlayout.addWidget(self.extrabuttondialogs)

        midleftlayout.addWidget(self.EventsGroupLayout)

        self.slider1 = self.slider()
        self.sliderLCD1 = self.sliderLCD()
        self.sliderLCD1.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[0])
        self.sliderLCD1.display(self.slider1.value())
        sliderGrp1 = QVBoxLayout()
        sliderGrp1.addWidget(self.sliderLCD1)
        sliderGrp1.addWidget(self.slider1)
        sliderGrp1.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp1.setContentsMargins(0,7,0,0)
        sliderGrp1.setSpacing(0)
        self.sliderGrpBox1 = QGroupBox()
        self.sliderGrpBox1.setLayout(sliderGrp1)
        self.sliderGrpBox1.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox1.setMinimumWidth(55)
        self.sliderGrpBox1.setMaximumWidth(55)
        self.sliderGrpBox1.setVisible(False)
        self.sliderGrpBox1.setFlat(True)
        self.sliderGrpBox1x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox1x.addWidget(self.sliderGrpBox1)
# simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
#        self.slider1.setTracking(False)
#        self.slider1.sliderMoved.connect(self.slider1Moved)
#        self.slider1.valueChanged.connect(self.slider1valueChanged)
# tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider1.valueChanged.connect(self.updateSlider1LCD)
        self.slider1.sliderReleased.connect(self.slider1released)
        # needed for both tracking variants:
        self.slider1.actionTriggered.connect(self.slider1actionTriggered)
        self.slider1.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider2 = self.slider()
        self.sliderLCD2 = self.sliderLCD()
        self.sliderLCD2.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[1])
        self.sliderLCD2.display(self.slider2.value())
        sliderGrp2 = QVBoxLayout()
        sliderGrp2.addWidget(self.sliderLCD2)
        sliderGrp2.addWidget(self.slider2)
        sliderGrp2.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp2.setContentsMargins(0,7,0,0)
        sliderGrp2.setSpacing(0)
        self.sliderGrpBox2 = QGroupBox()
        self.sliderGrpBox2.setLayout(sliderGrp2)
        self.sliderGrpBox2.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox2.setMinimumWidth(55)
        self.sliderGrpBox2.setMaximumWidth(55)
        self.sliderGrpBox2.setVisible(False)
        self.sliderGrpBox2.setFlat(True)
        self.sliderGrpBox2x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox2x.addWidget(self.sliderGrpBox2)
# simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
#        self.slider2.setTracking(False)
#        self.slider2.sliderMoved.connect(self.slider2Moved)
#        self.slider2.valueChanged.connect(self.slider2valueChanged)
# tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider2.valueChanged.connect(self.updateSlider2LCD)
        self.slider2.sliderReleased.connect(self.slider2released)
        # needed for both tracking variants:
        self.slider2.actionTriggered.connect(self.slider2actionTriggered)
        self.slider2.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider3 = self.slider()
        self.sliderLCD3 = self.sliderLCD()
        self.sliderLCD3.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[2])
        self.sliderLCD3.display(self.slider3.value())
        sliderGrp3 = QVBoxLayout()
        sliderGrp3.addWidget(self.sliderLCD3)
        sliderGrp3.addWidget(self.slider3)
        sliderGrp3.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp3.setContentsMargins(0,7,0,0)
        sliderGrp3.setSpacing(0)
        self.sliderGrpBox3 = QGroupBox()
        self.sliderGrpBox3.setLayout(sliderGrp3)
        self.sliderGrpBox3.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox3.setMinimumWidth(55)
        self.sliderGrpBox3.setMaximumWidth(55)
        self.sliderGrpBox3.setVisible(False)
        self.sliderGrpBox3.setFlat(True)
        self.sliderGrpBox3x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox3x.addWidget(self.sliderGrpBox3)
# simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
#        self.slider3.setTracking(False)
#        self.slider3.sliderMoved.connect(self.slider3Moved)
#        self.slider3.valueChanged.connect(self.slider3valueChanged)
# tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider3.valueChanged.connect(self.updateSlider3LCD)
        self.slider3.sliderReleased.connect(self.slider3released)
        # needed for both tracking variants:
        self.slider3.actionTriggered.connect(self.slider3actionTriggered)
        self.slider3.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider4 = self.slider()
        self.sliderLCD4 = self.sliderLCD()
        self.sliderLCD4.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[3])
        self.sliderLCD4.display(self.slider4.value())
        sliderGrp4 = QVBoxLayout()
        sliderGrp4.addWidget(self.sliderLCD4)
        sliderGrp4.addWidget(self.slider4)
        sliderGrp4.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp4.setContentsMargins(0,7,0,0)
        sliderGrp4.setSpacing(0)
        self.sliderGrpBox4 = QGroupBox()
        self.sliderGrpBox4.setLayout(sliderGrp4)
        self.sliderGrpBox4.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox4.setMinimumWidth(55)
        self.sliderGrpBox4.setMaximumWidth(55)
        self.sliderGrpBox4.setVisible(False)
        self.sliderGrpBox4.setFlat(True)
        self.sliderGrpBox4x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox4x.addWidget(self.sliderGrpBox4)
# simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
#        self.slider4.setTracking(False)
#        self.slider4.sliderMoved.connect(self.slider4Moved)
#        self.slider4.valueChanged.connect(self.slider4valueChanged)
# tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider4.valueChanged.connect(self.updateSlider4LCD)
        self.slider4.sliderReleased.connect(self.slider4released)
        # needed for both tracking variants:
        self.slider4.actionTriggered.connect(self.slider4actionTriggered)
        self.slider4.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.sliderSV = self.slider()
        self.sliderLCDSV = self.sliderLCD()
#        self.sliderLCDSV.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.palette["text"])
        self.sliderLCDSV.setNumDigits(3)
        self.sliderLCDSV.setStyleSheet('font-weight: bold;')
        self.sliderLCDSV.display(self.pidcontrol.svValue)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.addWidget(self.sliderLCDSV)
        sliderGrpSV.addWidget(self.sliderSV)
        sliderGrpSV.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrpSV.setContentsMargins(0,7,0,0)
        sliderGrpSV.setSpacing(0)
        self.sliderGrpBoxSV = QGroupBox()
        self.sliderGrpBoxSV.setLayout(sliderGrpSV)
        self.sliderGrpBoxSV.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBoxSV.setMinimumWidth(55)
        self.sliderGrpBoxSV.setMaximumWidth(55)
        self.sliderGrpBoxSV.setVisible(False)
        self.sliderGrpBoxSV.setTitle('SV')
        self.sliderGrpBoxSV.setFlat(True)
        self.sliderSV.valueChanged.connect(self.updateSVSliderLCD)
        self.sliderSV.sliderReleased.connect(self.sliderSVreleased)
        self.sliderSV.actionTriggered.connect(self.sliderSVactionTriggered)
        self.sliderSV.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ClickFocus TabFocus StrongFocus

        sliderGrp12 = QVBoxLayout()
        sliderGrp12.setSpacing(0)
        sliderGrp12.setContentsMargins(0,0,0,0)
        sliderGrp12.addLayout(self.sliderGrpBox1x)
        sliderGrp12.addLayout(self.sliderGrpBox2x)
        sliderGrp34 = QVBoxLayout()
        sliderGrp34.setSpacing(0)
        sliderGrp34.setContentsMargins(0,0,0,0)
        sliderGrp34.addLayout(self.sliderGrpBox3x)
        sliderGrp34.addLayout(self.sliderGrpBox4x)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.setSpacing(0)
        sliderGrpSV.setContentsMargins(0,0,0,0)
        sliderGrpSV.addWidget(self.sliderGrpBoxSV)

        self.leftlayout = QHBoxLayout()
        self.leftlayout.setSpacing(0)
        self.leftlayout.setContentsMargins(0,0,0,0)
        self.leftlayout.addLayout(sliderGrp12)
        self.leftlayout.addLayout(sliderGrp34)
        self.leftlayout.addLayout(sliderGrpSV)

        self.sliderFrame = QFrame()
        self.sliderFrame.setLayout(self.leftlayout)
        self.sliderFrame.setVisible(False)
        self.sliderFrame.setContentsMargins(0,0,0,0)

        self.lcdFrame = QFrame()
        self.lcdFrame.setLayout(LCDlayout)
        self.lcdFrame.setVisible(False)
        self.lcdFrame.setContentsMargins(0,0,0,0)
        self.lcdFrame.setSizePolicy(QSizePolicy.Policy.Maximum,QSizePolicy.Policy.Expanding) # prevent horizontal expansion (graph might not maximize otherwise)

        self.midlayout = QHBoxLayout()
        self.midlayout.addWidget(self.sliderFrame)
        self.midlayout.addLayout(midleftlayout)
        self.midlayout.addWidget(self.lcdFrame)
        self.midlayout.setSpacing(0)
        self.midlayout.setContentsMargins(0,0,0,0)

        mainlayout = QVBoxLayout(self.main_widget)
        mainlayout.addWidget(self.level1frame)
        mainlayout.addLayout(self.midlayout)
        mainlayout.setContentsMargins(0,0,0,0)
        mainlayout.setSpacing(0)

        self.qmc.toolbar.hide() # we need to hide the default navigation toolbar that we don't use
        self.qmc.toolbar.destroy()

        # this variable is bound to the Roast Properties dialog if it is open, set to False to block opening the dialog or None otherwise
        self.editgraphdialog = None

#        # provide information message to user about sharing settings at start-up
        if settingsRelocated:
            string =  QApplication.translate('Message','Welcome to version {0} of Artisan!').format(__version__) + '\n\n'
            string += QApplication.translate('Message','This is a one time message to inform you about a change in Artisan.') + '\n\n'
            string += QApplication.translate('Message','If you never run older versions of Artisan you can skip this message, the change does not affect you.') + '  '
            string += QApplication.translate('Message','Artisan preserves all your configuration settings when you exit so they will automatically be available the next time you start Artisan.') + '  '
            string += QApplication.translate('Message','Beginning with release v2.0, settings will no longer be automatically shared at start-up with versions before v2.0.') + '\n\n'
            string += QApplication.translate('Message','Do not worry. Since this is the first time you opened this new version Artisan has already loaded your last used settings.') + '\n\n'
            string += QApplication.translate('Message',"To share settings between this version and Artisan versions before v2.0 use 'Help>Save Settings' and 'Help>Load Settings'.") + '\n\n'
            string += QApplication.translate('Message','Enjoy using Artisan, The Artisan Team')
            QMessageBox.information(aw,QApplication.translate('Message','One time message about loading settings at start-up'),string)

        # provide information message to user about ArtisanViewer the first time it is started
        if artisanviewerFirstStart:
            string =  QApplication.translate('Message','Welcome to the ArtisanViewer!').format(__version__) + '\n\n'
            string += QApplication.translate('Message','This is a one time message to introduce you to the ArtisanViewer.') + '\n\n'
            string += QApplication.translate('Message','The ArtisanViewer opens whenever a copy of Artisan is already running.') + '\n\n'
            string += QApplication.translate('Message','ArtisanViewer will preserve all your configuration settings when you exit so they will automatically be available the next time you start ArtisanViewer.') + '\n\n'
            string += QApplication.translate('Message',"Caution, the only way to share settings between Artisan and ArtisanViewer is to explicitly save and load them using 'Help>Save Settings' and 'Help>Load Settings'.") + '\n\n'
            string += QApplication.translate('Message','Enjoy using ArtisanViewer,') +'\n'
            string += QApplication.translate('Message','The Artisan Team')
            QMessageBox.information(aw,QApplication.translate('Message','One time message about ArtisanViewer'),string)
            settings.setValue('Mode',self.qmc.mode)  #prevent this popup in case a second instance is started before this first one is closed.


        # we connect the signals
        self.singleShotPhidgetsPulseOFF.connect(self.processSingleShotPhidgetsPulse)
        self.singleShotPhidgetsPulseOFFSerial.connect(self.processSingleShotPhidgetsPulse)
        self.setTitleSignal.connect(self.qmc.setProfileTitle)
        self.sendmessageSignal.connect(self.sendmessage)
        self.openPropertiesSignal.connect(self.editgraph)
        self.soundpopSignal.connect(self.soundpop)
        self.setCanvasColorSignal.connect(self.setCanvasColor)
        self.resetCanvasColorSignal.connect(self.resetCanvasColor)
        self.setbuttonsfromSignal.connect(self.setbuttonsfrom)
        self.loadBackgroundSignal.connect(self.loadbackgroundRedraw)
        self.clearBackgroundSignal.connect(self.clearbackgroundRedraw)
        self.adjustSVSignal.connect(self.adjustPIDsv)
        self.updateSerialLogSignal.connect(self.updateSerialLog)
        self.fireslideractionSignal.connect(self.fireslideraction)
        self.moveButtonSignal.connect(self.moveKbutton)
        self.sendnotificationMessageSignal.connect(self.sendNotificationMessage)
        self.updateSubscriptionSignal.connect(self.updateSubscription)
        self.updateLimitsSignal.connect(self.updateLimits)
        self.updatePlaybackIndicatorSignal.connect(self.updatePlaybackIndicator)
        self.pidOnSignal.connect(self.pidcontrol.pidOn)
        self.pidOffSignal.connect(self.pidcontrol.pidOff)

        self.notificationManager = None
        if not app.artisanviewerMode:
            self.notificationManager = NotificationManager()

        if sys.platform.startswith('darwin'):
            # only on macOS we install the eventFilter to catch the signal on switching between light and dark modes
            self.installEventFilter(self)

#PLUS
        self.updatePlusStatusSignal.connect(self.updatePlusStatusSlot)

        QTimer.singleShot(2000,self.donate)

        QTimer.singleShot(0,lambda : _log.info('startup time: %.2f', libtime.process_time() - startup_time))


    def scrollingPhases(self, event):
        val = self.scroll.verticalScrollBar().value()
        if event.button =='down':
            self.scroll.verticalScrollBar().setValue(val+10)
        else:
            self.scroll.verticalScrollBar().setValue(val-10)


    # timer_color one of "timer" (black), "slowcoolingtimer" (red), "rstimer" (blue)
    def setTimerColor(self, timer_color:str):
        self.lcd1.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF[timer_color],self.lcdpaletteB[timer_color]))
        self.qmc.setTimerLargeLCDcolorSignal.emit(self.lcdpaletteF[timer_color], self.lcdpaletteB[timer_color])
        # HACK: PID/CONTROL button changes shape/shadow on setTimerColor() as triggered by RESET
        # there reason remains unclear
        # the following prevents this
        try:
            self.buttonCONTROL.setStyleSheet(self.buttonCONTROL.styleSheet())
        except Exception:  # pylint: disable=broad-except
            pass

    def mousePressEvent(self, event):
        super().mousePressEvent(event)
        if event.button() == Qt.MouseButton.LeftButton:
            self.releaseminieditor()
            self.releaseSliderFocus()

    def updateSubscription(self, subscription: str):
        _log.debug('updateSubscription(%s)', subscription)
        if subscription:
            self.plus_subscription = subscription
        else:
            self.plus_subscription = None

    # if any of the parameters is <0 the corresponding variable is not updated
    def updatePlusLimits(self, rlimit: float, used: float):
        _log.debug('updatePlusLimits(%s, %s)', rlimit, used)
        if rlimit > -1:
            self.plus_rlimit = rlimit
        if used > -1:
            self.plus_used = used

    # if pu is "" the corresponding variable is not updated
    def updatePlusPaidUntil(self, pu: str):
        _log.debug('updatePlusPaidUntil(%s)', pu)
        try:
            if pu != '':
                self.plus_paidUntil = (
                    dateutil.parser.parse(pu)
                )
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # if rlimit = -1 or rused = -1 or pu = "", no update information is available and the state is not updated
    @pyqtSlot(float,float,str,int,list)
    def updateLimits(self, rlimit:float, rused:float, pu:str, notifications:int, machines: List[str]):  #for Python >= 3.9 can replace 'List' with the generic type hint 'list'
        _log.debug('updateLimits(%s,%s,%s,%s,%s)', rlimit, rused, pu, notifications, machines)
        self.updatePlusLimits(rlimit, rused)
        self.updatePlusPaidUntil(pu)
        plus.notifications.updateNotifications(notifications, machines)

    @pyqtSlot(str,str,NotificationType)
    def sendNotificationMessage(self, title, message, notification_type):
        if self.notificationManager:
            self.notificationManager.sendNotificationMessage(title.strip(), message.strip(), notification_type)

    # cache curve visibilities on recording start to be able to revert to users settings after recording
    def cacheCurveVisibilities(self):
        self.qmc.curveVisibilityCache = (
            self.qmc.BTcurve,
            self.qmc.ETcurve,
            self.qmc.DeltaBTflag,
            self.qmc.DeltaETflag,
            self.extraCurveVisibility1,
        	self.extraCurveVisibility2,
        )

    # revert curve visibilities to user settings after recording
    def resetCurveVisibilities(self):
        if self.qmc.curveVisibilityCache is not None:
            (self.qmc.BTcurve,
             self.qmc.ETcurve,
             self.qmc.DeltaBTflag,
             self.qmc.DeltaETflag,
             self.extraCurveVisibility1,
             self.extraCurveVisibility2) = self.qmc.curveVisibilityCache

    @pyqtSlot()
    def toggleETCurve(self):
        if self.qmc.swaplcds:
            self.qmc.BTcurve = not self.qmc.BTcurve
        else:
            self.qmc.ETcurve = not self.qmc.ETcurve
        self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleBTCurve(self):
        if self.qmc.swaplcds:
            self.qmc.ETcurve = not self.qmc.ETcurve
        else:
            self.qmc.BTcurve = not self.qmc.BTcurve
        self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleDeltaETCurve(self):
        if self.qmc.swapdeltalcds:
            self.qmc.DeltaBTflag = not self.qmc.DeltaBTflag
        else:
            self.qmc.DeltaETflag = not self.qmc.DeltaETflag
        self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleDeltaBTCurve(self):
        if self.qmc.swapdeltalcds:
            self.qmc.DeltaETflag = not self.qmc.DeltaETflag
        else:
            self.qmc.DeltaBTflag = not self.qmc.DeltaBTflag
        self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleExtraCurve1(self):
        try:
            sender = self.sender()
            i = self.extraLCDframe1.index(sender)
            self.extraCurveVisibility1[i] = not self.extraCurveVisibility1[i]
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleExtraCurve2(self):
        try:
            sender = self.sender()
            i = self.extraLCDframe2.index(sender)
            self.extraCurveVisibility2[i] = not self.extraCurveVisibility2[i]
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        self.qmc.redraw(recomputeAllDeltas=False)

    def addLanguage(self, locale, menu_entry):
        languageAction = QAction(menu_entry, self)
        if locale in ['ru']:
            languageAction.setEnabled(False)
        else:
            languageAction.setCheckable(True)
            languageAction.triggered.connect(self.change_local_action)
            self.language_menu_actions[locale] = languageAction
        self.languageMenu.addAction(languageAction)
        if self.locale_str == locale:
            languageAction.setChecked(True)

    def sendLog(self) -> None:
        _log.info('sendLog()')

        from email import encoders, generator
        from email.mime.base import MIMEBase
        from email.mime.multipart import MIMEMultipart
        from email.mime.text import MIMEText

        message = MIMEMultipart()
        if self.plus_email is not None:
            message['From'] = self.plus_email
        message['To'] = '{}@{}'.format(
            'logfile', 'artisan.plus'
        )
        message['Subject'] = 'artisan log'
        message['X-Unsent'] = '1'
        # message["X-Uniform-Type-Identifier"] = "com.apple.mail-draft"
        message.attach(
            MIMEText(
                (
                    'Please find attached the log files written by Artisan!'
                    '\nPlease forward this email to {}\n--\n'
                ).format(message['To']),
                'plain',
            )
        )
        try:
            for log_file_name in ['artisan.log', 'artisanViewer.log']:
                try:
                    with open(os.path.join(getDataDirectory(),log_file_name), 'rb') as attachment:
                        # Add file as application/octet-stream
                        # Email client can usually download this automatically
                        # as attachment
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(attachment.read())
                    # Encode file in ASCII characters to send by email
                    encoders.encode_base64(part)
                    # Add header as key/value pair to attachment part
                    part.add_header(
                        'Content-Disposition',
                        f'attachment; filename= {log_file_name}',
                    )
                    # Add attachment to message and convert message to string
                    message.attach(part)
                except FileNotFoundError:
                    _log.debug('log file %s not found', log_file_name)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        try:
            with open(self.qmc.device_log_file, 'rb') as attachment:
                # Add file as application/octet-stream
                # Email client can usually download this automatically
                # as attachment
                part2 = MIMEBase('application', 'octet-stream')
                part2.set_payload(attachment.read())
            # Encode file in ASCII characters to send by email
            encoders.encode_base64(part2)
            # Add header as key/value pair to attachment part
            part2.add_header(
                'Content-Disposition',
                'attachment; filename= {}{}'.format(
                    self.qmc.device_log_file_name, '.log'
                ),
            )
            # Add attachment to message and convert message to string
            message.attach(part2)
        except FileNotFoundError:
            _log.debug('log file %s not found', self.qmc.device_log_file)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        # Save message to file tmp file
        tmpfile = QDir(QDir.tempPath()).filePath('plus-log.eml')
        try:
            os.remove(tmpfile)
        except OSError:
            pass
        with open(tmpfile, 'w', encoding='utf-8') as outfile:
            gen = generator.Generator(outfile)
            gen.flatten(message)
        QDesktopServices.openUrl(QUrl.fromLocalFile(tmpfile))

    def updateWindowTitle(self):
        try:
            appTitle = '%s %s'%((application_viewer_name if app.artisanviewerMode else application_name), str(__version__))
            if self.qmc.safesaveflag:
                # file Dirty
                dirtySign = '* '
            else:
                # file Clean
                dirtySign = ''
            if bool(self.simulator) and self.simulatorpath:
                # simulator running
                speed = int(self.qmc.timeclock.getBase()/1000)
                self.setWindowTitle(f'@{speed}x {self.strippedName(self.simulatorpath)} ** {appTitle}')
            elif self.curFile:
                # profile loaded
                self.setWindowTitle(f'{dirtySign}{self.strippedName(self.curFile)}  {appTitle}')
            else:
                # no profile loaded
                if __release_sponsor_name__:
                    self.setWindowTitle('{}{}  {} ({})'.format(dirtySign,appTitle,__release_sponsor_name__,QApplication.translate('About','Release Sponsor')))
                else:
                    self.setWindowTitle(f'{dirtySign}{appTitle}')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @staticmethod
    def resetDonateCounter():
        settings = QSettings()
        settings.setValue('lastdonationpopup',int(libtime.time()))
        settings.setValue('starts',0)
        settings.sync()

    def donate(self):
        try:
            everytime = 4*30*24*60*60 # 4 month in seconds
            everystarts = 30 # number of recordings
            starts = None
            lastdonationpopup = None
            settings = QSettings()
            if settings.contains('starts'):
                starts = toInt(settings.value('starts'))
            if settings.contains('lastdonationpopup'):
                lastdonationpopup = toInt(settings.value('lastdonationpopup'))
            now = int(libtime.time())
            if not(settings.status() == QSettings.Status.NoError and
                    lastdonationpopup is not None and
                    starts is not None and
                    (now >= lastdonationpopup > now-everytime) and
                    0 <= starts < everystarts):
                message = QApplication.translate('Message', 'Artisan is free to use!<br><br>To keep it free and current please support us<br><br><a href="{0}">{0}</a><br><br>and book<br><br><a href="{1}">{1}</a><br><br>to suppress this dialog')
                message = message.format('https://artisan-scope.org/donate/', 'https://artisan.plus')
                donate_message_box = QMessageBox(self)
                donate_message_box.setText(message)
                donate_message_box.setIcon(QMessageBox.Icon.Information)
                donate_message_box.setModal(True)
                donate_message_box.setStandardButtons(QMessageBox.StandardButton.Ok)
                donate_message_box.setDefaultButton(QMessageBox.StandardButton.Ok)
                donate_message_box.exec()
                self.resetDonateCounter()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    def setCanvasColor(self, c): # pylint: disable=no-self-use # used as slot
        try:
            QColor(c) # test if color is valid
            aw.qmc.palette['canvas_alt'] = aw.qmc.palette['canvas']
            aw.qmc.palette['canvas'] = c
            aw.updateCanvasColors()
            aw.qmc.redraw()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    def resetCanvasColor(self): # pylint: disable=no-self-use # used as slot
        try:
            if 'canvas_alt' in aw.qmc.palette:
                aw.qmc.palette['canvas'] = aw.qmc.palette['canvas_alt']
                aw.qmc.palette.pop('canvas_alt')
                aw.updateCanvasColors()
                aw.qmc.redraw()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)


    # takes an "Arduino" float time in seconds and returns the corresponding QTime() object
    @staticmethod
    def time2QTime(t: float):
        return QTime(0,t//60,t%60)

    @staticmethod
    def QTime2time(t: QTime):
        return t.minute() * 60 + t.second()

    def dragEnterEvent(self, event): # pylint: disable=no-self-use # class method
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event): # pylint: disable=no-self-use # class method
        urls = event.mimeData().urls()
        if urls and len(urls)>0:
            app.open_url(urls[0])
            if bool(aw.comparator):
                for url in urls[0:]:
                    app.open_url(url)

    def showHelpDialog(self,parent,dialog,title,content):
        try: # sip not supported on older PyQt versions (RPi!)
            if sip.isdeleted(dialog):
                dialog = None
        except Exception: # pylint: disable=broad-except
            pass
        if dialog is None:
            dialog = HelpDlg(parent,self,title,content) # parent, application window, title, content
        dialog.show()
        dialog.activateWindow()
        dialog.raise_()
        return dialog

    @staticmethod
    def closeHelpDialog(dialog):
        if dialog is not None:
            try:
                if not sip.isdeleted(dialog):
                    dialog.close()
            except Exception: # pylint: disable=broad-except
                try:
                    dialog.close()
                except Exception: # pylint: disable=broad-except
                    pass

    # takes a fit from numpy.polyfit and renders it as string to be copied as symbolic formula
    @staticmethod
    def fit2str(fit):
        s = ''
        sign = '+'
        fit = fit[::-1]
        try:
            for i in range(len(fit)):
                v = abs(fit[i])
                if round(v,3) != 0.0:
                    if i == 0:
                        s = ('%.4f' % v)
                    elif i == 1:
                        if s != '':
                            s = ' ' + sign + ' ' + s
                        if v == 1:
                            s = ('x' + s)
                        else:
                            s = ('%.4f*x' % v + s)
                    else:
                        if s != '':
                            s = ' ' + sign + ' ' + s
                        if v == 1:
                            s = ('x^%i' % i + s)
                        else:
                            s = ('%.4f*x^%i' % (v,i) + s)
                    s = s.rstrip('0').rstrip('.')
                    if fit[i] < 0:
                        sign = '-'
                    else:
                        sign = '+'
            if sign == '-':
                s = sign + s
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        return s

    def eventFilter(self, obj, event):
        if event.type() == QEvent.Type.ApplicationPaletteChange:  # called if the palette changed (switch between dark and light mode on macOS)
            self.updateCanvasColors()
            return True
        return super().eventFilter(obj, event)

    # search the given QTable table for a row with the given widget as cellWidget or item in column col or as a sub-widget contained in the layout of a widget in place
    # returns the row number if the widget was found or None
    @staticmethod
    def findWidgetsRow(table,widget,col):
        for r in range(table.rowCount()):
            if table.cellWidget(r,col) == widget or table.item(r,col) == widget or \
                (table.cellWidget(r,col) is not None and table.cellWidget(r,col).layout() is not None and table.cellWidget(r,col).layout().indexOf(widget) > -1):
                return r
        return None

    # search the given QTable table for a column with the given widget in row
    # returns the column number if the widget was found or None
    @staticmethod
    def findWidgetsColumn(table,widget,row):
        for c in range(table.columnCount()):
            if table.cellWidget(row,c) == widget or table.item(row,c) == widget or \
                (table.cellWidget(row,c) is not None and table.cellWidget(row,c).layout() is not None and table.cellWidget(row,c).layout().indexOf(widget) > -1):
                return c
        return None

    @pyqtSlot()
    def redraw_action(self):
        try:
            self.qmc.redraw(False,False)
        except Exception: # pylint: disable=broad-except
            # self.qmc might not be defined yet
            pass

    # c a QColor instance, returns the standard W3C value for the perceived brightness of an RGB color in the range of 0-255, ignoring the alpha channel
    # see https://www.w3.org/TR/AERT/#color-contrast
    @staticmethod
    def QColorBrightness(c):
        r,g,b,_ = c.getRgb()
        return ((r*299) + (g*587) + (b*114)) / 1000

    # this is important to have . as decimal separator independent of the systems locale
    @staticmethod
    def createCLocaleDoubleValidator(bot,top,dec,w):
        validator = MyQDoubleValidator(bot,top,dec,w)
        validator.setLocale(QLocale.c())
        validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        return validator

#    @pyqtSlot()
#    def mainButtonPressed(self):
#        self.sender().setGraphicsEffect(self.makeShadow(strong=True))
#
#    @pyqtSlot()
#    def mainButtonReleased(self):
#        self.sender().setGraphicsEffect(self.makeShadow())

    # for use in widgets that expects a double via a aw.createCLocalDoubleValidator that accepts both,
    # one dot and several commas. If there is no dot, the last comma is interpreted as decimal separator and the others removed
    # if there is a dot, the last one is used as a decimal separator and all other comma and dots are removed
    @staticmethod
    def comma2dot(s):
        s = s.strip()
        last_dot = s.rfind('.')
        if last_dot > -1:
            if last_dot + 1 == len(s):
                # this is just a trailing dot, we remove this and all other dots and commas
                return s.replace(',','').replace('.','')
            # we just keep this one and remove all other comma and dots
            return s[:last_dot].replace(',','').replace('.','') + s[last_dot:].replace(',','')
        # there is no dot in the string
        last_pos = s.rfind(',')
        if last_pos > -1:
            if last_pos + 1 == len(s):
                # this is just a trailing comma, we remove this and all other dots and commas
                return s.replace(',','').replace('.','')
            # we turn the last comma into a dot and remove all others
            return s[:last_pos].replace(',','') + '.' + s[last_pos+1:]
        return s

    @pyqtSlot('QPoint')
    def setTareET(self,_):
        self.setTare(0)

    @pyqtSlot('QPoint')
    def setTareBT(self,_):
        self.setTare(1)

    @pyqtSlot('QPoint')
    def setTare_slot(self,_):
        sender = self.sender()
        try:
            idx = self.extraLCDframe1.index(sender)
            self.setTare(2+idx*2)
        except Exception: # pylint: disable=broad-except
            pass
        try:
            idx = self.extraLCDframe2.index(sender)
            self.setTare(2+idx*2 + 1)
        except Exception: # pylint: disable=broad-except
            pass

    # set the tare values per channel (0: ET, 1:BT, 2:E1c0, 3:E1c1, 4:E1c0, 5:E1c1,...)
    def setTare(self,n):
        if self.qmc.flagon: # we set the tare value
            if n == 0:
                temp = (self.qmc.temp1 if self.qmc.flagstart else self.qmc.on_temp1)
                symb_formula = self.qmc.ETfunction.strip()
            elif n == 1:
                temp = (self.qmc.temp2 if self.qmc.flagstart else self.qmc.on_temp2)
                symb_formula = self.qmc.BTfunction.strip()
            else:
                i = (n - 2) // 2
                if n % 2 == 0: # even
                    temp = (self.qmc.extratemp1[i] if self.qmc.flagstart else self.qmc.on_extratemp1[i])
                    symb_formula = self.qmc.extramathexpression1[i].strip()
                else:
                    temp = (self.qmc.extratemp2[i] if self.qmc.flagstart else self.qmc.on_extratemp2[i])
                    symb_formula = self.qmc.extramathexpression2[i].strip()
            postfix = temp[-3:]
            if len(postfix) > 0:
                stable_reading = numpy.median(postfix)
                if symb_formula == '':
                    self.channel_tare_values[n] = stable_reading
                else:
                    self.channel_tare_values[n] = self.channel_tare_values[n] + stable_reading
        else: # we reset the tare value
            self.channel_tare_values[n] = 0

#PLUS
    @pyqtSlot()
    def updatePlusStatusSlot(self):
        self.updatePlusStatus()

    def updatePlusStatus(self,ntb=None):
        if ntb is None:
            ntb = self.ntb
        try:
            subscription_icon = None
            if aw.plus_account is not None:
                if plus.controller.is_connected():
                    if aw.editgraphdialog == False:
                        # syncing from server in progress
                        plus_icon = 'plus-dirty'
                        tooltip = QApplication.translate('Tooltip', 'Syncing with artisan.plus')
                    else:
                        if plus.controller.is_synced():
                            plus_icon = 'plus-connected'
                            tooltip = QApplication.translate('Tooltip', 'Disconnect artisan.plus')
                        else:
                            plus_icon = 'plus-unsynced'
                            tooltip = QApplication.translate('Tooltip', 'Upload to artisan.plus')
                    if True: # pylint: disable=using-constant-test
                        #not aw.plus_readonly: # we want to show the status also if read-only due to extension of the subscription limit
                        if aw.plus_subscription == 'HOME':
                            subscription_icon = 'plus-home'
                            if aw.plus_paidUntil is not None:
                                remaining_days = (aw.plus_paidUntil.date() - datetime.datetime.now().date()).days
                                if remaining_days <= 0:
                                    subscription_icon = 'plus-home-off'
                                elif remaining_days < 31:
                                    subscription_icon = 'plus-home-low'
                                if aw.plus_rlimit > 0:
                                    percent_used = aw.plus_used/(aw.plus_rlimit/100)
                                    if percent_used >= 100:
                                        subscription_icon = 'plus-home-off'
                                    elif percent_used >= 90:
                                        subscription_icon = 'plus-home-low'
                        elif aw.plus_subscription == 'PRO':
                            subscription_icon = 'plus-pro'
                            if aw.plus_paidUntil is not None:
                                remaining_days = (aw.plus_paidUntil.date() - datetime.datetime.now().date()).days
                                if remaining_days <= 0:
                                    subscription_icon = 'plus-pro-off'
                                elif remaining_days < 31:
                                    subscription_icon = 'plus-pro-low'
                                if aw.plus_rlimit > 0:
                                    percent_used = aw.plus_used/(aw.plus_rlimit/100)
                                    if percent_used >= 100:
                                        subscription_icon = 'plus-pro-off'
                                    elif percent_used >= 90:
                                        subscription_icon = 'plus-pro-low'
                else:
                    plus_icon = 'plus-on'
                    tooltip = QApplication.translate('Tooltip', 'Disconnect artisan.plus')
            else:
                plus_icon = 'plus-off'
                tooltip = QApplication.translate('Tooltip', 'Connect artisan.plus')
            if svgsupport:
                plus_icon += '.svg'
            else:
                plus_icon += '.png'
            if subscription_icon is not None:
                if svgsupport:
                    subscription_icon += '.svg'
                else:
                    subscription_icon += '.png'
            if len(ntb.actions()) > 0:
                a = ntb.actions()[0] # the plus action is the first one
                a.setIcon(ntb._icon(plus_icon)) # pylint: disable=protected-access
                a.setToolTip(tooltip)
                if len(ntb.actions()) > 1:
                    a = ntb.actions()[1] # the plus subscription action is the second one
                    if subscription_icon is None:
                        a.setEnabled(False)
                        a.setIcon(QIcon())
                    else:
                        a.setEnabled(True)
                        a.setIcon(ntb._icon(subscription_icon)) # pylint: disable=protected-access
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' updatePlusStatus(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))



    # turns channel off after millis
    @pyqtSlot(int,int,str)
    @pyqtSlot(int,int,str,str)
    def processSingleShotPhidgetsPulse(self,channel,millis,fct,serial=None):
        if fct == 'OUTsetPWM':
            QTimer.singleShot(int(round(millis)),lambda : self.ser.phidgetOUTsetPWM(channel,0,serial))
        elif fct == 'OUTsetPWMhub':
            QTimer.singleShot(int(round(millis)),lambda : self.ser.phidgetOUTsetPWMhub(channel,0,serial))
        elif fct == 'BinaryOUTset':
            QTimer.singleShot(int(round(millis)),lambda : self.ser.phidgetBinaryOUTset(channel,0,serial))


###################################   APPLICATION WINDOW (AW) FUNCTIONS  #####################################

    # if recurse is True (default) and no selection exists, all is selected before calling the copy function again
    def copy_cells_to_clipboard(self,table_widget,adjustment=0,recurse=True):  # adjustment bitwise 0:None, 1: add leading tab to header, 2: add leading tab to first data row, 4: remove extra cell at the end of header
        if len(table_widget.selectionModel().selectedIndexes()) > 0:
            # sort select indexes into rows and columns
            previous = table_widget.selectionModel().selectedIndexes()[0]
            columns = []
            rows = []
            for index in table_widget.selectionModel().selectedIndexes():
                if previous.row() != index.row():
                    columns.append(rows)
                    rows = []
                rows.append(index.data())
                previous = index
            columns.append(rows)

            # add rows and columns to clipboard
            clipboard = ''
            nrows = len(columns)
            ncols = len(columns[0])
            if adjustment & 4:
                ncols = ncols - 1

            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.AltModifier:  #alt click
                import prettytable  # @UnresolvedImport
                tbl = prettytable.PrettyTable()
                re_strip = re.compile('[\u2009]')  #thin space is not read properly by prettytable
                fields = []
                if adjustment & 1:
                    fields.append(' ')
                for c in range(ncols):
                    hdr = re_strip.sub('',table_widget.horizontalHeaderItem(c).text())
                    #protect against duplicate header labels
                    while hdr in fields:
                        hdr = hdr + ' '
                    fields.append(hdr)
                tbl.field_names = fields
                for r in range(nrows):
                    tblrows = []
                    if adjustment & 2 and r == 0:
                        tblrows.append(' ')
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(' ')
                            if idx > -1 and c == 0:
                                tblrows.append(entry[:idx])
                                tblrows.append(entry[idx+1:])
                            else:
                                tblrows.append(entry)
                    tbl.add_row(tblrows)
                clipboard = tbl.get_string()
            else:
                if adjustment & 1:
                    clipboard += '' + '\t'
                for c in range(ncols):
                    clipboard += table_widget.horizontalHeaderItem(c).text()
                    if c != (ncols-1):
                        clipboard += '\t'
                clipboard += '\n'
                if adjustment & 2:
                    clipboard += '' + '\t'
                for r in range(nrows):
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(' ')
                            if idx > -1 and c == 0:
                                entry = entry[:idx] + '\t' + entry[idx+1:]
                            clipboard += entry
                            if c != (ncols-1):
                                clipboard += '\t'
                    clipboard = clipboard + '\n'
            # copy to the system clipboard
            sys_clip = QApplication.clipboard()
            sys_clip.setText(clipboard)
        # if nothing is selected, temporary select all and try to copy
        elif recurse:
            table_widget.selectAll()
            self.copy_cells_to_clipboard(table_widget, adjustment, False)
            table_widget.clearSelection()

    @staticmethod
    def createRecentRoast(title,beans,weightIn,
            weightUnit,volumeIn,volumeUnit,densityWeight,beanSize_min, beanSize_max,
            moistureGreen,colorSystem,file,roastUUID,
            batchnr,batchprefix,plus_account,plus_store,plus_store_label,plus_coffee,
            plus_coffee_label,plus_blend_label,plus_blend_spec,plus_blend_spec_labels,
            weightOut, volumeOut, densityRoasted, moistureRoasted, wholeColor, groundColor):
        d = {
            'title': title,
            'weightIn': weightIn,
            'weightUnit': weightUnit,
        }
        d['beans'] = beans
        if weightOut is not None:
            d['weightOut'] = weightOut
        d['volumeIn'] = volumeIn
        if volumeOut is not None:
            d['volumeOut'] = volumeOut
        d['volumeUnit'] = volumeUnit
        d['densityWeight'] = densityWeight
#        d["densityWeightUnit"] = densityWeightUnit
#        d["densityVolume"] = densityVolume
#        d["densityVolumeUnit"] = densityVolumeUnit
        if densityRoasted is not None:
            d['densityRoasted'] = densityRoasted
        d['beanSize_min'] = beanSize_min
        d['beanSize_max'] = beanSize_max
        d['moistureGreen'] = moistureGreen
        if moistureRoasted is not None:
            d['moistureRoasted'] = moistureRoasted
        if wholeColor is not None:
            d['wholeColor'] = wholeColor
        if groundColor is not None:
            d['groundColor'] = groundColor
        if colorSystem is not None:
            d['colorSystem'] = colorSystem
        d['background'] = file
        d['roastUUID'] = roastUUID
        d['batchnr'] = batchnr
        d['batchprefix'] = batchprefix
        d['plus_account'] = plus_account
        d['plus_store'] = plus_store
        d['plus_store_label'] = plus_store_label
        d['plus_coffee'] = plus_coffee
        d['plus_coffee_label'] = plus_coffee_label
        d['plus_blend_label'] = plus_blend_label
        d['plus_blend_spec'] = plus_blend_spec
        d['plus_blend_spec_labels'] = plus_blend_spec_labels
        return d

    # recentRoast activated via NEW
    def setRecentRoast(self,rr):
        if 'title' in rr and rr['title'] is not None:
            self.qmc.title = rr['title']
            if not aw.qmc.flagstart or aw.qmc.title_show_always:
                aw.qmc.setProfileTitle(self.qmc.title,updatebackground=True)
        if 'weightIn' in rr and 'weightUnit' in rr and rr['weightIn'] is not None and rr['weightUnit'] is not None:
            self.qmc.weight = [rr['weightIn'],self.qmc.weight[1],rr['weightUnit']]
        if 'weightOut' in rr and 'weightUnit' in rr and rr['weightOut'] is not None and rr['weightUnit'] is not None:
            self.qmc.weight = [self.qmc.weight[0],rr['weightOut'],rr['weightUnit']]
        else:
            self.qmc.weight[1] = 0
        if 'volumeIn' in rr and 'volumeUnit' in rr and rr['volumeIn'] is not None and rr['volumeUnit'] is not None:
            self.qmc.volume = [rr['volumeIn'],self.qmc.volume[1],rr['volumeUnit']]
        if 'volumeOut' in rr and 'volumeUnit' in rr and rr['volumeOut'] is not None and rr['volumeUnit'] is not None:
            self.qmc.volume = [self.qmc.volume[0],rr['volumeOut'],rr['volumeUnit']]
        else:
            self.qmc.volume[1] = 0
        if 'densityWeight' in rr and rr['densityWeight'] is not None:
            self.qmc.density[0] = rr['densityWeight']
        if 'densityRoasted' in rr and rr['densityRoasted'] is not None:
            self.qmc.density_roasted[0] = rr['densityRoasted']
        else:
            self.qmc.density_roasted[0] = 0
        if 'beans' in rr and rr['beans'] is not None:
            aw.qmc.beans = rr['beans']
        if 'beanSize_min' in rr and rr['beanSize_min'] is not None:
            self.qmc.beansize_min = rr['beanSize_min']
        if 'beanSize_max' in rr and rr['beanSize_max'] is not None:
            self.qmc.beansize_max = rr['beanSize_max']
        if 'moistureGreen' in rr and rr['moistureGreen'] is not None:
            self.qmc.moisture_greens = rr['moistureGreen']
        if 'moistureRoasted' in rr and rr['moistureRoasted'] is not None:
            self.qmc.moisture_roasted = rr['moistureRoasted']
        else:
            self.qmc.moisture_roasted = 0
        if 'wholeColor' in rr and rr['wholeColor'] is not None:
            self.qmc.whole_color = rr['wholeColor']
        else:
            self.qmc.whole_color = 0
        if 'groundColor' in rr and rr['groundColor'] is not None:
            self.qmc.ground_color = rr['groundColor']
        else:
            self.qmc.ground_color = 0
        if 'colorSystem' in rr and rr['colorSystem'] is not None:
            self.qmc.color_system_idx = rr['colorSystem']
        # Note: the background profile will not be changed if recent roast is activated from Roast Properties
#PLUS
        if self.plus_account is not None and 'plus_account' in rr and self.plus_account == rr['plus_account']:
            if 'plus_store' in rr:
                self.qmc.plus_store = rr['plus_store']
            if 'plus_store_label' in rr:
                self.qmc.plus_store_label = rr['plus_store_label']
            if 'plus_coffee' in rr:
                self.qmc.plus_coffee = rr['plus_coffee']
            if 'plus_coffee_label' in rr:
                self.qmc.plus_coffee_label = rr['plus_coffee_label']
            if 'plus_blend_label' in rr:
                self.qmc.plus_blend_label = rr['plus_blend_label']
            if 'plus_blend_spec' in rr:
                self.qmc.plus_blend_spec = rr['plus_blend_spec']
            if 'plus_blend_spec_labels' in rr:
                self.qmc.plus_blend_spec_labels = rr['plus_blend_spec_labels']
            if self.qmc.plus_default_store is not None and self.qmc.plus_default_store != self.qmc.plus_store:
                self.qmc.plus_default_store = None # we reset the defaultstore
            # update blend spec/label/spec_labels and other attributes from current stock
            if self.qmc.plus_blend_spec is not None and 'hr_id' in self.qmc.plus_blend_spec and self.qmc.plus_store is not None:
                try:
                    weight_unit_idx = self.qmc. weight_units.index(rr['weightUnit'])
                    blends = plus.stock.getBlends(weight_unit_idx,self.qmc.plus_store)
                    blend = next(b for b in blends if \
                        plus.stock.getBlendId(b) == self.qmc.plus_blend_spec['hr_id'] and
                        plus.stock.getBlendStockDict(b)['location_hr_id'] == self.qmc.plus_store)
                    w = self.convertWeight(self.qmc.weight[0],weight_unit_idx,self.qmc.weight_units.index('Kg')) # w is weightIn converted to kg
                    bd = plus.stock.getBlendBlendDict(blend,w)
                    self.qmc.plus_blend_label = bd['label']
                    self.qmc.plus_blend_spec = dict(bd) # make a copy of the blend dict
                    self.qmc.plus_blend_spec_labels = [i['label'] for i in self.qmc.plus_blend_spec['ingredients']]
                    self.qmc.beans = '\n'.join(plus.stock.blend2beans(blend,weight_unit_idx,self.qmc.weight[0]))
                    if 'moisture' in bd and bd['moisture'] is not None:
                        self.qmc.moisture_greens = bd['moisture']
                    else:
                        self.qmc.moisture_greens = 0
                    if 'density' in bd and bd['density'] is not None:
                        self.qmc.density[0] = bd['density']
                    else:
                        self.qmc.density[0] = 0
                    if 'screen_min' in bd and bd['screen_min'] is not None:
                        self.qmc.beansize_min = bd['screen_min']
                    else:
                        self.qmc.beansize_min = 0
                    if 'screen_max' in bd and bd['screen_max'] is not None:
                        self.qmc.beansize_max = bd['screen_max']
                    else:
                        self.qmc.beansize_max = 0
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        aw.sendmessage(QApplication.translate('Message',f"Recent roast properties '{aw.recentRoastLabel(rr)}' set"))

    # returns the list of recentRoasts with the first entry with the given title, weight and weightunit removed
    def delRecentRoast(self,title,weightIn,weightUnit):
        # check for duplications
        entry_with_same_title = None
        for i in range(len(self.recentRoasts)):
            if self.recentRoasts[i]['title'] == title and self.recentRoasts[i]['weightIn'] == weightIn and self.recentRoasts[i]['weightUnit'] == weightUnit:
                entry_with_same_title = i
                break
        if entry_with_same_title is not None:
            # we remove the duplicate entry first
            return self.recentRoasts[:entry_with_same_title] + self.recentRoasts[entry_with_same_title+1:]
        return self.recentRoasts

    # d is a recentRoast dict
    def addRecentRoast(self,d):
        try:
            # check for duplications
            rr = self.delRecentRoast(d['title'],d['weightIn'],d['weightUnit'])
            self.recentRoasts = [d] + rr[:self.maxRecentRoasts-1]
            self.updateNewMenuRecentRoasts()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' addRecentRoast(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def recentRoastLabel(rr):
        res = rr['title'] + ' (' + '%g' % rr['weightIn'] +rr['weightUnit']+')'
        return res

    @pyqtSlot(bool)
    def newRecentRoast(self, _checked:bool = False):
        action = self.sender()
        if action:
            modifiers = QApplication.keyboardModifiers()
            alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier
            rr = action.data()
            if 'background' in rr and rr['background'] is not None and rr['background'] != '':
                background_UUID = (rr['roastUUID'] if 'roastUUID' in rr else None)
                aw.qmc.resetlinecountcaches()
                if aw.loadbackgroundUUID(rr['background'],background_UUID):
                    try:
                        aw.qmc.background = not aw.qmc.hideBgafterprofileload
                        aw.qmc.timealign(redraw=False)
                        aw.qmc.redraw()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
            if alt_modifier:
                if self.qmc.flagon:
                    self.setRecentRoast(rr)
                # only in off mode we first do a reset
                elif self.qmc.reset():
                    # and if successful (not canceled) we set just the recent roast properties without starting a new roast
                    self.setRecentRoast(rr)
            else:
                # in "normal" mode, we do the NEW action
                if self.newRoast():
                    # and then set the recent roast properties selected
                    self.setRecentRoast(rr)


    def updateNewMenuRecentRoasts(self):
        self.newRoastMenu.clear()
        # add NEW menu item
        newRoastAction = QAction(QApplication.translate('Menu', 'New'), self)
        newRoastAction.setShortcut(QKeySequence.StandardKey.New)
        newRoastAction.triggered.connect(self.newRoast)
        self.newRoastMenu.addAction(newRoastAction)
        # add recent roasts items
        if len(self.recentRoasts) > 0:
            self.newRoastMenu.addSeparator()
            for rr in self.recentRoasts:
                act = QAction(self, visible=True,
                                triggered=self.newRecentRoast)
                act.setData(rr)
                act.setText(self.recentRoastLabel(rr))
                self.newRoastMenu.addAction(act)

    def recentRoastsMenuList(self):
        return [self.recentRoastLabel(rr) for rr in self.recentRoasts]

    @staticmethod
    def establish_etypes():
        # update extra LCD label substitutions
        for i in range(len(aw.qmc.extradevices)):
            if i < len(aw.qmc.extraname1):
                l1 = '<b>' + aw.qmc.extraname1[i] + '</b>'
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except Exception: # pylint: disable=broad-except
                    aw.extraLCDlabel1[i].setText(l1)
            if i < len(aw.qmc.extraname2):
                l2 = '<b>' + aw.qmc.extraname2[i] + '</b>'
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except Exception: # pylint: disable=broad-except
                    aw.extraLCDlabel2[i].setText(l2)
        aw.settooltip()

    def populateListMenu(self,resourceName,ext,triggered,menu,addMenu = True,forceSubmenu=False):

        one_added = False
        res = {}
        for root,dirs,files in os.walk(os.path.join(getResourcePath(),resourceName)):
            dirs.sort()
            files.sort()
            for fl in files:
                if fl.endswith(ext):
                    d = os.path.split(root)[-1]
                    p = os.path.join(root,fl)
                    f = fl.replace(ext,'').replace('_',' ')
                    if len(d) > 0:
                        if not d in res:
                            res[d] = []
                        res[d].append((f,p))
        keys = list(res.keys())
        keys.sort()
        for k in keys:
            if len(res[k]) > 1:
                if len(keys) == 1 and not forceSubmenu:
                    for e in res[k]:
                        a = QAction(self, visible=True, triggered=triggered)
                        a.setData((e[1],str(k)))
                        if k == resourceName:
                            menu_title = str(e[0]) # + "..."
                        else:
                            menu_title = str(k) + ' ' + str(e[0])  # + "..."
                        menu_title = menu_title.replace('&','&&') # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                        a.setText(menu_title)
                        menu.addAction(a)
                    one_added = True
                else:
                    submenu_title = k.replace('&','&&') # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                    submenu = menu.addMenu(submenu_title)

# avoid slow importing natsort
#                    import natsort
#                    sorted_subentries = natsort.natsorted(res[k],key=lambda x: x[0])
                    sorted_subentries = sorted(res[k],key=lambda x: natsort(x[0]))

                    for e in sorted_subentries: #res[k]:
                        a = QAction(self, visible=True, triggered=triggered)
                        a.setData((e[1],str(k)))
                        menu_title = str(e[0])
                        menu_title = menu_title.replace('&','&&') # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                        a.setText(menu_title)
                        submenu.addAction(a)
                        one_added = True
            else:
                entry = res[k][0]
                a = QAction(self, visible=True, triggered=triggered)
                a.setData((entry[1],''))
                if k == resourceName:
                    menu_title = str(entry[0])
                else:
                    menu_title = str(k) + ' ' + str(entry[0])
                menu_title = menu_title.replace('&','&&') # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                a.setText(menu_title)
                menu.addAction(a)
                one_added = True
        if one_added and addMenu:
            self.ConfMenu.addMenu(menu)

    def populateMachineMenu(self):
        self.populateListMenu('Machines','.aset',self.openMachineSettings,self.machineMenu)

    @pyqtSlot(bool)
    def openMachineSettings(self, _checked:bool = False):
        action = self.sender()
        if action:
            label = (action.text() if action.data()[1] == '' else f'{action.data()[1]} {action.text()}')
            label = label.replace('&&','&') # we reduce those && again to & that were introduced to have the & rendered in the menu entry
            string = QApplication.translate('Message', 'Configure for {0}?<br><br>Your current settings will be overwritten!<br><br>It is advisable to save your current settings beforehand via menu Help >> Save Settings.').format(label)
            reply = QMessageBox.question(aw,QApplication.translate('Message', 'Adjust Settings'),string,
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Cancel:
                return
            if reply == QMessageBox.StandardButton.Yes:
                self.qmc.etypes = self.qmc.etypesdefault
                # keep original information to Cancel
                org_etypes = self.qmc.etypes
                org_device = self.qmc.device
                org_machinesetup = self.qmc.machinesetup
                org_modbus_host = self.modbus.host
                org_s7_host = self.s7.host
                org_ws_host = self.ws.host
                org_comport = self.ser.comport
                org_roastersize_setup = self.qmc.roastersize_setup
                org_last_batchsize = self.qmc.last_batchsize
                org_roastersize = self.qmc.roastersize
                org_roasterheating_setup = self.qmc.roasterheating_setup
                org_roasterheating = self.qmc.roasterheating
                #
                self.loadSettings(fn=action.data()[0],remember=False,machine=True,reload=False)
                if action.data()[1] == 'Phidget':
                    if action.text() == 'VINT Ambient Modules':
                        elevation,res = QInputDialog.getInt(self,
                            QApplication.translate('Message', 'Ambient'),
                            QApplication.translate('Message', 'Elevation (MASL)'),value=self.qmc.elevation)
                        if res:
                            try:
                                self.qmc.elevation = int(elevation)
                            except Exception: # pylint: disable=broad-except
                                pass
                        else:
                            self.sendmessage(QApplication.translate('Message','Action canceled'))
                    else:
                        res = True
                        self.qmc.machinesetup = action.text()
                    if res:
                        QTimer.singleShot(700, self.qmc.startPhidgetManager)
                else:
                    self.qmc.machinesetup = action.text()
                    res = True
                if self.qmc.device == 29 and self.modbus.type in [3,4]: # MODBUS TCP or UDP
                    host,res = QInputDialog.getText(self,
                        QApplication.translate('Message', 'Machine'),
                        QApplication.translate('Message', 'Network name or IP address'),text=self.modbus.host) #"127.0.0.1"
                    if res:
                        self.modbus.host = host
                elif self.qmc.device == 79: # S7
                    host,res = QInputDialog.getText(self,
                        QApplication.translate('Message', 'Machine'),
                        QApplication.translate('Message', 'Network name or IP address'),text=self.s7.host) #"127.0.0.1"
                    if res:
                        self.s7.host = host
                elif self.qmc.device == 111: # WebSocket
                    host,res = QInputDialog.getText(self,
                        QApplication.translate('Message', 'Machine'),
                        QApplication.translate('Message', 'Network name or IP address'),text=self.ws.host) #"127.0.0.1"
                    if res:
                        self.ws.host = host
                elif self.qmc.device in [0,9,19,53,101,115,126] or (self.qmc.device == 29 and self.modbus.type in [0,1,2]): # Fuji, Center301, TC4, Hottop, Behmor or MODBUS serial, HB/ARC
                    import serial.tools.list_ports
                    comports = [(cp if isinstance(cp, (list, tuple)) else [cp.device, cp.product, None]) for cp in serial.tools.list_ports.comports()]
                    if platf == 'Darwin':
                        ports = [p for p in comports if not(p[0] in ['/dev/cu.Bluetooth-PDA-Sync',
                            '/dev/cu.Bluetooth-Modem','/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem','/dev/cu.Bluetooth-Incoming-Port','/dev/tty.Bluetooth-Incoming-Port'])]
                        ports = list(filter (lambda x: 'Bluetooth-Inc' not in x[0],ports))
                    else:
                        ports = list(comports)
                    if self.ser.comport not in [p[0] for p in ports]:
                        ports.append([self.ser.comport,'',''])
                    ports = sorted(ports,key=lambda p: p[0])
                    items = [(p[1] if (p[1] and p[1]!='n/a') else p[0]) for p in ports]
                    current = 0
                    try:
                        current = [p[0] for p in ports].index(self.ser.comport)
                    except Exception: # pylint: disable=broad-except
                        pass
                    if self.qmc.device == 53: # Hottop 2k+
                        try:
                            current = [p[0] for p in ports].index('FT230X Basic UART')
                        except Exception: # pylint: disable=broad-except
                            pass
                    port_name,res = QInputDialog.getItem(self,
                        QApplication.translate('Message', 'Port Configuration'),
                        QApplication.translate('Message', 'Comm Port'),
                        items,
                        current,
                        False)
                    if res:
                        try:
                            pos = items.index(port_name)
                            if self.qmc.device == 29: # MODBUS serial
                                self.modbus.comport = ports[pos][0]
                            else: # Fuji or HOTTOP
                                self.ser.comport = ports[pos][0]
                        except Exception: # pylint: disable=broad-except
                            pass
                if res:
                    if self.qmc.roastersize_setup == 0:
                        batchsize,res = QInputDialog.getDouble(self,
                            QApplication.translate('Message', 'Machine'),
                            QApplication.translate('Message', 'Machine Capacity (kg)'),
                            0, # value
                            0, # min
                            999, # max
                            1) # decimals
                        if res:
                            self.qmc.roastersize_setup = self.qmc.roastersize = batchsize
                    else:
                        res = self.qmc.roastersize_setup # roastersize_setup was loaded from machine setup
                if res:
                    # first establish roastersize_setup batchsizes as default batchsize (potentially unit converted)
                    if self.qmc.roastersize_setup > 0:
                        if self.qmc.roastersize_setup > 1 and self.qmc.weight[2] == 'g':
                            self.qmc.weight[2] = 'Kg'
                        nominal_batch_size = aw.convertWeight(self.qmc.roastersize_setup,1,self.qmc.weight_units.index(self.qmc.weight[2]))
                        self.qmc.last_batchsize = nominal_batch_size
                        self.qmc.weight = [nominal_batch_size,0,self.qmc.weight[2]]
                    # size set, ask for heating
                    if self.qmc.roasterheating_setup == 0:
                        dlg = ArtisanComboBoxDialog(self,aw,QApplication.translate('Message',
                                'Machine'),QApplication.translate('Label', 'Heating'),self.qmc.heating_types,0)
                        if dlg.exec():
                            res = dlg.idx
                        else:
                            res = None
                    else:
                        res = self.qmc.roasterheating_setup
                    if res is not None:
                        self.qmc.roasterheating_setup = self.qmc.roasterheating = res
                        # now check if the machine setup contains energy default ratings for the given batch size and energy rating
                        if self.qmc.machinesetup_energy_ratings is not None:
                            if self.qmc.roastersize_setup > 0 and self.qmc.roasterheating_setup > 0 and \
                                self.qmc.roasterheating_setup in self.qmc.machinesetup_energy_ratings:
                                heating_ratings = self.qmc.machinesetup_energy_ratings[self.qmc.roasterheating_setup]
                                if self.qmc.roastersize_setup in heating_ratings:
                                    ratings = heating_ratings[self.qmc.roastersize_setup]
                                    if 'loadlabels' in ratings and len(ratings['loadlabels']) == 4:
                                        self.qmc.loadlabels_setup = ratings['loadlabels']
                                    if 'loadratings' in ratings and len(ratings['loadratings']) == 4:
                                        self.qmc.loadratings_setup = ratings['loadratings']
                                    if 'ratingunits' in ratings and len(ratings['ratingunits']) == 4:
                                        self.qmc.ratingunits_setup = ratings['ratingunits']
                                    if 'sourcetypes' in ratings and len(ratings['sourcetypes']) == 4:
                                        self.qmc.sourcetypes_setup = ratings['sourcetypes']
                                    if 'load_etypes' in ratings and len(ratings['load_etypes']) == 4:
                                        self.qmc.load_etypes_setup = ratings['load_etypes']
                                    if 'presssure_percents' in ratings and len(ratings['presssure_percents']) == 4:
                                        self.qmc.presssure_percents_setup = ratings['presssure_percents']
                                    if 'loadevent_zeropcts' in ratings and len(ratings['loadevent_zeropcts']) == 4:
                                        self.qmc.loadevent_zeropcts_setup = ratings['loadevent_zeropcts']
                                    if 'loadevent_hundpcts' in ratings and len(ratings['loadevent_hundpcts']) == 4:
                                        self.qmc.loadevent_hundpcts_setup = ratings['loadevent_hundpcts']
                                    self.qmc.restoreEnergyLoadDefaults()
                                    self.sendmessage(QApplication.translate('Message','Energy loads configured for {0} {1}kg').format(label,self.qmc.roastersize_setup))
                        self.sendmessage(QApplication.translate('Message','Artisan configured for {0}').format(label))
                        _log.info('Artisan configured for %s',label)
                    else:
                        res = None
                if res is None:
                    # reset
                    self.qmc.etypes= org_etypes
                    self.qmc.device = org_device
                    self.qmc.machinesetup = org_machinesetup
                    self.modbus.host = org_modbus_host
                    self.s7.host = org_s7_host
                    self.ws.host = org_ws_host
                    self.ser.comport = org_comport
                    self.qmc.roastersize_setup = org_roastersize_setup
                    self.qmc.last_batchsize = org_last_batchsize
                    self.qmc.roastersize = org_roastersize
                    self.qmc.roasterheating_setup = org_roasterheating_setup
                    self.qmc.roasterheating = org_roasterheating
                    #
                    self.sendmessage(QApplication.translate('Message','Action canceled'))
                else:
                    # setup not canceled, we establish the last_batchsize
                    self.qmc.weight = [self.qmc.last_batchsize,0,self.qmc.weight[2]]
                self.establish_etypes()


    def populateThemeMenu(self):
        self.themeMenu.clear()
        self.populateListMenu('Themes','.athm',self.openThemeSettings,self.themeMenu, False, True)
        submenu = self.themeMenu.addMenu('User')
        for i in range(self.MaxRecentFiles):
            submenu.addAction(self.recentThemeActs[i])

        self.loadThemeAction = QAction(QApplication.translate('Menu', 'Load Theme...'), self)
        self.loadThemeAction.triggered.connect(self.loadSettings_theme_Slot)
        self.loadThemeAction.setMenuRole(QAction.MenuRole.NoRole) # avoid specific handling of settings menu

        self.saveAsThemeAction = QAction(QApplication.translate('Menu', 'Save Theme...'), self)
        self.saveAsThemeAction.triggered.connect(self.saveSettings_theme)
        self.saveAsThemeAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu

        submenu.addSeparator()
        submenu.addAction(self.loadThemeAction)
        submenu.addAction(self.saveAsThemeAction)

    @pyqtSlot(bool)
    def openThemeSettings(self, _checked:bool = False):
        action = self.sender()
        if action:
            label = (action.text() if action.data()[1] == '' else f'{action.data()[1]} {action.text()}')
            string = QApplication.translate('Message', 'Load theme {0}?').format(label)
            reply = QMessageBox.question(aw,QApplication.translate('Message', 'Adjust Theme Related Settings'),string,
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Cancel:
                return
            if reply == QMessageBox.StandardButton.Yes:
                aw.loadSettings(fn=action.data()[0],remember=False,reset=False, theme=True)
                self.sendmessage(QApplication.translate('Message','Loaded theme {0}').format(action.text()))
                libtime.sleep(.8)
                aw.qmc.redraw(True)

    @staticmethod
    def getcolorPairsToCheck():
        try:
            colorPairsToCheck = [
                # aw.qmc.palette
                (QApplication.translate('Label','BT'), aw.qmc.palette['bt'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','ET'), aw.qmc.palette['et'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (deltaLabelPrefix+QApplication.translate('Label','BT'), aw.qmc.palette['deltabt'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (deltaLabelPrefix+QApplication.translate('Label','ET'), aw.qmc.palette['deltaet'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Markers'), aw.qmc.palette['markers'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Text'), aw.qmc.palette['text'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Time Guide'), aw.qmc.palette['timeguide'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Background ET'), aw.qmc.backgroundmetcolor,
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Background BT'), aw.qmc.backgroundbtcolor,
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Background')+' '+deltaLabelPrefix+QApplication.translate('Label','ET'), aw.qmc.backgrounddeltaetcolor,
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Background')+' '+deltaLabelPrefix+QApplication.translate('Label','BT'), aw.qmc.backgrounddeltabtcolor,
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','Background Extra'), aw.qmc.palette['xt'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                (QApplication.translate('Label','X Label'), aw.qmc.palette['xlabel'],
                 QApplication.translate('Label','Canvas'), aw.qmc.palette['canvas']),

                (QApplication.translate('Label','Y Label'), aw.qmc.palette['ylabel'],
                 QApplication.translate('Label','Canvas'), aw.qmc.palette['canvas']),

                (QApplication.translate('Label','Title'), aw.qmc.palette['title'],
                 QApplication.translate('Label','Canvas'), aw.qmc.palette['canvas']),

                (QApplication.translate('Label','SpecialEventText'), aw.qmc.palette['specialeventtext'],
                 QApplication.translate('Label','SpecialEventBox'), aw.qmc.palette['specialeventbox']),

                (QApplication.translate('Label','Bg SpecialEventText'), aw.qmc.palette['bgeventtext'],
                 QApplication.translate('Label','Bg SpecialEventBox'), aw.qmc.palette['bgeventmarker']),

                (QApplication.translate('Label','ET'), aw.qmc.palette['et'],
                 QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['legendbg']),

                (QApplication.translate('Label','BT'), aw.qmc.palette['bt'],
                 QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['legendbg']),

                (deltaLabelPrefix+QApplication.translate('Label','ET'), aw.qmc.palette['deltaet'],
                 QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['legendbg']),

                (deltaLabelPrefix+QApplication.translate('Label','BT'), aw.qmc.palette['deltabt'],
                 QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['legendbg']),

                (QApplication.translate('Label','MET Text'), aw.qmc.palette['mettext'],
                 QApplication.translate('Label','MET Box'), aw.qmc.palette['metbox']),

                (QApplication.translate('Label','MET Box'), aw.qmc.palette['metbox'],
                 QApplication.translate('Label','Background'), aw.qmc.palette['background']),

                # aw.lcdpalette
                (QApplication.translate('Label','Timer LCD Digits'), aw.lcdpaletteF['timer'],
                 QApplication.translate('Label','Timer LCD Background'), aw.lcdpaletteB['timer']),

                (QApplication.translate('Label','ET LCD Digits'), aw.lcdpaletteF['et'],
                 QApplication.translate('Label','ET LCD Background'), aw.lcdpaletteB['et']),

                (QApplication.translate('Label','BT LCD Digits'), aw.lcdpaletteF['bt'],
                 QApplication.translate('Label','BT LCD Background'), aw.lcdpaletteB['bt']),

                (deltaLabelPrefix+QApplication.translate('Label','ET LCD Digits'), aw.lcdpaletteF['deltaet'],
                 deltaLabelPrefix+QApplication.translate('Label','ET LCD Background'), aw.lcdpaletteB['deltaet']),

                (deltaLabelPrefix+QApplication.translate('Label','BT LCD Digits'), aw.lcdpaletteF['deltabt'],
                 deltaLabelPrefix+QApplication.translate('Label','BT LCD Background'), aw.lcdpaletteB['deltabt']),

                (QApplication.translate('Label','Extra/PID LCD Digits'), aw.lcdpaletteF['sv'],
                 QApplication.translate('Label','Extra/PID LCD Background'), aw.lcdpaletteB['sv']),
            ]

            # extra devices
            for i in range(len(aw.qmc.extradevices)):
                if  aw.extraCurveVisibility1[i]:
                    colorPairsToCheck.append(
                        (aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate('Label','Background'), aw.qmc.palette['background']),
                    )
                    colorPairsToCheck.append(
                        (aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['background']),
                    )
                if  aw.extraCurveVisibility2[i]:
                    colorPairsToCheck.append(
                        (aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate('Label','Background'), aw.qmc.palette['background']),
                    )
                    colorPairsToCheck.append(
                        (aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate('Label','Legend bkgnd'),aw.qmc.palette['background']),
                    )

            # special events
            for i in range(len(aw.qmc.EvalueColor)):
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +' '+QApplication.translate('Label','Event'), aw.qmc.EvalueColor[i], QApplication.translate('Label','Background'),   aw.qmc.palette['background']),
                )
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +' '+QApplication.translate('Label','Event'), aw.qmc.EvalueColor[i], QApplication.translate('Label','Legend bkgnd'), aw.qmc.palette['background']),
                )
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +' '+QApplication.translate('Label','Slider'),aw.qmc.EvalueColor[i], QApplication.translate('Label','Background'),       aw.qmc.palette['canvas']),
                )
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +' '+QApplication.translate('Label','Text'), aw.qmc.EvalueTextColor[i], aw.qmc.etypes[i] +' '+QApplication.translate('Label','Event'), aw.qmc.EvalueColor[i]),
                )

            #events buttons
            for i in range(len(aw.extraeventstypes)):
                colorPairsToCheck.append(
                    (QApplication.translate('Label','Event button')+' '+ aw.extraeventslabels[i], aw.extraeventbuttoncolor[i], ' '+QApplication.translate('Label','its text'), aw.extraeventbuttontextcolor[i]),
                )

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' getcolorPairsToCheck() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        return colorPairsToCheck


    @staticmethod
    def colorDifference(color1,color2):
        cDiff = 100
        try:
            from colorspacious import deltaE
            if color1 is None or color1 == 'None':
                color1 = '#f0f0f0'
            if color2 is None or color2 == 'None':
                color2 = '#f0f0f0'
            if color1.lower() == 'transparent':
                if aw.qmc.palette['canvas'] is None or aw.qmc.palette['canvas'] == 'None':
                    color1 = '#f0f0f0'
                else:
                    color1 = aw.qmc.palette['canvas']
            if color2.lower() == 'transparent':
                if aw.qmc.palette['canvas'] is None or aw.qmc.palette['canvas'] == 'None':
                    color2 = '#f0f0f0'
                else:
                    color2 = aw.qmc.palette['canvas']
            c1 = str(QColor(color1).name())
            c2 = str(QColor(color2).name())
            c1_rgb = tuple(int(c1[i:i+2], 16) for i in (1, 3 ,5))
            c2_rgb = tuple(int(c2[i:i+2], 16) for i in (1, 3 ,5))
            cDiff = deltaE(c1_rgb, c2_rgb, input_space='sRGB255', uniform_space='CIELab')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' colorDifference() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        return cDiff


    def checkColors(self,colorPairsToCheck=None,showMsg=True):
        if colorPairsToCheck is None:
            colorPairsToCheck = []
        val = -1
        try:
            for c in colorPairsToCheck:
                c1 = c[1]
                c3 = c[3]
                # if one color is the canvas color set to None (transparent), we try to avoid a false warning
                if str(c1) == 'None' and c[0] == 'Canvas':
                    if sys.platform.startswith('darwin') and darkdetect.isDark() and appFrozen():
                        c1 = 'black'
                    else:
                        c1 = 'white'
                if str(c3) == 'None' and c[2] == 'Canvas':
                    if sys.platform.startswith('darwin') and darkdetect.isDark() and appFrozen():
                        c3 = 'black'
                    else:
                        c3 = 'white'
                val = self.colorDifference(c1,c3)
                if val < aw.qmc.colorDifferenceThreshold :
                    val = aw.float2float(val,1)
                    if showMsg:
                        aw.sendmessage(QApplication.translate('Message','Detected a color pair that may be hard to see: ') + f'{c[0]!s} ({c[1]!s}) <-> {c[2]!s} ({c[3]!s}) [deltaE={val:.1f}]')
#                    print("checkColors", str(c[0]), "/", str(c[2]), "  Too similar", str(c[1]), str(c[3]), str(val)) #debugprint
#                else: #debugprint
#                    print("checkColors", str(c[0]), "/", str(c[2]), "  Okay", str(c[1]), str(c[3]), str(val))  #debugprint
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' checkColors() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        return val

    @staticmethod
    def convertToGreyscale(c):
        try:
            nc = c
            from colorspacious import cspace_convert
            if c is None or c == 'None':
                return 'None'
            if isinstance(c,str) and c.lower() == 'transparent':
                return 'transparent'
            cq = str(QColor(c).name())
            c_rgb = tuple(int(cq[i:i+2], 16) for i in (1, 3 ,5))
            nc_greyscale_JCh = cspace_convert(c_rgb, 'sRGB255', 'JCh')
            nc_greyscale_JCh[..., 1] = 0
            nc_greyscale_sRGB = cspace_convert(nc_greyscale_JCh, 'JCh', 'sRGB255')
            nc_greyscale_sRGB = numpy.clip(nc_greyscale_sRGB, 0, 255)
            nc_greyscale = f'#{int(nc_greyscale_sRGB[0]):2x}{int(nc_greyscale_sRGB[1]):2x}{int(nc_greyscale_sRGB[2]):2x}'
            nc = str(QColor(nc_greyscale).name())
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' convertToGreyscale() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return nc

    def labelBorW(self,backgroundcolor):
        base = self.convertToGreyscale(backgroundcolor)
        if self.checkColors([('base',base,'white','#ffffff')], False) > self.checkColors([('base',base,'black','#000000')],False):
            return 'white'
        return 'black'

    @staticmethod
    def setLCDsBW():
        aw.lcdpaletteB['timer'] = 'black'
        aw.lcdpaletteF['timer'] = 'white'
        aw.lcdpaletteB['et'] = 'black'
        aw.lcdpaletteF['et'] = 'white'
        aw.lcdpaletteB['bt'] = 'black'
        aw.lcdpaletteF['bt'] = 'white'
        aw.lcdpaletteB['deltaet'] = 'black'
        aw.lcdpaletteF['deltaet'] = 'white'
        aw.lcdpaletteB['deltabt'] = 'black'
        aw.lcdpaletteF['deltabt'] = 'white'
        aw.lcdpaletteB['sv'] = 'black'
        aw.lcdpaletteF['sv'] = 'white'
        aw.lcdpaletteB['rstimer'] = 'white'
        aw.lcdpaletteF['rstimer'] = 'black'
        aw.lcdpaletteB['slowcoolingtimer'] = 'black'
        aw.lcdpaletteF['slowcoolingtimer'] = 'white'
        aw.setTimerColor('timer')
        aw.lcd2.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['et'],aw.lcdpaletteB['et']))
        aw.lcd3.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['bt'],aw.lcdpaletteB['bt']))
        aw.lcd4.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['deltaet'],aw.lcdpaletteB['deltaet']))
        aw.lcd5.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['deltabt'],aw.lcdpaletteB['deltabt']))
        aw.lcd6.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['sv'],aw.lcdpaletteB['sv']))
        aw.lcd7.setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['sv'],aw.lcdpaletteB['sv']))
        aw.updateExtraLCDvisibility()

    def updateCanvasColors(self, checkColors=True):
        canvas_color = self.qmc.palette['canvas']
        if canvas_color is not None and canvas_color != 'None' and not QColor.isValidColor(canvas_color):
            # we re-initialize broken canvas color
            canvas_color = self.qmc.palette['canvas'] = '#F8F8F8'
        try:
            if str(canvas_color) == 'None' and sys.platform.startswith('darwin'):
                if darkdetect.isDark() and appFrozen():
                    # in dark mode on macOS, the transparent canvas of the classic Artisan theme leeds to unreadable text, thus we switch to standard gray
                    canvas_color = self.qmc.palette['canvas'] = '#333333' # for light: "#F8F8F8"
                    self.qmc.palette['title'] = '#e6e6e6'
                    self.qmc.palette['xlabel'] = '#cccccc'
                    self.qmc.palette['ylabel'] = '#cccccc'
                else:
                    if self.qmc.palette['title'] == '#e6e6e6':
                        self.qmc.palette['title'] = '#000000'
                    if self.qmc.palette['xlabel'] == '#cccccc':
                        self.qmc.palette['xlabel'] = '#000000'
                    if self.qmc.palette['ylabel'] == '#cccccc':
                        self.qmc.palette['ylabel'] = '#000000'
                for label in self.qmc.ax.xaxis.get_ticklabels():
                    label.set_color(self.qmc.palette['xlabel'])
                for label in self.qmc.ax.yaxis.get_ticklabels():
                    label.set_color(self.qmc.palette['ylabel'])
                if self.qmc.delta_ax:
                    for label in self.qmc.delta_ax.yaxis.get_ticklabels():
                        label.set_color(self.qmc.palette['ylabel'])
                    self.qmc.delta_ax.yaxis.get_label().set_color(self.qmc.palette['ylabel'])
                self.qmc.ax.xaxis.get_label().set_color(self.qmc.palette['xlabel'])
                self.qmc.ax.yaxis.get_label().set_color(self.qmc.palette['ylabel'])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

        title_color = self.qmc.palette['title']

        current_background_color = None
        try:
            s = self.styleSheet()[12+len('background-color:'):]
            current_background_color = s[:s.index(';')]
        except Exception: # pylint: disable=broad-except
            pass

        # whitep = True in darkmode (dark canvas)
        if str(canvas_color) == 'None':
            if sys.platform.startswith('darwin'):
                whitep = darkdetect.isDark() and appFrozen()
            else:
                whitep = False
        else:
            whitep = self.colorDifference('white',canvas_color) > self.colorDifference('black',canvas_color)

        self.qmc.fig.patch.set_facecolor(str(canvas_color))
        self.setStyleSheet('QMainWindow{background-color:' + str(canvas_color) + ';'
                                   + 'border: 0px solid black;'
                                   + '}' )

        if current_background_color is None or current_background_color != str(canvas_color) or (whitep and self.qmc.palette['messages'] != 'white'): # canvas color did not change, we do not need to redo the navigation bar
            # update navigationbar
            self.level1layout.removeWidget(self.ntb) # remove current bar

            if mpl_version[0] > 2 and mpl_version[1] > 2:
                if self.ntb.mode == MPL_Mode.PAN:
                    self.ntb.pan() # PAN is active, we deactivate it before changing the ToolBar
                if self.ntb.mode == MPL_Mode.ZOOM:
                    self.ntb.zoom() # ZOOM is active, we deactivate it before changing the ToolBar
            else:
                if self.ntb._active == 'PAN': # pylint: disable=protected-access
                    self.ntb.pan() # PAN is active, we deactivate it before changing the ToolBar
                if self.ntb._active == 'ZOOM': # pylint: disable=protected-access
                    self.ntb.zoom() # ZOOM is active, we deactivate it before changing the ToolBar
            self.removeToolBar(self.ntb)
#            self.ntb.hide() # seems not to be necessary anymore with the removeToolBar() above
            self.ntb.destroy()
            self.ntb = VMToolbar(self.qmc, self.main_widget, whitep)

        if whitep:
            self.qmc.palette['messages'] = 'white'
        else:
            self.qmc.palette['messages'] = 'black'
        self.sendmessage('', append=False)
        self.ntb.setMinimumHeight(50)

        aw.sliderFrame.setStyleSheet('QGroupBox {background-color:' + str(canvas_color) + ';'
                                    + 'color: ' + str(title_color) + ';'
                                    + 'border: 0px solid gray;'
                                    + 'border-width: 0px;'
                                    + 'padding-top: 12px;'
                                    + 'padding-bottom: 5px;'
                                    + 'padding-left: 0px;'
                                    + 'padding-right: 0px;'
                                    + '}'
                                    + 'QGroupBox::title {background-color:' + str(canvas_color) + ';'
                                    + 'subcontrol-origin: margin;' # or border or margin
                                    + 'subcontrol-position: top center;' #/* position at the top center */
                                    + 'color: ' + aw.qmc.palette['messages'] + ';'
                                    + '}')

        # ensure x/y coordinates are readable
        self.ntb.locLabel.setStyleSheet('QWidget {background-color:' + str(canvas_color) + ';'
                                    + 'color: ' + str(title_color) + ';'
                                    + '}' )
        # make QToolBar background transparent
        self.ntb.setStyleSheet('QToolBar {background-color:' + str(canvas_color) + ';'
                                    + 'border: 5px solid ' + str(canvas_color) + ';'
                                    + 'color: ' + str(title_color) + ';'
                                    + '}' )

        self.qmc.setProfileTitle(self.qmc.title,updatebackground=True)

        self.level1layout.insertWidget(0,self.ntb)

        if str(canvas_color) == 'None':
            self.qmc.fig.canvas.setStyleSheet('background-color:transparent;')
            self.ntb.setStyleSheet('QToolBar {background-color:transparent;}')

        self.updateSliderColors()
        self.updatePhasesLCDsColors()

        if checkColors:
            colorPairsToCheck = self.getcolorPairsToCheck()
            self.checkColors(colorPairsToCheck)


    @staticmethod
    def process_active_quantifiers():
        # called every sampling interval
        for i in range(4):
            if aw.eventquantifieractive[i]:
                # we reduce the block values by one for each channel
                aw.block_quantification_sampling_ticks[i] = max(0, aw.block_quantification_sampling_ticks[i] - 1)

                if not aw.block_quantification_sampling_ticks[i]:
                    temp,_ = aw.quantifier2tempandtime(i)
                    if temp is not None and len(temp)>0: # corresponding curve is available
                        linespace = aw.eventquantifierlinspaces[i]
                        if aw.eventquantifiercoarse[i]:
                            linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdcoarse
                        else:
                            linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdfine
                        t = temp[-1]
                        if t != -1: # -1 is an error value
                            d = aw.digitize(t,linespace,aw.eventquantifiercoarse[i],i)
                            ld = aw.lastdigitizedvalue[i] # in internal format so 8 representing 70%
                            lt = aw.lastdigitizedtemp[i] # last digitized raw value corresponding to ld
                            if d is not None and (ld is None or ld != d):
                                if ld is None or lt is None or linespacethreshold < abs(t - lt): # and only if significantly different than previous to avoid fluktuation
                                    # test if t is increasing or decreasing
                                    v = d * 10.
                                    # establish this one
                                    aw.lastdigitizedvalue[i] = d
                                    aw.lastdigitizedtemp[i] = t
                                    lv = aw.lastEventValue(i)
                                    # now move corresponding slider and add event if its value is not equal to the previous one
                                    if (aw.float2float((v + 10.0) / 10.0)) != lv:
                                        # we set the last value to be used for relative +- button action as base
                                        aw.extraeventsactionslastvalue[i] = int(round(v))
                                        aw.qmc.quantifiedEvent.append([i,v])

    def updateSliderColors(self):
        self.sliderLCD1.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[0])
        self.sliderLCD2.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[1])
        self.sliderLCD3.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[2])
        self.sliderLCD4.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.EvalueColor[3])
        self.sliderLCDSV.setStyleSheet('font-weight: bold; color: %s;'%self.qmc.palette['title'])
        self.slider1.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[0]))
        self.slider2.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[1]))
        self.slider3.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[2]))
        self.slider4.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[3]))
        self.sliderSV.setStyleSheet(artisan_slider_style.format(color=self.qmc.palette['title']))

    def updatePhasesLCDsColors(self):
        label_style = 'QLabel { color : ' + self.qmc.palette['messages']  + '; }'
        self.TPlabel.setStyleSheet(label_style)
        self.TP2DRYlabel.setStyleSheet(label_style)
        self.DRYlabel.setStyleSheet(label_style)
        self.DRY2FCslabel.setStyleSheet(label_style)
        self.FCslabel.setStyleSheet(label_style)
        self.AUClabel.setStyleSheet(label_style)

    # timex: if True, adjust time axis
    # deltas: if True adjust delta axis
    # background: if True, adjust such that background from CHARGE to DROP is fully in view
    #      (automatic set if time axis adjust is active, timex=True, during sampling and recording)
    #      if background is False, the RESET min/max times are respected even if a background profile is loaded
    @staticmethod
    def autoAdjustAxis(background=False,timex=True,deltas=True):
        try:
            if aw.qmc.autotimex and timex:
                # auto timex adjust
                if aw.qmc.flagon and aw.qmc.background:
                    # if we are recording and background profile is loaded and shown
                    background = True
                if background:
                    t_min,t_max = aw.calcAutoAxisBackground()
                else:
                    if len(aw.qmc.timex) > 3:
                        t_min,t_max = aw.calcAutoAxisForeground()
                    else:
                        t_min = aw.qmc.chargemintime
                        t_max = aw.qmc.resetmaxtime
                if aw.qmc.background and aw.qmc.autotimexMode != 2:
                    if background:
                        t_max_b = t_max
                    else:
                        _,t_max_b = aw.calcAutoAxisBackground()
                    if aw.qmc.timeindexB[0] != -1:
                        t_max = max(t_max,t_max_b - aw.qmc.timeB[aw.qmc.timeindexB[0]])
                    else:
                        t_max = max(t_max,t_max_b)

                if background and aw.qmc.timeindexB[0] != -1:
                    aw.qmc.startofx = t_min - aw.qmc.timeB[aw.qmc.timeindexB[0]]
                else:
                    aw.qmc.startofx = t_min

                if not background and aw.qmc.timeindex[0] != -1 and len(aw.qmc.timex) > aw.qmc.timeindex[0]:
                    aw.qmc.endofx = t_max - aw.qmc.timex[aw.qmc.timeindex[0]]
                elif background and aw.qmc.timeindexB[0] != -1 and len(aw.qmc.timeB) > aw.qmc.timeindexB[0]:
                    aw.qmc.endofx = t_max - aw.qmc.timeB[aw.qmc.timeindexB[0]]
                else:
                    aw.qmc.endofx = t_max
            if (aw.qmc.autodeltaxET or aw.qmc.autodeltaxBT) and deltas:
                # auto delta adjust
                if background:
                    dmax = aw.calcAutoDeltaAxisBackground()
                else:
                    dmax = aw.calcAutoDeltaAxis()
                if aw.qmc.background:
                    if background:
                        dmax_b = dmax
                    else:
                        dmax_b = aw.calcAutoDeltaAxisBackground()
                else:
                    dmax_b = 0
                dmax = max(dmax,dmax_b)
                # we only adjust the upper limit automatically
                if dmax > aw.qmc.zlimit_min:
                    aw.qmc.zlimit = int(dmax) + 1
                else:
                    aw.qmc.zlimit = aw.qmc.zlimit_min + 1
                # adjust zgrid (only if zgrid not deactivated)
                if aw.qmc.zgrid != 0:
                    d = aw.qmc.zlimit - aw.qmc.zlimit_min
                    steps = int(round(d/5))
                    if steps > 50:
                        steps = int(round(steps/10))*10
                    elif steps > 10:
                        steps = int(round(steps/5))*5
                    elif steps > 5:
                        steps = 5
                    else:
                        steps = int(round(steps/2))*2
                    auto_grid = max(2,steps)
                    aw.qmc.zgrid = auto_grid
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' autoAdjustAxis() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleFullscreen(self,_=False):
        if self.full_screen_mode_active or self.isFullScreen():
            self.full_screen_mode_active = False
            self.showNormal()
            if not (platf == 'Darwin' and self.qmc.locale_str == 'en'):
                aw.fullscreenAction.setChecked(False)
        else:
            self.full_screen_mode_active = True
            self.showFullScreen()
            if not (platf == 'Darwin' and self.qmc.locale_str == 'en'):
                aw.fullscreenAction.setChecked(True)

    def calcAutoAxisForeground(self):
        return self.calcAutoAxis(self.qmc.timex,self.qmc.timeindex, self.qmc.foregroundShowFullflag or self.qmc.flagstart)

    # returns time axis min and max
    # min to be about 1min (1/16 of total time) before CHARGE or first recording if no CHARGE
    # max to be about 1min (1/10 of total time) after COOL or DROP or last recording if no DROP nor COOL
    def calcAutoAxis(self, timex, timeindex, beyondDROP):
        if len(timex) > 3:
            # profile loaded?
            t_start = self.qmc.startofx
            t_end = self.qmc.endofx
            if self.qmc.autotimexMode == 0 and timeindex[0] > -1: # CHARGE set
                t_start = timex[timeindex[0]]
            else:
                t_start = timex[0]
            if self.qmc.autotimexMode == 2 and timeindex[0] > -1:
                t_end = timex[timeindex[0]]
            else:
                if timeindex[7] > 0 and self.qmc.buttonvisibility[7] and beyondDROP: # COOL set, COOL button shown and the curves are drawn beyond DROP or recording
                    t_end = timex[timeindex[7]]
                elif timeindex[6] > 0: # DROP set
                    t_end = timex[timeindex[6]]
                else:
                    t_end = timex[-1]
            # add padding
            time_period = t_end - t_start
            t_start -= 1/16*time_period
            t_end += 1/10*time_period
            return t_start, t_end
        return self.qmc.startofx, self.qmc.endofx

    def calcAutoDelta(self,d1,d2,timeindex,d1flag,d2flag):
        # returns the max ET/BT RoR between CHARGE and DROP
        start = 0
        end = min(len(d1),len(d2)) - 1
        if timeindex[0] != -1:
            start = timeindex[0]
        if timeindex[6] > 0:
            end = timeindex[6]
        try:
            visible_readings = []
            if d1flag and self.qmc.autodeltaxET:
                visible_readings.extend(d1[start:end])
            if d2flag and self.qmc.autodeltaxBT:
                visible_readings.extend(d2[start:end])
            if len(visible_readings) > 0:
                return max(filter(None,visible_readings))
            return 0
        except Exception: # pylint: disable=broad-except
            # if filtered list is empty, max fails and we return 0
            return 0

    def calcAutoDeltaAxis(self):
        if not(aw.qmc.flagstart) and (len(aw.qmc.delta1) > 3 or len(aw.qmc.delta2) > 3):
            return self.calcAutoDelta(self.qmc.delta1,self.qmc.delta2,self.qmc.timeindex,self.qmc.DeltaETflag,self.qmc.DeltaBTflag)
        if self.qmc.flagon:
            if aw.qmc.mode == 'C':
                return self.qmc.zlimit_C_default - 1
            return self.qmc.zlimit_F_default - 1
        return 0

    def calcAutoDeltaAxisBackground(self):
        if len(aw.qmc.delta1B) > 3 or len(aw.qmc.delta2B) > 3:
            return self.calcAutoDelta(self.qmc.delta1B,aw.qmc.delta2B,self.qmc.timeindexB,self.qmc.DeltaETBflag,self.qmc.DeltaBTBflag)
        return 0

    def calcAutoAxisBackground(self):
        return self.calcAutoAxis(self.qmc.timeB,self.qmc.timeindexB,self.qmc.backgroundShowFullflag or self.qmc.flagstart)

    # returns the last event value of the given type, or None if no event was ever recorded
    @staticmethod
    def lastEventValue(tp):
        res_last = None
        try:
            r = range(len(aw.qmc.specialeventstype) - 1, -1, -1)  # @UndefinedVariable
            for i in r:
                if aw.qmc.specialeventstype[i] == tp:
                    res_last = aw.qmc.specialeventsvalue[i]
                    break
        except Exception: # pylint: disable=broad-except
            pass
        return res_last

    # order event table by time
    def orderEvents(self, lock=True):
        try:
            #### lock shared resources #####
            if lock:
                self.qmc.profileDataSemaphore.acquire(1)
            nevents = len(aw.qmc.specialevents)
            packed_events = []
            # pack
            for i in range(nevents):
                packed_events.append(
                    (self.qmc.specialevents[i],
                     self.qmc.specialeventstype[i],
                     self.qmc.specialeventsStrings[i],
                     self.qmc.specialeventsvalue[i]))
            # sort
            packed_events.sort(key=lambda tup: tup[0])
            # unpack
            for i in range(nevents):
                self.qmc.specialevents[i] = packed_events[i][0]
                self.qmc.specialeventstype[i] = packed_events[i][1]
                self.qmc.specialeventsStrings[i] = packed_events[i][2]
                self.qmc.specialeventsvalue[i] = packed_events[i][3]
            # we have to clear the event flag positions as those are now out of order
            self.qmc.l_event_flags_dict = {}
            self.qmc.l_event_flags_pos_dict = {}
            # update minievent editor
            self.changeEventNumber(0)
        finally:
            if lock and self.qmc.profileDataSemaphore.available() < 1:
                self.qmc.profileDataSemaphore.release(1)


    # if only_active then only the event types with quantifiers activated are grouped
    def clusterEvents(self,only_active=False):
        for i in range(4):
            if not only_active or aw.eventquantifieractive[i]:
                self.clusterEventsType(i)

    # cluster of events of the given type (0-3)
    def clusterEventsType(self,tp):
        try:
            #### lock shared resources #####
            aw.qmc.profileDataSemaphore.acquire(1)
            nevents = len(aw.qmc.specialevents)
            if nevents:
                # first order the events table
                self.orderEvents(lock=False)
                # second detect the minimum time span between two events (could be equal to the sampling rate)
                min_span = None
                last_event_idx = None # index of last event analyzed
                for i in range(len(aw.qmc.specialevents)):
                    if aw.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                        time_diff = aw.qmc.specialevents[i] - aw.qmc.specialevents[last_event_idx]
                        if min_span is None or time_diff < min_span:
                            min_span = time_diff
                    last_event_idx = i
                if min_span is not None:
                    min_span = min(1,min_span,aw.qmc.delay/1000 * 3)
                    indexes_to_be_removed = []
                    last_event_idx = None # index of last event analyzed
                    last_index_not_removed = None
                    # group those with minimally 2x min_span time delta by keeping the first with the value of the last
                    for i in range(len(aw.qmc.specialevents)):
                        if aw.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                            if aw.qmc.specialeventsvalue[last_event_idx] == aw.qmc.specialeventsvalue[i]:
                                # if the value of the event is the same as the previous, we remove it
                                indexes_to_be_removed.append(i)
                            else:
                                time_diff = aw.qmc.specialevents[i] - aw.qmc.specialevents[last_event_idx]
                                if time_diff < 2*min_span:
                                    indexes_to_be_removed.append(i)
                                    if last_index_not_removed is not None:
                                        aw.qmc.specialeventsvalue[last_index_not_removed] = aw.qmc.specialeventsvalue[i]
                                else:
                                    last_index_not_removed = i
                        if aw.qmc.specialeventstype[i] == tp:
                            last_event_idx = i
                    # remove marked events
                    specialevents = []
                    specialeventstype = []
                    specialeventsStrings = []
                    specialeventsvalue = []
                    for i in range(len(aw.qmc.specialevents)):
                        if not (i in indexes_to_be_removed):
                            specialevents.append(aw.qmc.specialevents[i])
                            specialeventstype.append(aw.qmc.specialeventstype[i])
                            specialeventsStrings.append(aw.qmc.specialeventsStrings[i])
                            specialeventsvalue.append(aw.qmc.specialeventsvalue[i])
                    aw.qmc.specialevents = specialevents
                    aw.qmc.specialeventstype = specialeventstype
                    aw.qmc.specialeventsStrings = specialeventsStrings
                    aw.qmc.specialeventsvalue = specialeventsvalue
        finally:
            if aw.qmc.profileDataSemaphore.available() < 1:
                aw.qmc.profileDataSemaphore.release(1)


    # decides on visibility of the Control button based on the selected devices and configuration
    def showControlButton(self):
        res = False
        lcds = False
        if aw.qmc.device in (0, 26): # FUJI, DTA
            res = True
            if aw.ser.showFujiLCDs:
                lcds = True
#        elif aw.qmc.device == 19 and aw.qmc.PIDbuttonflag: # ARDUINOTC4
#            res = True
        elif aw.qmc.Controlbuttonflag:
            res = True
        if res:
            aw.pidcontrol.activateONOFFeasySV(aw.pidcontrol.svButtons)
            aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider)
        else:
            aw.pidcontrol.activateONOFFeasySV(False)
            aw.pidcontrol.activateSVSlider(False)
        if app.artisanviewerMode:
            aw.buttonCONTROL.setVisible(False)
        else:
            aw.buttonCONTROL.setVisible(res)
        self.LCD6frame.setVisible(lcds)
        self.LCD7frame.setVisible(lcds)

    # i/o: 0:g, 1:Kg, 2:lb (pound), 3:oz (ounce)
    @staticmethod
    def convertWeight(v,i,o):
        #                g,            kg,         lb,             oz,
        convtable = [
                        [1.,           0.001,      0.00220462262,  0.035274],  # g
                        [1000,         1.,         2.205,          35.274],    # Kg
                        [453.591999,   0.45359237, 1.,             16.],       # lb
                        [28.3495,      0.0283495,  0.0625,         1.]         # oz
                    ]
        return v*convtable[i][o]

    # i/o: 0:l (liter), 1:gal (gallons US), 2:qt, 3:pt, 4:cup, 5:cm^3/ml
    @staticmethod
    def convertVolume(v,i,o):
                        #liter          gal             qt              pt              cup             ml/cm^3
        convtable = [
                        [1.,            0.26417205,     1.05668821,     2.11337643,     4.22675284,     1000.                ],    # liter
                        [3.78541181,    1.,             4.,             8.,             16,             3785.4117884         ],    # gallon
                        [0.94635294,    0.25,           1.,             2.,             4.,             946.352946           ],    # quart
                        [0.47317647,    0.125,          0.5,            1.,             2.,             473.176473           ],    # pint
                        [0.23658823,    0.0625,         0.25,           0.5,            1.,             236.5882365          ],    # cup
                        [0.001,         2.6417205e-4,   1.05668821e-3,  2.11337641e-3,  4.2267528e-3,   1.                   ]     # cm^3
                    ]
        return v*convtable[i][o]



    @pyqtSlot()
    def superusermodeLeftClicked(self):
        if self.simulator is not None and self.qmc.flagstart:
            try:
                self.qmc.samplingSemaphore.acquire(1)
                self.sample_loop_running = not self.sample_loop_running
                if self.sample_loop_running:
                    period_stopped = (self.qmc.timeclock.elapsed() / self.qmc.timeclock.getBase()) - aw.time_stopped
                    self.qmc.timeclock.addClock(period_stopped)

                    # restart the stopped simulator
                    modifiers = QApplication.keyboardModifiers()
                    control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier # command/apple key on macOS, Control key on Windows
                    alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier # OPTION on macOS, ALT on Windows
                    shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier # SHIFT
                    if control_modifier or alt_modifier or shift_modifier:
                        # if a modifier we change the speed instead of leaving the simulator (shift: 1x, alt: 2x, control: 4x):
                        speed = 1
                        if alt_modifier:
                            speed = 2
                        elif control_modifier:
                            speed = 4
                        old_base = self.qmc.timeclock.getBase()
                        old_speed = old_base/1000
                        if old_speed != speed:
                            old_elapsed = self.qmc.timeclock.elapsed()
                            # switch to new speed:
                            new_base = 1000*speed
                            self.qmc.timeclock.setBase(new_base)
                            # time-base changed, we have to adjust our clock
                            new_elapsed = self.qmc.timeclock.elapsed()
                            offset = (new_elapsed - old_elapsed)/new_base
                            self.qmc.timeclock.addClock(offset)
                            self.updateWindowTitle()
                        self.sendmessage(QApplication.translate('Message','Simulator started @{}x').format(speed))
                    self.qmc.updateDeltaSamples() # to get the delta_spans right
                else:
                    # remember the time on stopping the simulator
                    aw.time_stopped = self.qmc.timeclock.elapsed() / self.qmc.timeclock.getBase()
            finally:
                if self.qmc.samplingSemaphore.available() < 1:
                    self.qmc.samplingSemaphore.release(1)
        else:
            self.superusermode = not self.superusermode
            if self.superusermode:
                aw.sendmessage(QApplication.translate('Message','super on'))
            else:
                aw.sendmessage(QApplication.translate('Message','super off'))

    @pyqtSlot('QPoint')
    def PhaseslcdClicked(self,_): # pylint: disable=no-self-use # used as slot
        aw.qmc.phasesLCDmode = (aw.qmc.phasesLCDmode + 1)%3
        aw.updatePhasesLCDs()

    @pyqtSlot('QPoint')
    def AUClcdClicked(self,_):
        aw.qmc.AUCLCDmode = (aw.qmc.AUCLCDmode + 1)%3
        if aw.qmc.AUCLCDmode == 0:
            label = QApplication.translate('Label', 'AUC')
        elif aw.qmc.AUCLCDmode == 1:
            label = '&raquo;' + QApplication.translate('Label', 'AUC')
        else:
            label = QApplication.translate('Label', 'AUC FCs')
        self.AUClabel.setText('<small><b>' + label + '</b></small>')
        if aw.LargePhasesLCDsFlag and aw.largePhasesLCDs_dialog:
            aw.largePhasesLCDs_dialog.updatePhasesLabels([None,None,None,label])
        aw.updateAUCLCD()

    @staticmethod
    def colordialog(c,noButtons=False,parent=None): # c a QColor
        if platform.system() == 'Darwin':
            if noButtons:
                if parent is None:
                    parent = aw
                cd = QColorDialog(parent)
                cd.setModal(True)
                cd.setWindowModality(Qt.WindowModality.ApplicationModal)
                cd.setOption(QColorDialog.ColorDialogOption.NoButtons,True)
#                cd.setOption(QColorDialog.ColorDialogOption.ShowAlphaChannel,True)
#                cd.setOption(QColorDialog.ColorDialogOption.NoButtons | QColorDialog.ColorDialogOption.ShowAlphaChannel,True)
                cd.setCurrentColor(c)
                cd.exec()
                cr = cd.currentColor()
                return cr
        return QColorDialog.getColor(c)

    @pyqtSlot(int)
    def adjustPIDsv(self,x):
        if self.qmc.device == 0: # Fuji PID
            self.fujipid.adjustsv(x)
#        elif self.qmc.device == 19: # Arduino TC4
        else: # Arduino TC4, internal Software PID or MODBUS/S7 external PID
            self.pidcontrol.adjustsv(x)

    @pyqtSlot(bool)
    def adjustPIDsv5(self,_=False):
        self.adjustPIDsv(5)

    @pyqtSlot(bool)
    def adjustPIDsv10(self,_=False):
        self.adjustPIDsv(10)

    @pyqtSlot(bool)
    def adjustPIDsv20(self,_=False):
        self.adjustPIDsv(20)

    @pyqtSlot(bool)
    def adjustPIDsv20m(self,_=False):
        self.adjustPIDsv(-20)

    @pyqtSlot(bool)
    def adjustPIDsv10m(self,_=False):
        self.adjustPIDsv(-10)

    @pyqtSlot(bool)
    def adjustPIDsv5m(self,_=False):
        self.adjustPIDsv(-5)

    # compute the 12 or 102 event quantifier linespace for type n in [0,3]
    def computeLinespace(self,n):
        if self.eventquantifiercoarse[n]:
            num = int(round((self.eventslidermax[n] - self.eventslidermin[n])/10.)) + 1
        else:
            num = self.eventslidermax[n] - self.eventslidermin[n] + 1
        return numpy.linspace(self.eventquantifiermin[n], self.eventquantifiermax[n], num=num)

    # update all 4 event quantifier linespaces
    def computeLinespaces(self):
        for n in range(4):
            self.eventquantifierlinspaces[n] = self.computeLinespace(n)

    # returns temp and time arrays corresponding to the quantifier source
    # temp might be None if there is no corresponding curve
    @staticmethod
    def quantifier2tempandtime(i):
        temp = None
        if aw.qmc.flagstart or not aw.qmc.flagon:
            timex = aw.qmc.timex
        else:
            timex = aw.qmc.on_timex
        if aw.eventquantifiersource[i] == 0:
            if aw.qmc.flagstart or not aw.qmc.flagon:
                temp = aw.qmc.temp1
            else:
                temp = aw.qmc.on_temp1
        elif aw.eventquantifiersource[i] == 1:
            if aw.qmc.flagstart or not aw.qmc.flagon:
                temp = aw.qmc.temp2
            else:
                temp = aw.qmc.on_temp2
        else:
            x = (aw.eventquantifiersource[i]-2)
            try:
                if aw.qmc.flagstart or not aw.qmc.flagon:
                    timex = aw.qmc.extratimex[x // 2]
                else:
                    timex = aw.qmc.on_extratimex[x // 2]
                if x % 2 == 0:
                    # even
                    if len(aw.qmc.extratemp1) > (x/2):
                        if aw.qmc.flagstart or not aw.qmc.flagon:
                            temp = aw.qmc.extratemp1[x // 2]
                        else:
                            temp = aw.qmc.on_extratemp1[x // 2]
                else:
                    # odd
                    if len(aw.qmc.extratemp2) > (x/2):
                        if aw.qmc.flagstart or not aw.qmc.flagon:
                            temp = aw.qmc.extratemp2[x // 2]
                        else:
                            temp = aw.qmc.on_extratemp2[x // 2]
            except Exception: # pylint: disable=broad-except
                # timex might not have an index x // 2
                pass
        return temp,timex

    # returns min/max 0/(aw.eventsMaxValue / 10) for values outside of the given linespace ls defining the interval
    # note that the value returned is the event value divided by 10, but not with the internal offset of +1 !!
    # otherwise the bin number from [0-self.eventquantifiersteps]
    @staticmethod
    def digitize(v,ls,coarse,i):
        if coarse:
            r = ((numpy.digitize([v],ls)[0] - 1) * 10. + aw.eventslidermin[i]) / 10.
        else:
            r = (numpy.digitize([v],ls)[0]+aw.eventslidermin[i] - 1) / 10.
        return max(aw.eventslidermin[i]/10., min(aw.eventslidermax[i] / 10.,r))

    def curveSimilarity2(self,exp=-1,analysis_starttime=0,analysis_endtime=0): # pylint: disable=no-self-use
        result = {}
        result['mse_BT'] = float('nan')
        result['mse_deltaBT'] = float('nan')
        result['rmse_BT'] = float('nan')
        result['rmse_deltaBT'] = float('nan')
        result['r2_BT'] = float('nan')
        result['r2_deltaBT'] = float('nan')
        result['ror_fcs_act'] = '--'  #not a type issue, prettytable accepts text or number
        result['ror_fcs_delta'] = '--'  #not a type issue, prettytable accepts text or number
        result['ror_max_delta'] = float('nan')
        result['ror_min_delta'] = float('nan')
        result['segmentresultstr'] = ''
        mask = numpy.empty(0)
        fitRoR = '--'  #not a type issue, prettytable accepts text or number
        RoR_FCs_act = '--'  #not a type issue, prettytable accepts text or number
        mse_BT = float('nan')
        mse_deltaBT = float('nan')
        rmse_BT = float('nan')
        rmse_deltaBT = float('nan')
        r2_BT = float('nan')
        r2_deltaBT = float('nan')
        RoR_FCs_delta = '--'  #not a type issue, prettytable accepts text or number
        maxdelta = float('nan')
        mindelta = float('nan')
        try:
            if self.qmc.background:
                analysis_start = aw.qmc.time2index(analysis_starttime)
                analysis_end = aw.qmc.time2index(analysis_endtime) +1 # +1 was added 9/25
                np_bt = numpy.array(aw.qmc.stemp2[analysis_start:analysis_end])
                np_dbt = numpy.array(aw.qmc.delta2[analysis_start:analysis_end])
                #compare to background curve?
                if exp == 4:
                    # create background BT and background delta BT arrays over the interval of interest
                    xarray = numpy.array(aw.qmc.timex[analysis_start:analysis_end])
                    # replace None entries with 0 in the background delta list
                    _delta2B = [0 if x is None else x for x in aw.qmc.delta2B]
                    np_dbtb = numpy.array([self.qmc.timetemparray2temp(aw.qmc.timeB,_delta2B,x) for x in xarray])
                    np_btb = numpy.array([self.qmc.timetemparray2temp(aw.qmc.timeB,aw.qmc.temp2B,x) for x in xarray])
                else:
                    np_btb = numpy.array(aw.qmc.stemp2B[analysis_start:analysis_end])
                    np_dbtb = numpy.array(aw.qmc.delta2B[analysis_start:analysis_end])

                # Replace None values in the Delta curves with the closest numeric value on the right
                def replNone(a,nv):
                    for i in range(len(nv)):
                        if i == len(nv) -1:
                            a[nv[i]] = 0
                        elif a[nv[i]+1] == None:
                            a[nv[i]] = 0
                        else:
                            a[nv[i]] = a[nv[i] +1]
                    return a
                nv = numpy.where(np_dbt == None)[0]
                nvb = numpy.where(np_dbtb == None)[0]
                np_dbt = replNone(np_dbt,nv)
                np_dbtb = replNone(np_dbtb,nvb)

                if len(np_dbt) == 0:
                    raise ValueError('Length of np_dbt is zero')
                if len(np_dbtb) == 0:
                    raise ValueError('Length of np_dbtb is zero')

                #MSE
                mse_BT = numpy.mean(numpy.square(np_bt - np_btb))
                mse_deltaBT = numpy.mean(numpy.square(np_dbt - np_dbtb))

                # RMSE
                rmse_BT = numpy.sqrt(mse_BT)
                rmse_deltaBT = numpy.sqrt(mse_deltaBT)

                # R squared - Coefficient of determination from 0 to 1 (1 is a good result, 0 is not good)
                # residual sum of squares
                ss_res_bt = numpy.sum((np_bt - np_btb) ** 2)
                ss_res_dbt = numpy.sum((np_dbt - np_dbtb) ** 2)
                # total sum of squares
                ss_tot_bt = numpy.sum((np_bt - numpy.mean(np_bt)) ** 2)
                ss_tot_dbt = numpy.sum((np_dbt - numpy.mean(np_dbt)) ** 2)
                # r-squared
                r2_BT = 1 - (ss_res_bt / ss_tot_bt)
                r2_deltaBT = 1 - (ss_res_dbt / ss_tot_dbt)

                # Tests that require FCs is marked
                if aw.qmc.timeindex[2]:
                    # RoR at time of FCs, and Actual RoR versus Template RoR at FCs
                    RoR_FCs_act = aw.qmc.delta2[aw.qmc.timeindex[2]]
                    try:
                        fcs_idx = aw.qmc.timeindex[2]-analysis_start
                        RoR_FCs_delta = RoR_FCs_act - np_dbtb[fcs_idx]
                    except Exception: # pylint: disable=broad-except
                        RoR_FCs_delta = float('nan')

                #max and min difference between actual RoR and template RoR
                maxdelta = numpy.max(np_dbt - np_dbtb)
                mindelta = numpy.min(np_dbt - np_dbtb)

                # calculate the rise, crash and flick
                #create array of differences between actual curve and the fit curve
                deltas_all = numpy.array(np_dbt - np_dbtb, dtype=float)
                #array indicating the actual curve is greater than the fit curve (+1) or is less than (-1)
                signs_all = numpy.sign(deltas_all).astype(int)
                #array with start index of each interval between crossings
                starts = numpy.r_[0, numpy.flatnonzero(~numpy.isclose(signs_all[1:], signs_all[:-1])) + 1.].astype(int)
                #array with the length (number of samples) of each internal between crossings
                lengths = numpy.diff(numpy.r_[starts, len(signs_all)])
                # array of all the time index values
                timeindexs_all = numpy.arange(analysis_start, analysis_end, 1)
                # time indexes of the start of segments
                timeindexs = timeindexs_all[starts]
                # array with all time values
                times_all = numpy.array(aw.qmc.timex[analysis_start:analysis_end])
                # array with start times of segments
                times = times_all[starts]
                # add the ending (DROP) time to use when creating deltatimes
                times = numpy.append(times,times_all[-1])
                # array containing the delta times from segment start to end
                deltatimes = numpy.diff(times)
                #array indicating segment has actual greater than fit (+1) or actual less than fit (-1)
                signs = signs_all[starts]

                #array of max difference for each segment
                maxdeltas = numpy.empty(0)
                for i in range(len(starts)):
                    x = deltas_all[starts[i]:starts[i]+lengths[i]]
                    maxdeltas = numpy.append(maxdeltas,x[abs(x).argmax()])

                # thresholds
                segtimethreshold = aw.qmc.segmentsamplesthreshold * self.qmc.profile_sampling_interval
                segdeltathreshold = aw.qmc.segmentdeltathreshold
                reductions = numpy.zeros_like(signs).astype(int)

                # mark segments that are insignificant and should be combined (reduced) to the left
                for i in range(len(starts)):
                    if deltatimes[i] <= segtimethreshold or abs(maxdeltas[i]) <= segdeltathreshold:
                        reductions[i] = 1

                # extend the reduction to include the sample on the right when its sign matches the sign of the first segment in the reduction
                prevsign = signs[0]
                prevreduction = 0
                reductions[0] = 0  # the first entry is never combined to the left.
                for i in range(1,len(starts)):
                    if reductions[i] == 1:
                        prevreduction = 1
                    elif signs[i] == prevsign and prevreduction == 1:
                        reductions[i] = 1
                    else:
                        prevreduction = 0
                        prevsign = signs[i]

                # generate the reduced segment arrays
                rs_starts = numpy.zeros_like(starts)
                rs_deltatimes = numpy.zeros_like(starts,dtype=float)
                rs_lengths = numpy.zeros_like(starts,dtype=int)
                lasti = 0
                for i in range(0,len(starts)):
                    if reductions[i] == 1 and i+1 < len(starts):
                        rs_lengths[lasti] += lengths[i]
                        rs_deltatimes[lasti] += deltatimes[i]
                    elif reductions[i] == 1 :
                        rs_lengths[lasti] += numpy.sum(lengths[i:])
                        rs_deltatimes[lasti] += numpy.sum(deltatimes[i:])
                    else:
                        rs_starts[i] = starts[i]
                        rs_lengths[i] = lengths[i]
                        rs_deltatimes[i] = deltatimes[i]
                        lasti = i
                mask = numpy.r_[0, numpy.flatnonzero(rs_starts)]
                starts_seg = rs_starts[mask]
                lengths_seg = rs_lengths[mask]
                deltatimes_seg = rs_deltatimes[mask]
                timeindexs_seg = timeindexs[mask]
                maxdeltas_seg = numpy.empty(0)
                for i in range(len(mask)):
                    if i < len(mask) -1:
                        x = maxdeltas[mask[i]:mask[i+1]]
                    else:
                        x = maxdeltas[mask[i]:]
                    maxdeltas_seg = numpy.append(maxdeltas_seg,x[abs(x).argmax()])

                # Per segment metrics
                segment_rmse_deltas = numpy.empty(0) #segment root mean square error (difference)
                segment_mse_deltas = numpy.empty(0)  #segment mean square error (difference)
                segment_abc_deltas = numpy.empty(0)  #segmnt area between the curves
                for i in range(len(starts_seg)):
                    segment_deltas = deltas_all[starts_seg[i]:starts_seg[i]+lengths_seg[i]+1]
                    segment_abs_deltas = numpy.absolute(segment_deltas)
                    segment_rmse_deltas = numpy.append(segment_rmse_deltas, numpy.sqrt(numpy.mean(numpy.square(segment_deltas))))
                    segment_mse_deltas = numpy.append(segment_mse_deltas, numpy.mean(numpy.square(segment_deltas)))
                    segment_times = times_all[starts_seg[i]:starts_seg[i]+lengths_seg[i]+1]
                    segment_abc_deltas = numpy.append(segment_abc_deltas, numpy.trapz(segment_abs_deltas, x=segment_times))

                # interval of interest metrics
                ioi_start = self.eventtime2string(aw.qmc.timex[timeindexs_seg[0]] - aw.qmc.timex[aw.qmc.timeindex[0]])
                ioi_seconds = analysis_endtime - analysis_starttime
                ioi_duration = self.eventtime2string(ioi_seconds)
                ioi_abs_deltas = numpy.absolute(deltas_all)
                ioi_maxdelta = deltas_all[numpy.asarray(ioi_abs_deltas == numpy.amax(ioi_abs_deltas)).nonzero()[0][0]]
                ioi_abc_deltas = numpy.sum(numpy.trapz(ioi_abs_deltas, x=times_all))
                ioi_abcprime = ioi_abc_deltas / ioi_seconds

                # fit RoR in C/min/min
                if exp == 2:
                    fitRoR = 60*(np_dbtb[-1] - np_dbtb[0]) / (aw.qmc.timex[timeindexs_all[-1]] - aw.qmc.timex[timeindexs_all[0]])
                    fitRoR = f'{fitRoR:.2f}'
            else:
                # there is no background
                pass

            # general information
            fitTypes = [QApplication.translate('Label','ln()'),
                        '',
                        QApplication.translate('Label','x') + '\u00b2',
                        QApplication.translate('Label','x') + '\u00b3',
                        QApplication.translate('Label','Bkgnd'), '']
            fitType = fitTypes[exp]
            if aw.qmc.filterDropOuts:
                smoothspikes = QApplication.translate('Label','On')
            else:
                smoothspikes = QApplication.translate('Label','Off')
            if aw.qmc.optimalSmoothing:
                optimal= QApplication.translate('Label','On')
            else:
                optimal = QApplication.translate('Label','Off')
            if aw.qmc.polyfitRoRcalc:
                polyfit = QApplication.translate('Label','On')
            else:
                polyfit = QApplication.translate('Label','Off')

            # build a table of results
            import prettytable  # @UnresolvedImport
            tbl = prettytable.PrettyTable()
            tbl.field_names = [QApplication.translate('Label','Start'),
                               QApplication.translate('Label','Duration'),
                               QApplication.translate('Label','Max Delta'),
                               QApplication.translate('Label','Swing'),
                               QApplication.translate('Label','ABC/secs')  ]
            tbl.float_format = '5.2'
            for i in range(len(mask)):
                thistime = self.eventtime2string(aw.qmc.timex[timeindexs_seg[i]] - aw.qmc.timex[aw.qmc.timeindex[0]])
                duration = self.eventtime2string(deltatimes_seg[i])
                if i > 0:
                    swing = maxdeltas_seg[i] - maxdeltas_seg[i-1]
                else:
                    swing = ''
                abcprime = segment_abc_deltas[i] / deltatimes_seg[i]
                tbl.add_row([thistime, duration, maxdeltas_seg[i], swing, abcprime ])
            if len(mask) > 1:
                tbl.add_row(['~~~~~','~~~~~','~~~~~','~~~~~','~~~~~'])
                tbl.add_row([ioi_start, ioi_duration, ioi_maxdelta, '-', ioi_abcprime ])
            segmentresultstr = QApplication.translate('Label','Segment Analysis (rise, crash and flick)') + '\n'
            segmentresultstr += tbl.get_string(border=True)

            # set background alignment information for Fit to Bkgnd
            if exp == 4:   #background fit
                bgAlignLabel = QApplication.translate('Label','Background Align')
                bgAlignType = aw.qmc.alignnames[aw.qmc.alignEvent]
            else:
                bgAlignLabel = ''
                bgAlignType = ''

            # build table of general information
            tbl2 = prettytable.PrettyTable()
            tbl2.field_names = ['A','A1', 'B', 'B1'  ]
            tbl2.align = 'l'
            tbl2.align['A1'] = 'r'
            tbl2.align['B1'] = 'r'
            tbl2.float_format = '5.2'
            tbl2.add_row([QApplication.translate('Label','Curve Fit'), fitType, bgAlignLabel, bgAlignType])
            tbl2.add_row([QApplication.translate('Label','Samples Threshold'), aw.qmc.segmentsamplesthreshold, QApplication.translate('Label','Delta Threshold'), aw.qmc.segmentdeltathreshold])
            tbl2.add_row([QApplication.translate('Label','Sample rate (secs)'), self.qmc.profile_sampling_interval, QApplication.translate('Label','Smooth Curves/Spikes'), f'{str(int((aw.qmc.curvefilter-1)/2))}/{str(smoothspikes)}' ])
            tbl2.add_row([QApplication.translate('Label','Delta Span/Smoothing'), f'{str(aw.qmc.deltaBTspan)}/{str(int((aw.qmc.deltaBTfilter-1)/2))}', QApplication.translate('Label','Polyfit/Optimal Smoothing'), f'{str(polyfit)}/{str(optimal)}'  ])
            tbl2.add_row([QApplication.translate('Label','Fit RoRoR (C/min/min)'), fitRoR, QApplication.translate('Label','Actual RoR at FCs'), RoR_FCs_act])
            segmentresultstr += '{}{}'.format('\n', tbl2.get_string(border=False,header=False))

            result['segmentresultstr'] = segmentresultstr

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' curveSimilatrity2(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        # build the dict to return
        result['mse_BT'] = mse_BT
        result['mse_deltaBT'] = mse_deltaBT
        result['rmse_BT'] = rmse_BT
        result['rmse_deltaBT'] = rmse_deltaBT
        result['r2_BT'] = r2_BT
        result['r2_deltaBT'] = r2_deltaBT
        result['ror_fcs_act'] = RoR_FCs_act
        result['ror_fcs_delta'] = RoR_FCs_delta
        result['ror_max_delta'] = maxdelta
        result['ror_min_delta'] = mindelta

        return result

    # computes the similarity between BT and backgroundBT as well as ET and backgroundET
    # known as CM (idea by Hungary roasting company Casino Mocca)
    # computes from profile DRY END as set in Phases dialog through DROP
    # returns None in case no similarity can be computed
    # refactored to use numpy arrays.
    def curveSimilarity(self): # pylint: disable=no-self-use
        try:
            # if background profile is loaded and both profiles have a DROP event set
            if aw.qmc.backgroundprofile is not None and aw.qmc.timeindex[6] and aw.qmc.timeindexB[6]:

#                _log.debug(f"curveSimilarity: {self.qmc.profile_sampling_interval=}")  #pylint: disable=logging-fstring-interpolation
#                _log.debug(f"curveSimilarity: {self.qmc.background_profile_sampling_interval=}")  #pylint: disable=logging-fstring-interpolation

                # create arrays using smoothed data if available
                if aw.qmc.stemp1 is not None and len(aw.qmc.stemp1) == len(aw.qmc.temp1):
                    # take smoothed data if available
                    np_et = numpy.array(aw.qmc.stemp1)
                else:
                    np_et = numpy.array(aw.qmc.temp1)
                    _log.debug('curveSimilarity: using non-smoothed ET')
                if aw.qmc.stemp2 is not None and len(aw.qmc.stemp2) == len(aw.qmc.temp2):
                    # take smoothed data if available
                    np_bt = numpy.array(aw.qmc.stemp2)
                else:
                    np_bt = numpy.array(aw.qmc.temp2)
                    _log.debug('curveSimilarity: using non-smoothed BT')

                # CM is based on the Phases Dry not marked Dry
                # Find the DRY point
                # create a view of the original with a stride that accesses it in reverse order
                rev_np_bt = np_bt[::-1]
                # Find TP or if there is not one then find the minimum temp before DROP
                # Note - CHARGE is not considered
                len_bt = len(aw.qmc.stemp2)
                rev_drop_idx = len_bt - aw.qmc.timeindex[6]
                BTlimit = aw.qmc.phases[1]
                if len(rev_np_bt[rev_drop_idx:]) == 0:
                    return None, None
                rev_min_idx = numpy.argmin(rev_np_bt[rev_drop_idx:]) + rev_drop_idx

                if len(rev_np_bt[rev_drop_idx:rev_min_idx]) == 0:
                    return None, None
                # Find the first sample less than the phases DRY temp (going backwards from DROP)
                rev_dry_idx = numpy.argmin(numpy.sign(rev_np_bt[rev_drop_idx:rev_min_idx] - BTlimit))

                # Flip the index to forward looking
                dry_idx = len_bt - (rev_drop_idx + rev_dry_idx)

                # set start and end indexes
                start = dry_idx
                end = aw.qmc.timeindex[6] +1  #the +1 adjusts for Python indexing

                # create arrays from Dry to DROP,
                np_et = np_et[start:end]
                np_bt = np_bt[start:end]
                np_timex = numpy.array(aw.qmc.timex[start:end])

                # diference in time between DROPs in profile and background
                dropTimeDelta = aw.qmc.timex[aw.qmc.timeindex[6]] - aw.qmc.timeB[aw.qmc.timeindexB[6]]

                # these are not the smoothed background temps, which is how the old CM was done
                np_etb = numpy.array(aw.qmc.temp1B)
                np_btb = numpy.array(aw.qmc.temp2B)
                np_timeB = numpy.array(aw.qmc.timeB) + dropTimeDelta

                # hack to work like OLD method where any temp before timeB[0] is -1
                np_etb = numpy.insert(np_etb,0,-1)
                np_btb = numpy.insert(np_btb,0,-1)
                np_timeB = numpy.insert(np_timeB,0,np_timeB[0]-0.1)

                interp_np_etb = numpy.interp(np_timex,np_timeB,np_etb)
                interp_np_btb = numpy.interp(np_timex,np_timeB,np_btb)

                det = numpy.sqrt(numpy.mean(numpy.square(np_et - interp_np_etb)))
                dbt = numpy.sqrt(numpy.mean(numpy.square(np_bt - interp_np_btb)))

                if numpy.isnan(det):
                    det = None
                if numpy.isnan(dbt):
                    dbt = None

                return det,dbt

            # no DROP event registered
            return None, None
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' curveSimilatrity(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return None, None

    def setLCDsDigitCount(self,n):
        self.lcd2.setDigitCount(n)
        self.lcd2.setMinimumWidth(n*16)
        self.lcd3.setDigitCount(n)
        self.lcd3.setMinimumWidth(n*16)
        self.lcd4.setDigitCount(n)
        self.lcd4.setMinimumWidth(n*16)
        self.lcd5.setDigitCount(n)
        self.lcd5.setMinimumWidth(n*16)
        self.lcd6.setDigitCount(n)
        self.lcd6.setMinimumWidth(n*16)
        self.lcd7.setDigitCount(n)
        self.lcd7.setMinimumWidth(n*16)
        for i in range(self.nLCDS):
            self.extraLCD1[i].setDigitCount(n)
            self.extraLCD1[i].setMinimumWidth(n*16)
            self.extraLCD2[i].setDigitCount(n)
            self.extraLCD2[i].setMinimumWidth(n*16)
        #
        if not aw.qmc.flagon:
            if self.qmc.LCDdecimalplaces:
                zz = '-.-'
            else:
                zz = '--'
            self.lcd2.display(zz)
            self.lcd3.display(zz)
            self.lcd4.display(zz)
            self.lcd5.display(zz)
            self.lcd6.display(zz)
            self.lcd7.display(zz)
            for i in range(self.nLCDS):
                self.extraLCD1[i].display(zz)
                self.extraLCD2[i].display(zz)
        #
        if aw.largeLCDs_dialog:
            aw.largeLCDs_dialog.updateDecimals()
        if aw.largeDeltaLCDs_dialog:
            aw.largeDeltaLCDs_dialog.updateDecimals()
        if aw.largePIDLCDs_dialog:
            aw.largePIDLCDs_dialog.updateDecimals()
        if aw.largeExtraLCDs_dialog:
            aw.largeExtraLCDs_dialog.updateDecimals()

    def ArtisanLCD(self):
        lcd = MyQLCDNumber()
        lcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        lcd.setFrameStyle(QFrame.Shadow.Plain)
        lcd.setSmallDecimalPoint(False)
        lcd.setMinimumHeight(35)
        x = 16
        if self.qmc.LCDdecimalplaces:
            lcd.setDigitCount(5) # default is 5
            lcd.setMinimumWidth(5*x)
            lcd.setMaximumWidth(5*x)
        else:
            lcd.setDigitCount(3) # default is 5
            lcd.setMinimumWidth(3*x)
            lcd.setMaximumWidth(3*x)
        return lcd

    def releaseSliderFocus(self):
        for s in [self.slider1,self.slider2,self.slider3,self.slider4]:
            s.releaseKeyboard()
            s.clearFocus()

    # set slider focus to Qt.FocusPolicy.StrongFocus to allow keyboard control and
    # Qt.FocusPolicy.NoFocus to deactivate it
    def setSliderFocusPolicy(self,focus):
        if bool(aw.eventslidervisibilities[0]):
            self.slider1.setFocusPolicy(focus)
        else:
            self.slider1.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider1.clearFocus()
        if bool(aw.eventslidervisibilities[1]):
            self.slider2.setFocusPolicy(focus)
        else:
            self.slider2.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider2.clearFocus()
        if bool(aw.eventslidervisibilities[2]):
            self.slider3.setFocusPolicy(focus)
        else:
            self.slider3.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider3.clearFocus()
        if bool(aw.eventslidervisibilities[3]):
            self.slider4.setFocusPolicy(focus)
        else:
            self.slider4.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider4.clearFocus()

    def setFonts(self, redraw=True):
        # try to select the right font for matplotlib according to the given locale and platform
        if self.qmc.graphfont == 0:
            try:
                rcParams['axes.unicode_minus'] = True
                rcParams['font.size'] = 12.0
                if platf == 'Darwin':
                    mpl.rcParams['font.family'] = 'Arial Unicode MS'
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                elif platf == 'Linux':
                    if self.locale_str == 'ar':
                        mpl.rcParams['font.family'] = ['DejaVu Sans','DejaVu Sans Mono','Times New Roman']
                    elif self.locale_str == 'ja':
                        mpl.rcParams['font.family'] = ['TakaoPGothic']
                    elif self.locale_str == 'el':
                        mpl.rcParams['font.family'] = ['DejaVu Sans','DejaVu Sans Mono']
                    elif self.locale_str == 'zh_CN':
                        mpl.rcParams['font.family'] = ['NanumGothic','DejaVu Sans Mono']
                    elif self.locale_str == 'zh_TW':
                        mpl.rcParams['font.family'] = ['NanumGothic','DejaVu Sans Mono']
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                else: # Windows:
                    mpl.rcParams['font.family'] = ['Microsoft Sans Serif', 'Arial'] # works for Greek and Arabic
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                    # for asian languages on Windows we have to set the parameters directly to *.ttc fonts (mpl supports only *.ttf)
                    if self.locale_str == 'ja':
                        aw.set_mpl_fontproperties('C:\\Windows\\Fonts\\MSGOTHIC.ttc')
                    elif self.locale_str == 'zh_CN':
                        aw.set_mpl_fontproperties('C:\\Windows\\Fonts\\simsun.ttc')
                    elif self.locale_str == 'zh_TW':
                        aw.set_mpl_fontproperties('C:\\Windows\\Fonts\\mingliu.ttc')
                    elif self.locale_str == 'ko':
                        aw.set_mpl_fontproperties('C:\\Windows\\Fonts\\batang.ttc')
#                    elif self.locale_str == "ar":
#                        mpl.rcParams['font.family'] = "TraditionalArabic"
#                        self.mpl_fontproperties = mpl.font_manager.FontProperties()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        elif self.qmc.graphfont == 3: # WenQuanYi Zen Hei
            # font WenQuanYi selected
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['WenQuanYi Zen Hei']
            rcParams['axes.unicode_minus'] = False
#            aw.set_mpl_fontproperties(self.getResourcePath() + "wqy-zenhei.ttc") # .ttc fonts are not supported yet by the PDF backend
            aw.set_mpl_fontproperties(getResourcePath() + 'WenQuanYiZenHei-01.ttf')
        elif self.qmc.graphfont == 4: # Source Han Sans (CN, TW, HK, KR, JP)
            # font Source Han Sans selected, Simplified Chinese
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans CN']
            aw.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansCN-Regular.otf')
        elif self.qmc.graphfont == 5: # Source Han Sans (CN, TW, HK, KR, JP)
            # font Source Han Sans selected, Traditional Chinese, Taiwan
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans TW']
            aw.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansTW-Regular.otf')
        elif self.qmc.graphfont == 6: # Source Han Sans (CN, TW, HK, KR, JP)
            # font Source Han Sans selected, Traditional Chinese, Hong Kong
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans HK']
            aw.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansHK-Regular.otf')
        elif self.qmc.graphfont == 7: # Source Han Sans (CN, TW, HK, KR, JP)
            # font Source Han Sans selected, Korean
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans KR']
            aw.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansKR-Regular.otf')
        elif self.qmc.graphfont == 8: # Source Han Sans (CN, TW, HK, KR, JP)
            # font Source Han Sans selected, Japanese
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans JP']
            aw.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansJP-Regular.otf')
        elif self.qmc.graphfont == 9:
            # font Dijkstra selected
            rcParams['font.size'] = 10.0
            rcParams['font.family'] = ['Dijkstra']
            rcParams['axes.unicode_minus'] = False
            aw.set_mpl_fontproperties(getResourcePath() + 'dijkstra.ttf')
        elif self.qmc.graphfont == 1 or platf == 'Linux': # no Comic on Linux!
            # font Humor selected
            rcParams['axes.unicode_minus'] = False
            rcParams['font.size'] = 16.0
            if platf == 'Linux':
                rcParams['font.family'] = ['Humor Sans']
            else:
                rcParams['font.family'] = ['Humor Sans', 'Comic Sans MS']
            aw.set_mpl_fontproperties(getResourcePath() + 'Humor-Sans.ttf')
        elif self.qmc.graphfont == 2 and not platf == 'Linux':
            # font Comic selected
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Comic Sans MS','Humor Sans']
            self.mpl_fontproperties = mpl.font_manager.FontProperties()
        if redraw:
            self.qmc.redraw(recomputeAllDeltas=False)

    def set_mpl_fontproperties(self,fontpath):
        if os.path.exists(fontpath):
            mpl.font_manager.fontManager.addfont(fontpath)
            self.mpl_fontproperties = mpl.font_manager.FontProperties(fname=fontpath)

    # trims arabic strings to be rendered correctly with unicode fonts if arabic locale is active
    # if s is a QString with one {0} placeholder and a is an argument, the argument is reversed, and then the whole string result is reversed
    # if it contains any arabic characters
    def arabicReshape(self,s,a=None):
        if self.locale_str == 'ar':
            st = str(s)
            if artisanlib.arabic_reshaper.has_arabic_letters(st):
                if a:
                    return artisanlib.arabic_reshaper.reshape(str(s.format(a[::-1])))[::-1]
                return artisanlib.arabic_reshaper.reshape(st)[::-1]
            if a:
                return s.format(a)
            return s
        if self.locale_str == 'he':
            if a:
                return s[::-1].format(a[::-1])
            return s[::-1]
        if a:
            return s.format(a)
        return s

    @staticmethod
    def makePhasesLCDbox(label, lcd):
        label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        lcd.setMinimumHeight(30)
        lcd.setMinimumWidth(80)  # NOTE: with minimumWidth 84 the lcds not always fit in on Mac, 80 works! Better to keep at default.
        lcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        lcd.setFrameStyle(QFrame.Shadow.Plain)
        lcd.setNumDigits(6)
        lcd.setLineWidth(0)
        lcd.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        LCDVbox = QVBoxLayout()
        LCDVbox.addWidget(label)
        LCDVbox.addWidget(lcd)
        LCDVbox.addSpacing(5)
        LCDVbox.setSpacing(0)
        LCDVbox.setContentsMargins(0, 0, 0, 0)
        frame.setStyleSheet('QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}')
#        frame.setFrameShadow(QFrame.Shadow.Sunken)
#        frame.setLineWidth(1)
#        frame.setFrameShape(QFrame.Shape.Panel)
        frame.setLayout(LCDVbox)

        return frame

    def updateAUCLCD(self):
        try:
            auc_value_str = '---'
            auc_style = 'QLCDNumber { color: black; }'
            if ((aw.qmc.AUCbegin == 0 and aw.qmc.timeindex[0] > -1) or
                (aw.qmc.AUCbegin == 1 and aw.qmc.TPalarmtimeindex) or
                (aw.qmc.AUCbegin == 2 and self.qmc.timeindex[1] > 0) or
                (aw.qmc.AUCbegin == 3 and self.qmc.timeindex[2] > 0)):
                if aw.qmc.AUCLCDmode == 0: # AUC abs value
                    v = int(round(aw.qmc.AUCvalue))
                    if v > 9999:
                        auc_value_str = '--'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                    auc_style = 'QLCDNumber { color: black; }'
                elif aw.qmc.AUCLCDmode == 1: # AUC delta to target/background
                    if aw.qmc.AUCtargetFlag and aw.qmc.backgroundprofile is not None and aw.qmc.AUCbackground > 0:
                        # background AUC as target
                        target = aw.qmc.AUCbackground
                    else:
                        # use target AUC as specified by the user
                        target = aw.qmc.AUCtarget
                    d = aw.qmc.AUCvalue-target
                    if d < 0:
                        # too low => blue
                        auc_style = 'QLCDNumber { color: blue; }'
                    else:
                        # too high => red
                        auc_style = 'QLCDNumber { color: red; }'
                        self.AUClabel.setText('<small><b>' + QApplication.translate('Label', 'AUC') + '&laquo;</b></small>')
                    v = abs(int(round(d)))
                    if v > 9999:
                        auc_value_str = '--'
                        auc_style = 'QLCDNumber { color: black; }'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                elif aw.qmc.timeindex[2] > 0: # AUC since FCs
                    v = int(round(aw.qmc.AUCsinceFCs))
                    if v > 9999:
                        auc_value_str = '--'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                    auc_style = 'QLCDNumber { color: black; }'
                else:
                    self.AUClcd.setNumDigits(3)
                    auc_value_str = '--'
                    auc_style = 'QLCDNumber { color: black; }'
            self.AUClcd.display(auc_value_str)
            self.AUClcd.setStyleSheet(auc_style)
            if aw.LargePhasesLCDsFlag and aw.largePhasesLCDs_dialog:
                aw.largePhasesLCDs_dialog.updateValues([None,None],[None,auc_value_str])
                aw.largePhasesLCDs_dialog.updateAUCstyle(auc_style)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' updateAUCLCD(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # returns multiple results on the current state of the phases:
    #  TP, TPlabel, DRY, DRY, FCs, FCslabel
    #  TP2DRYlabel, DRY2FCslabel
    #  TP2DRYframeTooltip
    #  DRY2FCsframeTooltip
    #  phasesLCDsTooltip
    # all are returning strings with the actual values or None if values did not change
    def getPhasesLCDsData(self):
        TP = TPlabel = DRY = DRYlabel = FCs = FCslabel = TP2DRYlabel = DRY2FCslabel = TP2DRYframeTooltip = DRY2FCsframeTooltip = phasesLCDsTooltip = None
        try:
            if self.qmc.timex: # requires at least some recordings
                window_width = aw.width()
                if aw.qmc.LCDdecimalplaces:
                    fmtstr = '%.1f'
                else:
                    fmtstr = '%.0f'
                tx = self.qmc.timex[-1]
                if self.qmc.timeindex[0]:
                    chrg = self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    chrg = 0
                if self.qmc.timeindex[6]: # after drop
                    totaltime = self.qmc.timex[self.qmc.timeindex[6]] - chrg
                else: # before drop
                    totaltime = tx - chrg

                if self.qmc.backgroundprofile is not None and self.qmc.timeindexB[1] and not aw.qmc.autoDRYflag: # with AutoDRY, we always use the set DRY phase temperature as target
                    drytarget = self.qmc.temp2B[self.qmc.timeindexB[1]] # Background DRY BT temperature
                else:
                    drytarget = self.qmc.phases[1] # Drying max phases definition

                if aw.qmc.phasesLCDmode_all[2] and self.qmc.timeindex[1] and self.qmc.timeindex[2]: # DRY and FCs
                    # show all finish phase values: time/percent/temp
                    # FIN phase temp on LCD1
                    # FIN phase time on LCD2
                    # FIN phase percentage on LCD3
                    phasesLCDsTooltip = QApplication.translate('Tooltip','Phase LCDs\nCurrently in ALL FINISHING MODE')
                    if self.qmc.timeindex[6]: # after drop
                        ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                    else: # before drop
                        ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                    DRY2FCsframeTooltip = QApplication.translate('Label','ALL FINISHING MODE')
                    TPlabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                    #time
                    TP = stringfromseconds(ts,leadingzero=False)
                    #temp
                    if self.qmc.timeindex[6]: # after drop
                        dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                    else:
                        dBT = self.qmc.temp2[-1]
                    dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[2]])
                    DRYlabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                    DRY = dBT + self.qmc.mode
                    #percentage
                    if totaltime:
                        finishphaseP = fmtstr%(ts*100./totaltime)
                    else:
                        finishphaseP = ' --- '
                    if not aw.qmc.LCDdecimalplaces and totaltime:
                        finishphaseP += ' '
                    FCslabel = QApplication.translate('Label', 'DEV%')
                    FCs = finishphaseP
                    # DRY2FCs
                    if  window_width > 950 and self.qmc.timeindex[1]:
                        t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                        DRY2FCslabel = stringfromseconds(t,leadingzero=False)
                    else:
                        DRY2FCslabel = ''
                else:
                    # show the regular phases LCD values split by phase

                    # 1st PhaseLCD: TP
                    if aw.qmc.phasesLCDmode == 0: # time mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip','Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TIME MODE')
                        TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                        if self.qmc.flagon:
                            TP_index = self.qmc.TPalarmtimeindex
                        else:
                            TP_index = self.findTP()
                        if TP_index and TP_index < len(self.qmc.timex):
                            # after TP
                            if self.qmc.timeindex[6]:
                                ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[TP_index]
                            else:
                                ts = tx - self.qmc.timex[TP_index]
                            tss = stringfromseconds(ts,leadingzero=False)
                            TP = tss
                        else:
                            # before TP
                            TP = '--:--'
                    elif aw.qmc.phasesLCDmode == 1: # percentage mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip','Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in PERCENTAGE MODE')
                        TPlabel = QApplication.translate('Label', 'DRY%')
                        if self.qmc.timeindex[1]: # after DRY
                            ts = self.qmc.timex[self.qmc.timeindex[1]] - chrg
                            if totaltime:
                                dryphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                dryphaseP = ' --- '
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                dryphaseP += ' '
                            TP = dryphaseP
                        else:
                            TP = ' --- '
                    elif aw.qmc.phasesLCDmode == 2: # temp mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip','Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TEMP MODE')
                        TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                        if self.qmc.flagon:
                            TP_index = self.qmc.TPalarmtimeindex
                        else:
                            TP_index = self.findTP()
                        if TP_index:
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[TP_index])
                            TP = dBT + self.qmc.mode
                        else:
                            # before TP
                            TP = ' --- '

                    # 2nd PhaseLCD: DRY
                    if self.qmc.timeindex[1]:
                        # after DRY
                        if self.qmc.timeindex[6]:
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[1]]
                        else:
                            ts = tx - self.qmc.timex[self.qmc.timeindex[1]]
                        if aw.qmc.phasesLCDmode == 0: # time mode
                            TP2DRYframeTooltip = QApplication.translate('Label','TIME MODE')
                            DRYlabel = QApplication.translate('Label', 'DRY') + '&raquo;'
                            DRY = stringfromseconds(ts,leadingzero=False)
                        elif aw.qmc.phasesLCDmode == 1: # percentage mode
                            TP2DRYframeTooltip = QApplication.translate('Label','PERCENTAGE MODE')
                            if self.qmc.timeindex[2]:
                                ts = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            if totaltime:
                                midphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                midphaseP = ' --- '
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                midphaseP += ' '
                            DRYlabel = QApplication.translate('Label', 'RAMP%')
                            DRY = midphaseP
                        elif aw.qmc.phasesLCDmode == 2: # temp mode
                            TP2DRYframeTooltip = QApplication.translate('Label','TEMP MODE')
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[1]])
                            DRYlabel = QApplication.translate('Label', 'DRY') + '&raquo;'
                            DRY = dBT + self.qmc.mode
                        # TP2DRY
                        if window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = self.qmc.timex[self.qmc.timeindex[1]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                            TP2DRYlabel = stringfromseconds(t,leadingzero=False)
                        else:
                            TP2DRYlabel = ''
                    else:
                        # before DRY
                        dryexpectedtime = None
                        if aw.qmc.phasesLCDmode == 2:
                            DRYlabel = '&darr;' + QApplication.translate('Label', 'DRY')
                        else:
                            DRYlabel = '&raquo;' + QApplication.translate('Label', 'DRY')
                        if self.qmc.timeindex[0] > -1 and self.qmc.TPalarmtimeindex and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            # display expected time to reach DRY as defined in the background profile or the phases dialog
                            if drytarget > self.qmc.temp2[-1]:
                                dryexpectedtime = (drytarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                                if aw.qmc.phasesLCDmode == 2:
                                    tstring = stringfromseconds(dryexpectedtime,leadingzero=False)
                                else:
                                    tstring = stringfromseconds(tx - self.qmc.timex[self.qmc.timeindex[0]] + dryexpectedtime,leadingzero=False)
                                DRY = tstring
                            else:
                                DRY = '--:--'
                        else:
                            DRY = '--:--'

                        # TP2DRY (display estimated time between TP and DRY)
                        if dryexpectedtime and window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = tx - self.qmc.timex[self.qmc.TPalarmtimeindex] + dryexpectedtime # time after TP plus expected-time-to-DRY = total time expected for 1st phase
                            if t > 3600:
                                TP2DRYlabel = ''
                            else:
                                TP2DRYlabel = stringfromseconds(t,leadingzero=False)
                        else:
                            TP2DRYlabel = ''

                    # 3rd PhasesLCD: FCs
                    if self.qmc.timeindex[2]:
                        # after FCs
                        if self.qmc.timeindex[6]: # after drop
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                        else: # before drop
                            ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                        if aw.qmc.phasesLCDmode == 0: # time mode
                            DRY2FCsframeTooltip = QApplication.translate('Label','TIME MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','TIME MODE')
                            FCslabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                            FCs = stringfromseconds(ts,leadingzero=False)
                        elif aw.qmc.phasesLCDmode == 1: # percentage mode
                            DRY2FCsframeTooltip = QApplication.translate('Label','PERCENTAGE MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','PERCENTAGE MODE')
                            FCslabel = QApplication.translate('Label', 'DEV%')
                            if totaltime:
                                finishphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                finishphaseP = ' --- '
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                finishphaseP += ' '
                            FCs = finishphaseP
                        elif aw.qmc.phasesLCDmode == 2: # temp mode
                            DRY2FCsframeTooltip = QApplication.translate('Label','TEMP MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','TEMP MODE')
                            FCslabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[2]])
                            FCs = dBT + self.qmc.mode
                        # DRY2FCs
                        if  window_width > 950 and self.qmc.timeindex[1]:
                            t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            DRY2FCslabel = stringfromseconds(t,leadingzero=False)
                        else:
                            DRY2FCslabel = ''
                    else:
                        # before FCs
                        fcsexpectedtime = None
                        if aw.qmc.phasesLCDmode == 0:
                            DRY2FCsframeTooltip = QApplication.translate('Label','TIME MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','TIME MODE')
                            FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                        elif aw.qmc.phasesLCDmode == 1:
                            DRY2FCsframeTooltip = QApplication.translate('Label','PERCENTAGE MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','PERCENTAGE MODE')
                            FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                        elif aw.qmc.phasesLCDmode == 2:
                            DRY2FCsframeTooltip = QApplication.translate('Label','TEMP MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label','TEMP MODE')
                            FCslabel = '&darr;' + QApplication.translate('Label', 'FCs')
                        if self.qmc.timeindex[0] > -1 and (self.qmc.timeindex[1] or (drytarget <= self.qmc.temp2[-1])) and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            ## after DRY:
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.qmc.backgroundprofile is not None and self.qmc.timeindexB[2]:
                                fcstarget = self.qmc.temp2B[self.qmc.timeindexB[2]] # Background FCs BT temperature
                            else:
                                fcstarget = self.qmc.phases[2] # FCs min phases definition
                            if fcstarget > self.qmc.temp2[-1]:
                                fcsexpectedtime = (fcstarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                                if aw.qmc.phasesLCDmode == 2:
                                    tstring = stringfromseconds(fcsexpectedtime, leadingzero=False)
                                else:
                                    tstring = stringfromseconds(tx - self.qmc.timex[self.qmc.timeindex[0]] + fcsexpectedtime, leadingzero=False)
                                FCs = tstring
                            else:
                                FCs = '--:--'
                        else:
                            FCs = '--:--'

                        # DRY2FCs (display estimated time between DRY and FCs)
                        if fcsexpectedtime and window_width > 950 and self.qmc.timeindex[1]:
                            t = tx - self.qmc.timex[self.qmc.timeindex[1]] + fcsexpectedtime # time after DRY plus expected-time-to-FCs = total time expected for 2nd phase
                            DRY2FCslabel =stringfromseconds(t, leadingzero=False)
                        else:
                            DRY2FCslabel = ''
            else:
                if aw.qmc.phasesLCDmode == 0: # time mode
                    TP = '--:--'
                    TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                elif aw.qmc.phasesLCDmode == 1: # percentage mode
                    TP = ' --- '
                    TPlabel = QApplication.translate('Label', 'DRY%')
                elif aw.qmc.phasesLCDmode == 2: # temp mode
                    TP = ' --- '
                    TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                DRYlabel = '&raquo;' + QApplication.translate('Label', 'DRY')
                FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                TP2DRYlabel = ''
                DRY2FCslabel = ''
                DRY =  '--:--'
                FCs = '--:--'
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' updatePhasesLCDs() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return TP,TPlabel,DRY,DRYlabel,FCs,FCslabel,TP2DRYlabel,DRY2FCslabel,TP2DRYframeTooltip,DRY2FCsframeTooltip,phasesLCDsTooltip


    def updatePhasesLCDs(self):
        try:
            if aw.qmc.phasesLCDflag or aw.LargePhasesLCDsFlag:
                TP,TPlabel,DRY,DRYlabel,FCs,FCslabel,TP2DRYlabel,DRY2FCslabel,TP2DRYframeTooltip,DRY2FCsframeTooltip,phasesLCDsTooltip = self.getPhasesLCDsData()

                if aw.qmc.phasesLCDflag:
                    label_fmt = '<small><b>{}</b></small>'
                    #
                    if TP is not None:
                        self.TPlcd.display(TP)
                    if DRY is not None:
                        self.DRYlcd.display(DRY)
                    if FCs is not None:
                        self.FCslcd.display(FCs)
                    #
                    if TPlabel is not None:
                        self.TPlabel.setText(label_fmt.format(TPlabel))
                    if DRYlabel is not None:
                        self.DRYlabel.setText(label_fmt.format(DRYlabel))
                    if FCslabel is not None:
                        self.FCslabel.setText(label_fmt.format(FCslabel))
                    #
                    if TP2DRYlabel is not None:
                        self.TP2DRYlabel.setText(TP2DRYlabel)
                        if TP2DRYlabel == '':
                            width = 0
                        else:
                            width = self.TP2DRYlabel.fontMetrics().boundingRect('88:::88').width()
                        self.TP2DRYlabel.setMinimumWidth(width)
                    if DRY2FCslabel is not None:
                        self.DRY2FCslabel.setText(DRY2FCslabel)
                        if DRY2FCslabel == '':
                            width = 0
                        else:
                            width = self.DRY2FCslabel.fontMetrics().boundingRect('88:::88').width()
                        self.DRY2FCslabel.setMinimumWidth(width)
                    #
                    if TP2DRYframeTooltip is not None:
                        self.TP2DRYframe.setToolTip(TP2DRYframeTooltip)
                    if DRY2FCsframeTooltip is not None:
                        self.DRY2FCsframe.setToolTip(DRY2FCsframeTooltip)
                    if phasesLCDsTooltip is not None:
                        self.phasesLCDs.setToolTip(phasesLCDsTooltip)

                if aw.LargePhasesLCDsFlag:
                    # update large phases LCDs
                    try:
                        if aw.largePhasesLCDs_dialog is not None:
                            values1 = [TP, FCs] # TP and FCs phase LCDs
                            values2 = [DRY, None] # DRY phase and AUC LCDs
                            aw.largePhasesLCDs_dialog.updateValues(values1,values2)
                            aw.largePhasesLCDs_dialog.updatePhasesLabels([TPlabel,DRYlabel,FCslabel,None])
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' updatePhasesLCDs() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def makeLCDbox(label, lcd, lcdframe):
        LCDbox = QVBoxLayout()
        LCDbox.setSizeConstraint(QLayout.SizeConstraint.SetFixedSize)
        LCDbox.setSpacing(0)
        LCDbox.addWidget(label)
        LCDhBox = QHBoxLayout()
        LCDhBox.addStretch()
        LCDhBox.addWidget(lcd)
        LCDbox.addLayout(LCDhBox)
        LCDhBox.setContentsMargins(0, 0, 0, 0)
        LCDbox.setContentsMargins(0, 0, 0, 0)
        lcdframe.setContentsMargins(0, 10, 0, 3)
        lcdframe.setLayout(LCDbox)
        return lcdframe

    @staticmethod
    def setSliderNumber(lcd, v):
        if v < 10:
            lcd.setNumDigits(1)
        elif v > 99:
            lcd.setNumDigits(3)
        else:
            lcd.setNumDigits(2)
        lcd.display(v)

    def updateSliderLCD(self, n, v):
        if n == 0:
            self.setSliderNumber(self.sliderLCD1,v)
        elif n == 1:
            self.setSliderNumber(self.sliderLCD2,v)
        elif n == 2:
            self.setSliderNumber(self.sliderLCD3,v)
        elif n == 3:
            self.setSliderNumber(self.sliderLCD4,v)

    @pyqtSlot(int)
    def updateSVSliderLCD(self,v):
        if v > aw.pidcontrol.svSliderMax:
            v = aw.pidcontrol.svSliderMax
        if v < aw.pidcontrol.svSliderMin:
            v = aw.pidcontrol.svSliderMin
        self.sliderLCDSV.display(v)
        if self.SVslidermoved:
            if self.sliderLCDSV.intValue() != self.sliderSV.value():
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
                self.sliderSV.setValue(self.sliderLCDSV.intValue())
            self.sliderSVreleased()
            self.SVslidermoved = 0

    @pyqtSlot(int)
    def sliderSVactionTriggered(self,n):
        if n in [
                    1, 2, 3, 4,
#                    QAbstractSlider.SliderAction.SliderSingleStepAdd,
#                    QAbstractSlider.SliderAction.SliderSingleStepSub,
#                    QAbstractSlider.SliderAction.SliderPageStepAdd,
#                    QAbstractSlider.SliderAction.SliderPageStepSub
                ]: # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.SVslidermoved = 1

    @pyqtSlot()
    def sliderSVreleased(self):
        try:
            if aw.qmc.device == 0:
                aw.fujipid.setsv(self.sliderSV.value(),silent=True)
            else:
                aw.pidcontrol.setSV(self.sliderSV.value(),False)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # if setValue=False, the slider is only moved without a change signal being issued
    def moveSVslider(self, v:float, setValue:bool=True):
        v = int(round(v))
        if aw.pidcontrol.svSlider:
            if setValue:
                self.sliderSV.setValue(v)
            else:
                self.sliderSV.setSliderPosition(v)

    # NOTE on those slider signals:
    # there are different ways to move the sliders
    # - by click into the slider bar
    # - by drag and release the slider handle
    # - by using the up/down cursor keys or page up/down keys
    # - using the Artisan slider shortcuts via keys Q, W, E, R
    # - using an Artisan Command (eg. via an alarm)
    # - programmatically (PID)
    # The drag-and-release action (at least on Mac OS X) in some cases triggers
    # a valueChanged signal short after fetching the handle and before moving it.
    # To avoid the generation of an additional event with an event value close to the last one, the eventslidermoved variable has been added.
    # It is set after a slider move. If it is not set, only value changes above a certain limit (here 3) are accepted.

    # the following are only needed with the slider tracking off work around:
#    @pyqtSlot(int)
#    def slider1Moved(self,v):
#        self.eventslidermoved[0]=1
#        self.updateSliderLCD(0,v)
#    @pyqtSlot(int)
#    def slider2Moved(self,v):
#        self.eventslidermoved[1]=1
#        self.updateSliderLCD(1,v)
#    @pyqtSlot(int)
#    def slider3Moved(self,v):
#        self.eventslidermoved[2]=1
#        self.updateSliderLCD(2,v)
#    @pyqtSlot(int)
#    def slider4Moved(self,v):
#        self.eventslidermoved[3]=1
#        self.updateSliderLCD(3,v)

# required for the default tracking sliders
    @pyqtSlot()
    def slider1released(self):
        self.sliderReleased(0,force=True,updateLCD=False)
    @pyqtSlot()
    def slider2released(self):
        self.sliderReleased(1,force=True,updateLCD=False)
    @pyqtSlot()
    def slider3released(self):
        self.sliderReleased(2,force=True,updateLCD=False)
    @pyqtSlot()
    def slider4released(self):
        self.sliderReleased(3,force=True,updateLCD=False)

# required for the default tracking sliders
    @pyqtSlot(int)
    def updateSlider1LCD(self,v):
        if aw.eventslidercoarse[0]:
            v = int(round(v / 10.))*10
        self.updateSliderLCD(0,v)
        if self.eventslidermoved[0]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD1.intValue() != self.slider1.value():
                self.slider1.setValue(self.sliderLCD1.intValue())
            self.slider1released()
            self.eventslidermoved[0] = 0
    @pyqtSlot(int)
    def updateSlider2LCD(self,v):
        if aw.eventslidercoarse[1]:
            v = int(round(v / 10.))*10
        self.updateSliderLCD(1,v)
        if self.eventslidermoved[1]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD2.intValue() != self.slider2.value():
                self.slider2.setValue(self.sliderLCD2.intValue())
            self.slider2released()
            self.eventslidermoved[1] = 0
    @pyqtSlot(int)
    def updateSlider3LCD(self,v):
        if aw.eventslidercoarse[2]:
            v = int(round(v / 10.))*10
        self.updateSliderLCD(2,v)
        if self.eventslidermoved[2]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD3.intValue() != self.slider3.value():
                self.slider3.setValue(self.sliderLCD3.intValue())
            self.slider3released()
            self.eventslidermoved[2] = 0
    @pyqtSlot(int)
    def updateSlider4LCD(self,v):
        if aw.eventslidercoarse[3]:
            v = int(round(v / 10.))*10
        self.updateSliderLCD(3,v)
        if self.eventslidermoved[3]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD4.intValue() != self.slider4.value():
                self.slider4.setValue(self.sliderLCD4.intValue())
            self.slider4released()
            self.eventslidermoved[3] = 0

# required for simulating slider tracking via sliderMove events to work around an issue of certain PyQt5 variants
#    @pyqtSlot(int)
#    def slider1valueChanged(self,_):
#        self.sliderReleased(0,updateLCD=True)
#    @pyqtSlot(int)
#    def slider2valueChanged(self,_):
#        self.sliderReleased(1,updateLCD=True)
#    @pyqtSlot(int)
#    def slider3valueChanged(self,_):
#        self.sliderReleased(2,updateLCD=True)
#    @pyqtSlot(int)
#    def slider4valueChanged(self,_):
#        self.sliderReleased(3,updateLCD=True)

    @pyqtSlot(int)
    def slider1actionTriggered(self,n):
        if n in [
                    1, 2, 3, 4,
#                    QAbstractSlider.SliderAction.SliderSingleStepAdd,
#                    QAbstractSlider.SliderAction.SliderSingleStepSub,
#                    QAbstractSlider.SliderAction.SliderPageStepAdd,
#                    QAbstractSlider.SliderAction.SliderPageStepSub
                ]: # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.eventslidermoved[0]=1
    @pyqtSlot(int)
    def slider2actionTriggered(self,n):
        if n in [
                    1, 2, 3, 4,
#                    QAbstractSlider.SliderAction.SliderSingleStepAdd,
#                    QAbstractSlider.SliderAction.SliderSingleStepSub,
#                    QAbstractSlider.SliderAction.SliderPageStepAdd,
#                    QAbstractSlider.SliderAction.SliderPageStepSub
                ]: # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.eventslidermoved[1]=1
    @pyqtSlot(int)
    def slider3actionTriggered(self,n):
        if n in [
                    1, 2, 3, 4,
#                    QAbstractSlider.SliderAction.SliderSingleStepAdd,
#                    QAbstractSlider.SliderAction.SliderSingleStepSub,
#                    QAbstractSlider.SliderAction.SliderPageStepAdd,
#                    QAbstractSlider.SliderAction.SliderPageStepSub
                ]: # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.eventslidermoved[2]=1
    @pyqtSlot(int)
    def slider4actionTriggered(self,n):
        if n in [
                    1, 2, 3, 4,
#                    QAbstractSlider.SliderAction.SliderSingleStepAdd,
#                    QAbstractSlider.SliderAction.SliderSingleStepSub,
#                    QAbstractSlider.SliderAction.SliderPageStepAdd,
#                    QAbstractSlider.SliderAction.SliderPageStepSub
                ]: # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.eventslidermoved[3]=1

    # if updateLCD=True, call moveslider() which in turn updates the LCD
    def sliderReleased(self,n,force=False,updateLCD=False):
        if n == 0:
            sv1 = self.slider1.value()
            if force or (self.eventslidermoved[0] and sv1 != self.eventslidervalues[0]) or abs(sv1-self.eventslidervalues[0]) > 3:
                self.eventslidermoved[0] = 0
                if aw.eventslidercoarse[0]:
                    sv1 = int(round(sv1 / 10.))*10
                self.eventslidervalues[0] = sv1
                if updateLCD or (aw.eventslidercoarse[0] and sv1 != self.slider1.value()):
                    self.moveslider(0,sv1,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 1:
            sv2 = self.slider2.value()
            if force or (self.eventslidermoved[1] and sv2 != self.eventslidervalues[1]) or abs(sv2-self.eventslidervalues[1]) > 3:
                self.eventslidermoved[1] = 0
                if aw.eventslidercoarse[1]:
                    sv2 = int(round(sv2 / 10.))*10
                self.eventslidervalues[1] = sv2
                if updateLCD or (aw.eventslidercoarse[1] and sv2 != self.slider2.value()):
                    self.moveslider(1,sv2,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 2:
            sv3 = self.slider3.value()
            if force or (self.eventslidermoved[2] and sv3 != self.eventslidervalues[2]) or abs(sv3-self.eventslidervalues[2]) > 3:
                self.eventslidermoved[2] = 0
                if aw.eventslidercoarse[2]:
                    sv3 = int(round(sv3 / 10.))*10
                self.eventslidervalues[2] = sv3
                if updateLCD or (aw.eventslidercoarse[2] and sv3 != self.slider3.value()):
                    self.moveslider(2,sv3,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 3:
            sv4 = self.slider4.value()
            if force or (self.eventslidermoved[3] and sv4 != self.eventslidervalues[3]) or abs(sv4-self.eventslidervalues[3]) > 3:
                self.eventslidermoved[3] = 0
                if aw.eventslidercoarse[3]:
                    sv4 = int(round(sv4 / 10.))*10
                self.eventslidervalues[3] = sv4
                if updateLCD or (aw.eventslidercoarse[3] and sv4 != self.slider4.value()):
                    self.moveslider(3,sv4,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        return False

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    @pyqtSlot(int)
    def fireslideraction(self,n):
        action = self.eventslideractions[n]
        if action:
            try:
            # before adaption:
                # action =0 (None), =1 (Serial), =2 (Modbus), =3 (DTA Command), =4 (Call Program [with argument])
                #  =5 (Hottop Heater), =6 (Hottop Fan), =7 (Hottop Command), =8 (Fuji Command), =9 (PWM Command), =10 (VOUT Command)
                #  =11 (IO Command), =12 (S7 Command), =13 (Aillio R1 Heater Command), =14 (Aillio R1 Fan Command), =15 (Aillio R1 Drum Command)
                #  =16 (Artisan Command), 17= (RC Command)
                action = (action+2 if action > 1 else action) # skipping (2 Call Program and 3 Multiple Event)
                if action > 5:
                    action = action + 1 # skip the 6:IO Command
                    if 15 > action > 10:
                        action = action + 1 # skip the 11 p-i-d action
                        if action == 15:
                            action = 6 # map IO Command back
                    if action > 18:
                        action = action + 1 # skip the 19: Aillio PRS
            # after adaption: (see eventaction)
                value = self.calcSliderSendValue(n)
                if not (action in [6, 14, 15, 21]): # only for IO, VOUT, S7 and RC Commands we keep the floats
                    value = int(round(value))
                if action in [8,9,16,17,18]: # for Hottop/R1 Heater or Fan, we just forward the value
                    cmd = str(int(round(value)))
                else:
                    cmd = self.eventslidercommands[n]
                    cmd = cmd.format(*(tuple([value]*cmd.count('{}'))))
                self.eventaction(action,cmd) # cmd needs to be a string!
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' fireslideraction() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    # from a given value and the event type number, calc the event value respecting the event types slider offset, factor and bernulli settings
    def calcEventValue(self, n, slider_value):
        if self.eventsliderBernoulli[n]:
            # if ticked we add the Bernoulli's gas law factor to the computed value
            # (see https://www.home-barista.com/home-roasting/coffee-roasting-best-practices-scott-rao-t65601-70.html#p724654)
            # so we have f(x) = (max-min) * ((x-min)/(max-min))^2 + min
            slider_delta = self.eventslidermax[n] - self.eventslidermin[n]
            slider_value = slider_delta * pow((slider_value - self.eventslidermin[n])/slider_delta,2) + self.eventslidermin[n]
        # f(x) = k*x + o
        return (self.eventsliderfactors[n] * slider_value) + self.eventslideroffsets[n]

    def calcSliderSendValue(self,n):
        return self.calcEventValue(n, self.eventslidervalues[n])

    def recordsliderevent(self,n):
        if aw.eventquantifierSV[n]:
            # if source of event quantifier is a SV, we do not block further quantification for a period (only for PV values that lag behind)
            aw.block_quantification_sampling_ticks[n] = 0
        else:
            aw.block_quantification_sampling_ticks[n] = aw.sampling_ticks_to_block_quantifiction
        self.extraeventsactionslastvalue[n] = self.eventslidervalues[n]
        if self.qmc.flagstart:
            value = aw.float2float((self.eventslidervalues[n] + 10.0) / 10.0)
            description = str(aw.float2float(self.calcSliderSendValue(n),2)).rstrip('0').rstrip('.') + self.eventsliderunits[n]
            self.qmc.EventRecordAction(extraevent = 1,eventtype=n,eventvalue=value,eventdescription=description)
        self.fireslideraction(n)

    @staticmethod
    def sliderLCD():
        slcd = QLCDNumber()
        slcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        slcd.setNumDigits(1)
        slcd.setMinimumHeight(35)
        slcd.setMinimumWidth(50)
        slcd.setMaximumWidth(50)
        slcd.setFrameStyle(QFrame.Shape.Panel | QFrame.Shadow.Plain)
        slcd.setLineWidth(0)
        slcd.setContentsMargins(0,0,0,0)
        return slcd

    @staticmethod
    def slider():
        s = QSlider()
        s.setTickPosition(QSlider.TickPosition.TicksBothSides)
        s.setTickInterval(10)
        s.setSingleStep(1)
        s.setPageStep(10)
        s.setMaximum(100)
        s.setMinimumWidth(50)
        s.setMaximumWidth(50)
        s.setContentsMargins(0,0,0,0)
        return s

    def updateSliderMinMax(self):
        # first block slider signals to avoid sending out signals
        self.slider1.blockSignals(True)
        self.slider2.blockSignals(True)
        self.slider3.blockSignals(True)
        self.slider4.blockSignals(True)
        try:
            # reset limits
            self.slider1.setMinimum(self.eventslidermin[0])
            self.slider1.setMaximum(self.eventslidermax[0])
            self.slider2.setMinimum(self.eventslidermin[1])
            self.slider2.setMaximum(self.eventslidermax[1])
            self.slider3.setMinimum(self.eventslidermin[2])
            self.slider3.setMaximum(self.eventslidermax[2])
            self.slider4.setMinimum(self.eventslidermin[3])
            self.slider4.setMaximum(self.eventslidermax[3])
            # update slider LCDs
            self.updateSliderLCD(0,min(self.eventslidermax[0],max(self.eventslidermin[0],self.slider1.value())))
            self.updateSliderLCD(1,min(self.eventslidermax[1],max(self.eventslidermin[1],self.slider2.value())))
            self.updateSliderLCD(2,min(self.eventslidermax[2],max(self.eventslidermin[2],self.slider3.value())))
            self.updateSliderLCD(3,min(self.eventslidermax[3],max(self.eventslidermin[3],self.slider4.value())))
        finally:
            # unblock sliders signaling
            self.slider1.blockSignals(False)
            self.slider2.blockSignals(False)
            self.slider3.blockSignals(False)
            self.slider4.blockSignals(False)

    # creates a drop shadow effect
    def makeShadow(self,strong=False):
        shadow = QGraphicsDropShadowEffect(self)
        if strong:
            shadow.setBlurRadius(20)
        else:
            shadow.setBlurRadius(20)
        shadow.setOffset(0,0.9)
        return shadow

    @staticmethod
    def setLabelColor(label,color):
        label.setStyleSheet('QLabel { color: %s; }' % color.name())

    @pyqtSlot()
    def updateSerialLog(self):
        if self.serial_dlg is not None:
            self.serial_dlg.update()

    #adds to serial log
    def addserial(self,serialstring):
        if aw.seriallogflag:
            try:
                #### lock shared resources #####
                aw.qmc.seriallogsemaphore.acquire(1)
                timez = QDateTime.currentDateTime().toString('hh:mm:ss.zzz')    #zzz = milliseconds
                #keep a max of 1000 comm strings
                if len(self.seriallog) > 999:
                    self.seriallog = self.seriallog[1:]
                self.seriallog.append(timez + ' ' + serialstring)
                # if logging is not on, we have to update the serial log here:
                if not self.qmc.flagon and self.serial_dlg is not None:
                    self.updateSerialLogSignal.emit() # as addserial might be called from another (samplinig) thread we need to ensure that this is processed this within the GUI thread via a signal
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                if aw.qmc.seriallogsemaphore.available() < 1:
                    aw.qmc.seriallogsemaphore.release(1)

    def resizeEvent(self, event):
        if not aw.qmc.flagon and aw.qmc.statssummary and len(aw.qmc.timex) > 3:
            self.redrawTimer.start(500) # (re-) start the redraw time to be fired in half a second
        super().resizeEvent(event)

    def setdpi(self,dpi,moveWindow=True):
        if aw:
            aw.dpi = dpi
            # on mpl >= v2 we assume hidpi support and consider the pixel ratio
            self.qmc.fig.set_dpi(dpi*aw.devicePixelRatio())
            #move widget to update display
            if moveWindow:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    aw.qmc.fig.canvas.draw()
                    aw.qmc.fig.canvas.update()
                aw.qmc.adjustSize()
                FigureCanvas.updateGeometry(aw.qmc)  #@UndefinedVariable
                QApplication.processEvents()
                if aw.qmc.statssummary:
                    aw.qmc.redraw(recomputeAllDeltas=False)
            if aw.qpc:
                aw.qpc.setdpi(dpi,moveWindow)

    def enableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(True)
            self.fileSaveAsAction.setEnabled(True)
            #self.ConfMenu.setEnabled(True)
            self.calibrateDelayAction.setEnabled(True)

    def disableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False)
            #self.ConfMenu.setEnabled(False)
            self.calibrateDelayAction.setEnabled(False)

    # relocate event actions, by skippig 3=MultipleEvent and 7=Call Program SliderAction
    def eventactionx(self, a: int, cmd: str):
        try:
            # we added "Multiple Events" at position 20 which has to be mapped to action 3
            self.eventaction((a if (a < 3) else (3 if (a == 20) else ((a + 2) if (21 > a > 5) else (a + 1)))), cmd)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    #actions: 0 = None; 1= Serial Command; 2= Call program; 3= Multiple Event; 4= Modbus Command; 5=DTA Command; 6=IO Command (Phidgets/Yocto IO);
    #         7= Call Program with argument (slider action); 8= HOTTOP Heater; 9= HOTTOP Main Fan; 10= HOTTOP Command; 11= p-i-d; 12= Fuji Command;
    #         13= PWM Command; 14= VOUT Command; 15= S7 Command; 16= Aillio R1 Heater; 17= Aillio R1 Fan; 18= Aillio R1 Drum; 19= Aillio R1 Command;
    #         20= Artisan Command; 21= RC Command; 22= WebSocket Command
    def eventaction(self,action,cmd,parallel=True):
        # split on an octothorpe '#' that is not inside parentheses '()'
        cmd = re.split(r'\#(?![^\(]*\))',cmd)[0].strip()
        if action:
            if not parallel:# or action==3: # subactions of multiple event actions, may crash if run in parallel, especially if they update the UI like button shape!
                self.eventaction_internal(action,cmd)
            else:
                eventActionThread = EventActionThread(action,cmd)
                eventActionThread.finished.connect(self.eventactionThreadDone_slot)
                try:
                    aw.qmc.eventactionsemaphore.acquire(1)
                    self.eventaction_running_threads.append(eventActionThread)
                finally:
                    if aw.qmc.eventactionsemaphore.available() < 1:
                        aw.qmc.eventactionsemaphore.release(1)
                eventActionThread.start()

    @pyqtSlot()
    def eventactionThreadDone_slot(self):
        try:
            self.qmc.eventactionsemaphore.acquire(1)
            actionthread = self.sender()
            if actionthread in self.eventaction_running_threads:
                self.eventaction_running_threads.remove(actionthread)
            actionthread.disconnect()
        finally:
            if self.qmc.eventactionsemaphore.available() < 1:
                self.qmc.eventactionsemaphore.release(1)
#        if self.qmc.flagstart:
#            self.qmc.updateBackground()
#            self.qmc.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    # NOTE: this may runs in a separate EventActionThread and not in the GUI thread thus actions modifying the GUI might need to use signals to
    # ensure that they run in the GUI thread to avoid hard crashes (see pidON/pidOFF)
    def eventaction_internal(self,action,cmd):
        if action:
            try:
                if aw.simulator and not action in [2,3,20]:  # 2 (Call Program) 3 (Multiple Event), 20 (Artisan Command)
                    # disable all communicating commands in simulation mode
                    return

                cmd_str = str(cmd)

                # we add {BT}, {ET}, {time} substitutions for Serial/CallProgram/MODBUS/S7/Artisan/WebSocket command actions
                if action in [1,2,4,7,15,20,22]:
                    BT_subst = -1
                    ET_subst = -1
                    timex = 0
                    BTB_subst = -1
                    ETB_subst = -1
                    if (self.qmc.flagstart and len(self.qmc.timex) > 0 or (self.qmc.flagon and len(self.qmc.on_timex) > 0)):
                        try:
                            if self.qmc.flagstart and len(self.qmc.timex)>0:
                                timex = self.qmc.timex[-1]
                                if self.qmc.timeindex[0] != -1:
                                    timex -= self.qmc.timex[self.qmc.timeindex[0]]
                                BT_subst = self.qmc.temp2[-1]
                                ET_subst = self.qmc.temp1[-1]
                                if self.qmc.background:
                                    btb = self.qmc.backgroundSmoothedBTat(timex)
                                    if btb != -1:
                                        BTB_subst = btb
                                    etb = self.qmc.backgroundSmoothedETat(timex)
                                    if etb != -1:
                                        ETB_subst = etb
                            elif self.qmc.flagon:
                                timex = self.qmc.on_timex[-1]
                                if self.qmc.timeindex[0] != -1:
                                    timex -= self.qmc.on_timex[self.qmc.timeindex[0]]
                                BT_subst = self.qmc.on_temp2[-1]
                                ET_subst = self.qmc.on_temp1[-1]
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    try:
                        if action == 22:
                            # in JSON we have to do string substitution
                            cmd_str = cmd_str.replace('{BT}',str(BT_subst))
                            cmd_str = cmd_str.replace('{ET}',str(ET_subst))
                            cmd_str = cmd_str.replace('{t}',str(timex))
                            cmd_str = cmd_str.replace('{BTB}',str(BTB_subst))
                            cmd_str = cmd_str.replace('{ETB}',str(ETB_subst))
                        else:
                            cmd_str = cmd_str.format(BT=BT_subst,ET=ET_subst,t=timex,BTB=BTB_subst,ETB=ETB_subst)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                if action == 1:
                    cmd_str_bin = ''
                    #example a2b_uu("Hello") sends Hello in binary format instead of ASCII
                    if 'a2b_uu' in cmd_str:
                        cmd_str = cmd_str[(len('a2b_uu')+1):][:1]  # removes function-name + char ( and )
                        import binascii
                        cmd_str_bin = binascii.a2b_uu(cmd_str)
                    if cmd_str_bin:
                        self.ser.sendTXcommand(cmd_str_bin)
                    else:
                        cmd_str = cmd_str.replace('\\r\\n','\n\r').replace('\\n', '\n').replace('\\t','\t')
                        self.ser.sendTXcommand(cmd_str)
                elif action == 2: # button call program action
                    try:
                        if cmd_str:
                            self.call_prog_with_args(cmd_str)
#                        if cmd_str and (len(cmd_str.split(" ")) > 1 or platf == 'Darwin' or platf == 'Linux'):
#                            self.call_prog_with_args(cmd_str) # a command with argument
#                        else:
## take care, the QDir().current() directory changes with loads and saves
##                        QDesktopServices.openUrl(QUrl("file:///" + str(QDir().current().absolutePath()) + "/" + cmd_str, QUrl.ParsingMode.TolerantMode))
#                            if platf in ['Windows','Linux']:
#                                QDesktopServices.openUrl(QUrl("file:///" + str(QApplication.applicationDirPath()) + "/" + cmd_str, QUrl.ParsingMode.TolerantMode))
#                            else: # on Darwin
#                                QDesktopServices.openUrl(QUrl("file:///" + str(QApplication.applicationDirPath()) + "/../../../" + cmd_str, QUrl.ParsingMode.TolerantMode))
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' eventaction() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                elif action == 3: # Multiple Event
                    cmd_list = cmd_str.split(',')
                    for i in range(len(cmd_list)):
                        cs = cmd_list[i]
                        if cs.startswith('sleep'):
                            try:
                                cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                if isinstance(cmds,(float, int)):
                                    # cmd has format "sleep(xx.yy)"
                                    libtime.sleep(cmds)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        else:
                            buttonnumber = int(cs)-1
                            if self.extraeventsactions[buttonnumber] != 3:   #avoid calling other buttons with multiple actions to avoid possible infinite loops
                                self.recordextraevent(buttonnumber,parallel=False,updateButtons=False)
                elif action == 4: # MODBUS Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0 # contains the required sleep time
                        for c in cmds:
                            cs = c.strip().replace('_',str(aw.modbus.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                if followupCmd == 0.08:
                                    aw.modbus.sleepBetween(write=True)
                                else:
                                    aw.modbus.sleepBetween(write=False)
                                #libtime.sleep(followupCmd) #this guarantees a minimum of 30 milliseconds between readings and 80ms between writes (according to the Modbus spec)
                            if cs.startswith('writem'):
                                try:
                                    cmds = eval(cs[len('writem'):])  # pylint: disable=eval-used
                                    if isinstance(cmds,tuple) and len(cmds) == 3:
                                        # cmd has format "writem(s,r,[v1,..,vn])"
                                        aw.modbus.writeRegisters(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep'):
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeBCD'):
                                try:
                                    cmds = eval(cs[len('writeBCD'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "writeBCD(s,r,v)"
                                            aw.modbus.writeBCD(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "writeBCD([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                aw.modbus.writeBCD(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeBCD([s,r,v])"
                                        aw.modbus.writeBCD(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeWord'): # writing directly floats
                                try:
                                    cmds = eval(cs[len('writeWord'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "writeWord(s,r,v)"
                                            aw.modbus.writeWord(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "writeWord([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                aw.modbus.writeWord(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write(Word[s,r,v])"
                                        aw.modbus.writeWord(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeLong'): # writing directly 32bit integers in two consecutive registers
                                try:
                                    cmds = eval(cs[len('writeLong'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "writeLong(s,r,v)"
                                            aw.modbus.writeLong(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "writeLong([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                aw.modbus.writeLong(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeLong([s,r,v])"
                                        aw.modbus.writeLong(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeSingle'):
                                try:
                                    cmds = eval(cs[len('writeSingle'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "writeSingle(s,r,v)"
                                            aw.modbus.writeSingleRegister(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "writeSingle([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                aw.modbus.writeSingleRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeSingle([s,r,v])"
                                        aw.modbus.writeSingleRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            aw.modbus.writeRegister(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                aw.modbus.writeRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        aw.modbus.writeRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('mwrite'):
                                try:
                                    cmds = eval(cs[len('mwrite'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 4 and not isinstance(cmds[0],list):
                                            # cmd has format "mwrite(s,r,am,om)"
                                            aw.modbus.maskWriteRegister(*cmds)
                                            followupCmd = 0.08
                                        elif len(cmds) == 5 and not isinstance(cmds[0],list):
                                            # cmd has format "mwrite(s,r,am,om,v)" with v the new value that might be evaluated from _ (last MODBUS read result)
                                            # here a local mask write is computed on v and send via MODBUS fct. 6 (instead of fct.25 used by the standard mwrite function below)
                                            aw.modbus.localMaskWriteRegister(*cmds)
                                        else:
                                        # cmd has format "mwrite([s,r,am,om],..,[s,r,am,om])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                if len(cmd) == 4:
                                                    aw.modbus.maskWriteRegister(*cx)
                                                elif len(cmd) == 5:
                                                    aw.modbus.localMaskWriteRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,am,om])"
                                        aw.modbus.maskWriteRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('wcoils'):
                                try:
                                    cmds = eval(cs[len('wcoils'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "wcoils(s,r,[<b>,..<b>])"
                                            aw.modbus.writeCoils(*cmds)
                                            followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('wcoil'):
                                try:
                                    cmds = eval(cs[len('wcoil'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple) and len(cmds) == 3:
                                        # cmd has format "wcoil(s,r,<b>)"
                                        aw.modbus.writeCoil(*cmds)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read'):
                                try:
                                    cmds = eval(cs[len('read'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple) and len(cmds) == 2:
                                        # cmd has format "read(s,r)"
                                        aw.modbus.lastReadResult = aw.modbus.readSingleRegister(*cmds,force=True)
                                        followupCmd = 0.03
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('button'):
                                # cmd has format "button(<bool>)" # 0 or 1 or True or False
                                try:
                                    cmds = eval(cs[len('button'):]) # pylint: disable=eval-used
                                    last = self.lastbuttonpressed
                                    if last != -1 and len(self.buttonlist)>last:
                                        #block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        if cmds:
                                            aw.setExtraEventButtonStyle(last, style='pressed')
                                        else:
                                            aw.setExtraEventButtonStyle(last, style='normal')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('MODBUS Command <%s> not recognized', cs)
                elif action == 5: # DTA Command
                    try:
                        DTAvalue=cmd_str.split(':')[1]
                        DTAaddress=cmd_str.split(':')[0]
                        aw.dtapid.writeDTE(DTAvalue,DTAaddress)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                elif action == 6:  # IO Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  set(c,b[,sn])   : switches channel c off (b=0) and on (b=1)
                    ##  toggle(c[,sn])  : toggles channel c
                    ##  pulse(c,t[,sn]) : sets the output of channel c to on for time t in milliseconds
                    ##  out(c,v[,sn])   : sets voltage output of channel c to v (float)
                    ##  accel(c,v[,sn]) : sets acceleration of channel c to v (float) on a DCMotor phidget
                    ##  vel(c,v[,sn])   : sets target velocity of channel c to v (float) on a DCMotor phidget
                    ##  limit(c,v[,sn]) : sets current limit of channel c to v (float) on a DCMotor phidget
                    #
                    # YOCTOPUCE
                    ##  on(c[,sn])   : turn channel c of the relay module on
                    ##  off(c[,sn])  : turn channel c of the relay module off
                    ##  flip(c[,sn]) : toggle the state of channel c
                    ##  pip(c,delay,duration[,sn]) : pulse the channel c on after a delay of delay milliseconds for the duration of duration milliseconds
                    #
                    # OTHERS
                    ##  slider(c,v)   : move slider c to value v
                    ##  button(i,c,b[,sn]) : switches channel c off (b=0) and on (b=1) and sets button i to pressed or normal depending on the value b
                    ##  sleep(s) : sleep for s seconds, s a float
                    #
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                            cs_len = len(cs_a)

                            if cs_a[0] == 'set':
                                if cs_len>2:
                                    channel=toInt(cs_a[1])
                                    value=toBool(cs_a[2])
                                if cs_len == 3:
                                    if not aw.ser.phidgetBinaryOUTset(channel, value):
                                        aw.sendmessage(QApplication.translate('Message', f'Failed to set({cs_a[1]}, {cs_a[2]})'))
                                elif cs_len == 4:
                                    serial = cs_a[3]
                                    if not aw.ser.phidgetBinaryOUTset(channel, value, serial):
                                        aw.sendmessage(QApplication.translate('Message', f'Failed to set({cs_a[1]}, {cs_a[2]}, {serial})'))

                            elif cs_a[0] == 'toggle' and cs_len > 1:
                                c = toInt(cs_a[1])
                                if cs_len > 2:
                                    sn = cs_a[2]
                                else:
                                    sn = None
                                #keep state of this gpio, rather than rely on phidget and use non-zero value to set button color
                                # NOTE: with this strategy the modules state might be different to this one if also a set command is used
                                newValue = (self.buttonStates[self.lastbuttonpressed] + 1) & 0x1
                                if aw.ser.phidgetBinaryOUTset(c, bool(newValue),sn):
                                    self.buttonStates[self.lastbuttonpressed] = newValue
                                else:
                                    aw.sendmessage(QApplication.translate('Message', 'Failed to toggle(%s)' % (cs_a[1])))
                                    #clear style that got set in button press event handler
                                    if 0 != self.buttonStates[self.lastbuttonpressed]:
                                        self.setExtraEventButtonStyle(self.lastbuttonpressed, style='pressed')
                                    else:
                                        self.setExtraEventButtonStyle(self.lastbuttonpressed, style='normal')
                                #block resetting style of last button
                                self.lastbuttonpressed = -1

                            elif cs_a[0] == 'pulse' and cs_len > 2:
                                c = toInt(cs_a[1])
                                t = toInt(cs_a[2])
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                if 0.0 <= t <= 999999:
                                    aw.ser.phidgetBinaryOUTpulse(c, t, sn)
                                else:
                                    aw.sendmessage(QApplication.translate('Message', 'Pulse out of range (%d)' % (t)))

                            elif cs_a[0] == 'out' and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                if not aw.ser.phidgetVOUTsetVOUT(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn): # pylint: disable=eval-used
                                    aw.sendmessage(QApplication.translate('Message', f'Failed to set VOUT({cs_a[1]}, {cs_a[2]})'))

                            elif cs_a[0] == 'accel' and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                aw.ser.phidgetDCMotorSetAcceleration(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn) # pylint: disable=eval-used

                            elif cs_a[0] == 'vel' and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                aw.ser.phidgetDCMotorSetVelocity(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn) # pylint: disable=eval-used

                            elif cs_a[0] == 'limit' and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                aw.ser.phidgetDCMotorSetCurrentLimit(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn) # pylint: disable=eval-used

                            elif cs_a[0] == 'slider' and cs_len == 3:
                                v = toFloat(cs_a[2])
                                aw.moveslider(toInt(cs_a[1]), v)
                            elif cs_a[0] == 'button' and cs_len > 3:
                                b = toInt(cs_a[1]) - 1 # gui button list is indexed from 1
                                c = toInt(cs_a[2])
                                v = toInt(cs_a[3])
                                if cs_len > 4:
                                    sn = cs_a[4]
                                else:
                                    sn = None
                                if aw.ser.phidgetBinaryOUTset(c, bool(v & 0x1), sn):
                                    self.buttonStates[b] = v & 0x1
                                else:
                                    aw.sendmessage(QApplication.translate('Message', f'Failed to set button({cs_a[1]}, {cs_a[2]}, {cs_a[3]})'))

                                if self.buttonStates[b] != 0:
                                    self.setExtraEventButtonStyle(b, style='pressed')
                                else:
                                    self.setExtraEventButtonStyle(b, style='normal')
                            elif cs_a[0] == 'sleep' and cs_len == 2: # in seconds
                                try:
                                    t = eval(cs_a[1]) # pylint: disable=eval-used
                                    if isinstance(t,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(t)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                            # Yoctopuce Relay Command Actions
                            # on(c[,sn])
                            elif cs_a[0] == 'on' and cs_len == 2:
                                aw.ser.yoctoRELon(int(cs_a[1]),None)
                            elif cs_a[0] == 'on' and cs_len == 3:
                                aw.ser.yoctoRELon(int(cs_a[1]),cs_a[2])
                            # off(c[,sn])
                            elif cs_a[0] == 'off' and cs_len == 2:
                                aw.ser.yoctoRELoff(int(cs_a[1]),None)
                            elif cs_a[0] == 'off' and cs_len == 3:
                                aw.ser.yoctoRELoff(int(cs_a[1]),cs_a[2])
                            # flip(c[,sn])
                            elif cs_a[0] == 'flip' and cs_len == 2:
                                aw.ser.yoctoRELflip(int(cs_a[1]),None)
                            elif cs_a[0] == 'flip' and cs_len == 3:
                                aw.ser.yoctoRELflip(int(cs_a[1]),cs_a[2])
                            # pulse(c,delay,duration[,sn])
                            elif cs_a[0] == 'pip' and cs_len == 4:
                                aw.ser.yoctoRELpulse(int(cs_a[1]),int(cs_a[2]),int(cs_a[3]),None)
                            elif cs_a[0] == 'pip' and cs_len == 5:
                                aw.ser.yoctoRELpulse(int(cs_a[1]),int(cs_a[2]),int(cs_a[3]),cs_a[4])
                            else:
                                #print("no match for command [%s], continue" % (cs_a[0]))
                                _log.info('IO Command <%s> not recognized', cs_a[0])
                                aw.sendmessage(QApplication.translate('Message','No match for command [%s], continuing' % (cs_a[0])))

                elif action == 7: # slider call-program action
                    try:
                        self.call_prog_with_args(cmd_str)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' callProgram(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                elif action == 8: # HOTTOP Heater
                    from artisanlib.hottop import setHottop
                    setHottop(heater=int(cmd))
                elif action == 9: # HOTTOP Main Fan
                    from artisanlib.hottop import setHottop # @Reimport
                    setHottop(main_fan=int(cmd))
                elif action == 10: # HOTTOP Command (one of "heater", "fan", "motor", "solenoid", "stirrer")
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            from artisanlib.hottop import setHottop # @Reimport
                            if cs.startswith('heater'):
                                try:
                                    cmds = eval(cs[len('heater'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,int):
                                        setHottop(heater = min(max(cmds,0),100))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('fan'):
                                try:
                                    cmds = eval(cs[len('fan'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,int):
                                        setHottop(main_fan = int(min(max(cmds,0),10) * 10))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('motor'):
                                try:
                                    cmds = eval(cs[len('motor'):]) # pylint: disable=eval-used
                                    if cmds:
                                        setHottop(drum_motor=True)
                                    else:
                                        setHottop(drum_motor=False)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('solenoid'):
                                try:
                                    cmds = eval(cs[len('solenoid'):]) # pylint: disable=eval-used
                                    if cmds:
                                        setHottop(solenoid=True)
                                    else:
                                        setHottop(solenoid=False)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('stirrer'):
                                try:
                                    cmds = eval(cs[len('stirrer'):]) # pylint: disable=eval-used
                                    if cmds:
                                        setHottop(cooling_motor=True)
                                    else:
                                        setHottop(cooling_motor=False)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('HOTTOP Command <%s> not recognized', cs)
                elif action == 11: # p-i-d, expects 3 float numbers separated by semicolon
                    if cmd_str:
                        cmds = list(filter(None, cmd_str.split(';'))) # "<p>;<i>;<d>"
                        if len(cmds) == 3:
                            kp = float(cmds[0])
                            ki = float(cmds[1])
                            kd = float(cmds[2])
                            #FUJI/DELTA pid
                            if aw.qmc.device in (0, 26):
                                # set-p-i-d currently only set from dialog
                                if self.ser.controlETpid[0] == 0:
                                    # 1. get current PID
                                    N = aw.fujipid.getCurrentPIDnumberPXG()
                                    # 2. call setpid(self,k) with k that active pid
                                    aw.fujipid.setpidPXG(N,kp,ki,kd)
                                elif self.ser.controlETpid[0] == 1:
                                    aw.fujipid.setpidPXR('p',kp)
                                    libtime.sleep(0.035)
                                    aw.fujipid.setpidPXR('i',ki)
                                    libtime.sleep(0.035)
                                    aw.fujipid.setpidPXR('d',kd)
                                elif self.ser.controlETpid[0] == 4: # PXF
                                    # 1. get current PID
                                    N = aw.fujipid.getCurrentPIDnumberPXF()
                                    # 2. call setpid(self,k) with k that active pid
                                    aw.fujipid.setpidPXF(N,kp,ki,kd)
                            else:
                                aw.pidcontrol.confPID(kp,ki,kd,pOnE=aw.pidcontrol.pOnE)
                                #aw.pidcontrol.setPID(kp,ki,kd) # we don't set the new values in the dialog
                elif action == 12: # Fuji Command (currently only "write(<unitId>,<register>,<value>)" is supported
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0 # contains the required sleep time
                        for c in cmds:
                            if aw.modbus.lastReadResult is None:
                                aw.modbus.lastReadResult = 0
                            cs = c.strip().replace('_',str(aw.modbus.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                try:
                                    if followupCmd == 0.08:
                                        aw.modbus.sleepBetween(write=True)
                                    else:
                                        aw.modbus.sleepBetween(write=False)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            if cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            command = aw.fujipid.message2send(cmds[0],6,cmds[1],cmds[2])
                                            aw.ser.sendFUJIcommand(command,8)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceded)
                                                command = aw.fujipid.message2send(cx[0],6,cx[1],cx[2])
                                                aw.ser.sendFUJIcommand(command,8)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        command = aw.fujipid.message2send(cmds[0],6,cmds[1],cmds[2])
                                        aw.ser.sendFUJIcommand(command,8)
                                        followupCmd = 0.08
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                elif action == 13: # PWM Command
                    # PHIDGET  <sn> : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    #
                    ## out(<channel>,<value>[,<sn>])  with <value> in [0-100]
                    ## frequency(<value>[,<sn>])  with <value> a real number
                    ## toggle(<channel>[,<sn>])
                    ## outhub(<channel>,<value>[,<sn>])
                    ## togglehub(<channel>[,<sn>])
                    ## pulse(<channel>,<millis>[,<sn>])
                    ## pulsehub(<channel>,<millis>[,<sn>])
                    #
                    # YOCTOPUCE
                    #
                    ## enabled(c,b[,sn])
                    ## freq(c,f[,sn])
                    ## duty(c,d[,sn])
                    ## move(c,d,t[,sn])
                    ##
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            try:
                                if cs.startswith('out(') and len(cs)>7:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split)>1:
                                        channel=toInt(cs_split[0])
                                        value=toInt(eval(cs_split[1])) # pylint: disable=eval-used
                                        if len(cs_split) == 2:
                                            aw.ser.phidgetOUTsetPWM(channel, value)
                                        elif len(cs_split) == 3:
                                            serial=cs_split[2]
                                            aw.ser.phidgetOUTsetPWM(channel, value, serial)
                                elif cs.startswith('frequency(') and len(cs)>14:
                                    cs_split = cs[10:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTsetPWMfrequency(int(cs_split[0]),toFloat(eval(cs_split[1]))) # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTsetPWMfrequency(int(cs_split[0]),toFloat(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                elif cs.startswith('toggle(') and len(cs)>8:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 1:
                                        aw.ser.phidgetOUTtogglePWM(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        aw.ser.phidgetOUTtogglePWM(int(cs_split[0]),cs_split[1])
                                elif cs.startswith('outhub(') and len(cs)>10:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTsetPWMhub(int(cs_split[0]),toInt(eval(cs_split[1]))) # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTsetPWMhub(int(cs_split[0]),toInt(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                elif cs.startswith('togglehub(') and len(cs)>11:
                                    cs_split = cs[10:-1].split(',')
                                    if len(cs_split) == 1:
                                        aw.ser.phidgetOUTtogglePWMhub(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        aw.ser.phidgetOUTtogglePWMhub(int(cs_split[0]),cs_split[1])
                                elif cs.startswith('pulsehub(') and len(cs)>12:
                                    cs_split = cs[9:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTpulsePWMhub(int(cs_split[0]),int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTpulsePWMhub(int(cs_split[0]),int(cs_split[1]),cs_split[2])
                                elif cs.startswith('pulse(') and len(cs)>9:
                                    cs_split = cs[6:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTpulsePWM(int(cs_split[0]),int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTpulsePWM(int(cs_split[0]),int(cs_split[1]),cs_split[2])
                                elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)


                                # Commands for the YoctoPWM module

                                # enabled(c,b[,sn])
                                elif cs.startswith('enabled') and cs.endswith(')') and len(cs)>11:
                                    try:
                                        cs_split = cs[len('enabled('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMenabled(int(cs_split[0]),toBool(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                        else:
                                            aw.ser.yoctoPWMenabled(int(cs_split[0]),toBool(eval(cs_split[1]))) # pylint: disable=eval-used
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                # freq(c,f[,sn])
                                elif cs.startswith('freq') and cs.endswith(')') and len(cs)>8:
                                    try:
                                        cs_split = cs[len('freq('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMsetFrequency(int(cs_split[0]),toInt(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                        else:
                                            aw.ser.yoctoPWMsetFrequency(int(cs_split[0]),toInt(eval(cs_split[1]))) # pylint: disable=eval-used
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                # duty(c,d[,sn])
                                elif cs.startswith('duty') and cs.endswith(')') and len(cs)>8:
                                    try:
                                        cs_split = cs[len('duty('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMsetDuty(int(cs_split[0]),toFloat(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                        else:
                                            aw.ser.yoctoPWMsetDuty(int(cs_split[0]),toFloat(eval(cs_split[1]))) # pylint: disable=eval-used
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                # move(c,d,t[,sn])
                                elif cs.startswith('move') and cs.endswith(')') and len(cs)>10:
                                    try:
                                        cs_split = cs[len('move('):-1].split(',')
                                        if len(cs_split) > 3:
                                            aw.ser.yoctoPWMmove(int(cs_split[0]),toFloat(eval(cs_split[1])),int(cs_split[2]),cs_split[3]) # pylint: disable=eval-used
                                        else:
                                            aw.ser.yoctoPWMmove(int(cs_split[0]),toFloat(eval(cs_split[1])),int(cs_split[2])) # pylint: disable=eval-used
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                else:
                                    # command not recognized
                                    _log.info('PMW Command <%s> not recognized', cs)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                elif action == 14: # VOUT Command to drive Phidget/Yocto Output Modules
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # for Phidgets OUT modules "out(<channel>,<value>[,<serial>])" with <value> a float
                            if cs.startswith('out(') and len(cs)>7:
                                try:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetVOUTsetVOUT(int(cs_split[0]),toFloat(eval(cs_split[1]))) # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetVOUTsetVOUT(int(cs_split[0]),toFloat(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('range(') and len(cs)>7:
                                try:
                                    cs_split = cs[6:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetVOUTsetRange(int(cs_split[0]),int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetVOUTsetRange(int(cs_split[0]),int(cs_split[1]),cs_split[2])
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # for YOCTOPUCE VOLTAGE OUT modules "vout(c,v[,sn])" with c the channel (1 or 2),v the voltage as float [0.0-10.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('vout(') and len(cs)>8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 2:
                                        aw.ser.yoctoVOUTsetVOUT(int(cs_split[0]),toFloat(eval(cs_split[1])),cs_split[2]) # pylint: disable=eval-used
                                    else:
                                        aw.ser.yoctoVOUTsetVOUT(int(cs_split[0]),toFloat(eval(cs_split[1]))) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # for YOCTOPUCE CURRENT OUT modules "cout(c[,sn])" with c the current as float [3.0-21.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('cout(') and len(cs)>6:
                                try:
                                    #c = cs[5:-1]
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 1:
                                        aw.ser.yoctoCOUTsetCOUT(toFloat(eval(cs_split[0])),cs_split[1]) # pylint: disable=eval-used
                                    else:
                                        aw.ser.yoctoCOUTsetCOUT(toFloat(eval(cs_split[0]))) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('VOUT Command <%s> not recognized', cs)
                elif action == 15: # S7 Command
                    # getDBbool(<dbnumber>,<start>,<index>)
                    # getDBint(<dbnumber>,<start>)
                    # getDBfloat(<dbnumber>,<start>)
                    #-
                    # setDBbool(<dbnumber>,<start>,<index>,<value>)
                    # setDBint(<dbnumber>,<start>,<value>)
                    # msetDBint(<dbnumber>,<start>,andMaks,orMask,value)
                    # setDBfloat(<dbnumber>,<start>,<value>)
                    #-
                    # button(<b>)
                    # sleep(<xx.yy>) xx.yy in seconds
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            if aw.s7.lastReadResult is None:
                                aw.s7.lastReadResult = 0
                            cs = c.strip().replace('_',str(aw.s7.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if cs.startswith('setDBint(') and len(cs) > 14:
                                try:
                                    dbnr,s,v = cs[len('setDBint('):-1].split(',')
                                    aw.s7.writeInt(5,int(dbnr),int(s),eval(v)) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('msetDBint(') and len(cs) > 16:
                                try:
                                    dbnr,s,a,o,v = cs[len('msetDBint('):-1].split(',')
                                    aw.s7.maskWriteInt(5,int(dbnr),int(s),int(a),int(o),eval(v)) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBint(') and len(cs) > 13:
                                try:
                                    dbnr,s = cs[len('getDBint('):-1].split(',')
                                    aw.s7.lastReadResult = aw.s7.readInt(5,int(dbnr),int(s),force=True)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('setDBfloat(') and len(cs) > 16:
                                try:
                                    dbnr,s,v = cs[len('setDBfloat('):-1].split(',')
                                    aw.s7.writeFloat(5,int(dbnr),int(s),eval(v)) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBfloat(') and len(cs) > 14:
                                try:
                                    dbnr,s = cs[len('getDBfloat('):-1].split(',')
                                    aw.s7.lastReadResult = aw.s7.readFloat(5,int(dbnr),int(s),force=True)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('setDBbool(') and len(cs) > 17:
                                try:
                                    dbnr,s,i,v = cs[len('setDBbool('):-1].split(',')
                                    aw.s7.writeBool(5,int(dbnr),int(s),int(i),eval(v)) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBbool(') and len(cs) > 15:
                                try:
                                    dbnr,s,i = cs[len('getDBbool('):-1].split(',')
                                    aw.s7.lastReadResult = aw.s7.readBool(5,int(dbnr),int(s),int(i),force=True)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                            elif cs.startswith('button'):
                                # cmd has format "button(<bool>)" # 0 or 1 or True or False
                                try:
                                    cmds = eval(cs[len('button'):]) # pylint: disable=eval-used
                                    last = self.lastbuttonpressed
                                    if last != -1 and len(self.buttonlist)>last:
                                        #block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        if cmds:
                                            aw.setExtraEventButtonStyle(last, style='pressed')
                                        else:
                                            aw.setExtraEventButtonStyle(last, style='normal')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('S7 Command <%s> not recognized', cs)
                elif action == 16: # Aillio Heater
                    self.ser.R1.set_heater(int(cmd)/10)
                elif action == 17 and self.ser.R1 is not None: # Aillio Fan
                    self.ser.R1.set_fan(int(cmd)/10)
                elif action == 18 and self.ser.R1 is not None: # Aillio Drum
                    self.ser.R1.set_drum(int(cmd)/10)
                elif action == 19 and self.ser.R1 is not None:
                    if cmd_str == 'PRS':
                        self.ser.R1.prs()
                elif action == 20: # Artisan Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # alarms(<bool>) enable/disable alarms
                            if cs.startswith('alarms(') and cs.endswith(')'):
                                try:
                                    value = cs[len('alarms('):-1]
                                    if value.lower() in ('yes', 'true', 't', '1'):
                                        aw.qmc.silent_alarms = False
                                        aw.sendmessage(QApplication.translate('Message','Alarms on'))
                                    else:
                                        aw.qmc.silent_alarms = True
                                        aw.sendmessage(QApplication.translate('Message','Alarms off'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # autoCHARGE(<bool>) enable/disable autoCHARGE
                            elif cs.startswith('autoCHARGE(') and cs.endswith(')'):
                                try:
                                    value = cs[len('autoCHARGE('):-1]
                                    if value.lower() in ('yes', 'true', 't', '1'):
                                        aw.qmc.autoChargeFlag = True
                                        aw.sendmessage(QApplication.translate('Message','autoCHARGE on'))
                                    else:
                                        aw.qmc.autoChargeFlag = False
                                        aw.sendmessage(QApplication.translate('Message','autoCHARGE off'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # autoDROP(<bool>) enable/disable autoDROP
                            elif cs.startswith('autoDROP(') and cs.endswith(')'):
                                try:
                                    value = cs[len('autoDROP('):-1]
                                    if value.lower() in ('yes', 'true', 't', '1'):
                                        aw.qmc.autoDropFlag = True
                                        aw.sendmessage(QApplication.translate('Message','autoDROP on'))
                                    else:
                                        aw.qmc.autoDropFlag = False
                                        aw.sendmessage(QApplication.translate('Message','autoDROP off'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # sleep(<n>) sleep <n> seconds (might be a float like in "sleep(1.2)"
                            elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # tare(<n>) tare channel <n> with 1 => ET, 2 => BT, 3 => E1c1, 4: E1c2,..
                            elif cs.startswith('tare') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('tare'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,int):
                                        aw.setTare(cmds-1)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs == 'PIDoff':
                                if aw.qmc.device == 0: # Fuji
                                    standby = aw.fujipid.getONOFFstandby()
                                    if standby == 0: # standby is off (=0), turn it on (=1)
                                        aw.fujipid.setONOFFstandby(1)
                                        aw.sendmessage(QApplication.translate('Message','PID set to OFF'))
                                else:
                                    self.pidOffSignal.emit()
                            elif cs == 'PIDon':
                                if aw.qmc.device == 0: # Fuji
                                    standby = aw.fujipid.getONOFFstandby()
                                    if standby == 1: # standby is on (=1), turn it off (=0)
                                        aw.fujipid.setONOFFstandby(0)
                                        aw.sendmessage(QApplication.translate('Message','PID set to ON'))
                                else:
                                    self.pidOnSignal.emit()
                            elif cs == 'PIDtoggle':
                                if aw.qmc.device == 0: # Fuji
                                    standby = aw.fujipid.getONOFFstandby()
                                    if standby == 1: # standby is on (=1), turn it off (=0)
                                        aw.fujipid.setONOFFstandby(0)
                                        aw.sendmessage(QApplication.translate('Message','PID set to ON'))
                                    elif standby == 0: # standby is off (=0), turn it on (=1)
                                        aw.fujipid.setONOFFstandby(1)
                                        aw.sendmessage(QApplication.translate('Message','PID set to OFF'))
                                else:
                                    aw.pidcontrol.togglePID()
                            # pidmode(<n>) : 0: manual, 1: RS, 2: background follow
                            elif cs.startswith('pidmode(') and cs.endswith(')'):
                                try:
                                    value = int(cs[len('pidmode('):-1])
                                    if aw.qmc.device == 0: # Fuji PID
                                        #rs state =0 OFF, = 1 ON, = 2 hold
                                        if value == 0:
                                            aw.fujipid.setrampsoak(0)
                                            aw.fujipid.followBackground = False
                                            aw.sendmessage(QApplication.translate('Message','PID mode manual'))
                                        elif value == 1:
                                            aw.fujipid.setrampsoak(1)
                                            aw.fujipid.followBackground = False
                                            aw.sendmessage(QApplication.translate('Message','PID mode Ramp/Soak'))
                                        elif value == 2:
                                            aw.fujipid.setrampsoak(0)
                                            aw.fujipid.followBackground = True
                                            aw.sendmessage(QApplication.translate('Message','PID mode background'))
                                    else: # software PID
                                        if value == 0:
                                            aw.pidcontrol.svMode = 0
                                            aw.sendmessage(QApplication.translate('Message','PID mode manual'))
                                        elif value == 1:
                                            aw.pidcontrol.svMode = 1
                                            aw.sendmessage(QApplication.translate('Message','PID mode Ramp/Soak'))
                                        elif value == 2:
                                            aw.pidcontrol.svMode = 2
                                            aw.sendmessage(QApplication.translate('Message','PID mode background'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # playbackmode(<n>) with 0: off, 1: time, 2: BT, 3: ET
                            elif cs.startswith('playbackmode(') and cs.endswith(')'):
                                try:
                                    value = int(cs[len('playbackmode('):-1])
                                    if value == 0:
                                        aw.qmc.replayType = 0
                                        aw.qmc.backgroundPlaybackEvents = False
                                        aw.sendmessage(QApplication.translate('Message','playback off'))
                                    elif value == 1:
                                        aw.qmc.replayType = 0
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate('Message','playback by time'))
                                    elif value == 2:
                                        aw.qmc.replayType = 1
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate('Message','playback by BT'))
                                    elif value == 3:
                                        aw.qmc.replayType = 2
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate('Message','playback by ET'))
                                    self.updatePlaybackIndicatorSignal.emit()
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # openProperties : open Roast Properties dialog
                            elif cs == 'openProperties':
                                aw.openPropertiesSignal.emit()
                            # popup(<m>[,<t>]) with <m> the message and <t> the optional timeout in seconds
                            # message can be a quoted string or just a sequence of characters
                            elif cs.startswith('popup(') and cs.endswith(')'):
                                try:
                                    # quoted string message
                                    values = cs[len('popup('):-1].split(',')
                                    message = str(eval(values[0])) # pylint: disable=eval-used
                                    timeout = 0
                                    if len(values)>1:
                                        timeout = int(eval(values[1])) # pylint: disable=eval-used
                                    self.qmc.showAlarmPopupSignal.emit(message,timeout)
                                except Exception: # pylint: disable=broad-except
                                    # sequence of character message
                                    try:
                                        message = str(values[0])
                                        timeout = 0
                                        if len(values)>1:
                                            timeout = int(eval(values[1])) # pylint: disable=eval-used
                                        self.qmc.showAlarmPopupSignal.emit(message,timeout)
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # message(<m>) with <m> the message
                            elif cs.startswith('message(') and cs.endswith(')'):
                                try:
                                    message = str(eval(cs[len('message('):-1])) # pylint: disable=eval-used
                                    self.sendmessageSignal.emit(message,True,None)
                                except Exception: # pylint: disable=broad-except
                                    try:
                                        message = cs[len('message('):-1]
                                        self.sendmessageSignal.emit(message,True,None)
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # notify(<t>[,<m>) with <t> the title of the notification and <m> an optional message
                            elif cs.startswith('notify(') and cs.endswith(')'):
                                try:
                                    cs_split = cs[len('notify('):-1].split(',')
                                    try:
                                        title = str(eval(cs_split[0])) # pylint: disable=eval-used
                                    except Exception: # pylint: disable=broad-except
                                        title = str(cs_split[0])
                                    message = ''
                                    if len(cs_split) > 1:
                                        try:
                                            message = str(eval(cs_split[1])) # pylint: disable=eval-used
                                        except Exception: # pylint: disable=broad-except
                                            message = str(cs_split[1])
                                    self.sendnotificationMessageSignal.emit(title, message, NotificationType.ARTISAN_USER)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # notifications(<bool>) enable/disable notifications
                            elif cs.startswith('notifications(') and cs.endswith(')'):
                                try:
                                    if aw.notificationManager:
                                        value = cs[len('notifications('):-1]
                                        if value.lower() in ('yes', 'true', 't', '1'):
                                            aw.notificationManager.enableNotifications()
                                            aw.sendmessage(QApplication.translate('Message','Notifications on'))
                                        else:
                                            aw.notificationManager.disableNotifications()
                                            aw.sendmessage(QApplication.translate('Message','Notifications off'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # setCanvasColor(<c>) with <c> the color in RGB-hex format like #ae12f7
                            elif cs.startswith('setCanvasColor(') and cs.endswith(')'):
                                try:
                                    color = str(eval(cs[len('setCanvasColor('):-1])) # pylint: disable=eval-used
                                    self.setCanvasColorSignal.emit(color)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception: # pylint: disable=broad-except
                                    try:
                                        color = cs[len('setCanvasColor('):-1].strip()
                                        self.setCanvasColorSignal.emit(color)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # resetCanvasColor()
                            elif cs == 'resetCanvasColor':
                                try:
                                    self.resetCanvasColorSignal.emit()
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # button(<e>) with <e> one of { ON, START, CHARGE, DRY, FCs, FCe, SCs, SCe, DROP, COOL, OFF }
                            elif cs.startswith('button(') and cs.endswith(')'):
                                try:
                                    try:
                                        event = str(eval(cs[len('button('):-1])).strip() # pylint: disable=eval-used
                                    except Exception: # pylint: disable=broad-except
                                        event = cs[len('button('):-1].strip()
                                    if event == 'ON' and not self.qmc.flagon:
                                        self.qmc.toggleMonitorSignal.emit()
                                    elif event == 'START' and not self.qmc.flagstart:
                                        self.qmc.toggleRecorderSignal.emit()
                                    elif event == 'CHARGE':
                                        self.qmc.markChargeSignal.emit(0)
                                    elif event == 'DRY':
                                        self.qmc.markDRYSignal.emit()
                                    elif event == 'FCs':
                                        self.qmc.markFCsSignal.emit()
                                    elif event == 'FCe':
                                        self.qmc.markFCeSignal.emit()
                                    elif event == 'SCs':
                                        self.qmc.markSCsSignal.emit()
                                    elif event == 'SCe':
                                        self.qmc.markSCeSignal.emit()
                                    elif event == 'DROP':
                                        self.qmc.markDropSignal.emit()
                                    elif event == 'COOL':
                                        self.qmc.markCoolSignal.emit()
                                    elif event == 'OFF' and self.qmc.flagon:
                                        self.qmc.toggleMonitorSignal.emit()
                                    else:
                                        return
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # p-i-d(<p>,<i>,<d>) with <p>, <i>, <d> numbers to set the p-i-d parameters
                            elif cs.startswith('p-i-d(') and cs.endswith(')'):
                                try:
                                    args = cs[len('p-i-d('):-1].split(',')
                                    if len(args) == 3:
                                        kp = float(args[0])
                                        ki = float(args[1])
                                        kd = float(args[2])
                                        #FUJI/DELTA pid
                                        if self.qmc.device in (0, 26):
                                            # set-p-i-d currently only set from dialog
                                            if self.ser.controlETpid[0] == 0: # PXG
                                                # 1. get current PID
                                                N = self.fujipid.getCurrentPIDnumberPXG()
                                                # 2. call setpid(self,k) with k that active pid
                                                self.fujipid.setpidPXG(N,kp,ki,kd)
                                                self.sendmessage(f'Artisan Command: {cs}')
                                            elif self.ser.controlETpid[0] == 1: # PRG
                                                self.fujipid.setpidPXR('p',kp)
                                                libtime.sleep(0.035)
                                                self.fujipid.setpidPXR('i',ki)
                                                libtime.sleep(0.035)
                                                self.fujipid.setpidPXR('d',kd)
                                                self.sendmessage(f'Artisan Command: {cs}')
                                            elif self.ser.controlETpid[0] == 4: # PXF
                                                # 1. get current PID
                                                N = self.fujipid.getCurrentPIDnumberPXF()
                                                # 2. call setpid(self,k) with k that active pid
                                                self.fujipid.setpidPXF(N,kp,ki,kd)
                                                self.sendmessage(f'Artisan Command: {cs}')
                                        else:
                                            self.pidcontrol.confPID(kp,ki,kd,pOnE=self.pidcontrol.pOnE)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidSV(<n>) with <n> a number to be used as PID SV
                            elif cs.startswith('pidSV(') and cs.endswith(')'):
                                try:
                                    sv = max(0,int(eval(cs[len('pidSV('):-1]))) # we don't send SV < 0 # pylint: disable=eval-used
                                    if self.qmc.device == 0 and sv != aw.fujipid.sv:
                                        self.fujipid.setsv(sv,silent=True)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                    elif sv != aw.pidcontrol.sv:
                                        self.pidcontrol.setSV(sv,init=False)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidRS(<n>) with <n> a number to be used to select the PID RS pattern (1-based for the internal software PID)
                            elif cs.startswith('pidRS(') and cs.endswith(')'):
                                try:
                                    rs = int(eval(cs[len('pidRS('):-1])) # pylint: disable=eval-used
                                    if self.qmc.device in (0, 26):
                                        if self.ser.controlETpid[0] == 0: # PXG
                                            pass
                                        elif self.ser.controlETpid[0] == 1: # PRG
                                            pass
                                        elif self.ser.controlETpid[0] == 4: # PXF
                                            pass
                                    else:
                                        if rs>0:
                                            self.pidcontrol.setRSpattern(rs-1)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                except Exception: # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('pidRS('):-1])) # pylint: disable=eval-used
                                        rs = self.pidcontrol.findRSset(label) # here rs is 0-based!!
                                        if rs is not None:
                                            self.pidcontrol.setRSpattern(rs)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # pidSource(<n>) with <n> 0: BT, 1: ET (Artisan internal software PID); <n> in {0,..,3} (Arduino PID)
                            elif cs.startswith('pidSource(') and cs.endswith(')'):
                                try:
                                    source = int(cs[len('pidSource('):-1])
                                    if self.qmc.device not in (0, 26):
                                        kp = aw.pidcontrol.pidKp
                                        ki = aw.pidcontrol.pidKi
                                        kd = aw.pidcontrol.pidKd
                                        self.pidcontrol.confPID(kp,ki,kd,pOnE=self.pidcontrol.pOnE,source=source)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # palette(<n>) with <n> a number between 0 and 9 or an existing palette label
                            elif cs.startswith('palette(') and cs.endswith(')'):
                                try:
                                    p = min(9,max(0,int(cs[len('palette('):-1])))
                                    self.setbuttonsfromSignal.emit(p)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception: # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('palette('):-1])) # pylint: disable=eval-used
                                        p = self.findPalette(label)
                                        if p is not None:
                                            self.setbuttonsfromSignal.emit(p)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # loadBackground(<filepath>)
                            elif cs.startswith('loadBackground(') and cs.endswith(')'):
                                try:
                                    try:
                                        fp = str(eval(cs[len('loadBackground('):-1])) # pylint: disable=eval-used
                                    except Exception: # pylint: disable=broad-except
                                        fp = str(cs[len('loadBackground('):-1])
                                    self.loadBackgroundSignal.emit(fp)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # clearBackground
                            elif cs == 'clearBackground':
                                try:
                                    self.clearBackgroundSignal.emit()
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # alarmset(<n>) with <n> a number between 0 and 9 or an existing alarmset label
                            elif cs.startswith('alarmset(') and cs.endswith(')'):
                                try:
                                    p = min(9,max(0,int(cs[len('alarmset('):-1])))
                                    self.qmc.alarmsetSignal.emit(p)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception: # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('alarmset('):-1])) # pylint: disable=eval-used
                                        p = self.qmc.findAlarmSet(label)
                                        if p is not None:
                                            self.qmc.alarmsetSignal.emit(p)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                            # adjustSV(<n>) adds <n> to the current SV. Note that n can be negative
                            elif cs.startswith('adjustSV(') and cs.endswith(')'):
                                try:
                                    sv_offset = int(eval(cs[len('adjustSV('):-1])) # pylint: disable=eval-used
                                    if self.qmc.device != 26: # not for DTA
                                        self.adjustSVSignal.emit(sv_offset)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # moveBackground(<direction>,<step>) with <direction> one of up,down,left,right and <step> the length of the move
                            elif cs.startswith('moveBackground(') and cs.endswith(')'):
                                try:
                                    args = cs[len('moveBackground('):-1].split(',')
                                    if len(args) == 2:
                                        direction = args[0].lower()
                                        if len(direction)>3 and (direction[0]=='"' or direction[0]=="'") and (direction[-1]=='"' or direction[-1]=="'"):
                                            direction = eval(direction) # pylint: disable=eval-used
                                        step = int(args[1])
                                        self.qmc.moveBackgroundSignal.emit(direction,step)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidLookahead(<n>) adds <n> to the current SV. Note that n can be negative
                            elif cs.startswith('pidLookahead(') and cs.endswith(')'):
                                try:
                                    lookahead = toInt(eval(cs[len('pidLookahead('):-1])) # pylint: disable=eval-used
                                    if self.qmc.device == 0 and self.fujipid and self.qmc.Controlbuttonflag: # FUJI PID
                                        self.fujipid.lookahead = lookahead
                                        self.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(self.fujipid.lookahead))
                                    elif (self.pidcontrol and self.qmc.Controlbuttonflag): # MODBUS hardware PID
                                        self.pidcontrol.svLookahead = lookahead
                                        aw.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(self.pidcontrol.svLookahead))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # keyboard(<bool>) enable/disable keyboard mode
                            elif cs.startswith('keyboard(') and cs.endswith(')'):
                                try:
                                    value = cs[len('keyboard('):-1]
                                    if ((value.lower() in ('yes', 'true', 't', '1') and self.qmc.flagstart and self.keyboardmoveflag == 0) or
                                        (value.lower() not in ('yes', 'true', 't', '1') and self.keyboardmoveflag == 1)):
                                        self.moveButtonSignal.emit('enter')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # keepON(<bool>) enable/disable Keep ON mode
                            elif cs.startswith('keepON(') and cs.endswith(')'):
                                try:
                                    value = cs[len('keepON('):-1]
                                    if (value.lower() in ('yes', 'true', 't', '1')):
                                        self.qmc.flagKeepON = True
                                        aw.sendmessage(QApplication.translate('Message','Keep ON enabled'))
                                    else:
                                        self.qmc.flagKeepON = False
                                        aw.sendmessage(QApplication.translate('Message','Keep ON disable'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # showCurve(<name>, <bool>) with <name> one of { ET, BT, DeltaET, DeltaBT, BackgroundET, BackgroundBT}
                            elif cs.startswith('showCurve(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showCurve('):-1].split(',')
                                    if len(args) == 2:
                                        curve_name = args[0]
                                        state = toBool(eval(args[1])) # pylint: disable=eval-used
                                        self.qmc.showCurveSignal.emit(curve_name, state)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # showExtraCurve(<extra_device>, <curve>, <bool>) with <extra_device> zero-based number of extra device, curve one of { T1, T2 }
                            elif cs.startswith('showExtraCurve(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showExtraCurve('):-1].split(',')
                                    if len(args) == 3:
                                        extra_device = int(args[0])
                                        curve = args[1]
                                        state = toBool(eval(args[2])) # pylint: disable=eval-used
                                        self.qmc.showExtraCurveSignal.emit(extra_device, curve, state)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # showEvents(<event>, <bool>) with <event_type> a number from [1, 5]
                            elif cs.startswith('showEvents(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showEvents('):-1].split(',')
                                    if len(args) == 2:
                                        event_type = int(args[0])
                                        state = toBool(eval(args[1])) # pylint: disable=eval-used
                                        self.qmc.showEventsSignal.emit(event_type, state)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # showBackgroundEvents(<bool>)
                            elif cs.startswith('showBackgroundEvents(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showBackgroundEvents('):-1].split(',')
                                    if len(args) == 1:
                                        state = toBool(eval(args[0])) # pylint: disable=eval-used
                                        self.qmc.showBackgroundEventsSignal.emit(state)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('Artisan Command <%s> not recognized', cs)
                elif action == 21: # RC Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  pulse(ch,min,max[,sn]) : sets the min/max pulse width in microseconds
                    ##  pos(ch,min,max[,sn]) : sets the min/max position
                    ##  engaged(ch,b[,sn]) : engage (b=1) or disengage (b = 0)
                    ##  ramp(ch,b[,sn]) : activates or deactivates the speed ramping state
                    ##  volt(ch,v[,sn]) : set the voltage to one of 5, 6 or 7.4 in Volt
                    ##  accel(ch,a[,sn]) : set the acceleration
                    ##  veloc(ch,v[,sn]) : set the velocity
                    ##  set(ch,pos[,sn]) : set the target position
                    #
                    # YOCTOPUCE
                    #
                    ## enabled(c,b[,sn])
                    ## move(c,p[,t][,sn])
                    ## neutral(c,n[,sn])
                    ## range(c,r[,sn])
                    ##

                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # pulse(ch,min,max[,sn]) # sets min/max pulse width
                            if cs.startswith('pulse(') and len(cs) > 11:
                                try:
                                    n = 3
                                    cs_split = cs[len('pulse('):-1].split(',')
                                    channel,min_pulse,max_pulse = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCpulse(int(channel),int(min_pulse),int(max_pulse),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('pos(') and len(cs) > 9:
                                # pos(ch,min,max[,sn]) # sets min/max position
                                try:
                                    n = 3
                                    cs_split = cs[len('pos('):-1].split(',')
                                    channel,min_pos,max_pos = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCpos(int(channel),float(min_pos),float(max_pos),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('engaged(') and len(cs) > 11:
                                # engaged(ch,state[,sn]) # engage channel
                                try:
                                    n = 2
                                    cs_split = cs[len('engaged('):-1].split(',')
                                    channel,state = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCengaged(int(channel),bool(int(state)),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('set(') and len(cs) > 7:
                                # set(ch,pos[,sn]) # set position
                                try:
                                    n = 2
                                    cs_split = cs[len('set('):-1].split(',')
                                    channel,pos = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCset(int(channel),toFloat(eval(pos)),sn) # pylint: disable=eval-used
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('ramp(') and len(cs) > 8:
                                # ramp(ch,state) # set speed ramping state per channel
                                try:
                                    n = 2
                                    cs_split = s[len('ramp('):-1].split(',')
                                    channel,state = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCspeedRamping(int(channel),bool(int(state)),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('volt(') and len(cs) > 8:
                                # volt(ch,v) # sets voltage
                                try:
                                    n = 2
                                    cs_split = cs[len('volt('):-1].split(',')
                                    channel,volt = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCvoltage(int(channel),float(volt),n)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('accel(') and len(cs) > 9:
                                # accel(ch,accel) # sets acceleration
                                try:
                                    n = 2
                                    cs_split = cs[len('accel('):-1].split(',')
                                    channel,accel = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCaccel(int(channel),float(accel),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('veloc(') and len(cs) > 9:
                                # veloc(ch,veloc) # sets velocity
                                try:
                                    n = 2
                                    cs_split = cs[len('veloc('):-1].split(',')
                                    channel,veloc = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCveloc(int(channel),float(veloc),sn)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep('): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                            # functions supporting the Yoctopuce RC module
                            # enabled(c,b[,sn]) with c:int the channel, b a bool (eg. enabled(0,1) or enabled(0,True)), sn the optional modules serial number or logical name
                            elif cs.startswith('enabled(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    c = int(cs_split[0])
                                    b = toBool(eval(cs_split[1])) # pylint: disable=eval-used
                                    if len(cs_split) > 2:
                                        sn = cs_split[2]
                                        aw.ser.yoctoSERVOenabled(c,b,sn)
                                    else:
                                        aw.ser.yoctoSERVOenabled(c,b)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # move(c,p[,t][,sn]) with c:int the channel, p:int the target position, the optional t the duration in ms, sn the optional modules serial number or logical name
                            elif cs.startswith('move(') and len(cs) > 8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    c = int(cs_split[0])
                                    p = toInt(eval(cs_split[1])) # pylint: disable=eval-used
                                    if len(cs_split) > 2:
                                        try:
                                            t = int(cs_split[2])
                                            if len(cs_split) > 3:
                                                aw.ser.yoctoSERVOmove(c,p,t,cs_split[3])
                                            else:
                                                aw.ser.yoctoSERVOmove(c,p,t)
                                        except Exception: # pylint: disable=broad-except
                                            aw.ser.yoctoSERVOposition(c,p,cs_split[2])
                                    else:
                                        aw.ser.yoctoSERVOposition(c,p)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # neutral(c,n[,sn]) with n an int [0..65000] in us, sn the modules serial number or logical name
                            elif cs.startswith('neutral(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    c = int(cs_split[0])
                                    n = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        aw.ser.yoctoSERVOneutral(c,n,sn)
                                    else:
                                        aw.ser.yoctoSERVOneutral(c,n)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            # range(c,r[,sn]) with r an int in %, sn the modules serial number or logical name
                            elif cs.startswith('range(') and len(cs) > 8:
                                try:
                                    cs_split = cs[6:-1].split(',')
                                    c = int(cs_split[0])
                                    r = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        aw.ser.yoctoSERVOrange(c,r,sn)
                                    else:
                                        aw.ser.yoctoSERVOrange(c,r)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('RC Command <%s> not recognized', cs)
                elif action == 22: # WebSocket Command
                    # send(<json>)
                    # sleep(xx.yy)  with xx.yy sleep time in seconds
                    # read(request) request is a JSON request in brackets; full JSON response is bound to _
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(';')) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip().replace('_',str(aw.ws.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            # send(<json>) : send <json> request to connected WebSocket
                            if cs.startswith('send') and cs.endswith(')'):
                                try:
                                    request = eval(cs[len('send('):-1]) # pylint: disable=eval-used
                                    self.ws.send(request,block=False)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):]) # pylint: disable=eval-used
                                    if isinstance(cmds,(float,int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read'):
                                try:
                                    request = eval(cs[len('read'):]) # pylint: disable=eval-used
                                    if isinstance(request,dict):
                                        # cmd has format "read(<requestJSON>)"
                                        aw.ws.lastReadResult = aw.ws.send(request)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('button'):
                                # cmd has format "button(<bool>)" # 0 or 1 or True or False
                                try:
                                    cmds = eval(cs[len('button'):]) # pylint: disable=eval-used
                                    last = self.lastbuttonpressed
                                    if last != -1 and len(self.buttonlist)>last:
                                        #block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        if cmds:
                                            aw.setExtraEventButtonStyle(last, style='pressed')
                                        else:
                                            aw.setExtraEventButtonStyle(last, style='normal')
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('WebSocket Command <%s> not recognized', cs)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    @staticmethod
    @functools.lru_cache(maxsize=None)  #for Python >= 3.9 can use @functools.cache
    def calc_env():
        # we try to set the users standard environment, replacing the one pointing to the restrictive python build in Artisan
        my_env = os.environ.copy()
        try:
            for v in ['PYTHONHOME','PYTHONPATH','LD_LIBRARY_PATH']:
                if v in my_env:
                    del my_env[v]
            # try to source users environment to make external Python scripts run in their "natural" env
            if platf in ['Darwin', 'Linux']:
                command = ['bash', '-c', 'source ~/.bash_profile ~/.bash_login ~/.profile 2>/dev/null && env']
                try:
                    from subprocess import Popen as subprocessPopen, PIPE as subprocessPIPE # @Reimport
                    with subprocessPopen(command, stdout = subprocessPIPE) as proc:
                        for line in proc.stdout:
                            if isinstance(line, bytes):
                                (k, _, value) = line.partition(b'=')
                                k = k.decode('UTF-8')
                                value = value.decode('UTF-8')
                            else:
                                (k, _, value) = line.partition('=')
                            # don't copy PYTHONHOME nor PYTHONPATH if it points to the Artisan.app
                            if not ((k in ['PYTHONHOME','PYTHONPATH']) and (('Artisan.app' in value) or 'artisan' in value)):
                                my_env[k] = value
                        proc.communicate()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        _log.debug('my_env: %s', my_env)
        return my_env

    @staticmethod
    def re_split(s):
        def strip_quotes(s):
            if s and (s[0] == '"' or s[0] == "'") and s[0] == s[-1]:
                return s[1:-1]
            return s
        return [strip_quotes(p).replace('\\"', '"').replace("\\'", "'") for p in re.findall(r'"(?:\\.|[^"])*"|\'(?:\\.|[^\'])*\'|[^\s]+', s)]
    # dummy ' for syntax parsers confused by odd numbers of quotes


    def call_prog_with_args(self,cmd_str):
#        cmd_str_parts = cmd_str.split(" ") # does split quoted strings ('this "is a" test' => ['this','"is','a"','test'])
        cmd_str_parts = self.re_split(cmd_str) # this preserves quoted strings ('this "is a" test' => ['this','is a','test'])
        if len(cmd_str_parts) > 0:
            try:
                import subprocess # @Reimport
                cmd = cmd_str_parts[0].strip()
                qd = QDir(cmd)
                current = QDir.current()
                QDir.setCurrent(getAppPath())
                my_env = self.calc_env()
                if platf == 'Windows':
                    startupinfo = subprocess.STARTUPINFO()
                    try:
                        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                    except AttributeError:
                        try:
                            startupinfo.dwFlags |= subprocess._subprocess.STARTF_USESHOWWINDOW  # @UndefinedVariable # pylint: disable=maybe-no-member # pylint: disable=protected-access
                        except AttributeError:
                            pass
                    prg_file = str(qd.absolutePath())
#                    CREATE_NEW_PROCESS_GROUP = 0x00000200
#                    DETACHED_PROCESS = 0x00000008
                    #subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]], shell=False,env=my_env)
                    subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]], # pylint: disable=consider-using-with
                        startupinfo=startupinfo,
#                        creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP, # with this the process ends before sleep
#                        close_fds=True, # this seems not to change a thing
                        env=my_env,
                        stdin=None,
                        # suppress output:
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.STDOUT
                        ) #.wait() # with this wait(), the script blocks the Artisan event loop
                else:
                    subprocess.Popen(os.path.expanduser(cmd_str), # pylint: disable=consider-using-with
                        shell=True,
                        close_fds=True,
                        env=my_env,
                        stdin=None,
                        # suppress output:
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.STDOUT)
                QDir.setCurrent(current.absolutePath())
                # alternative approach, that seems to fail on some Mac OS X versions:
                #QProcess.startDetached(prg_file)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    def sliderpos(self,n):
        if n == 0:
            return self.slider1.value()
        if n == 1:
            return self.slider2.value()
        if n == 2:
            return self.slider3.value()
        return self.slider4.value()

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    # updates corresponding eventslidervalues
    def moveslider(self, n:int, v:float, forceLCDupdate=False):
        v = min(max(int(round(v)),self.eventslidermin[n]),self.eventslidermax[n])
        self.eventslidervalues[n] = v
        # first update slider LCDs if needed
        if n == 0 and (forceLCDupdate or self.slider1.value() != v):
            self.updateSliderLCD(0,v)
        elif n == 1 and (forceLCDupdate or self.slider2.value() != v):
            self.updateSliderLCD(1,v)
        elif n == 2 and (forceLCDupdate or self.slider3.value() != v):
            self.updateSliderLCD(2,v)
        elif n == 3 and (forceLCDupdate or self.slider4.value() != v):
            self.updateSliderLCD(3,v)
        # now move sliders to actual values if needed
        if n == 0 and self.slider1.value() != v:
            self.slider1.setValue(v)
        elif n == 1 and self.slider2.value() != v:
            self.slider2.setValue(v)
        elif n == 2 and self.slider3.value() != v:
            self.slider3.setValue(v)
        elif n == 3 and self.slider4.value() != v:
            self.slider4.setValue(v)

    def extraEventButtonStyle(self,tee,style='normal'):
        left_rounded_style = 'border-radius:0px;border-top-left-radius:4px;border-bottom-left-radius:4px;'
        right_rounded_style = 'border-radius:0px;border-top-right-radius:4px;border-bottom-right-radius:4px;'
        fully_rounded_style = 'border-radius:4px;'
        square_style = 'border-radius:0px;'
        if aw.buttonsize == 0:
            # tiny
            button_min_width = self.tiny_button_min_width_str
            button_font_size = self.button_font_size_micro
        elif aw.buttonsize == 2:
            # large
            button_min_width = str(self.standard_button_min_width_px)
            button_font_size = self.button_font_size_small
        else:
            # small (default)
            button_min_width = self.small_button_min_width_str
            button_font_size = self.button_font_size_tiny
        ##
        if len(self.extraeventbuttonround) > tee:
            if self.extraeventbuttonround[tee] == 1: # left-side rounded
                rounding = left_rounded_style
            elif self.extraeventbuttonround[tee] == 2: # right-side rounded
                rounding = right_rounded_style
            elif self.extraeventbuttonround[tee] == 3: # both-sides rounded
                rounding = fully_rounded_style
            else:
                rounding = square_style
        #
        if style=='normal':
            color = self.extraeventbuttontextcolor[tee]
            backgroundcolor = self.extraeventbuttoncolor[tee]
        else: # style=="pressed":
            # set color of this button to "pressed"
            color = self.extraeventbuttoncolor[tee]
            backgroundcolor = self.extraeventbuttontextcolor[tee]
        buttonstyle = f'min-width:{button_min_width};margin:0px;padding:0px;border-style:solid;border-color:darkgrey;border-width:0px;font-size:{button_font_size};font-weight:bold;{rounding}color:{color};'
        #
        plain_style = f'QPushButton {{{buttonstyle}background:{createGradient(backgroundcolor)}}}'
        pressed_style = f'QPushButton:hover:pressed {{background:{createGradient(QColor(backgroundcolor).lighter(80).name())}}}'
        hover_style = f'QPushButton:hover:!pressed {{background:{createGradient(QColor(backgroundcolor).lighter(110).name())}}}'
        return f'{plain_style}{hover_style}{pressed_style}'

    def setExtraEventButtonStyle(self, tee, style='normal'):
        button_style = self.extraEventButtonStyle(tee, style)
        self.buttonlist[tee].setStyleSheet(button_style)

    @pyqtSlot(bool)
    def recordextraevent_slot(self,_):
        try:
            self.recordextraevent(self.buttonlist.index(self.sender()))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    #called from user configured event buttons
    #by default actions are processed in a parallel thread, but components of multiple button actions not to avoid crashes
    def recordextraevent(self,ee,parallel=True,updateButtons=True):
        eventtype = self.extraeventstypes[ee]
        if updateButtons: # not if triggered from mutiplebutton actions:
            try:
                aw.qmc.eventactionsemaphore.acquire(1)
                # reset color of last pressed button
                if self.lastbuttonpressed != -1 and len(self.buttonlist)>self.lastbuttonpressed:
                    self.setExtraEventButtonStyle(self.lastbuttonpressed, style='normal')

                #toggle button if it has nonzero state prior to toggling
                if self.buttonStates[ee] != 0:
                    self.setExtraEventButtonStyle(ee, style='normal')
                else:
                    self.setExtraEventButtonStyle(ee, style='pressed')

                # reset lastbuttonpressed
                self.lastbuttonpressed = ee

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                if aw.qmc.eventactionsemaphore.available() < 1:
                    aw.qmc.eventactionsemaphore.release(1)
        cmdvalue = self.qmc.eventsInternal2ExternalValue(self.extraeventsvalues[ee])
        if eventtype < 4 or eventtype > 4:  ## if eventtype == 4 we have an button event of type " " that does not add an event; if eventtype == 9 ("-") we have an untyped event
            if eventtype == 9: # an untyped event
                # we just fire the action
                # split on an octothorpe '#' that is not inside parentheses '()'
                cmd = re.split(r'\#(?![^\(]*\))',self.extraeventsactionstrings[ee])[0].strip()
                cmd = cmd.format(*(tuple([cmdvalue]*cmd.count('{}'))))
                self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)
                # and record the event
                if self.qmc.flagstart:
                    # we use event handling to enable the doupdategraphics/doupdatebackground also if running in background thread
                    self.qmc.eventRecordSignal.emit(ee)
            else:
                if eventtype < 4: # absolute values
                    etype = eventtype
                    new_value = cmdvalue
                elif eventtype > 4: # relative values for +/- actions
                    etype = eventtype-5 # the real event type has a offset of 5 in this case
                    p = self.extraeventsactionslastvalue[etype]
                    if p is None:
                        new_value = cmdvalue
                    else:
                        new_value = p + cmdvalue
                # limit value w.r.t. the event slider min/max specification
                new_value = min(aw.eventslidermax[etype],max(aw.eventslidermin[etype],new_value))

                # the new_value is combined with the event factor and offset as specified in the slider definition
                actionvalue = self.calcEventValue(etype, new_value)
                if self.extraeventsactions[ee] != 14: # only for VOUT Commands we keep the floats
                    actionvalue = int(round(actionvalue))
                if self.extraeventsactions[ee] in [8,9,16,17,18]: # for Hottop Heater/Fan/CoolingFan action we take the event value instead of the event string as cmd action
                    self.eventaction(self.extraeventsactions[ee],str(int(new_value)),parallel=parallel)
                else:
                    # split on an octothorpe '#' that is not inside parentheses '()'
                    cmd = re.split(r'\#(?![^\(]*\))',self.extraeventsactionstrings[ee])[0].strip()
                    try:
                        cmd = cmd.format(*(tuple([actionvalue]*cmd.count('{}'))))
                    except Exception: # pylint: disable=broad-except
                        pass
                    self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)
                # remember the new value as the last value set for this event
                self.block_quantification_sampling_ticks[etype] = self.sampling_ticks_to_block_quantifiction
                self.extraeventsactionslastvalue[etype] = new_value
                # move corresponding slider to new value:
                self.moveslider(etype,new_value)
                if self.qmc.flagstart:
                    # we use event handling to enable the doupdategraphics/doupdatebackground also if running in background thread
                    self.qmc.eventRecordSignal.emit(ee)
        else:
            # just issue the eventaction (no cmd substitution here)
            # split on an octothorpe '#' that is not inside parentheses '()'
            cmd = re.split(r'\#(?![^\(]*\))',self.extraeventsactionstrings[ee])[0].strip()
            cmd = cmd.format(*(tuple([cmdvalue]*cmd.count('{}'))))
            self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resetApplication(self,_=False):
        if app.artisanviewerMode:
            string = QApplication.translate('Message','Do you want to reset all settings?<br> ArtisanViewer has to be restarted!')
        else:
            string = QApplication.translate('Message','Do you want to reset all settings?<br> Artisan has to be restarted!')
        reply = QMessageBox.warning(aw,QApplication.translate('Message','Factory Reset'),string,
                            QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.Reset, QMessageBox.StandardButton.Cancel)
        if reply == QMessageBox.StandardButton.Reset :
            #raise flag. Next time app will open, the settings (bad settings) will not be loaded.
            self.resetqsettings = 1
            self.clearExtraDeviceSettingsBackup()
            self.close()
        elif reply == QMessageBox.StandardButton.Cancel:
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCut_triggered(self,_=False): # pylint: disable=no-self-use # used as slot
        try:
            app.activeWindow().focusWidget().cut()
        except Exception: # pylint: disable=broad-except
            pass # not every QWidget has a cut method

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCopy_triggered(self,_=False): # pylint: disable=no-self-use # used as slot
        try:
            app.activeWindow().focusWidget().copy()
        except Exception: # pylint: disable=broad-except
            pass # not every QWidget has a copy method

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionPaste_triggered(self,_=False): # pylint: disable=no-self-use # used as slot
        try:
            app.activeWindow().focusWidget().paste()
        except Exception: # pylint: disable=broad-except
            pass # not every QWidget has a paste method

    # clears the message line without appending to the message log
    def clearMessageLine(self,style=None):
        self.sendmessage('',append=False,style=style)

    # this should only be called from within the main GUI thread (and never from the sampling thread!)
    @pyqtSlot(str,bool,str)
    def sendmessage(self,message,append=True,style=None):
        if isinstance(threading.current_thread(), threading._MainThread): # pylint: disable=protected-access
            # we are running in the main thread thus we can call sendmessage_internal via a QTimer to avoid redraw issues
            QTimer.singleShot(2,lambda : self.sendmessage_internal(message,append,style))
        else:
            # we are not running in the main thread thus we CANNOT call sendmessage_internal via a QTimer
            aw.sendmessageSignal.emit(message,append,style) # we emit a signal to the main thread to resend this message and then process it via the QTimer
            #self.sendmessage_internal(message,append,style,repaint=False)
            # if this is executed via a QTimer we receive "QObject::startTimer: Timers can only be used with threads started with QThread"

    def sendmessage_internal(self,message,append=True,style=None,repaint=True):
        try:
            #### lock shared resources #####
            aw.qmc.messagesemaphore.acquire(1)
            if message and not self.qmc.designerflag:
                _log.debug('message: %s', message)
            if style is not None and style != '':
                aw.messagelabel.setStyleSheet(style)
            else:
                aw.messagelabel.setStyleSheet(f"background-color:'transparent'; color: {aw.qmc.palette['messages']};")
            message = aw.arabicReshape(message)
            #keep a max of 100 messages
            if append:
                if len(self.messagehist) > 99:
                    self.messagehist = self.messagehist[1:]
                timez = QDateTime.currentDateTime().toString('hh:mm:ss.zzz ')    #zzz = milliseconds
                self.messagehist.append(f'{timez}{message}')
            self.messagelabel.setText(message)
            if repaint: # if repaint is executed in the main thread we receive "QWidget::repaint: Recursive repaint detected"
                self.messagelabel.repaint()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        finally:
            if aw.qmc.messagesemaphore.available() < 1:
                aw.qmc.messagesemaphore.release(1)

    def hideDefaultButtons(self):
        self.lowerbuttondialog.setVisible(False)

    def showDefaultButtons(self):
        self.lowerbuttondialog.setVisible(True)

    # update the visibility of the extra event buttons based on the users preference for the current state
    def updateExtraButtonsVisibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.extraeventsbuttonsflags[2]
        elif aw.qmc.flagon:
            visible = aw.extraeventsbuttonsflags[1]
        else:
            visible = aw.extraeventsbuttonsflags[0]
        if visible:
            self.showExtraButtons(False)
        else:
            self.hideExtraButtons(False)
        if app.artisanviewerMode:
            self.hideExtraButtons(True)

    def hideExtraButtons(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != aw.centralWidget():
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(False)
        aw.buttonsAction.setChecked(False)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.extraeventsbuttonsflags[2] = 0
            elif aw.qmc.flagon:
                aw.extraeventsbuttonsflags[1] = 0
            else:
                aw.extraeventsbuttonsflags[0] = 0

    def showExtraButtons(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != aw.centralWidget():
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(True)
        aw.buttonsAction.setChecked(True)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.extraeventsbuttonsflags[2] = 1
            elif aw.qmc.flagon:
                aw.extraeventsbuttonsflags[1] = 1
            else:
                aw.extraeventsbuttonsflags[0] = 1

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleExtraButtons(self,_=False):
        if self.extrabuttondialogs.isVisible():
            self.hideExtraButtons()
        else:
            self.showExtraButtons()

    # update the visibility of the sliders based on the users preference for the current state
    def updateSlidersVisibility(self):
        if app.artisanviewerMode:
            self.hideSliders(True)
        else:
            # update visibility (based on the app state)
            if aw.qmc.flagstart:
                visible = aw.eventslidersflags[2]
            elif aw.qmc.flagon:
                visible = aw.eventslidersflags[1]
            else:
                visible = aw.eventslidersflags[0]
            if visible:
                self.showSliders(False)
            else:
                self.hideSliders(False)

    def hideSliders(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != aw.centralWidget():
            focused_widget.clearFocus()
        self.setSliderFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider1.setVisible(False)
        self.slider2.setVisible(False)
        self.slider3.setVisible(False)
        self.slider4.setVisible(False)
        self.sliderSV.setVisible(False)
        self.sliderFrame.setVisible(False)
        aw.slidersAction.setChecked(False)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.eventslidersflags[2] = 0
            elif aw.qmc.flagon:
                aw.eventslidersflags[1] = 0
            else:
                aw.eventslidersflags[0] = 0

    def showSliders(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != aw.centralWidget():
            focused_widget.clearFocus()
        self.sliderFrame.setVisible(True)
        self.slider1.setVisible(True)
        self.slider2.setVisible(True)
        self.slider3.setVisible(True)
        self.slider4.setVisible(True)
        self.sliderSV.setVisible(True)
        self.setSliderFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # on "coarse" sliders we set the single step to 10, otherwise (default) to 1:
        if self.eventslidercoarse[0]:
            self.slider1.setSingleStep(10)
        else:
            self.slider1.setSingleStep(1)
        if self.eventslidercoarse[1]:
            self.slider2.setSingleStep(10)
        else:
            self.slider2.setSingleStep(1)
        if self.eventslidercoarse[2]:
            self.slider3.setSingleStep(10)
        else:
            self.slider3.setSingleStep(1)
        if self.eventslidercoarse[3]:
            self.slider4.setSingleStep(10)
        else:
            self.slider4.setSingleStep(1)
        #
        aw.slidersAction.setChecked(True)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.eventslidersflags[2] = 1
            elif aw.qmc.flagon:
                aw.eventslidersflags[1] = 1
            else:
                aw.eventslidersflags[0] = 1

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleSliders(self,_=False):
        if self.sliderFrame.isVisible():
            self.hideSliders()
        else:
            self.showSliders()

    def hideControls(self):
        self.level1frame.hide()
        aw.controlsAction.setChecked(False)

    def showControls(self):
        self.level1frame.show()
        aw.controlsAction.setChecked(True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleControls(self,_=False):
        if self.level1frame.isVisible():
            self.hideControls()
        else:
            self.showControls()

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleReadings(self,_=False):
        if self.lcdFrame.isVisible():
            self.hideLCDs()
        else:
            self.showLCDs()

    @staticmethod
    def updateSlidersProperties():
        # update slider properties and event type names
        if bool(aw.eventslidervisibilities[0]):
            aw.sliderGrpBox1.setVisible(True)
            aw.sliderGrpBox1.setTitle(aw.qmc.etypesf(0))
        else:
            aw.sliderGrpBox1.setVisible(False)
            aw.sliderGrpBox1.setTitle(None)
        if bool(aw.eventslidervisibilities[1]):
            aw.sliderGrpBox2.setVisible(True)
            aw.sliderGrpBox2.setTitle(aw.qmc.etypesf(1))
        else:
            aw.sliderGrpBox2.setVisible(False)
            aw.sliderGrpBox2.setTitle(None)
        if bool(aw.eventslidervisibilities[2]):
            aw.sliderGrpBox3.setVisible(True)
            aw.sliderGrpBox3.setTitle(aw.qmc.etypesf(2))
        else:
            aw.sliderGrpBox3.setVisible(False)
            aw.sliderGrpBox3.setTitle(None)
        if bool(aw.eventslidervisibilities[3]):
            aw.sliderGrpBox4.setVisible(True)
            aw.sliderGrpBox4.setTitle(aw.qmc.etypesf(3))
        else:
            aw.sliderGrpBox4.setVisible(False)
            aw.sliderGrpBox4.setTitle(None)

    def hideLCDs(self,changeDefault=True):
        self.lcd1.setVisible(False)
        self.lcdFrame.setVisible(False)
        aw.readingsAction.setChecked(False)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.readingslcdsflags[2] = 0
            elif aw.qmc.flagon:
                aw.readingslcdsflags[1] = 0
            else:
                aw.readingslcdsflags[0] = 0

    def showLCDs(self,changeDefault=True):
        self.lcd1.setVisible(True)
        self.lcdFrame.setVisible(True)
        aw.readingsAction.setChecked(True)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.readingslcdsflags[2] = 1
            elif aw.qmc.flagon:
                aw.readingslcdsflags[1] = 1
            else:
                aw.readingslcdsflags[0] = 1

    def updateReadingsLCDsVisibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.readingslcdsflags[2]
        elif aw.qmc.flagon:
            visible = aw.readingslcdsflags[1]
        else:
            visible = aw.readingslcdsflags[0]
        if visible:
            self.showLCDs(False)
        else:
            self.hideLCDs(False)
        if app.artisanviewerMode:
            self.hideLCDs(True)

    def hideEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(False)

    def showEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(True)

    def updateLCDproperties(self):
        # set LCDframe visibilities and labels
        ndev = len(aw.qmc.extradevices)
        for i in range(ndev):
            aw.extraLCDframe1[i].setVisible(bool(aw.extraLCDvisibility1[i]))
            if i < len(aw.qmc.extraname1):
                l1 = '<b>' + aw.qmc.extraname1[i] + '</b>'
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
                except Exception: # pylint: disable=broad-except
                    aw.extraLCDlabel1[i].setText(l1)
                self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
            aw.extraLCD1[i].setStyleSheet('QLCDNumber { border-radius:4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
            self.extraLCDframe2[i].setVisible(bool(aw.extraLCDvisibility2[i]))
            if i < len(aw.qmc.extraname2):
                l2 = '<b>' + aw.qmc.extraname2[i] + '</b>'
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
                except Exception: # pylint: disable=broad-except
                    aw.extraLCDlabel2[i].setText(l2)
                self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
            aw.extraLCD2[i].setStyleSheet('QLCDNumber { border-radius:4; color: %s; background-color: %s;}'%(aw.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
        #hide the rest (just in case)
        for i in range(ndev,aw.nLCDS):
            aw.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)
        aw.LCD2frame.setVisible(aw.qmc.BTlcd if aw.qmc.swaplcds else aw.qmc.ETlcd)
        aw.LCD3frame.setVisible(aw.qmc.ETlcd if aw.qmc.swaplcds else aw.qmc.BTlcd)
        aw.LCD4frame.setVisible(aw.qmc.DeltaBTlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaETlcdflag)
        aw.LCD5frame.setVisible(aw.qmc.DeltaETlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaBTlcdflag)
        #
        if aw.largeLCDs_dialog is not None:
            aw.largeLCDs_dialog.updateVisiblitiesETBT()
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.updateVisiblitiesDeltaETBT()
        if aw.largePIDLCDs_dialog is not None:
            aw.largePIDLCDs_dialog.updateVisiblitiesPID()
        if aw.largeExtraLCDs_dialog is not None:
            aw.largeExtraLCDs_dialog.updateVisiblitiesExtra()
        if aw.largePhasesLCDs_dialog is not None:
            aw.largePhasesLCDs_dialog.updateVisiblitiesPhases()
        #
        if aw.ser.showFujiLCDs and aw.qmc.device in (0, 26):         #extra LCDs for Fuji or DTA pid
            aw.LCD6frame.setVisible(True)
            aw.LCD7frame.setVisible(True)
        else:
            aw.LCD6frame.setVisible(False)
            aw.LCD7frame.setVisible(False)
        if self.qmc.LCDdecimalplaces:
            self.setLCDsDigitCount(5)
        else:
            self.setLCDsDigitCount(3)

    def disableLoadImportConvertMenus(self):
        self.fileLoadAction.setEnabled(False) # open
        self.openRecentMenu.setEnabled(False) # open recent
        self.importMenu.setEnabled(False) # import
        self.convMenu.setEnabled(False) # convert

    def enableLoadImportConvertMenus(self):
        self.fileLoadAction.setEnabled(True) # open
        self.openRecentMenu.setEnabled(True) # open recent
        self.importMenu.setEnabled(True) # import
        self.convMenu.setEnabled(True) # convert

    def enableEditMenus(self):
        self.newRoastMenu.setEnabled(True)
        self.fileLoadAction.setEnabled(True) # open
        self.openRecentMenu.setEnabled(True) # open recent
        self.importMenu.setEnabled(True) # import
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        self.fileSaveCopyAsAction.setEnabled(True)
        self.exportMenu.setEnabled(True)
        self.convMenu.setEnabled(True)
        self.saveGraphMenu.setEnabled(True)
        self.htmlAction.setEnabled(True)
        self.roastReportPDFAction.setEnabled(True)
        self.reportMenu.setEnabled(True)
        self.productionMenu.setEnabled(True)
        self.rankingMenu.setEnabled(True)
        self.printAction.setEnabled(True)
        self.editGraphAction.setEnabled(True)
        self.backgroundAction.setEnabled(True)
        self.switchAction.setEnabled(True)
        self.switchETBTAction.setEnabled(True)
        self.flavorAction.setEnabled(True)
        self.temperatureMenu.setEnabled(True)
        self.temperatureConfMenu.setEnabled(True)
        self.languageMenu.setEnabled(True)
        self.deviceAction.setEnabled(True)
        self.commportAction.setEnabled(True)
        self.curvesAction.setEnabled(True)
        self.analyzeMenu.setEnabled(True)
        self.roastCompareAction.setEnabled(True)
        self.designerAction.setEnabled(True)
        self.simulatorAction.setEnabled(True)
        self.wheeleditorAction.setEnabled(True)
        self.transformAction.setEnabled(True)
        self.loadSettingsAction.setEnabled(True)
        self.openRecentSettingMenu.setEnabled(True)
        self.saveAsSettingsAction.setEnabled(True)
        self.resetAction.setEnabled(True)
        self.switchAction.setEnabled(True)
        self.machineMenu.setEnabled(True)
        self.editGraphAction.setEnabled(True)
        self.backgroundAction.setEnabled(True)
        self.switchETBTAction.setEnabled(True)
        self.eventsAction.setEnabled(True)
        self.phasesGraphAction.setEnabled(True)
        self.StatisticsAction.setEnabled(True)
        self.WindowconfigAction.setEnabled(True)
        self.colorsAction.setEnabled(True)
        self.themeMenu.setEnabled(True)
        self.controlsAction.setEnabled(True)
        self.readingsAction.setEnabled(True)
        self.eventsEditorAction.setEnabled(True)
        self.buttonsAction.setEnabled(True)
        self.slidersAction.setEnabled(True)

        if self.qmc.statssummary:
            self.savestatisticsAction.setEnabled(True)
        self.displayonlymenus()

    def disableEditMenus(self,designer=False,wheel=False,compare=False,sampling=False):
        # FILE menu
        if designer or wheel or compare:
            self.newRoastMenu.setEnabled(False)
        else:
            self.newRoastMenu.setEnabled(True)
        if compare:
            self.fileLoadAction.setEnabled(True) # open
            self.openRecentMenu.setEnabled(True) # open recent
        else:
            self.fileLoadAction.setEnabled(False) # open
            self.openRecentMenu.setEnabled(False) # open recent
        self.importMenu.setEnabled(False) # import
        if not sampling:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False)
            self.fileSaveCopyAsAction.setEnabled(False)
            self.exportMenu.setEnabled(False)
        self.convMenu.setEnabled(False)
        if not wheel and not compare and not sampling:
            self.saveGraphMenu.setEnabled(False)
        self.htmlAction.setEnabled(False)
        self.roastReportPDFAction.setEnabled(False)
        self.reportMenu.setEnabled(False)
        self.productionMenu.setEnabled(False)
        self.rankingMenu.setEnabled(False)
        if not compare and not sampling:
            self.printAction.setEnabled(False)
        self.savestatisticsAction.setEnabled(False)
        # EDIT menu
        # ROAST menu
        if compare or wheel:
            self.editGraphAction.setEnabled(False)
            self.backgroundAction.setEnabled(False)
        self.flavorAction.setEnabled(False)
        self.switchAction.setEnabled(False)
        self.switchETBTAction.setEnabled(False)
        # CONFIG menu
        if not compare:
            self.machineMenu.setEnabled(False)
            self.deviceAction.setEnabled(False)
            self.commportAction.setEnabled(False)
        if designer or wheel:
            self.curvesAction.setEnabled(False) # Curves menu
        else:
            self.curvesAction.setEnabled(True)
        if wheel or designer:
            self.eventsAction.setEnabled(False)
            self.phasesGraphAction.setEnabled(False)
            self.StatisticsAction.setEnabled(False)
            self.WindowconfigAction.setEnabled(False)
            self.colorsAction.setEnabled(False)
        self.themeMenu.setEnabled(False)
        self.temperatureConfMenu.setEnabled(False)
        self.languageMenu.setEnabled(False)
        # TOOLS menu
        self.analyzeMenu.setEnabled(False)
        if not compare:
            self.roastCompareAction.setEnabled(False)
        else:
            self.roastCompareAction.setEnabled(True)
        if not designer:
            self.designerAction.setEnabled(False)
        else:
            self.designerAction.setEnabled(True)
        self.simulatorAction.setEnabled(False)
        if not wheel:
            self.wheeleditorAction.setEnabled(False)
        else:
            self.wheeleditorAction.setEnabled(True)
        self.transformAction.setEnabled(False)
        self.temperatureMenu.setEnabled(False)
        # VIEW menu
        if wheel:
            self.controlsAction.setEnabled(False)
        if wheel or designer:
            self.readingsAction.setEnabled(False)
            self.eventsEditorAction.setEnabled(False)
            self.buttonsAction.setEnabled(False)
            self.slidersAction.setEnabled(False)
        # HELP menu
        self.loadSettingsAction.setEnabled(False)
        self.openRecentSettingMenu.setEnabled(False)
        self.saveAsSettingsAction.setEnabled(False)
        self.resetAction.setEnabled(False)
        #
        self.displayonlymenus()

    def displayonlymenus(self):
        if app.artisanviewerMode:
            self.newRoastMenu.setEnabled(False)
#            self.deviceAction.setEnabled(False)
#            self.commportAction.setEnabled(False)
            self.calibrateDelayAction.setEnabled(False)
            self.saveAsSettingsAction.setEnabled(False)
#            self.resetAction.setEnabled(False)
            self.machineMenu.setEnabled(False)
            self.alarmAction.setEnabled(False)
            self.autosaveAction.setEnabled(False)
            self.batchAction.setEnabled(False)
            self.readingsAction.setEnabled(False)
            self.buttonsAction.setChecked(False)
            self.buttonsAction.setEnabled(False)
            self.slidersAction.setChecked(False)
            self.slidersAction.setEnabled(False)
            self.eventsEditorAction.setChecked(False)
            self.eventsEditorAction.setEnabled(False)
            self.lcdsAction.setEnabled(False)
            self.simulatorAction.setEnabled(False)
        else:
            return

    def update_minieventline_visibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.minieventsflags[2]
        elif aw.qmc.flagon:
            visible = aw.minieventsflags[1]
        else:
            visible = aw.minieventsflags[0]
        if visible:
            self.show_minieventline(False)
        else:
            self.hide_minieventline(False)

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggle_minieventline(self,_=False):
        if self.EventsGroupLayout.isVisible():
            self.hide_minieventline()
        else:
            self.show_minieventline()

    def hide_minieventline(self, changeDefault=True):
        self.releaseminieditor()
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != aw.centralWidget():
            focused_widget.clearFocus()
        self.EventsGroupLayout.setVisible(False)
        self.eventsEditorAction.setChecked(False)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.minieventsflags[2] = 0
            elif aw.qmc.flagon:
                aw.minieventsflags[1] = 0
            else:
                aw.minieventsflags[0] = 0

    def show_minieventline(self, changeDefault=True):
        self.EventsGroupLayout.setVisible(True)
        self.eventsEditorAction.setChecked(True)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.minieventsflags[2] = 1
            elif aw.qmc.flagon:
                aw.minieventsflags[1] = 1
            else:
                aw.minieventsflags[0] = 1

    def toggleForegroundShowfullFlag(self):
        self.qmc.foregroundShowFullflag = not self.qmc.foregroundShowFullflag
        self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3), deltas=False)
        self.qmc.redraw(recomputeAllDeltas=False)

    def toggleBackroundShowfullFlag(self):
        self.qmc.backgroundShowFullflag = not self.qmc.backgroundShowFullflag
        self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3), deltas=False)
        self.qmc.redraw(recomputeAllDeltas=False)

    def updatePlaybackIndicator(self):
        if self.qmc.l_subtitle is not None:
            if self.qmc.backgroundprofile is not None and self.qmc.backgroundPlaybackEvents:
                self.qmc.l_subtitle.set_color(self.qmc.palette['title_focus'])
            else:
                self.qmc.l_subtitle.set_color(self.qmc.palette['title'])
            self.qmc.ax.draw_artist(self.qmc.l_subtitle)
            self.qmc.ax.figure.canvas.blit()
            self.qmc.ax.figure.canvas.flush_events()
            self.qmc.ax_background = None

    def togglePlaybackEvents(self):
        self.qmc.backgroundPlaybackEvents = not self.qmc.backgroundPlaybackEvents
        if self.qmc.backgroundPlaybackEvents:
            self.sendmessage(QApplication.translate('ComboBox','Playback ON'))
        else:
            self.sendmessage(QApplication.translate('ComboBox','Playback OFF'))
        self.updatePlaybackIndicatorSignal.emit()

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work
    def keyPressEvent(self,event):
        if not self.processingKeyEvent:
            try:
                self.processingKeyEvent = True
                k = int(event.key())
                modifiers = event.modifiers()
                #Note: Windows only - PyQt will sometimes, but not always, interpret a shortcut k as a menu k.  For that
                #    reason only CTRL and CTRL+SHIFT modifier should be used with shortcut keys f,e,r,c,t,v, and h.
                control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier # command/apple k on macOS, CONTROL on Windows
                alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier # OPTION on macOS, ALT on Windows
                shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier # SHIFT
                control_alt_modifier = modifiers == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier)
                control_shift_modifier = modifiers == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier)
                #meta_modifier = modifiers == Qt.KeyboardModifier.MetaModifier # Control on macOS, Meta on Windows
                #uncomment next line to find the integer value of a k
                #print(k)
                #_log.info("PRINT key: %s",k)

                numberkeys = [48,49,50,51,52,53,54,55,56,57] # keycodes for number keys 0,1,...,9

                if k == 70:                         #F SELECTS FULL SCREEN MODE
                    self.toggleFullscreen()
                elif k == 71:                       #G (toggle time auto axis mode)
                    if not self.qmc.designerflag and not self.qmc.wheelflag:
                        if bool(aw.comparator):
                            aw.comparator.modeComboBox.setCurrentIndex((aw.comparator.modeComboBox.currentIndex()+1) % 3)
                        else:
                            self.qmc.autotimexMode = (self.qmc.autotimexMode+1) % 3
                            if self.qmc.autotimexMode == 0:
                                self.sendmessage(QApplication.translate('Message','Auto Axis Graph Mode: Roast'))
                            elif self.qmc.autotimexMode == 1:
                                self.sendmessage(QApplication.translate('Message','Auto Axis Graph Mode: BBP+Roast'))
                            elif self.qmc.autotimexMode == 2:
                                self.sendmessage(QApplication.translate('Message','Auto Axis Graph Mode: BBP'))
                            if not self.qmc.flagon:
                                # adjust foreground or if no foreground but background is loaded the background
                                self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3), deltas=False)
                                self.qmc.redraw()
                elif self.buttonpalette_shortcuts and control_modifier and k in numberkeys: # palette switch via SHIFT-NUM-Keys
                    self.setbuttonsfrom(numberkeys.index(k))
                elif k == 74:                       #J (toggle Playback Events)
                    self.togglePlaybackEvents()
                elif k == 73:                       #I (toggle foreground showfull flag)
                    self.toggleForegroundShowfullFlag()
                elif k == 79:                       #O (toggle background showfull flag)
                    self.toggleBackroundShowfullFlag()
                elif k == 72:                       #H  (load / delete background profile
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        # allow SHIFT-H for all platforms (ALT-H additionally for non-Windows platforms)
                        if ((alt_modifier or shift_modifier) and platf != 'Windows') or (control_shift_modifier or control_alt_modifier and platf == 'Windows'): #control_alt_modifier here for backward compatibility only, see note above
                            self.deleteBackground()
                            if not self.qmc.flagon:
                                self.autoAdjustAxis()
                            self.qmc.redraw()
                        else:
                            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Background'),ext_alt='.alog')
                            if len(filename) != 0:
                                try:
                                    self.qmc.resetlinecountcaches()
                                    self.loadbackground(filename)
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)
                                self.qmc.background = True
                                self.autoAdjustAxis()
                                self.qmc.timealign(redraw=False)
                                self.qmc.redraw()
                elif k == 76:                       #L
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Alarms'),ext='*.alrm')
                        if len(filename) == 0:
                            return
                        try:
                            aw.loadAlarms(filename)
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                elif k == 80:                       #P
                    # switch PID mode
                    if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                        # toggle mode: manual => RS => background
                        if not aw.fujipid.rampsoak and not aw.fujipid.followBackground: # => RS
                            aw.fujipid.setrampsoak(1)
                            aw.fujipid.rampsoak = True # even if activation failed to allow to further toggle around
                            aw.fujipid.followBackground = False
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Ramp/Soak'))
                        elif aw.fujipid.rampsoak: # => background
                            aw.fujipid.setrampsoak(0)
                            aw.fujipid.rampsoak = False # even if activation failed to allow to further toggle around
                            aw.fujipid.followBackground = True
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Background'))
                        else: # => manual
                            aw.fujipid.setrampsoak(0)
                            aw.fujipid.followBackground = False
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Manual'))
                    elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware/software PID
                        aw.pidcontrol.svMode = (aw.pidcontrol.svMode+1) %3
                        # 0: manual, 1: Ramp/Soak, 2: Follow (background profile)
                        if aw.pidcontrol.svMode == 0:
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Manual'))
                        elif  aw.pidcontrol.svMode == 1:
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Ramp/Soak'))
                        elif  aw.pidcontrol.svMode == 2:
                            aw.sendmessage(QApplication.translate('Message','PID Mode: Background'))
                elif k == 45:                       #-
                    if control_modifier or control_shift_modifier:
                        aw.setdpi(aw.dpi-10)
                    else:
                        if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                            aw.fujipid.lookahead = max(0,aw.fujipid.lookahead-1)
                            aw.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(aw.fujipid.lookahead))
                        elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware PID
                            aw.pidcontrol.svLookahead = max(0,aw.pidcontrol.svLookahead-1)
                            aw.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(aw.pidcontrol.svLookahead))
                elif k == 43:                       #+
                    if control_modifier or control_shift_modifier:
                        aw.setdpi(aw.dpi+10)
                    else:
                        if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                            aw.fujipid.lookahead = aw.fujipid.lookahead+1
                            aw.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(aw.fujipid.lookahead))
                        elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware PID
                            aw.pidcontrol.svLookahead = aw.pidcontrol.svLookahead+1
                            aw.sendmessage(QApplication.translate('Message','PID Lookahead: {0}').format(aw.pidcontrol.svLookahead))
                elif k == 32:                       #SELECTS ACTIVE BUTTON
                    if self.qmc.flagstart:
                        if self.keyboardmoveflag:
                            # if recording and manual keyboard move mode is on and
                            # EVENT button is not enabled and all visible buttons are disabled (flat)
                            # and selected button is NOT DROP (to enable undo DROP) nor the EVENT button
                            if (all(not self.qmc.buttonvisibility[i] or b.isFlat() for i,b in enumerate(self.keyboardButtonList[:-1])) and
                                self.keyboardmoveindex != 6) and (not self.eventsbuttonflag or self.keyboardmoveindex != 8):
                                self.qmc.toggleRecorderSignal.emit()
                            else:
                                self.moveKbutton('space')
                        else:
                            self.qmc.EventRecord()
                    elif self.qmc.flagon:
                        self.qmc.toggleRecorderSignal.emit()
                elif k == 16777220:                 #ENTER: turns ON/OFF keyboard moves
                    self.releaseminieditor()
                    self.moveKbutton('enter')
                elif k == 16777216:                 #ESCAPE
                    self.quickEventShortCut = None
                    aw.clearMessageLine()
                    macfullscreen = False
                    try:
                        if platf == 'Darwin' and app.allWindows()[0].visibility() == QWindow.Visibility.FullScreen:
                            macfullscreen = True
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    if self.full_screen_mode_active or self.isFullScreen() or macfullscreen:
                        self.toggleFullscreen()
                    else:
                        #if designer ON
                        if self.qmc.designerflag:
                            string = QApplication.translate('Message','Exit Designer?')
                            reply = QMessageBox.question(aw,QApplication.translate('Message', 'Designer Mode ON'),string,QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                            if reply == QMessageBox.StandardButton.Yes:
                                self.stopdesigner()
                            else:
                                return
                        #if wheel graph ON
                        elif self.qmc.wheelflag:
                            self.qmc.wheelflag = False
                            self.wheeleditorAction.setChecked(self.qmc.wheelflag)
                            self.qmc.exitviewmode()
                            aw.enableEditMenus()
                            aw.showControls()
                        self.releaseminieditor()
                elif k == 16777234:               #MOVES CURRENT BUTTON LEFT
                    if self.keyboardmoveflag:
                        self.moveKbutton('left')
                    elif aw.qmc.background:
                        aw.qmc.movebackground('left',aw.qmc.backgroundmovespeed)
                        self.qmc.backmoveflag = 0 # do not align background automatically during redraw!
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif k == 16777236:               #MOVES CURRENT BUTTON RIGHT
                    if self.keyboardmoveflag:
                        self.moveKbutton('right')
                    elif aw.qmc.background:
                        aw.qmc.movebackground('right',aw.qmc.backgroundmovespeed)
                        self.qmc.backmoveflag = 0 # do not align background automatically during redraw!
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif k == 16777235:               #UP
                    if aw.qmc.background:
                        aw.qmc.movebackground('up',aw.qmc.backgroundmovespeed)
                        self.qmc.backmoveflag = 0 # do not align background automatically during redraw!
                        aw.qmc.redraw(recomputeAllDeltas=False,sampling=aw.qmc.flagon)
                elif k == 16777237:               #DOWN
                    if aw.qmc.background:
                        aw.qmc.movebackground('down',aw.qmc.backgroundmovespeed)
                        self.qmc.backmoveflag = 0 # do not align background automatically during redraw!
                        aw.qmc.redraw(recomputeAllDeltas=False,sampling=aw.qmc.flagon)
                elif k == 65:                     #letter A (automatic save)
                    if not app.artisanviewerMode and self.qmc.flagon and not self.qmc.designerflag and not bool(aw.comparator):
                        self.automaticsave()
                elif k == 68:                     #letter D (toggle xy coordinates between temp and RoR scale)
                    if not self.qmc.wheelflag:
                        if not self.qmc.fmt_data_ON:
                            self.qmc.fmt_data_ON = True
                        elif self.qmc.fmt_data_RoR == False and self.qmc.twoAxisMode():
                            self.qmc.fmt_data_RoR = True
                        else:
                            self.qmc.fmt_data_RoR = False
                            self.qmc.fmt_data_ON = False
                        aw.ntb.update_message()
                        # force redraw crosslines if active
                        if aw.qmc.crossmarker:
                            try:
                                aw.ntb.mouse_move(mplLocationevent.lastevent)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                elif k == 90:                     #letter Z (toggle xy coordinates between 0: cursor, 1: BT, 2: ET, 3: BTB, 4: ETB)
                    if not self.qmc.designerflag and not self.qmc.wheelflag and not bool(aw.comparator):
                        self.qmc.nextFmtDataCurve()
                elif k == 85:                     #letter U (toggle running LCDs on/off)
                    if not self.qmc.flagon:
                        if self.qmc.running_LCDs == 0 and self.curFile:
                            self.qmc.running_LCDs = 1
                            aw.sendmessage(QApplication.translate('Message', 'LCD cursor on profile data'))
                        elif self.qmc.running_LCDs in [0, 1] and self.qmc.backgroundprofile:
                            self.qmc.running_LCDs = 2
                            aw.sendmessage(QApplication.translate('Message', 'LCD cursor on template data'))
                        elif self.qmc.running_LCDs in [1, 2]:
                            self.qmc.running_LCDs = 0
                            aw.sendmessage(QApplication.translate('Message', 'LCD cursor OFF'))
                        if self.qmc.running_LCDs == 0:
                            self.qmc.updateLCDs(
                                -1,
                                self.qmc.temp1,
                                self.qmc.temp2,
                                self.qmc.delta1,
                                self.qmc.delta2,
                                self.qmc.extratemp1,
                                self.qmc.extratemp2,
                                idx=None) # show default OFF placeholders in LCDs
                        else:
                            aw.ntb.update_message()
                elif k == 67:                     #letter C (controls)
                    if not self.qmc.wheelflag:
                        self.toggleControls()
                elif k == 88:                     #letter X (readings)
                    if not app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggleReadings()
                elif k == 89:                     #letter Y (minieditor)
                    if not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggle_minieventline()
                elif k == 83:                     #letter S (sliders)
                    if not app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggleSliders()
                elif k == 84 and not self.qmc.flagon:  #letter T (mouse cross)
                    self.qmc.togglecrosslines()
                elif k == 81:  #letter q (quick entry of custom event 1)
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        self.quickEventShortCut = (0,'')
                        aw.sendmessage('%s'%aw.qmc.etypes[0])
                elif k == 87:  #letter w (quick entry of custom event 2)
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        self.quickEventShortCut = (1,'')
                        aw.sendmessage('%s'%aw.qmc.etypes[1])
                elif k == 69:  #letter e (quick entry of custom event 3)
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        self.quickEventShortCut = (2,'')
                        aw.sendmessage('%s'%aw.qmc.etypes[2])
                elif k == 82:  #letter r (quick entry of custom event 4)
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        self.quickEventShortCut = (3,'')
                        aw.sendmessage('%s'%aw.qmc.etypes[3])
                elif k == 86: #letter v (Set SV)
                    if not self.qmc.designerflag and not bool(aw.comparator):
                        self.quickEventShortCut = (4,'')
                        aw.sendmessage('SV')
                elif k == 66:  #letter b hides/shows extra rows of event buttons
                    if (alt_modifier and platf != 'Windows') or (control_shift_modifier and platf == 'Windows'):
                        # activate custom event button
                        self.quickEventShortCut = (-1,'')
                        aw.sendmessage(f"{QApplication.translate('Label','Event button')}")
                    else:
                        if not app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                            self.toggleextraeventrows()
                elif k == 77:  #letter m hides/shows standard buttons row
                    if aw.qmc.flagstart:
                        self.standardButtonsVisibility()
                #Extra event buttons palette. Numerical keys [0,1,2,3,4,5,6,7,8,9]
                elif 47 < k < 58:
                    if not app.artisanviewerMode:
                        button = [48,49,50,51,52,53,54,55,56,57]
                        if self.quickEventShortCut:
                            # quick custom event entry
                            eventNr = self.quickEventShortCut[0]
                            eventValueStr = self.quickEventShortCut[1] + str(button.index(k))
                            if eventNr == -1:
                                aw.sendmessage(f"{QApplication.translate('Label','Event button')} {eventValueStr}")
                            elif eventNr == 4:
                                aw.sendmessage('SV %s'%(eventValueStr))
                            else:
                                aw.sendmessage('%s %s'%(aw.qmc.etypes[eventNr],eventValueStr))
                            if eventNr == -1: # Custom Event Button
                                if len(eventValueStr) == 2:
                                    buttonnumber = int(eventValueStr)-1
                                    if buttonnumber < len(self.extraeventstypes):
                                        self.recordextraevent(buttonnumber,parallel=False,updateButtons=False)
                                    else:
                                        try:
                                            aw.sendmessage(QApplication.translate('Message',f'Button {int(eventValueStr)}not defined'))
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr,eventValueStr)
                            elif eventNr == 4: # SV
                                if len(eventValueStr) == 3:
                                    # three digits entered, set the SV
                                    self.quickEventShortCut = None
                                    value = int(eventValueStr)
                                    aw.clearMessageLine()
                                    self.SVslidermoved = 1
                                    self.updateSVSliderLCD(value)
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr,eventValueStr)
                            else:
                                if (len(eventValueStr) == 2 and aw.eventslidermax[eventNr]<=100) or (len(eventValueStr) == 3 and aw.eventslidermax[eventNr]>100):
                                    # both digits entered, create the event
                                    self.quickEventShortCut = None
                                    value = max(aw.eventslidermin[eventNr],min(aw.eventslidermax[eventNr],int(eventValueStr)))
                                    aw.moveslider(eventNr,value)
                                    aw.recordsliderevent(eventNr)
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr,eventValueStr)
# now shift modifier is required to switch palettes via number keys
#                       else:
#                            if aw.buttonpalette_shortcuts:
#                               self.setbuttonsfrom(button.index(k))
                elif k == 58 and not aw.qmc.flagon: # k ";": screenshots only if not sampling!
                    self.desktopscreenshot()
                elif k == 59 and not aw.qmc.flagon: # k ":": screenshots only if not sampling!
                    self.applicationscreenshot()
                else:
                    QWidget.keyPressEvent(self, event)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                self.processingKeyEvent = False

    def releaseminieditor(self):
        self.lineEvent.releaseKeyboard()
        self.valueEdit.releaseKeyboard()
        self.etimeline.releaseKeyboard()
        self.etypeComboBox.releaseKeyboard()
        self.eNumberSpinBox.releaseKeyboard()
        self.lineEvent.clearFocus()
        self.valueEdit.clearFocus()
        self.etimeline.clearFocus()
        self.etypeComboBox.clearFocus()
        self.eNumberSpinBox.clearFocus()
        self.buttonminiEvent.clearFocus()

    # this function respects the button visibility via aw.qmc.buttonvisibility and if button.isDisabled()
    # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END; 8:EVENT (EVENT is always enabled!)
    # buttons that trigger events and can be triggered only once
    def nextActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 8: # current: EVENT
            currentButtonIndex = -1 # next: CHARGE
        if currentButtonIndex == 7: # current: COOL (last before EVENT)
            # check if the EVENT button is active, else move to the ON/OFF
            if aw.eventsbuttonflag:
                return 8 # next: EVENT (always enabled)
            currentButtonIndex = -1 # next: CHARGE
        # we check if the next button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
        if self.qmc.buttonvisibility[currentButtonIndex + 1] and self.keyboardButtonList[currentButtonIndex + 1].isEnabled():
            return currentButtonIndex + 1
        if not any(self.qmc.buttonvisibility): # prevent infinite loop if all buttons are hidden
            return 7 # CHARGE
        return self.nextActiveButton(currentButtonIndex + 1)

    def previousActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 0: # current: CHARGE
            # check if the EVENT button is active, else move beyond
            if aw.eventsbuttonflag:
                return 8 # next: EVENT
            currentButtonIndex = 8 # set to EVENT and move to previous non-flat button
        # we check if the previous button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
        if self.qmc.buttonvisibility[currentButtonIndex - 1] and self.keyboardButtonList[currentButtonIndex - 1].isEnabled():
            return currentButtonIndex - 1
        if not any(self.qmc.buttonvisibility): # prevent infinite loop if all buttons are hidden
            return 0 # CHARGE
        return self.previousActiveButton(currentButtonIndex - 1)

    def resetKeyboardButtonMarks(self):
        if self.qmc.flagon:
            if self.simulator:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles_simulator['ON'])
            else:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['ON'])
        else:
            if self.simulator:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles_simulator['OFF'])
            else:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['OFF'])
        for b in [
                self.buttonCHARGE,  # CHARGE
                self.buttonDRY, # DRY END
                self.buttonFCs,  # FCs
                self.buttonFCe,  # FCe
                self.buttonSCs,  # SCs
                self.buttonSCe,  # SCe
                self.buttonDROP,  # DROP
                self.buttonCOOL, # COOL END
                self.buttonEVENT  # EVENT
                ]:
            b.setSelected(False)

    def ignoreFlatButtons(self,moveindex):
        # there is an offset between keyboardButtonList and self.buttonvisibilty of 1
        if self.keyboardButtonList[moveindex].isFlat() or (moveindex < 7 and not aw.qmc.buttonvisibility[moveindex]):
            # we search forward for the next non-flat button
            if moveindex < 7: # exclude the EVENT button that is not covered by aw.qmc.buttonvisibility
                m = moveindex + 1
                # we jump over invisible buttons
                while m < 8 and (not aw.qmc.buttonvisibility[m] or self.keyboardButtonList[m].isFlat()):
                    m = m + 1
                return m
        return moveindex

    # called after markCHARGE, markDROP,....
    # moves keyboard navigation to next button
    # and enables/disables buttons depending if undo is applicable
    def onMarkMoveToNext(self, button):
        try:
            this_index = self.keyboardButtonList.index(button)
            if self.qmc.buttonvisibility[this_index]:
                if button.isFlat():
                    if self.keyboardmoveflag:
                        # keyboard navigation is active, button is flat (was just activated), and button is visible
                        # move to the right up to the button index
                        if self.keyboardmoveindex < this_index:
                            for _ in range(this_index - self.keyboardmoveindex):
                                self.moveKbutton('right')
                                if self.keyboardmoveindex == this_index:
                                    break
                        # if we found our button, move one more to the right
                        if this_index == self.keyboardmoveindex:
                            self.moveKbutton('right') # now to the next
                    # disable all buttons before this_index until the previous registered event
                    for i in range(this_index-1,-1,-1):
                        self.keyboardButtonList[i].setEnabled(False)
                        if self.qmc.timeindex[i]>0:
                            # stop if already marked
                            break
                else:
                    # an undo action
                    # enable all buttons before this_index until the previous registered event
                    for i in range(this_index-1,-1,-1):
                        self.keyboardButtonList[i].setEnabled(True)
                        if self.qmc.timeindex[i]>0:
                            # stop if already marked
                            break
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    def moveKbutton(self, kcommand, force:bool = False):
        #"Enter" toggles ON/OFF keyboard
        if kcommand =='enter' and self.qmc.flagstart:
            if force or self.keyboardmoveflag == 0:
                #turn on
                self.keyboardmoveflag = 1
                # deactivate slider keyboard control
                self.setSliderFocusPolicy(Qt.FocusPolicy.NoFocus)
                self.sendmessage(QApplication.translate('Message','Keyboard moves turned ON'))
                self.keyboardmoveindex = self.ignoreFlatButtons(self.keyboardmoveindex) - 1
            elif self.keyboardmoveflag == 1:
                # turn off
                self.keyboardmoveflag = 0
                # activate slider keyboard control
                self.setSliderFocusPolicy(Qt.FocusPolicy.StrongFocus)
                # clear all
                self.sendmessage(QApplication.translate('Message','Keyboard moves turned OFF'))
                self.resetKeyboardButtonMarks()
        #if moves on
        if self.keyboardmoveflag:
            if kcommand == 'space':
                now = libtime.perf_counter()
                if self.lastkeyboardcmd == 0 or (now > self.lastkeyboardcmd + 1): # accept SPACE keyboard cmds only every 1sec.
                    self.keyboardmove[self.keyboardmoveindex]()   #apply button command
                    #behaviour rules after pressing a button
                    self.lastkeyboardcmd = now
                    self.releaseminieditor()
                else: # we ignore this event
                    return
            else:
                if kcommand == 'left':
                    nextcmd = self.previousActiveButton(self.keyboardmoveindex)
                else:
                    nextcmd = self.nextActiveButton(self.keyboardmoveindex)
                # activate the button at index nextcmd
                self.keyboardButtonList[nextcmd].setSelected(True)
                self.keyboardButtonList[self.keyboardmoveindex].setSelected(False)
                # update self.keyboardmoveindex
                self.keyboardmoveindex = nextcmd
        # we enable keyboard event processing again

    #sound feedback when pressing a push button
    @pyqtSlot()
    def soundpop(self):
        if self.soundflag:
            QApplication.beep()

#    @staticmethod
#    def removeDisallowedFilenameChars(filename):
#        import unicodedata # @UnresolvedImport
#        cleanedFilename = s2a(unicodedata.normalize('NFKD', filename))
#        import string as libstring
#        validFilenameChars = f'-_.() {libstring.ascii_letters}{libstring.digits}'
#        return ''.join(c for c in decodeLocal(cleanedFilename) if c in validFilenameChars)


    def generateFilename(self,prefix='',previewmode=0):
        filename = ''
        try:
            if prefix == '':
                title = None
                if  aw.qmc.title != '' and aw.qmc.title != QApplication.translate('Scope Title', 'Roaster Scope'):
                    title = aw.qmc.title
                if prefix == '' and title:
                    filename = title
                else:
                    filename = prefix
                if filename != '':
                    filename += '_' + aw.qmc.roastdate.toString('yy-MM-dd_hhmm')
                else:
                    filename += aw.qmc.roastdate.toString('yy-MM-dd_hhmm')
            else:
                filename = self.parseAutosaveprefix(prefix,previewmode=previewmode)
            filename += '.alog'
#            #clean name (disabled now since Artisan >2.6.0)
#            filename = self.removeDisallowedFilenameChars(filename)
            filename = filename.strip()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        return filename

    #replace fields delimited as %field% with the corresponding value
    #previewmode 0=not preview, 1=preview for while recording, 2=preview for while not recording
    def parseAutosaveprefix(self,fn,previewmode=0):
        try:
            currtime = QDateTime.currentDateTime().toString('hhmmss')

            #single, leading delimiter for the fields
            fieldDelim = '~'  #note this value is hard coded in autosavefields
            #delimiter for ON only
            onDelim = "'"
            #delimiter for OFF only
            offDelim = '"'

            #it is text only when there are no disallowed characters, so add the date for backward compatibility and return.
#            if fn == self.removeDisallowedFilenameChars(str(fn)):
            if fieldDelim not in fn:
                fn += '_' + self.qmc.roastdate.toString('yy-MM-dd_hhmm')
                return fn

            #newlines can sneak in from cut and paste from help page
            fn = fn.replace('\n', '')

            #if flagon then the batchcounter has not yet been incremented so we do that here
            if (self.qmc.flagon or previewmode==1) and self.qmc.batchcounter != -1:
                bnr = self.qmc.batchcounter + 1
            else:
                bnr = self.qmc.roastbatchnr

            #grab the first line of the beens field
            firstline = re.match(r'([^\n]*)',self.qmc.beans)
            if firstline:
                beansline = firstline.group(0)
            else:
                beansline = ''

            #grab the first line of the roasting notes field
            firstline = re.match(r'([^\n]*)',self.qmc.roastingnotes)
            if firstline:
                roastingnotesline = firstline.group(0)
            else:
                roastingnotesline = ''

            #grab the first line of the cupping notes field
            firstline = re.match(r'([^\n]*)',self.qmc.cuppingnotes)
            if firstline:
                cuppingnotesline = firstline.group(0)
            else:
                cuppingnotesline = ''

            cp = aw.computedProfileInformation()
            if 'DROP_time' in cp:
                m, s = divmod(cp['DROP_time'], 60)
                droptime_long = f'{int(m):02d}_{int(s):02d}'
            else:
                droptime_long = '00_00'
            if 'DROP_time' in cp and 'FCs_time' in cp and cp['DROP_time'] > 0 and cp['DROP_time'] > cp['FCs_time']:
                devtime_int = int(cp['DROP_time'] - cp['FCs_time'])
                devtime = str(devtime_int)
                m, s = divmod(devtime_int, 60)
                devtime_long = f'{int(m):02d}_{int(s):02d}'
                dtr = str(self.float2float(100 * (cp['DROP_time'] - cp['FCs_time'])/cp['DROP_time'],1))
            else:
                devtime = '0'
                devtime_long = '00_00'
                dtr = '0.0'
            if 'green_density' in cp and 'roasted_density' in cp:
                density_loss = str(aw.float2float(100 *(cp['green_density'] - cp['roasted_density']) / cp['green_density'],1))
            else:
                density_loss = '0.0'

            #note: since fields are delimited only at the start, to avoid ambiguity requires the shortest field string to be last in the list.  Example, "date_time" must come before "date" in the list.
            fields = [
                ('batch_long', self.qmc.roastbatchprefix + str(bnr) + ' (' + str(self.qmc.roastbatchpos) + ')'),
                ('batchprefix',self.qmc.roastbatchprefix),
                ('batchcounter',str(bnr)),
                ('batchposition',str(self.qmc.roastbatchpos)),
                ('batch', self.qmc.roastbatchprefix + str(bnr)),
                ('title',self.qmc.title),
                ('datetime_long',self.qmc.roastdate.toString('yyyy-MM-dd_hhmm')),
                ('datetime',self.qmc.roastdate.toString('yy-MM-dd_hhmm')),
                ('date_long',self.qmc.roastdate.toString('yyyy-MM-dd')),
                ('date',self.qmc.roastdate.toString('yy-MM-dd')),
                ('time',self.qmc.roastdate.toString('hhmm')),
                ('operator',self.qmc.operator),
                ('organization',self.qmc.organization),
                ('machine',self.qmc.roastertype),
                ('capacity',self.qmc.roastersize),
                ('drumspeed',self.qmc.drumspeed),
                ('weightloss',str(cp['weight_loss']) if 'weight_loss' in cp else '0.0'),
                ('volumegain',str(cp['volume_gain']) if 'volume_gain' in cp else '0.0'),
                ('densityloss',density_loss),
                ('moistureloss',str(cp['moisture_loss']) if 'moisture_loss' in cp else '0.0'),
                ('weightunits',self.qmc.weight[2]),
                ('weight',str(self.qmc.weight[0])),
                ('volumeunits',self.qmc.volume[2]),
                ('volume',str(self.qmc.volume[0])),
                ('densityunits',self.qmc.density[1] + '_' + self.qmc.density[3]),
                ('density',str(self.qmc.density[0])),
                ('moisture',str(self.qmc.moisture_greens)),
                ('beans_line',beansline),
                ('beans_10',beansline[:10]),
                ('beans_15',beansline[:15]),
                ('beans_20',beansline[:20]),
                ('beans_25',beansline[:25]),
                ('beans_30',beansline[:30]),
                ('beans',beansline[:30]),   #undocumented, remains here for hidden backward compatibility with v2.4RC
                ('roastedweight',str(self.float2float(float(self.qmc.weight[1]),1))),
                ('roastedvolume',str(self.float2float(float(self.qmc.volume[1]),1))),
                ('roasteddensity',str(self.float2float(float(self.qmc.density_roasted[0]),1))),
                ('roastedmoisture',str(self.float2float(float(self.qmc.moisture_roasted)))),
                ('colorwhole',str(self.qmc.whole_color)),
                ('colorground',str(self.qmc.ground_color)),
                ('colorsystem',str(self.qmc.color_systems[self.qmc.color_system_idx])),
                ('screenmax',str(aw.qmc.beansize_max)),
                ('screenmin',str(aw.qmc.beansize_min)),
                ('greenstemp',str(self.float2float(float(aw.qmc.greens_temp)))),
                ('ambtemp',str(cp['ambient_temperature']) if 'ambient_temperature' in cp else '0.0'),
                ('ambhumidity',str(cp['ambient_humidity']) if 'ambient_humidity' in cp else '0.0'),
                ('ambpressure',str(cp['ambient_pressure']) if 'ambient_pressure' in cp else '0.0'),
                ('aucbase',str(cp['AUCbase']) if 'AUCbase' in cp else '0'),
                ('auc',str(cp['AUC']) if 'AUC' in cp else '0'),
                ('chargeet',str(cp['CHARGE_ET']) if 'CHARGE_ET' in cp else '0.0'),
                ('chargebt',str(cp['CHARGE_BT']) if 'CHARGE_BT' in cp else '0.0'),
                ('fcset',str(cp['FCs_ET']) if 'FCs_ET' in cp else '0.0'),
                ('fcsbt',str(cp['FCs_BT']) if 'FCs_BT' in cp else '0.0'),
                ('dropet',str(cp['DROP_ET']) if 'DROP_ET' in cp else '0.0'),
                ('dropbt',str(cp['DROP_BT']) if 'DROP_BT' in cp else '0.0'),
                ('droptime_long', droptime_long),
                ('droptime',str(int(cp['DROP_time'])) if 'DROP_time' in cp else '0'),
                ('devtime_long', devtime_long),
                ('devtime', devtime),
                ('dtr', dtr),
                ('roastingnotes_line',roastingnotesline),
                ('roastingnotes_10',roastingnotesline[:10]),
                ('roastingnotes_15',roastingnotesline[:15]),
                ('roastingnotes_20',roastingnotesline[:20]),
                ('roastingnotes_25',roastingnotesline[:25]),
                ('roastingnotes_30',roastingnotesline[:30]),
#                ("roastingnotes",roastingnotesline[:30]),
                ('cuppingnotes_line',cuppingnotesline),
                ('cuppingnotes_10',cuppingnotesline[:10]),
                ('cuppingnotes_15',cuppingnotesline[:15]),
                ('cuppingnotes_20',cuppingnotesline[:20]),
                ('cuppingnotes_25',cuppingnotesline[:25]),
                ('cuppingnotes_30',cuppingnotesline[:30]),
#                ("cuppingnotes",cuppingnotesline[:30]),
                ('roastweight',str(self.float2float(float(self.qmc.weight[1]),1))),            #deprecated
                ('roastvolume',str(self.float2float(float(self.qmc.volume[1]),1))),            #deprecated
                ('roastdensity',str(self.float2float(float(self.qmc.density_roasted[0]),1))),  #deprecated
                ('roastmoisture',str(self.float2float(float(self.qmc.moisture_roasted)))),     #deprecated
                ('yyyy', self.qmc.roastdate.toString('yyyy')),
                ('yy', self.qmc.roastdate.toString('yy')),
                ('mmm', encodeLocal(self.qmc.roastdate.toString('MMM'))),
                ('mm', self.qmc.roastdate.toString('MM')),
                ('ddd', encodeLocal(self.qmc.roastdate.toString('ddd'))),
                ('dd', self.qmc.roastdate.toString('dd')),
                ('hour', self.qmc.roastdate.toString('hh')),
                ('minute', self.qmc.roastdate.toString('mm')),
                ('currtime', currtime),
                #  Energy Use
                ('btubatch', str(cp['BTU_batch']) if 'BTU_batch' in cp else '0.0'),
                ('co2batch', str(cp['CO2_batch']) if 'CO2_batch' in cp else '0.0'),
                ('btupreheat', str(cp['BTU_preheat']) if 'BTU_preheat' in cp else '0.0'),
                ('co2preheat', str(cp['CO2_preheat']) if 'CO2_preheat' in cp else '0.0'),
                ('btubbp', str(cp['BTU_bbp']) if 'BTU_bbp' in cp else '0.0'),
                ('co2bbp', str(cp['CO2_bbp']) if 'CO2_bbp' in cp else '0.0'),
                #("btucooling", str(cp["BTU_cooling"]) if "BTU_cooling" in cp else "0.0"),
                #("co2cooling", str(cp["CO2_cooling"]) if "CO2_cooling" in cp else "0.0"),
                ('bturoast', str(cp['BTU_roast']) if 'BTU_roast' in cp else '0.0'),
                ('co2roast', str(cp['CO2_roast']) if 'CO2_roast' in cp else '0.0'),
                ('co2batchpergreenkg', str(cp['CO2_batch_per_green_kg']) if 'CO2_batch_per_green_kg' in cp else '0.0'),
                ('co2roastpergreenkg', str(cp['CO2_roast_per_green_kg']) if 'CO2_roast_per_green_kg' in cp else '0.0'),
                ('btubatchpergreenkg', str(cp['BTU_batch_per_green_kg']) if 'BTU_batch_per_green_kg' in cp else '0.0'),
                ('bturoastpergreenkg', str(cp['BTU_roast_per_green_kg']) if 'BTU_roast_per_green_kg' in cp else '0.0'),
                ('effbatch', str(cp['KWH_batch_per_green_kg']) if 'KWH_batch_per_green_kg' in cp else '0.0'),
                ('effroast', str(cp['KWH_roast_per_green_kg']) if 'KEH_roast_per_green_kg' in cp else '0.0'),
                ]

            _ignorecase = re.IGNORECASE  # @UndefinedVariable
            #text between single quotes ' will show only when recording or for preview recording
            fn = re.sub(r'{od}([^{od}]+){od}'.format(od=onDelim),
                r'\1',fn) if (previewmode==1 or (previewmode==0 and self.qmc.flagon)) else re.sub(r'{od}([^{od}]+){od}'.format(
                    od=onDelim),r'',fn)
            #text between double quotes " will show only when flagon is False
            fn = re.sub(r'{od}([^{od}]+){od}'.format(od=offDelim),
                r'\1',fn) if (previewmode==2 or (previewmode==0 and not self.qmc.flagon)) else re.sub(r'{od}([^{od}]+){od}'.format(
                    od=offDelim),r'',fn)
            #replace the fields with content
            for i in range(len(fields)):
                fn = re.sub(fr'{fieldDelim}{fields[i][0]}', fr'{str(fields[i][1])}', fn, 0, _ignorecase)

            #cleaning is performed in generateFilename()
            #fn = self.removeDisallowedFilenameChars(str(fn))
            #fn = fn.strip()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Error:') + ' parseAutosaveprefix() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return fn

    #automatation of filename when saving a file through keyboard shortcut. Speeds things up for batch roasting.
    # returns filename on success, None otherwise
    def automaticsave(self,interactive=True):
        try:
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                prefix = ''
                if self.qmc.autosaveprefix != '':
                    prefix = self.qmc.autosaveprefix
                elif aw.qmc.batchcounter > -1 and aw.qmc.roastbatchnr > 0:
                    prefix += aw.qmc.batchprefix + str(aw.qmc.roastbatchnr)
                filename = self.generateFilename(prefix=prefix)
                filename_path = os.path.join(self.qmc.autosavepath,filename)
                oldDir = str(QDir.current())
                res = QDir.setCurrent(self.qmc.autosavepath)
                if res:
                    #write
                    pf = self.getProfile()
                    sync_record_hash = plus.controller.updateSyncRecordHashAndSync()
                    if sync_record_hash is not None:
                        # we add the hash over the sync record to be able to detect offline changes
                        pf['plus_sync_record_hash'] = encodeLocal(sync_record_hash)
                    self.serialize(filename_path,pf)
                    self.sendmessage(QApplication.translate('Message','Profile {0} saved in: {1}').format(filename,self.qmc.autosavepath))
                    self.setCurrentFile(filename_path,aw.qmc.autosaveaddtorecentfilesflag)
                    self.qmc.fileCleanSignal.emit()

                    if self.qmc.autosavealsopath != '':
                        other_filename_path = os.path.join(self.qmc.autosavealsopath,filename)
                    else:
                        other_filename_path = os.path.join(self.qmc.autosavepath,filename)

                    if self.qmc.autosaveimage and not aw.qmc.flagon:
                        if other_filename_path.endswith('.alog'):
                            other_filename_path = other_filename_path[0:-5]
                        if self.qmc.autosaveimageformat == 'PDF':
                            self.saveVectorGraph(extension='.pdf',fname=other_filename_path)
                        elif self.qmc.autosaveimageformat == 'PDF Report' and self.QtWebEngineSupport:
                            self.roastReport(pdf_filename=other_filename_path + '.pdf')
                        elif self.qmc.autosaveimageformat == 'SVG':
                            self.saveVectorGraph(extension='.svg',fname=other_filename_path)
                        elif self.qmc.autosaveimageformat == 'CSV':
                            self.exportCSV(other_filename_path + '.csv')
                        elif self.qmc.autosaveimageformat == 'JSON':
                            self.exportJSON(other_filename_path + '.json')
                        else:
#                            self.resizeImg(0,1,self.qmc.autosaveimageformat,fname=other_filename_path)
                            self.resizeImgToSize(0,0,self.qmc.autosaveimageformat,fname=other_filename_path)
                    #restore dirs
                    QDir.setCurrent(oldDir)
                    # file might be autosaved but not uploaded to plus yet (no DROP registered). This needs to be indicated by a red plus icon
                    try:
                        aw.updatePlusStatus()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    return filename
                self.sendmessage(QApplication.translate('Message','Autosave path does not exist. Autosave failed.'))
                return None
            if interactive:
                self.sendmessage(QApplication.translate('Message','Empty path or box unchecked in Autosave'))
                self.autosaveconf()
                return None
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Error:') + ' automaticsave() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return None

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewKshortcuts(self,_=False):
        from help import keyboardshortcuts_help
        self.helpdialog = aw.showHelpDialog(
                self,            # this dialog as parent
                self.helpdialog, # the existing help dialog
                QApplication.translate('Form Caption','Keyboard Shortcuts Help'),
                keyboardshortcuts_help.content())

    @pyqtSlot(bool)
    def decrEventNumber(self, _):
        self.eNumberSpinBox.stepBy(-1)

    @pyqtSlot(bool)
    def incrEventNumber(self, _):
        self.eNumberSpinBox.stepBy(1)

    #moves events in minieditor
    @pyqtSlot(int)
    def changeEventNumber(self,_=0):
        if self.qmc.designerflag:
            return
        #check
        lenevents = len(self.qmc.specialevents)
        currentevent = self.eNumberSpinBox.value()
        self.eNumberSpinBox.setDisabled(True)
        try:
            self.eventlabel.setText(f'{QApplication.translate("Form Caption", "Event")} #<b>{currentevent} </b>')

            if currentevent == 0:
                self.lineEvent.setText('')
                self.valueEdit.setText('')
                self.etypeComboBox.setCurrentIndex(0)
                self.etimeline.setText('')
                self.qmc.resetlines()
                if not aw.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
                return
            if currentevent > lenevents:
                self.eNumberSpinBox.setValue(int(lenevents))
                return
            self.lineEvent.setText(self.qmc.specialeventsStrings[currentevent-1])
            if aw.qmc.timeindex[0] > -1:
                timez = stringfromseconds(self.qmc.timex[self.qmc.specialevents[currentevent-1]]-self.qmc.timex[self.qmc.timeindex[0]])
            else:
                timez = stringfromseconds(self.qmc.timex[self.qmc.specialevents[currentevent-1]])
            self.etimeline.setText(timez)
            self.valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[currentevent-1]))
            self.etypeComboBox.setCurrentIndex(self.qmc.specialeventstype[currentevent-1])
            #plot little dot lines
            self.qmc.resetlines() #clear old
            etimeindex = self.qmc.specialevents[currentevent-1]
            if currentevent:
                x = [self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex]]
                y = [(self.qmc.ylimit_min-100),self.qmc.temp2[etimeindex],self.qmc.temp1[etimeindex],(self.qmc.ylimit+100)]
                self.qmc.ax.plot(x,y,marker ='o',markersize=12,color ='yellow',linestyle='-',linewidth = 7,alpha=.4)
                if not aw.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' changeEventNumber() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            self.eNumberSpinBox.setDisabled(False)
            self.eNumberSpinBox.setFocus()


    #updates events from mini edtitor
    @pyqtSlot(bool)
    def miniEventRecord(self,_):
        lenevents = self.eNumberSpinBox.value()
        if lenevents:
            self.qmc.specialeventstype[lenevents-1] = self.etypeComboBox.currentIndex()
            self.qmc.specialeventsvalue[lenevents-1] = aw.qmc.str2eventsvalue(str(self.valueEdit.text()))
            self.qmc.specialeventsStrings[lenevents-1] = self.lineEvent.text()
            if aw.qmc.timeindex[0] > -1:
                newtime = self.qmc.time2index(self.qmc.timex[self.qmc.timeindex[0]]+ stringtoseconds(str(self.etimeline.text())))
            else:
                newtime = self.qmc.time2index(stringtoseconds(str(self.etimeline.text())))
            self.qmc.specialevents[lenevents-1] = newtime

            self.lineEvent.clearFocus()
            self.eNumberSpinBox.clearFocus()
            self.etimeline.clearFocus()

            self.qmc.redraw(recomputeAllDeltas=False)

            #plot highest ET or BT (sometimes only BT is plot (et is zero))
            etimeindex = self.qmc.specialevents[lenevents-1]
            if self.qmc.temp1[etimeindex] > self.qmc.temp2[etimeindex]:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp1[etimeindex], 'o', color = self.qmc.palette['et'])
            else:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp2[etimeindex], 'o', color = self.qmc.palette['bt'])

            if not aw.qmc.flagstart:
                self.qmc.fig.canvas.draw()
                self.qmc.fileDirtySignal.emit()

            string = ''
            if len(self.qmc.specialeventsStrings[lenevents-1]) > 5:
                string += self.qmc.specialeventsStrings[lenevents-1][0:5]
                string += '...'

            message = QApplication.translate('Message','Event #{0}:  {1} has been updated').format(str(lenevents),string)
            self.sendmessage(message)

    @staticmethod
    def strippedName(fullFileName):
        return str(QFileInfo(fullFileName).fileName())

    @staticmethod
    def strippedDir(fullFileName):
        return str(QFileInfo(fullFileName).dir().dirName())

    # fileNamePath holds the full path to the loaded profile
    def setCurrentFile(self, fileNamePath,addToRecent=True):
        self.curFile = fileNamePath
        if self.curFile:
            try:
                if addToRecent:
                    settings = QSettings()
                    files = toStringList(settings.value('recentFileList'))
                    try:
                        removeAll(files,fileNamePath)
                    except ValueError:
                        pass
                    files.insert(0, fileNamePath)
                    del files[self.MaxRecentFiles:]
                    settings.setValue('recentFileList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentFileActions()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        self.updateWindowTitle()

    def updateRecentFileActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentFileList'))
        strippedNames = list(map(self.strippedName,files))
        numRecentFiles = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentFiles):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = '&%s' % strippedName
            self.recentFileActs[i].setText(text)
            self.recentFileActs[i].setData(files[i])
            self.recentFileActs[i].setVisible(True)

        for j in range(numRecentFiles, self.MaxRecentFiles):
            self.recentFileActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentFile(self, _checked:bool = False):
        action = self.sender()
        if action:
            filename = toString(action.data())
            if bool(aw.comparator):
                aw.comparator.addProfiles([filename])
            else:
                self.loadFile(filename)

    def getDefaultPath(self):
        #compare profilepath with userprofilepath (modulo the last two segments which are month/year respectively)
        return self.userprofilepath

    def setDefaultPath(self,f):
        if f:
            filepath_dir = QDir()
            filepath_dir.setPath(f)
            filepath_elements = filepath_dir.absolutePath().split('/')[:-1] # directories as QStrings (without the filename)
            self.userprofilepath = str(freduce(lambda x,y: x + '/' + y, filepath_elements) + '/')

    def ArtisanOpenFilesDialog(self,msg=QApplication.translate('Message','Select'),ext='*',path=None):
        if path is None:
            path = self.getDefaultPath()
        res = QFileDialog.getOpenFileNames(self,msg,path,ext)[0]
        for f in res:
            self.setDefaultPath(str(f))
        return res

    #the central OpenFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    # if ext is given, the file selector allows only file with that extension to be selected for open
    # if ext_alt is given (not None), all files can be selected, but if a file was selected not having the ext_alt the empty string is returned (used in the background profile dialog)
    def ArtisanOpenFileDialog(self,msg=QApplication.translate('Message','Open'),ext='*',ext_alt=None,path=None):
        if path is None:
            path = self.getDefaultPath()
        f = str(QFileDialog.getOpenFileName(self,caption=msg,directory=path,filter=ext)[0])
        if ext_alt is not None and not f.endswith(ext_alt):
            return ''
        self.setDefaultPath(f)
        return f

    def ArtisanOpenURLDialog(self,msg=QApplication.translate('Message','Open')):
        res = None
        dlg = ArtisanInputDialog(self,self,msg,QApplication.translate('Message', 'URL'))
        if dlg.exec():
            res = dlg.url
        try: # sip not supported on older PyQt versions (RPi!)
            sip.delete(dlg)
            #print(sip.isdeleted(dlg))
        except Exception: # pylint: disable=broad-except
            pass
        if res is None:
            return None
        url = QUrl(res,QUrl.ParsingMode.StrictMode)
        if url.isValid():
            return url
        return None

    #the central SaveFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanSaveFileDialog(self,msg=QApplication.translate('Message','Save'),ext='*.alog',path=None):
        if path is None:
            path = self.getDefaultPath()
        f = str(QFileDialog.getSaveFileName(self,msg,path,ext)[0])
        self.setDefaultPath(f)
        return f

    #the central ExistingDirectoryDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanExistingDirectoryDialog(self,msg=QApplication.translate('Message','Select Directory'),path=None,copy=False):
        if path is None:
            path = self.getDefaultPath()
        f = str(QFileDialog.getExistingDirectory(self,msg,path))
        if not copy:
            self.setDefaultPath(f)
        return f

    @pyqtSlot()
    @pyqtSlot(bool)
    def newRoast(self,_=False):
        #####################################
        #IF there is an ongoing roast (if START):
        #   (this block allows batch processing using the autosave feature)
        #   if no CHARGE found:
        #       return
        #   if no DROP found:
        #       #use last data point as DROP (mark DROP)
        #       return
        #   stop recording
        #   if there is an autosave path (from autosafe config) AND the autosave flag is ON:
        #       create filename using the autosavepath and date+time
        #   else:
        #       start autosave Dialog to set the name path
        #       return (nothing saved. Cancell New)
        #   reset  (delete everything)
        #   start new roast (START)
        #ELSE (if recording is stopped - OFF):
        #   if no profile present (no data present or profile loaded):
        #       start new roast (START)
        #   else:
        #       reset (reset offers three options: Save,Continue,Cancell)
        #       START
        #########################################

        # turn keepOn temporary off
        tmpKeepON = self.qmc.flagKeepON
        self.qmc.flagKeepON = False

        if self.qmc.flagstart:
            if self.qmc.timeindex[0] == -1:
                self.sendmessage(QApplication.translate('Message','NEW ROAST canceled: incomplete profile lacking CHARGE and DROP found'))
                return False
            #mark drop if not yet done
            if self.qmc.timeindex[6] == 0:
#                self.qmc.markDrop()
                self.sendmessage(QApplication.translate('Message','NEW ROAST canceled: incomplete profile lacking DROP found'))
                return False
            #invoke "OFF"
            self.qmc.OffMonitor()

            filename = self.automaticsave(interactive=False)
            if self.qmc.reset():
                #start new roast
                self.qmc.ToggleRecorder()
                if filename is not None:
                    self.sendmessage(QApplication.translate('Message','{0} has been saved. New roast has started').format(filename))
        else:
            if len(self.qmc.timex) > 1:
                self.qmc.ToggleRecorder()
            else:
                if self.qmc.flagon:
                    self.qmc.OffMonitor()
                if self.qmc.reset():
                    self.qmc.ToggleRecorder()
        self.qmc.flagKeepON = tmpKeepON
        return True

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileLoad(self,_=False):
        try:
            fileName = self.ArtisanOpenFileDialog(ext='*.alog')
            if bool(aw.comparator):
                aw.comparator.addProfiles([fileName])
            else:
                if fileName:
                    self.loadFile(fileName)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' fileLoad() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    #loads stored profiles. Called from file menu
    def loadFile(self,filename,quiet=False):
        f = None
        try:
            if self.qmc.clearBgbeforeprofileload:
                self.deleteBackground()
            f = QFile(filename)
            if not f.open(QFile.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                res = aw.qmc.reset(redraw=False,soundOn=False)
                obj = self.deserialize(filename)
                if 'extradevices' in obj:
                    org_obj_extra_devs = obj['extradevices'][:]
                else:
                    org_obj_extra_devs = []
                if res:
                    # we avoid the reset within setProfile as we just did a reset and do not want to confuse the ExtraDeviceSettingsBackup
                    res = self.setProfile(filename,obj,quiet=quiet,reset=False)
            else:
                self.sendmessage(QApplication.translate('Message','Invalid artisan format'))
                res = False
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                profile_changed = self.qmc.extradevices != org_obj_extra_devs
                self.setCurrentFile(filename) #update recent file list
                if profile_changed:
                    # profiles was adjusted, ensure that it does not overwrite the original file on saving
                    self.qmc.fileDirtySignal.emit()
                    self.curFile = None
                else:
                    self.qmc.fileCleanSignal.emit()
                if self.qmc.hideBgafterprofileload:
                    aw.qmc.background = False
                    aw.autoAdjustAxis()
                #Plot everything
                self.qmc.redraw()
                self.updatePhasesLCDs()
                message = QApplication.translate('Message','{0}  loaded ').format(filename)
                self.sendmessage(message)
                _log.info('profile loaded: %s', filename)

                # update plus data set modification date
                self.qmc.plus_file_last_modified = plus.util.getModificationDate(filename)
                if aw is not None:
                    aw.updatePlusStatus()
                    if aw.plus_account is not None:
                        if plus.config.uuid_tag in obj:
                            QTimer.singleShot(100, plus.sync.sync)

                #check colors
                self.checkColors(self.getcolorPairsToCheck())

        except OSError as ex:
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' {0}: {1}').format(str(ex),str(filename)),getattr(exc_tb, 'tb_lineno', '?'))
            # remove file from the recent file list
            settings = QSettings()
            files = toStringList(settings.value('recentFileList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        except ValueError as ex:
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Value Error:') + ' fileload() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' loadFile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if f:
                f.close()

    def loadAlarmsFromProfile(self,filename,profile):
        self.qmc.alarmsfile = filename
        if 'alarmsetlabel' in profile:
            self.qmc.alarmsetlabel = profile['alarmsetlabel']
        else:
            self.qmc.alarmsetlabel = ''
        if 'alarmflag' in profile:
            self.qmc.alarmflag = profile['alarmflag']
        else:
            self.qmc.alarmflag = []
        if 'alarmguard' in profile:
            self.qmc.alarmguard = profile['alarmguard']
        else:
            self.qmc.alarmguard = [0]*len(self.qmc.alarmflag)
        if 'alarmnegguard' in profile:
            self.qmc.alarmnegguard = profile['alarmnegguard']
        else:
            self.qmc.alarmnegguard = [0]*len(self.qmc.alarmflag)
        if 'alarmtime' in profile:
            self.qmc.alarmtime = profile['alarmtime']
        else:
            self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
        if 'alarmoffset' in profile:
            self.qmc.alarmoffset = profile['alarmoffset']
        else:
            self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
        if 'alarmcond' in profile:
            self.qmc.alarmcond = profile['alarmcond']
        else:
            self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
        if 'alarmsource' in profile:
            self.qmc.alarmsource = profile['alarmsource']
        else:
            self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
        if 'alarmtemperature' in profile:
            self.qmc.alarmtemperature = profile['alarmtemperature']
        else:
            self.qmc.alarmtemperature = [500.]*len(self.qmc.alarmflag)
        if 'alarmaction' in profile:
            self.qmc.alarmaction = profile['alarmaction']
        else:
            self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
        if 'alarmbeep' in profile:
            self.qmc.alarmbeep = profile['alarmbeep']
        else:
            self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
        if 'alarmstrings' in profile:
            self.qmc.alarmstrings = [decodeLocal(x) for x in profile['alarmstrings']]
        else:
            self.qmc.alarmstrings = ['']*len(self.qmc.alarmflag)
        self.qmc.alarmstate = [-1]*len(self.qmc.alarmflag)  #-1 = not triggered; otherwise idx = triggered

    def loadRampSoakFromProfile(self,filename,profile):
        self.qmc.rsfile = filename
        if 'svLabel' in profile:
            self.pidcontrol.svLabel = str(profile['svLabel'])
        if 'svValues' in profile:
            self.pidcontrol.svValues = [int(x) for x in profile['svValues']]
        if 'svRamps' in profile:
            self.pidcontrol.svRamps = [int(x) for x in profile['svRamps']]
        if 'svSoaks' in profile:
            self.pidcontrol.svSoaks = [int(x) for x in profile['svSoaks']]
        if 'svActions' in profile:
            self.pidcontrol.svActions = [int(x) for x in profile['svActions']]
        if 'svBeeps' in profile:
            self.pidcontrol.svBeeps = [bool(x) for x in profile['svBeeps']]
        if 'svDescriptions' in profile:
            self.pidcontrol.svDescriptions = [str(x) for x in profile['svDescriptions']]

    def loadEnergyFromProfile(self,profile):
        if 'loadlabels' in profile:
            self.qmc.loadlabels = [str(x) for x in profile['loadlabels']]
        if 'loadratings' in profile:
            self.qmc.loadratings = [float(x) for x in profile['loadratings']]
        if 'ratingunits' in profile:
            self.qmc.ratingunits = [int(x) for x in profile['ratingunits']]
        if 'sourcetypes' in profile:
            self.qmc.sourcetypes = [int(x) for x in profile['sourcetypes']]
        if 'load_etypes' in profile:
            self.qmc.load_etypes = [int(x) for x in profile['load_etypes']]
        if 'presssure_percents' in profile:
            self.qmc.presssure_percents = [int(x) for x in profile['presssure_percents']]
        if 'loadevent_zeropcts' in profile:
            self.qmc.loadevent_zeropcts = [int(x) for x in profile['loadevent_zeropcts']]
        if 'loadevent_hundpcts' in profile:
            self.qmc.loadevent_hundpcts = [int(x) for x in profile['loadevent_hundpcts']]
        if 'preheatDuration' in profile:
            self.qmc.preheatDuration = profile['preheatDuration']
        if 'preheatenergies' in profile:
            self.qmc.preheatenergies = [float(x) for x in profile['preheatenergies']]
        if 'betweenbatchDuration' in profile:
            self.qmc.betweenbatchDuration = profile['betweenbatchDuration']
        if 'betweenbatchenergies' in profile:
            self.qmc.betweenbatchenergies = [float(x) for x in profile['betweenbatchenergies']]
        if 'coolingDuration' in profile:
            self.qmc.coolingDuration = profile['coolingDuration']
        if 'coolingenergies' in profile:
            self.qmc.coolingenergies = [float(x) for x in profile['coolingenergies']]
        if 'betweenbatch_after_preheat' in profile:
            self.qmc.betweenbatch_after_preheat = profile['betweenbatch_after_preheat']
        if 'electricEnergyMix' in profile:
            self.qmc.electricEnergyMix = profile['electricEnergyMix']

    # returns True if data got updated, False otherwise
    def updateSymbolicETBT(self):
        try:
            if len(aw.qmc.timex)<=0:
                self.sendmessage(QApplication.translate('Message', 'No profile data.  ET/BT not recalculated'))
                return False
            if not(len(self.qmc.temp1)==len(aw.qmc.temp2)==len(aw.qmc.timex)):
                self.sendmessage(QApplication.translate('Message', 'Problem with the profile data.  ET/BT not recalculated'))
                return False

            # be sure there is an equation to process (already checked in devices.py, repeated here in case this is called from elsewhere)
            nonempty_ETfunction = bool(self.qmc.ETfunction is not None and len(self.qmc.ETfunction.strip()))
            nonempty_BTfunction = bool(self.qmc.BTfunction is not None and len(self.qmc.BTfunction.strip()))
            if (nonempty_ETfunction or nonempty_BTfunction):
                # set dirty
                self.qmc.fileDirtySignal.emit()
                self.curFile = None


                # update ET and BT
                newTemp1 = self.qmc.temp1.copy()
                newTemp2 = self.qmc.temp2.copy()
                for i in range(len(self.qmc.timex)):
                    if nonempty_ETfunction:
                        newTemp1[i] = self.qmc.eval_math_expression(self.qmc.ETfunction,self.qmc.timex[i])
                    if nonempty_BTfunction:
                        newTemp2[i] = self.qmc.eval_math_expression(self.qmc.BTfunction,self.qmc.timex[i])
                self.qmc.temp1 = newTemp1.copy()
                self.qmc.temp2 = newTemp2.copy()

                # reset the annotation flags
                aw.qmc.l_annotations_dict = {}
                aw.qmc.l_event_flags_dict = {}
                return True
            return False
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + 'updateSymbolicETBT(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return False

    # returns True if data got updated, False otherwise
    def calcVirtualdevices(self,update=False):
        try:
            dirty = False
            for j in range(len(self.qmc.extradevices)):
                if aw.qmc.extradevices[j] == 25:  #virtual device
                    if len(aw.qmc.extratimex[j]) > 0 and not update:  # move on if the virtual device already has data
                        continue

                    if update and not len(aw.qmc.extratimex[j]) > 0:
                        self.qmc.extratimex[j] = aw.qmc.timex[:]
                        self.qmc.extratemp1[j] = [-1]*len(self.qmc.timex)
                        self.qmc.extratemp2[j] = [-1]*len(self.qmc.timex)
                        y_range1 = []
                        y_range2 = []

                    nonempty_mathexpression1 = bool(self.qmc.extramathexpression1[j] is not None and len(self.qmc.extramathexpression1[j].strip()))
                    nonempty_mathexpression2 = bool(self.qmc.extramathexpression2[j] is not None and len(self.qmc.extramathexpression2[j].strip()))

                    if nonempty_mathexpression1 or nonempty_mathexpression2:
                        self.qmc.extratimex[j] = aw.qmc.timex[:]

                        # need two separate loops. without y2(x) cannot calculate a dependency on y1(x).

                        if nonempty_mathexpression1:
                            dirty = True
                            self.qmc.extratemp1[j] = [-1]*len(self.qmc.extratimex[j])
                            y_range1 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range1.append(self.qmc.eval_math_expression(self.qmc.extramathexpression1[j],self.qmc.extratimex[j][i]))
                            self.qmc.extratemp1[j] = y_range1[:]

                        if nonempty_mathexpression2:
                            dirty = True
                            self.qmc.extratemp2[j] = [-1]*len(self.qmc.extratimex[j])
                            y_range2 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range2.append(self.qmc.eval_math_expression(self.qmc.extramathexpression2[j],self.qmc.extratimex[j][i]))
                            self.qmc.extratemp2[j] = y_range2[:]

            if dirty:
                self.qmc.fileDirtySignal.emit()
                return True
            return False

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' calcVirtualdevices() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return False

    # tries to load background from the given path, if that fails try to deref the given UUID
    # returns True on success, Fail otherwise
    def loadbackgroundUUID(self,filename,UUID):
        if filename is not None and filename != '' and os.path.isfile(filename):
            try:
                self.loadbackground(filename)
                return True
            except Exception: # pylint: disable=broad-except
                return False
        elif UUID is not None:
            filepath = plus.register.getPath(UUID)
            if filepath is not None:
                try:
                    self.loadbackground(filepath)
                    return True
                except Exception: # pylint: disable=broad-except
                    return False
            else:
                return False
        else:
            return False

    @pyqtSlot()
    def clearbackgroundRedraw(self):
        self.deleteBackground()
        self.autoAdjustAxis()
        self.qmc.redraw()

    @pyqtSlot(str)
    def loadbackgroundRedraw(self,filename):
        _log.info('loadbackgroundRedraw(%s)',filename)
        if filename is None or len(filename) == 0:
            return
        try:
            filename = os.path.expanduser(filename) # expand users home directory abbreviation
        except Exception: # pylint: disable=broad-except
            pass
        if os.path.isfile(filename):
            try:
                self.sendmessage(QApplication.translate('Message','Reading background profile...'))
                self.qmc.resetlinecountcaches()
                self.loadbackground(filename)
                self.qmc.background = not self.qmc.hideBgafterprofileload
                self.autoAdjustAxis()
                self.qmc.timealign(redraw=True, recompute=True)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                self.deleteBackground() # delete a loaded background if any
        else:
            QTimer.singleShot(500,lambda : self.sendmessage(f'file not found: {filename}'))

    # Loads background profile
    # NOTE: this does NOT set the self.qmc.background flag to make the loaded background visible.
    def loadbackground(self,filename):
        try:
            f = QFile(filename)
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)

            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                profile = self.deserialize(filename)
                self.qmc.backgroundprofile = profile
                tb = profile['timex']
                t1 = profile['temp1']
                t2 = profile['temp2']
                t1x = profile['extratemp1']
                t2x = profile['extratemp2']

                # reset the movebackground cache:
                self.qmc.backgroundprofile_moved_x = 0
                self.qmc.backgroundprofile_moved_y = 0
                # delete background annotation positions
                self.qmc.deleteAnnoPositions(foreground=False, background=True)

                #remove the analysis results annotation if it exists
                aw.qmc.analysisresultsstr = ''

                if 'mode' in profile:
                    m = str(profile['mode'])
                    #convert modes only if needed comparing the new uploaded mode to the old one.
                    #otherwise it would incorrectly convert the uploaded phases
                    if m == 'F' and self.qmc.mode == 'C':
                        # we have to convert all temperatures from F to C
                        t1 = [fromFtoC(t) for t in t1]
                        t2 = [fromFtoC(t) for t in t2]
                        for e in range(len(t1x)):
                            t1x[e] = [fromFtoC(t) for t in t1x[e]]
                            t2x[e] = [fromFtoC(t) for t in t2x[e]]
                    if m == 'C' and self.qmc.mode == 'F':
                        # we have to convert all temperatures from C to F
                        t1 = [fromCtoF(t) for t in t1]
                        t2 = [fromCtoF(t) for t in t2]
                        for e in range(len(t1x)):
                            t1x[e] = [fromCtoF(t) for t in t1x[e]]
                            t2x[e] = [fromCtoF(t) for t in t2x[e]]

                names1x = [decodeLocal(x) for x in profile['extraname1']]
                names2x = [decodeLocal(x) for x in profile['extraname2']]
                timex = profile['extratimex']
                self.qmc.temp1B,self.qmc.temp2B,self.qmc.timeB, self.qmc.temp1BX, self.qmc.temp2BX = t1,t2,tb,t1x,t2x
                self.qmc.extratimexB = timex

                if 'extraDelta1' in profile:
                    self.qmc.temp1Bdelta = profile['extraDelta1']
                else:
                    self.qmc.temp1Bdelta = [False]*len(names1x)
                if 'extraDelta2' in profile:
                    self.qmc.temp2Bdelta = profile['extraDelta2']
                else:
                    self.qmc.temp2Bdelta = [False]*len(names2x)

                # we resample the temperatures to regular interval timestamps
                if tb is not None and tb:
                    tb_lin = numpy.linspace(tb[0],tb[-1],len(tb))
                else:
                    tb_lin = None
                decay_smoothing_p = not aw.qmc.optimalSmoothing
                b1 = self.qmc.smooth_list(tb,fill_gaps(t1),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)
                b2 = self.qmc.smooth_list(tb,fill_gaps(t2),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)

                self.qmc.extraname1B,self.qmc.extraname2B = names1x,names2x
                b1x = []
                b2x = []
                idx3 = aw.qmc.xtcurveidx - 1
                idx4 = aw.qmc.ytcurveidx - 1
                n3 = idx3 // 2
                n4 = idx4 // 2

                for i in range(min(len(t1x),len(t2x),len(timex))):
# we smooth also that 3rd and 4th background courve only on redraw with the actual smoothing parameters
                    if (aw.qmc.xtcurveidx > 0 and n3 == i) or (aw.qmc.ytcurveidx > 0 and n4 == i): # this is the 3rd or 4th background curve to be drawn, we smooth it
                        tx=timex[i]
                        if tx is not None and tx:
                            tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                        else:
                            tx_lin = None
                        if (aw.qmc.xtcurveidx > 0 and n3 == i and aw.qmc.xtcurveidx % 2) or (aw.qmc.ytcurveidx > 0 and n4 == i and aw.qmc.ytcurveidx % 2):
                            b1x.append(self.qmc.smooth_list(tx,fill_gaps(t1x[i]),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin))
                            b2x.append(fill_gaps(t2x[i]))
                        else:
                            b1x.append(fill_gaps(t1x[i]))
                            b2x.append(self.qmc.smooth_list(tx,fill_gaps(t2x[i]),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin))
                    else:
                        b1x.append(fill_gaps(t1x[i]))
                        b2x.append(fill_gaps(t2x[i]))
                # NOTE: parallel assignment after time intensive smoothing is necessary to avoid redraw failure!
                self.qmc.stemp1B,self.qmc.stemp2B,self.qmc.stemp1BX,self.qmc.stemp2BX = b1,b2,b1x,b2x
                self.qmc.backgroundEvents = profile['specialevents']
                self.qmc.backgroundEtypes = profile['specialeventstype']
                self.qmc.backgroundEvalues = profile['specialeventsvalue']
                self.qmc.backgroundEStrings = [decodeLocal(x) for x in profile['specialeventsStrings']]
                self.qmc.backgroundFlavors = profile['flavors']
                self.qmc.titleB = decodeLocal(profile['title'])

                if 'roastbatchnr' in profile:
                    try:
                        self.qmc.roastbatchnrB = int(profile['roastbatchnr'])
                    except Exception: # pylint: disable=broad-except
                        pass
                    self.qmc.roastbatchprefixB = profile['roastbatchprefix']
                    try:
                        self.qmc.roastbatchposB = profile['roastbatchpos']
                    except Exception: # pylint: disable=broad-except
                        pass
                else:
                    self.qmc.roastbatchnrB = 0
                    self.qmc.roastbatchprefixB = ''
                    self.qmc.roastbatchposB = 1

# on request we load alarms from backgrounds, but keep in mind as this would overload the one of the foreground profile that automatically loads this background
                if self.qmc.loadalarmsfrombackground:
                    self.loadAlarmsFromProfile(filename,profile)

                # Ramp/Soak Profiles
                if self.pidcontrol.loadRampSoakFromBackground:
                    self.loadRampSoakFromProfile(filename,profile)

                #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
                if self.qmc.backgroundFlavors[0] < 1. and self.qmc.backgroundFlavors[-1] < 1.:
                    l = len(self.qmc.backgroundFlavors)
                    for i in range(l):
                        self.qmc.backgroundFlavors[i] *= 10.
                    self.qmc.backgroundFlavors = self.qmc.backgroundFlavors[:(l-1)]
                if 'etypes' in profile:
                    self.qmc.Betypes = profile['etypes']
                if 'timeindex' in profile:
                    self.qmc.timeindexB = [max(0,v) if i>0 else max(-1,v) for i,v in enumerate(profile['timeindex'])]          #if new profile found with variable timeindex
                    if self.qmc.phasesfromBackgroundflag:
                        # adjust phases by DryEnd and FCs events from background profile
                        if self.qmc.timeindexB[1]:
                            self.qmc.phases[1] = int(round(self.qmc.temp2B[self.qmc.timeindexB[1]]))
                        if self.qmc.timeindexB[2]:
                            self.qmc.phases[2] = int(round(self.qmc.temp2B[self.qmc.timeindexB[2]]))
                else:
                    if 'startend' in profile:
                        startendB = profile['startend']
                        varCB = profile['cracks']
                        if 'dryend' in profile:
                            dryendB = profile['dryend']
                        else:
                            dryendB = [0,0]
                        times = []
                        times.append(startendB[0])
                        times.append(dryendB[0])
                        times.append(varCB[0])
                        times.append(varCB[2])
                        times.append(varCB[4])
                        times.append(varCB[6])
                        times.append(startendB[2])
                        self.qmc.timebackgroundindexupdate(times[:])
                self.qmc.timeindexB = self.qmc.timeindexB + [0 for i in range(8-len(self.qmc.timeindexB))]
                try:
                    self.qmc.background_profile_sampling_interval = profile['samplinginterval']
                except Exception: # pylint: disable=broad-except
                    pass # might not exist in older profiles
                try:
                    try:
                        self.qmc.TP_time_B_loaded = None
                        self.qmc.TP_time_B_loaded = profile['computed']['TP_time']
                        if self.qmc.TP_time_B_loaded is not None:
                            if self.qmc.timeindexB[0]>0:
                                # CHARGE set
                                shift = self.qmc.timeB[self.qmc.timeindexB[0]]
                            else:
                                shift = 0
                            TP_index = self.qmc.backgroundtime2index(self.qmc.TP_time_B_loaded + shift)
                        else:
                            TP_index = None
                        _,_,auc,_ = aw.ts(tp=TP_index,background=True)
                    except Exception: # pylint: disable=broad-except
                        _,_,auc,_ = aw.ts(tp=None,background=True)
                    aw.qmc.AUCbackground = auc
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

                if not aw.curFile and len(self.qmc.timex) < 10: # if no foreground is loaded, autoadjustAxis
                    aw.autoAdjustAxis(True)

                message = QApplication.translate('Message', 'Background {0} loaded successfully {1}').format(filename, '')
                self.sendmessage(message)
                self.qmc.backgroundpath = str(filename)
                if 'roastUUID' in profile:
                    self.qmc.backgroundUUID = profile['roastUUID']
                else:
                    self.qmc.backgroundUUID = None
                _log.info('background profile loaded: %s', filename)
            else:
                self.sendmessage(QApplication.translate('Message', 'Invalid artisan format'))
        except OSError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' loadbackground() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Value Error:') + ' loadbackground() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' loadbackground() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return
        finally:
            if f:
                f.close()

    @staticmethod
    def eventtime2string(time):
        if time == 0.0:
            return ''
        return '%02d:%02d'% divmod(time,60)

    #read Artisan CSV
    def importCSV(self,filename):
        import csv
        try:
            with open(filename, newline='',encoding='utf-8') as csvFile:
                data = csv.reader(csvFile,delimiter='\t')
                #read file header
                header = next(data)
                date = QDate.fromString(header[0].split('Date:')[1],"dd'.'MM'.'yyyy")
                if len(header) > 11:
                    try:
                        tm = QTime.fromString(header[11].split('Time:')[1])
                        self.qmc.roastdate = QDateTime(date,tm)
                    except Exception: # pylint: disable=broad-except
                        self.qmc.roastdate = QDateTime(date)
                else:
                    self.qmc.roastdate = QDateTime(date)
                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                self.qmc.roasttzoffset = 0
                unit = header[1].split('Unit:')[1]
                #set temperature mode
                if unit == 'F' and self.qmc.mode == 'C':
                    self.qmc.fahrenheitMode()
                if unit == 'C' and self.qmc.mode == 'F':
                    self.qmc.celsiusMode()
                #read column headers
                fields = next(data)
                extra_fields = fields[5:] # columns after 'Event'
                # add devices if needed
                for i in range(max(0,(len(extra_fields) // 2) - len(self.qmc.extradevices))):
                    self.addDevice()
                # set extra device names # NOTE: eventuelly we want to set/change the names only for devices that were just added in the line above!?
                for i in range(len(extra_fields)):
                    if i % 2 == 1:
                        # odd
                        self.qmc.extraname2[int(i/2)] = extra_fields[i]
                    else:
                        # even
                        self.qmc.extraname1[int(i/2)] = extra_fields[i]
                #read data
                last_time = None

                i = 0
                for row in data:
                    i = i + 1
                    items = list(zip(fields, row))
                    item = {}
                    for (name, value) in items:
                        item[name] = value.strip()
                    #add one measurement
                    timez = float(stringtoseconds(item['Time1']))
                    if not last_time or last_time < timez:
                        self.qmc.timex.append(timez)
                        self.qmc.temp1.append(float(item['ET']))
                        self.qmc.temp2.append(float(item['BT']))
                        for j in range(len(extra_fields)):
                            if j % 2 == 1:
                                # odd
                                self.qmc.extratemp2[int(j/2)].append(float(item[extra_fields[j]]))
                            else:
                                # even
                                self.qmc.extratimex[int(j/2)].append(timez)
                                self.qmc.extratemp1[int(j/2)].append(float(item[extra_fields[j]]))
                    last_time = timez
            #set events
            CHARGE = stringtoseconds(header[2].split('CHARGE:')[1])
            if CHARGE > 0:
                self.qmc.timeindex[0] = max(-1, self.qmc.time2index(CHARGE))
            DRYe = stringtoseconds(header[4].split('DRYe:')[1])
            if DRYe > 0:
                self.qmc.timeindex[1] = max(0, self.qmc.time2index(DRYe))
            FCs = stringtoseconds(header[5].split('FCs:')[1])
            if FCs > 0:
                self.qmc.timeindex[2] = max(0, self.qmc.time2index(FCs))
            FCe = stringtoseconds(header[6].split('FCe:')[1])
            if FCe > 0:
                self.qmc.timeindex[3] = max(0, self.qmc.time2index(FCe))
            SCs = stringtoseconds(header[7].split('SCs:')[1])
            if SCs > 0:
                self.qmc.timeindex[4] = max(0, self.qmc.time2index(SCs))
            SCe = stringtoseconds(header[8].split('SCe:')[1])
            if SCe> 0:
                self.qmc.timeindex[5] = max(0, self.qmc.time2index(SCe))
            DROP = stringtoseconds(header[9].split('DROP:')[1])
            if DROP > 0:
                self.qmc.timeindex[6] = max(0, self.qmc.time2index(DROP))
            COOL = stringtoseconds(header[10].split('COOL:')[1])
            if COOL > 0:
                self.qmc.timeindex[7] = max(0, self.qmc.time2index(COOL))
            self.qmc.endofx = self.qmc.timex[-1]
            self.sendmessage(QApplication.translate('Message','Artisan CSV file loaded successfully'))
            self.qmc.fileDirtySignal.emit()
            aw.autoAdjustAxis()
            self.qmc.redraw()
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importCSV() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def addSerialPort(self):
        n = len(self.qmc.extradevices) - 1
        self.extraser = self.extraser[:n]
        self.extraser.append(serialport(self))
        self.extracomport = self.extracomport[:n]
        self.extracomport.append('COM1')
        self.extrabaudrate = self.extrabaudrate[:n]
        self.extrabaudrate.append(9600)
        self.extrabytesize = self.extrabytesize[:n]
        self.extrabytesize.append(8)
        self.extraparity = self.extraparity[:n]
        self.extraparity.append('E')
        self.extrastopbits = self.extrastopbits[:n]
        self.extrastopbits.append(1)
        self.extratimeout = self.extratimeout[:n]
        self.extratimeout.append(0.4)

    def addDevice(self):
        try:
            self.qmc.extradevices.append(25)
            n = len(self.qmc.extradevices)
            self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:n-1]
            self.qmc.extradevicecolor1.append('black') #init color to black
            self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:n-1]
            self.qmc.extradevicecolor2.append('black')
            self.qmc.extraname1 = self.qmc.extraname1[:n-1]
            self.qmc.extraname1.append('Extra 1')
            self.qmc.extraname2 = self.qmc.extraname2[:n-1]
            self.qmc.extraname2.append('Extra 2')
            self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:n-1]
            self.qmc.extramathexpression1.append('')
            self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:n-1]
            self.qmc.extramathexpression2.append('')

            # ensure that the curves and LCDs of the new device are visible:
            self.extraLCDvisibility1[n-1] = True
            self.extraLCDvisibility2[n-1] = True
            self.extraCurveVisibility1[n-1] = True
            self.extraCurveVisibility2[n-1] = True
            self.extraDelta1[n-1] = False
            self.extraDelta2[n-1] = False
            self.extraFill1[n-1] = 0
            self.extraFill2[n-1] = 0

            #create new serial port (but don't open it yet). Store initial settings
            self.addSerialPort()

            #add new line variables
            self.qmc.extratimex = self.qmc.extratimex[:n-1]
            self.qmc.extratimex.append([])
            self.qmc.extratemp1 = self.qmc.extratemp1[:n-1]
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2 = self.qmc.extratemp2[:n-1]
            self.qmc.extratemp2.append([])
            self.qmc.extrastemp1 = self.qmc.extrastemp1[:n-1]
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2 = self.qmc.extrastemp2[:n-1]
            self.qmc.extrastemp2.append([])
            self.qmc.extractimex1 = self.qmc.extractimex1[:n-1]
            self.qmc.extractimex1.append([])
            self.qmc.extractimex2 = self.qmc.extractimex2[:n-1]
            self.qmc.extractimex2.append([])
            self.qmc.extractemp1 = self.qmc.extractemp1[:n-1]
            self.qmc.extractemp1.append([])
            self.qmc.extractemp2 = self.qmc.extractemp2[:n-1]
            self.qmc.extractemp2.append([])

            #add new style variables
            self.qmc.extralinestyles1 = self.qmc.extralinestyles1[:n-1]
            self.qmc.extralinestyles1.append(self.qmc.linestyle_default)
            self.qmc.extralinestyles2 = self.qmc.extralinestyles2[:n-1]
            self.qmc.extralinestyles2.append(self.qmc.linestyle_default)
            self.qmc.extradrawstyles1 = self.qmc.extradrawstyles1[:n-1]
            self.qmc.extradrawstyles1.append(self.qmc.drawstyle_default)
            self.qmc.extradrawstyles2 = self.qmc.extradrawstyles2[:n-1]
            self.qmc.extradrawstyles2.append(self.qmc.drawstyle_default)
            self.qmc.extralinewidths1 = self.qmc.extralinewidths1[:n-1]
            self.qmc.extralinewidths1.append(self.qmc.extra_linewidth_default)
            self.qmc.extralinewidths2 = self.qmc.extralinewidths2[:n-1]
            self.qmc.extralinewidths2.append(self.qmc.extra_linewidth_default)
            self.qmc.extramarkers1 = self.qmc.extramarkers1[:n-1]
            self.qmc.extramarkers1.append(self.qmc.marker_default)
            self.qmc.extramarkers2 = self.qmc.extramarkers2[:n-1]
            self.qmc.extramarkers2.append(self.qmc.marker_default)
            self.qmc.extramarkersizes1 = self.qmc.extramarkersizes1[:n-1]
            self.qmc.extramarkersizes1.append(self.qmc.markersize_default)
            self.qmc.extramarkersizes2 = self.qmc.extramarkersizes2[:n-1]
            self.qmc.extramarkersizes2.append(self.qmc.markersize_default)

            #add two extra lines in figure for extra ET and extra BT
            l = len(self.qmc.extradevices)-1  #new line index
            self.qmc.extratemp1lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp1[l],color=self.qmc.extradevicecolor1[l],markersize=self.qmc.extramarkersizes1[l],marker=self.qmc.extramarkers1[l],linewidth=self.qmc.extralinewidths1[l],linestyle=self.qmc.extralinestyles1[l],drawstyle=self.qmc.extradrawstyles1[l],label=self.qmc.extraname1[l])[0])
            self.qmc.extratemp2lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp2[l],color=self.qmc.extradevicecolor2[l],markersize=self.qmc.extramarkersizes2[l],marker=self.qmc.extramarkers2[l],linewidth=self.qmc.extralinewidths2[l],linestyle=self.qmc.extralinestyles2[l],drawstyle=self.qmc.extradrawstyles2[l],label=self.qmc.extraname2[l])[0])

            self.updateExtraLCDvisibility()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    #Write readings to Artisan JSON file
    def exportJSON(self,filename):
        try:
            with open(filename, 'w', encoding='utf-8') as outfile:
                from json import dump as json_dump
                json_dump(self.getProfile(), outfile, ensure_ascii=True)
                outfile.write('\n')
            return True
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' exportJSON() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return False

    def indent(self,elem, level=0):
        i = '\r\n' + level*'  ' # Windows line ending (as Pilot is only available on Windows)
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + '  '
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for e in elem:
                self.indent(e, level+1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i

    def exportPilot(self,filename):
        try:
            # warning popup if filename contains more than one _
            # only contain one _ followed by an index number like Name_0.xml
            s = filename.split('_')
            if (len(s) < 2 or len(s) > 2):
                QMessageBox.warning(aw,QApplication.translate('Message', 'Warning'),QApplication.translate('Message', 'The Probat Shop Pilot Software expects files named <Name>_<Index>.xml like in Test_0.xml on import'))

            import xml.etree.ElementTree as ET
            tree = ET.Element('recipe')

            charge = ET.SubElement(tree, 'charge')
            charge.text = str(aw.float2float(aw.convertWeight(aw.qmc.weight[0],aw.qmc.weight_units.index(aw.qmc.weight[2]),1)))

            beans = ET.SubElement(tree, 'coffeetype')
            if aw.qmc.beans and aw.qmc.beans != '':
                beans.text = aw.qmc.beans

            color = ET.SubElement(tree, 'coffeecolor')
            if aw.qmc.ground_color:
                color.text = str(aw.qmc.ground_color)

            endtemperature = ET.SubElement(tree, 'endtemperature')
            endtime = ET.SubElement(tree, 'endtime')
            cooling = ET.SubElement(tree, 'coolingtime')

            roaster = ET.SubElement(tree, 'roaster')
            if aw.qmc.roastertype and aw.qmc.roastertype != '':
                roaster.text = aw.qmc.roastertype

            notes = ET.SubElement(tree, 'notes')
            if self.qmc.roastingnotes and self.qmc.roastingnotes != '':
                notes.text = self.qmc.roastingnotes

            roasttype = ET.SubElement(tree, 'roasttype')
            roasttype.text = '0' # 0: global, 1: time, 2: temp

            recipedata = ET.SubElement(tree, 'recipedata_temp_unit')
            recipedata.text = aw.qmc.mode

            diagrampoints = ET.SubElement(tree, 'diagrampoints')

            time_tag = 'sTime'
            temp_tag = 'nTemperature'
            burner_tag = 'nBurnercapacity'
            rising_tag = 'bRising'

            # if CHARGE is defined, only export from CHARGE
            # if DROP is defined only export until DROP
            end_temp = None
            end_time = None
            idx = 1
            for i in range(len(aw.qmc.timex)):
                if (self.qmc.timeindex[0] < 0 or i >= self.qmc.timeindex[0]) and (self.qmc.timeindex[6] == 0 or i <= self.qmc.timeindex[6]):
                    data = ET.SubElement(diagrampoints, 'data', index=str(idx))
                    t = self.qmc.timex[i]
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timex[self.qmc.timeindex[0]]
                    time = ET.SubElement(data,time_tag)
                    time.text = '%02d:%02d'% divmod(t,60)
                    end_time = time.text
                    temp = ET.SubElement(data,temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[i])))
                    end_temp = temp.text
                    burner = ET.SubElement(data,burner_tag)
                    if len(self.qmc.extradevices) > 0:
                        burner.text = str(max(0,int(round(self.qmc.extratemp1[0][i]))))
                    else:
                        burner.text = '0'
                    rising = ET.SubElement(data,rising_tag)
                    if self.qmc.delta2[i] and self.qmc.delta2[i] > 0:
                        rising.text = 'true'
                    else:
                        rising.text = 'false'
                    idx = idx + 1

            if end_temp:
                endtemperature.text = end_temp

            if end_temp:
                endtime.text = end_time

            if self.qmc.timeindex[7]:
                t = self.qmc.timex[self.qmc.timeindex[7]] - self.qmc.timex[self.qmc.timeindex[6]]
                cooling.text = '%02d:%02d'% divmod(t,60)
            else:
                cooling.text = '00:00'

            switchpoints = ET.SubElement(tree, 'switchpoints')
            # take data from 2nd extra event type
            idx = 1
            for i in range(len(self.qmc.specialevents)):
                if self.qmc.specialeventstype[i] == 3 and (self.qmc.timeindex[0] < 0 or self.qmc.specialevents[i] >= self.qmc.timeindex[0]) and (self.qmc.timeindex[6] == 0 or self.qmc.specialevents[i] <= self.qmc.timeindex[6]):
                    data = ET.SubElement(switchpoints, 'data', index=str(idx))
                    if aw.qmc.timeindex[0] > -1 and len(aw.qmc.timex) > aw.qmc.timeindex[0]:
                        timez = stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[i]]-aw.qmc.timex[aw.qmc.timeindex[0]])
                    else:
                        timez = stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[i]])
                    t = self.qmc.specialevents[i]
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timeindex[0]
                    time = ET.SubElement(data,time_tag)
                    time.text = timez
                    temp = ET.SubElement(data,temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[self.qmc.specialevents[i]])))
                    burner = ET.SubElement(data,burner_tag)
                    b = self.qmc.eventsInternal2ExternalValue(self.qmc.specialeventsvalue[i])
                    burner.text = str(int(round(b)))
                    rising = ET.SubElement(data,rising_tag)
                    if self.qmc.delta2[i] and self.qmc.delta2[i] > 0:
                        rising.text = 'true'
                    else:
                        rising.text = 'false'
                    idx = idx + 1
            self.indent(tree)
            ET.ElementTree(tree).write(filename,encoding='utf-8', xml_declaration=True)
            return True
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' exportPilot() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return False

    #Write readings to RoastLogger CSV file
    def exportRoastLogger(self,filename):
        import csv
        try:
            with open(filename, 'w', encoding='utf-8') as outfile:
                outfile.write('Log created at 09:00:00 '+ self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + '\n')
                outfile.write('Use Options|Set template for new log to modify this template.\n')
                outfile.write('------------------------------------------------------\n')
                outfile.write('Bean/Blend name:\n')
                outfile.write('\n')
                outfile.write('Profile description:\n')
                outfile.write('\n')
                outfile.write('Roast notes:\n')
                outfile.write('\n')
                outfile.write('Cupping results:\n')
                outfile.write('\n')
                outfile.write('Roast Logger Copyright ? T. R. Coxon (GreenBean TMC).\n')
                outfile.write('Roast started at 09:00:00 ' + self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + '\n')
                if len(self.qmc.timex) > 0:
                    CHARGE = aw.qmc.timex[aw.qmc.timeindex[0]]
                else:
                    CHARGE = 0
                writer= csv.writer(outfile,delimiter=',')
                writer.writerow(['Elapsed time ',' T1 ',' T2 ',' Event type'])
                for i in range(len(aw.qmc.timex)):
                    if i == aw.qmc.timeindex[0]:
                        kind = 'Beans loaded'
                    elif i!=0 and i == aw.qmc.timeindex[2]:
                        kind = 'First crack start'
                    elif i!=0 and i == aw.qmc.timeindex[3]:
                        kind = 'First crack end'
                    elif i!=0 and i == aw.qmc.timeindex[4]:
                        kind = 'Second crack start'
                    elif i!=0 and i == aw.qmc.timeindex[6]:
                        kind = 'Beans ejected'
                    else:
                        kind = 'timer'
                    writer.writerow([stringfromseconds(aw.qmc.timex[i]-CHARGE),'%.1f'%float(aw.qmc.temp2[i]),'%.1f'%float(aw.qmc.temp1[i]),kind])
                outfile.write('\n')
                outfile.write('@actionT1Table\n')
                outfile.write('120|null|30\n')
                outfile.write('178|65|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('\n')
                outfile.write('@actionSecsFCTable\n')
                outfile.write('60|50|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('\n')
                outfile.write('@actionResetTable\n')
                outfile.write('100|0\n')
                outfile.write('\n')
                outfile.write('@loadBeansTable\n')
                outfile.write('146\n')
                outfile.write('\n')
            return True
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' exportRoastLogger() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return False
        finally:
            outfile.close()

    def importJSON(self,filename):
        try:
            from json import load as json_load
            with open(filename, encoding='utf-8') as infile:
                obj = json_load(infile)
                res = self.setProfile(filename,obj)
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                aw.autoAdjustAxis()
                self.qmc.redraw()
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importJSON() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def importRoastLogger(self,filename):
        self.resetExtraDevices()
        # the RoastLogger file might be in utf-8 or latin1 encoding, we cannot know so let's test both
        try:
            try:
                self.importRoastLoggerEnc(filename,'utf-8')
            except Exception: # pylint: disable=broad-except
                self.importRoastLoggerEnc(filename,'latin1')
            aw.qmc.fileDirtySignal.emit()
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importRoastLogger() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def resetExtraDevices():
        try:
            #delete extra devices
            aw.qmc.extradevices = []
            #delete extra curves variables
            aw.qmc.extratimex = []
            aw.qmc.extradevicecolor1 = []
            aw.qmc.extradevicecolor2 = []
            aw.qmc.extratemp1,aw.qmc.extratemp2 = [],[]
            aw.qmc.extrastemp1,aw.qmc.extrastemp2 = [],[]
            aw.qmc.extractimex1,aw.qmc.extractimex2 = [],[]
            aw.qmc.extractemp1,aw.qmc.extractemp2 = [],[]
            aw.qmc.extratemp1lines,aw.qmc.extratemp2lines = [],[]
            aw.qmc.extralinestyles1,aw.qmc.extralinestyles2 = [],[]
            aw.qmc.extradrawstyles1,aw.qmc.extradrawstyles2 = [],[]
            aw.qmc.extralinewidths1,aw.qmc.extralinewidths2 = [],[]
            aw.qmc.extramarkers1,aw.qmc.extramarkers2 = [],[]
            aw.qmc.extramarkersizes1,aw.qmc.extramarkersizes2 = [],[]
            aw.qmc.extraname1,aw.qmc.extraname2 = [],[]
            aw.qmc.extramathexpression1,aw.qmc.extramathexpression2 = [],[]
            aw.extraLCDvisibility1,aw.extraLCDvisibility2 = [False]*aw.nLCDS,[False]*aw.nLCDS
            aw.extraCurveVisibility1,aw.extraCurveVisibility2 = [True]*aw.nLCDS,[True]*aw.nLCDS
            aw.extraDelta1,aw.extraDelta2 = [False]*aw.nLCDS,[False]*aw.nLCDS
            aw.extraFill1,aw.extraFill2 = [0]*aw.nLCDS,[0]*aw.nLCDS
            for i in range(len(aw.extraLCDlabel1)):
                aw.extraLCDframe1[i].setVisible(False)
                aw.extraLCDframe2[i].setVisible(False)
            #delete EXTRA COMM PORTS VARIABLES
            aw.extraser = []
            aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            aw.qmc.resetlinecountcaches()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' resetExtraDevices(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def importRoastLoggerEnc(self,filename,enc='utf-8'):
        import csv
        roastlogger_action_section = ''
        # use io.open instead of open to have encoding support on Python 2
        with open(filename, encoding=enc) as infile:
            obj = {}
            obj['mode'] = 'C'
            obj['title'] = str(QFileInfo(filename).fileName())
            obj['roastdate'] = encodeLocal(QDate.currentDate().toString())
            # read roastdate from file
            while True:
                l = infile.readline()
                if l.startswith('Roast started at '):
                    #extract roast date
                    roastdate = QDateTime(QDate.fromString(l.split(' ')[-1][0:10],"dd'/'MM'/'yyyy"))
                    if not roastdate.isNull():
                        obj['roastdate'] = encodeLocal(roastdate.date().toString())
                    break
                if l == '':
                    break
            timeindex = [-1,0,0,0,0,0,0,0]
            timex = []
            temp1 = []
            temp2 = []
            data = csv.reader(infile,delimiter=',')
            #read file header
            next(data) # we do not use the labels
            #header = list(map(lambda s:s.strip(),next(data)))
            while True:
                fields = next(data)
                if len(fields) == 0:
                    break
                timex.append(float(stringtoseconds(fields[0])))
                try:
                    t1 = float(fields[1])
                except Exception: # pylint: disable=broad-except
                    t1 = -1
                temp1.append(t1)
                try:
                    t2 = float(fields[2])
                except Exception: # pylint: disable=broad-except
                    t2 = -1
                temp2.append(t2)
                event = fields[3]
                if event == 'Beans loaded':
                    timeindex[0] = max(-1,len(timex) - 1)
                elif event == 'First crack start':
                    timeindex[2] = max(0,len(timex) - 1)
                elif event == 'First crack end':
                    timeindex[3] = max(0,len(timex) - 1)
                elif event == 'Second crack start':
                    timeindex[4] = max(0,len(timex) - 1)
                elif event == 'Beans ejected':
                    timeindex[6] = max(0,len(timex) - 1)
            obj['timeindex'] = timeindex
            obj['timex'] = timex
            obj['temp1'] = temp2
            obj['temp2'] = temp1

            if len(obj['timex']) > 2:
                obj['samplinginterval'] = (obj['timex'][-1] - obj['timex'][0])/(len(obj['timex'] - 1))

            res = self.setProfile(filename,obj)

            try:
                error_msg = ''
                if aw.qmc.loadalarmsfromprofile:
                    aw.qmc.alarmsfile = filename
                    roastlogger_action_section = 'No actions loaded'

                    #Find sliders - exact names of the sliders must be defined
                    slider_power = -1
                    slider_fan = -1
                    try:
                        slider_power=aw.qmc.etypes.index('Power')
                    except Exception: # pylint: disable=broad-except
                        pass
                    try:
                        slider_fan=aw.qmc.etypes.index('Fan')
                    except Exception: # pylint: disable=broad-except
                        pass
                    #load only "Power" and "Fan" events
                    if slider_power != -1 and slider_fan != -1:
                        data_action = csv.reader(infile,delimiter='|')

                        aw.qmc.alarmsetlabel = ''
                        aw.qmc.alarmflag = []
                        aw.qmc.alarmguard = []
                        aw.qmc.alarmnegguard = []
                        aw.qmc.alarmtime = []
                        aw.qmc.alarmoffset = []
                        aw.qmc.alarmcond = []
                        aw.qmc.alarmstate = []
                        aw.qmc.alarmsource = []
                        aw.qmc.alarmtemperature = []
                        aw.qmc.alarmaction = []
                        aw.qmc.alarmbeep = []
                        aw.qmc.alarmstrings = []

                        while True:
                            fields_action = next(data_action)
                            if len(fields_action) == 0:
                                pass
                            elif len(fields_action) == 1 and fields_action[0].startswith('@'):
                                roastlogger_action_section=fields_action[0]
                            else:
                                #process items in the section
                                if roastlogger_action_section.startswith('@actionT1Table'):
                                    if len(fields_action) == 3 and fields_action[0] != 'null':
                                        #add temp alarm - POWER
                                        aw.qmc.alarmflag.append(1)
                                        aw.qmc.alarmguard.append(-1)
                                        aw.qmc.alarmnegguard.append(-1)
                                        aw.qmc.alarmtime.append(8)        #after TP
                                        aw.qmc.alarmoffset.append(0)
                                        aw.qmc.alarmcond.append(1)
                                        aw.qmc.alarmstate.append(-1)
                                        aw.qmc.alarmsource.append(1)    #BT
                                        aw.qmc.alarmtemperature.append(float(fields_action[0]))
                                        aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                        aw.qmc.alarmbeep.append(0)
                                        aw.qmc.alarmstrings.append(QApplication.translate('Label',fields_action[1]))

                                        #add temp alarm - FAN
                                        aw.qmc.alarmflag.append(1)
                                        aw.qmc.alarmguard.append(-1)
                                        aw.qmc.alarmnegguard.append(-1)
                                        aw.qmc.alarmtime.append(8)        #after TP
                                        aw.qmc.alarmoffset.append(0)
                                        aw.qmc.alarmcond.append(1)
                                        aw.qmc.alarmstate.append(-1)
                                        aw.qmc.alarmsource.append(1)    #BT
                                        aw.qmc.alarmtemperature.append(int(fields_action[0]))
                                        aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                        aw.qmc.alarmbeep.append(0)
                                        aw.qmc.alarmstrings.append(QApplication.translate('Label',fields_action[2]))

                                elif roastlogger_action_section.startswith('@actionSecsFCTable'):
                                    if len(fields_action) == 3 and fields_action[0] != 'null':

                                        #add time alarm - POWER
                                        aw.qmc.alarmflag.append(1)
                                        aw.qmc.alarmguard.append(-1)
                                        aw.qmc.alarmnegguard.append(-1)
                                        aw.qmc.alarmtime.append(2)        #after FC
                                        aw.qmc.alarmoffset.append(int(fields_action[0]))
                                        aw.qmc.alarmcond.append(1)
                                        aw.qmc.alarmstate.append(-1)
                                        aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                        aw.qmc.alarmtemperature.append(0)
                                        aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                        aw.qmc.alarmbeep.append(0)
                                        aw.qmc.alarmstrings.append(QApplication.translate('Label',fields_action[1]))

                                        #add time alarm - FAN
                                        aw.qmc.alarmflag.append(1)
                                        aw.qmc.alarmguard.append(-1)
                                        aw.qmc.alarmnegguard.append(-1)
                                        aw.qmc.alarmtime.append(2)        #after FC
                                        aw.qmc.alarmoffset.append(int(fields_action[0]))
                                        aw.qmc.alarmcond.append(1)
                                        aw.qmc.alarmstate.append(-1)
                                        aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                        aw.qmc.alarmtemperature.append(0)
                                        aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                        aw.qmc.alarmbeep.append(0)
                                        aw.qmc.alarmstrings.append(QApplication.translate('Label',fields_action[2]))

                                elif roastlogger_action_section.startswith('@actionResetTable'):
                                    if len(fields_action) == 2 and fields_action[0] != 'null':

                                        #add temp alarm - POWER
                                        aw.qmc.alarmflag.insert(0,1)
                                        aw.qmc.alarmguard.insert(0,-1)
                                        aw.qmc.alarmnegguard.insert(0,-1)
                                        aw.qmc.alarmtime.insert(0,9)        #after ON
                                        aw.qmc.alarmoffset.insert(0,0)
                                        aw.qmc.alarmcond.insert(0,1)
                                        aw.qmc.alarmstate.insert(0,-1)
                                        aw.qmc.alarmsource.insert(0,1)    #BT
                                        aw.qmc.alarmtemperature.insert(0,0)
                                        aw.qmc.alarmaction.insert(0,3+slider_power)    #SLIDER POWER
                                        aw.qmc.alarmbeep.insert(0,0)
                                        aw.qmc.alarmstrings.insert(0,QApplication.translate('Label',fields_action[0]))

                                        #add temp alarm - FAN
                                        aw.qmc.alarmflag.insert(0,1)
                                        aw.qmc.alarmguard.insert(0,-1)
                                        aw.qmc.alarmnegguard.insert(0,-1)
                                        aw.qmc.alarmtime.insert(0,9)        #after ON
                                        aw.qmc.alarmoffset.insert(0,0)
                                        aw.qmc.alarmcond.insert(0,1)
                                        aw.qmc.alarmstate.insert(0,-1)
                                        aw.qmc.alarmsource.insert(0,1)    #BT
                                        aw.qmc.alarmtemperature.insert(0,0)
                                        aw.qmc.alarmaction.insert(0,3+slider_fan)    #SLIDER POWER
                                        aw.qmc.alarmbeep.insert(0,0)
                                        aw.qmc.alarmstrings.insert(0,QApplication.translate('Label',fields_action[1]))

                                elif roastlogger_action_section.startswith('@loadBeansTable'):
                                    if len(fields_action) == 1 and fields_action[0] != 'null':

                                        #add START TRIGGER - 10 DEG before charge temp
                                        aw.qmc.alarmflag.insert(2,1)
                                        aw.qmc.alarmguard.insert(2,-1)
                                        aw.qmc.alarmnegguard.insert(2,-1)
                                        aw.qmc.alarmtime.insert(0,9)        #after ON
                                        aw.qmc.alarmoffset.insert(2,0)
                                        aw.qmc.alarmcond.insert(2,1)
                                        aw.qmc.alarmstate.insert(2,-1)
                                        aw.qmc.alarmsource.insert(2,1)    #BT
                                        aw.qmc.alarmtemperature.insert(2,float(fields_action[0])-10)
                                        aw.qmc.alarmaction.insert(2,7)    #initiate 7 (START)
                                        aw.qmc.alarmbeep.insert(2,0)
                                        aw.qmc.alarmstrings.insert(2,QApplication.translate('Label','Start recording'))

                                        #add CHARGE alarm
                                        aw.qmc.alarmflag.insert(3,1)
                                        aw.qmc.alarmguard.insert(3,-1)
                                        aw.qmc.alarmnegguard.insert(3,-1)
                                        aw.qmc.alarmtime.insert(3,-1)        #after START
                                        aw.qmc.alarmoffset.insert(3,0)
                                        aw.qmc.alarmcond.insert(3,1)
                                        aw.qmc.alarmstate.insert(3,-1)
                                        aw.qmc.alarmsource.insert(3,1)    #BT
                                        aw.qmc.alarmtemperature.insert(3,float(fields_action[0]))
                                        aw.qmc.alarmaction.insert(3,0)    #POPUP
                                        aw.qmc.alarmbeep.insert(3,1)      #do beep for charge
                                        aw.qmc.alarmstrings.insert(3,QApplication.translate('Label','Charge the beans'))
                                    break
                        else:
                            if slider_power == -1: error_msg += "Could not find slider named 'Power' "
                            if slider_fan == -1: error_msg += "Could not find slider named 'Fan' "
                            error_msg += 'Please rename sliders in Config - Events menu'

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                if roastlogger_action_section == 'No actions loaded':
                    error_msg += 'Roastlogger file does not contain actions.  Alarms will not be loaded.'
                else:
                    error_msg += "Roastlogger actions are not complete. Last loaded section is '" + roastlogger_action_section + "'"

            finally:
                if res:
                    aw.autoAdjustAxis()
                    self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                    self.qmc.redraw()

            if error_msg != '':
                aw.qmc.adderror(QApplication.translate('Error Message','Roastlogger log file exception: ' + error_msg))

    #Write readings to Artisan csv file
    def exportCSV(self,filename):
        import csv
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]]
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [
                    [CHARGE,'Charge',False],
                    [TP,'TP',False],
                    [DRYe,'Dry End',False],
                    [FCs,'FCs',False],
                    [FCe,'FCe',False],
                    [SCs,'SCs',False],
                    [SCe,'SCe',False],
                    [DROP, 'Drop',False],
                    [COOL, 'COOL',False],
                    ]
                with open(filename, 'w',newline='',encoding='utf8') as outfile:
                    writer= csv.writer(outfile,delimiter='\t')
                    writer.writerow([
                        'Date:' + self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy"),
                        'Unit:' + self.qmc.mode,
                        'CHARGE:' + self.eventtime2string(CHARGE),
                        'TP:' + self.eventtime2string(TP),
                        'DRYe:' + self.eventtime2string(DRYe),
                        'FCs:' + self.eventtime2string(FCs),
                        'FCe:' + self.eventtime2string(FCe),
                        'SCs:' + self.eventtime2string(SCs),
                        'SCe:' + self.eventtime2string(SCe),
                        'DROP:' + self.eventtime2string(DROP),
                        'COOL:' + self.eventtime2string(COOL),
                        'Time:' + self.qmc.roastdate.time().toString()[:-3]])
                    row = (['Time1','Time2','ET','BT','Event'] + freduce(lambda x,y: x + [str(y[0]),str(y[1])], list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)])),[]))
                    writer.writerow(row)
                    last_time = None
                    for i in range(len(self.qmc.timex)):
                        if self.qmc.timex[i] >= CHARGE > 0:
                            time2 = '%02d:%02d'% divmod(self.qmc.timex[i] - CHARGE, 60)
                        else:
                            time2 = ''
                        event = ''
                        for e in range(len(events)):
                            if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                                event = events[e][1]
                                events[e][2] = True
                                break
                        time1 = '%02d:%02d'% divmod(self.qmc.timex[i],60)
                        if not last_time or last_time != time1:
                            extratemps = []
                            for j in range(len(self.qmc.extradevices)):
                                if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                    extratemps.append(str(self.qmc.extratemp1[j][i]))
                                else:
                                    extratemps.append('-1')
                                if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                    extratemps.append(str(self.qmc.extratemp2[j][i]))
                                else:
                                    extratemps.append('-1')
                            writer.writerow([str(time1),str(time2),str(self.qmc.temp1[i]),str(self.qmc.temp2[i]),str(event)] + extratemps)
                        last_time = time1
                return True
            return False
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' exportCSV() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return False

    #Write readings to Artisan Excel file
    def exportExcel(self,filename):
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]]
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [
                    [CHARGE,'Charge',False],
                    [TP,'TP',False],
                    [DRYe,'Dry End',False],
                    [FCs,'FCs',False],
                    [FCe,'FCe',False],
                    [SCs,'SCs',False],
                    [SCe,'SCe',False],
                    [DROP, 'Drop',False],
                    [COOL, 'COOL',False],
                    ]

                from openpyxl import Workbook
                from openpyxl.styles import Font,Alignment # , Fill # ML: not used

                wb = Workbook()
                ws = wb.active
                ws.title = QApplication.translate('HTML Report Template', 'Profile')

                bf = Font(bold=True)

                #summary section
                fieldlist = [
                    ['Date',   self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy")   ],
                    ['Unit',   self.qmc.mode                                          ],
                    ['CHARGE', self.eventtime2string(CHARGE)                          ],
                    ['TP',     self.eventtime2string(TP)                              ],
                    ['DRYe',   self.eventtime2string(DRYe)                            ],
                    ['FCs',    self.eventtime2string(FCs)                             ],
                    ['FCe',    self.eventtime2string(FCe)                             ],
                    ['SCs',    self.eventtime2string(SCs)                             ],
                    ['SCe',    self.eventtime2string(SCe)                             ],
                    ['DROP',   self.eventtime2string(DROP)                            ],
                    ['COOL',   self.eventtime2string(COOL)                            ],
                    ['Time',   self.qmc.roastdate.time().toString()[:-3]              ],
                    ]
                for f in range(len(fieldlist)):
                    ws.cell(row=1,column=f+1).value = fieldlist[f][0]
                    ws.cell(row=1,column=f+1).font = bf
                    ws.cell(row=2,column=f+1).value = fieldlist[f][1]
                    ws.cell(row=1,column=f+1).alignment = Alignment(horizontal='center')
                    ws.cell(row=2,column=f+1).alignment = Alignment(horizontal='center')

                #profile data
                fieldlist = [
                    ['Time1',  'time1'             ],
                    ['Time2',  'time2'             ],
                    ['ET',     'self.qmc.temp1[i]' ],
                    ['BT',     'self.qmc.temp2[i]' ],
                    [deltaLabelUTF8 + 'BT','self.qmc.delta2[i]'],
                    ['Event',  'event'             ],
                    ]
                extraslist = list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)]))

                r = 4  #starting row number
                c = 0  #starting col number
                for f in range(len(fieldlist)):
                    c += 1
                    ws.cell(row=r,column=c,value=fieldlist[f][0])
                for f in range(len(extraslist)):
                    c += 1
                    ws.cell(row=r,column=c).value = extraslist[f][0]
                    c += 1
                    ws.cell(row=r,column=c).value = extraslist[f][1]

                for i in range(ws.max_column):
                    ws.cell(row=r,column=i+1).font = bf
                    ws.cell(row=r,column=i+1).alignment = Alignment(horizontal='center')
                r += 1

                last_time = None
                for i in range(len(self.qmc.timex)):
                    if self.qmc.timex[i] >= CHARGE > 0:
                        time2 = '%02d:%02d'% divmod(self.qmc.timex[i] - CHARGE, 60) #@UnusedVariable # pylint: disable=unused-variable
                    else:
                        time2 = '' #@UnusedVariable #@UnusedVariable # pylint: disable=unused-variable
                    event = ''     #@UnusedVariable #@UnusedVariable # pylint: disable=unused-variable
                    for e in range(len(events)):
                        if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                            event = events[e][1] #@UnusedVariable #@UnusedVariable # pylint: disable=unused-variable
                            events[e][2] = True
                            break
                    if i in aw.qmc.specialevents:
#                        a = [k for k, j in enumerate(aw.qmc.specialevents) if j == i]
                        for n,m in enumerate(aw.qmc.specialevents):
                            if m == i:
                                if len(event) > 0:
                                    event += ','
                                #if aw.qmc.specialeventstype[n] == 4:       # only export the event Description for -- type events
                                if len(aw.qmc.specialeventsStrings[n]) > 0: # always export the event Description if it exist
                                    event += aw.qmc.specialeventsStrings[n]
                                else:
                                    event += aw.qmc.etypesf(aw.qmc.specialeventstype[n])[0] + aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[n])

                    time1 = '%02d:%02d'% divmod(self.qmc.timex[i],60)
                    if not last_time or last_time != time1:
                        extratemps = []
                        for j in range(len(self.qmc.extradevices)):
                            if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                extratemps.append(self.qmc.extratemp1[j][i])
                            else:
                                extratemps.append(-1)
                            if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                extratemps.append(self.qmc.extratemp2[j][i])
                            else:
                                extratemps.append(-1)

                        for j in range(6):
                            try:
                                ws.cell(row=r+i, column=j+1).value = eval(fieldlist[j][1]) # pylint: disable=eval-used
                            except Exception: # pylint: disable=broad-except
                                pass

                        for j in range(len(extratemps)):
                            ws.cell(row=r+i, column=7+j).value = extratemps[j]

                    last_time = time1

                wb.save(filename)
                return True
            return False
        except Exception as ex:
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' exportExcel() {0}').format(str(ex)),exc_tb.tb_lineno)
            return False

    #Write object to file
    @staticmethod
    def serialize(filename, obj):
        fn = str(filename)
        import codecs # @Reimport
        with codecs.open(fn, 'w+', encoding='utf-8') as f:
            f.write(repr(obj))
#PLUS
        # fill plus UUID register
        try:
            if obj is not None:
                if plus.config.uuid_tag in obj:
                    plus.register.addPath(obj[plus.config.uuid_tag],fn)
        except Exception: # pylint: disable=broad-except
            pass

    #Read object from file
    @staticmethod
    def deserialize(filename):
        try:
            obj = None
            fn = str(filename)
            if os.path.exists(fn):
                import codecs
                with codecs.open(fn, 'rb', encoding='utf-8') as f:
                    obj=ast.literal_eval(f.read()) # pylint: disable=eval-used
#PLUS
            # fill plus UUID register
            try:
                if obj is not None:
                    if plus.config.uuid_tag in obj:
                        plus.register.addPath(obj[plus.config.uuid_tag],fn)
            except Exception: # pylint: disable=broad-except
                pass

            return obj
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' deserialize() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return {}
#            traceback.print_exc(file=sys.stdout)

    def ensureCorrectExtraDeviceListLenght(self):
        self.qmc.extraname1 = self.qmc.extraname1[:len(self.qmc.extradevices)]
        self.qmc.extraname1 = self.qmc.extraname1 + ['Extra 1']*max(0,len(self.qmc.extradevices)-len(self.qmc.extraname1))
        self.qmc.extraname2 = self.qmc.extraname2[:len(self.qmc.extradevices)]
        self.qmc.extraname2 = self.qmc.extraname2 + ['Extra 2']*max(0,len(self.qmc.extradevices)-len(self.qmc.extraname2))
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1 + ['']*max(0,len(self.qmc.extradevices)-len(self.qmc.extramathexpression1))
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2 + ['']*max(0,len(self.qmc.extradevices)-len(self.qmc.extramathexpression2))
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1 + ['black']*max(0,len(self.qmc.extradevices)-len(self.qmc.extradevicecolor1))
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2 + ['black']*max(0,len(self.qmc.extradevices)-len(self.qmc.extradevicecolor2))

    def saveExtradeviceSettings(self):
        self.org_extradevicesettings = {
                'extradevices'           : self.qmc.extradevices,
                'extradevicecolor1'      : self.qmc.extradevicecolor1,
                'extradevicecolor2'      : self.qmc.extradevicecolor2,
                'extraname1'             : self.qmc.extraname1,
                'extraname2'             : self.qmc.extraname2,
                'extramathexpression1'   : self.qmc.extramathexpression1,
                'extramathexpression2'   : self.qmc.extramathexpression2,
                'extraLCDvisibility1'    : self.extraLCDvisibility1,
                'extraLCDvisibility2'    : self.extraLCDvisibility2,
                'extraCurveVisibility1'  : self.extraCurveVisibility1,
                'extraCurveVisibility2'  : self.extraCurveVisibility2,
                'extraDelta1'            : self.extraDelta1,
                'extraDelta2'            : self.extraDelta2,
                'extraFill1'             : self.extraFill1,
                'extraFill2'             : self.extraFill2,
                'extralinestyles1'       : self.qmc.extralinestyles1,
                'extralinestyles2'       : self.qmc.extralinestyles2,
                'extradrawstyles1'       : self.qmc.extradrawstyles1,
                'extradrawstyles2'       : self.qmc.extradrawstyles2,
                'extralinewidths1'       : self.qmc.extralinewidths1,
                'extralinewidths2'       : self.qmc.extralinewidths2,
                'extramarkers1'          : self.qmc.extramarkers1,
                'extramarkers2'          : self.qmc.extramarkers2,
                'extramarkersizes1'      : self.qmc.extramarkersizes1,
                'extramarkersizes2'      : self.qmc.extramarkersizes2,
                'etypes'                 : self.qmc.etypes
                }

    def restoreExtradeviceSettings(self):
        self.qmc.extradevices         = self.org_extradevicesettings['extradevices']
        self.qmc.extradevicecolor1    = self.org_extradevicesettings['extradevicecolor1']
        self.qmc.extradevicecolor2    = self.org_extradevicesettings['extradevicecolor2']
        self.qmc.extraname1           = self.org_extradevicesettings['extraname1']
        self.qmc.extraname2           = self.org_extradevicesettings['extraname2']
        self.qmc.extramathexpression1 = self.org_extradevicesettings['extramathexpression1']
        self.qmc.extramathexpression2 = self.org_extradevicesettings['extramathexpression2']
        self.extraLCDvisibility1      = self.org_extradevicesettings['extraLCDvisibility1']
        self.extraLCDvisibility2      = self.org_extradevicesettings['extraLCDvisibility2']
        self.extraCurveVisibility1    = self.org_extradevicesettings['extraCurveVisibility1']
        self.extraCurveVisibility2    = self.org_extradevicesettings['extraCurveVisibility2']
        self.extraDelta1              = self.org_extradevicesettings['extraDelta1']
        self.extraDelta2              = self.org_extradevicesettings['extraDelta2']
        self.extraFill1               = self.org_extradevicesettings['extraFill1']
        self.extraFill2               = self.org_extradevicesettings['extraFill2']
        self.qmc.extralinestyles1     = self.org_extradevicesettings['extralinestyles1']
        self.qmc.extralinestyles2     = self.org_extradevicesettings['extralinestyles2']
        self.qmc.extradrawstyles1     = self.org_extradevicesettings['extradrawstyles1']
        self.qmc.extradrawstyles2     = self.org_extradevicesettings['extradrawstyles2']
        self.qmc.extralinewidths1     = self.org_extradevicesettings['extralinewidths1']
        self.qmc.extralinewidths2     = self.org_extradevicesettings['extralinewidths2']
        self.qmc.extramarkers1        = self.org_extradevicesettings['extramarkers1']
        self.qmc.extramarkers2        = self.org_extradevicesettings['extramarkers2']
        self.qmc.extramarkersizes1    = self.org_extradevicesettings['extramarkersizes1']
        self.qmc.extramarkersizes2    = self.org_extradevicesettings['extramarkersizes2']
        self.qmc.etypes               = self.org_extradevicesettings['etypes']
        self.updateExtradeviceSettings()

    def updateExtradeviceSettings(self):
        ndevices = len(self.qmc.extradevices)
        if ndevices != len(self.qmc.extralinestyles1) or \
           ndevices != len(self.qmc.extralinestyles2) or \
           ndevices != len(self.qmc.extradrawstyles1) or \
           ndevices != len(self.qmc.extradrawstyles2) or \
           ndevices != len(self.qmc.extralinewidths1) or \
           ndevices != len(self.qmc.extralinewidths2) or \
           ndevices != len(self.qmc.extramarkers1) or \
           ndevices != len(self.qmc.extramarkers2) or \
           ndevices != len(self.qmc.extramarkersizes1) or \
           ndevices != len(self.qmc.extramarkersizes2):
            self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*ndevices
            self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*ndevices
            self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*ndevices
            self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*ndevices
            self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default]*ndevices
            self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default]*ndevices
            self.qmc.extramarkers1 = [self.qmc.marker_default]*ndevices
            self.qmc.extramarkers2 = [self.qmc.marker_default]*ndevices
            self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*ndevices
            self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*ndevices
        self.qmc.extratemp1 = []
        self.qmc.extratemp2 = []
        self.qmc.extratimex = []
        self.qmc.extrastemp1 = []
        self.qmc.extrastemp2 = []
        for _ in range(len(self.qmc.extradevices)):
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2.append([])
            self.qmc.extratimex.append([])
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2.append([])
            self.qmc.extractimex1.append([])
            self.qmc.extractimex2.append([])
            self.qmc.extractemp1.append([])
            self.qmc.extractemp2.append([])
        #extra LCDs and other LCDs visibility
        self.updateLCDproperties()
        # set extraLCD colors
        for i in range(len(self.qmc.extradevices)):
            self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
            self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))

    def initializedMonitoringExtraDeviceStructures(self):
        self.qmc.on_timex = []
        self.qmc.on_temp1 = []
        self.qmc.on_temp2 = []
        self.qmc.on_ctimex1 = []
        self.qmc.on_ctemp1 = []
        self.qmc.on_ctimex2 = []
        self.qmc.on_ctemp2 = []
        self.qmc.on_tstemp1 = []
        self.qmc.on_tstemp2 = []
        self.qmc.on_unfiltereddelta1 = []
        self.qmc.on_unfiltereddelta2 = []
        self.qmc.on_delta1 = []
        self.qmc.on_delta2 = []
        # list of lists:
        self.qmc.on_extratemp1 = []
        self.qmc.on_extratemp2 = []
        self.qmc.on_extratimex = []
        self.qmc.on_extractimex1 = []
        self.qmc.on_extractemp1 = []
        self.qmc.on_extractimex2 = []
        self.qmc.on_extractemp2 = []
        for _ in range(len(self.qmc.extradevices)):
            self.qmc.on_extratemp1.append([])
            self.qmc.on_extratemp2.append([])
            self.qmc.on_extratimex.append([])
            self.qmc.on_extractimex1.append([])
            self.qmc.on_extractemp1.append([])
            self.qmc.on_extractimex2.append([])
            self.qmc.on_extractemp2.append([])

    @staticmethod
    def getExtraDeviceSettingsPath():
        if app.artisanviewerMode:
            return os.path.join(getDataDirectory(),'extra_devices_backup_viewer.aset')
        return os.path.join(getDataDirectory(),'extra_devices_backup.aset')

    def setExtraDeviceSettings(self, settings):
        settings.setValue('extradevices',self.qmc.extradevices)
        settings.setValue('extraname1',self.qmc.extraname1)
        settings.setValue('extraname2',self.qmc.extraname2)
        settings.setValue('extramathexpression1',self.qmc.extramathexpression1)
        settings.setValue('extramathexpression2',self.qmc.extramathexpression2)
        settings.setValue('extradevicecolor1',self.qmc.extradevicecolor1)
        settings.setValue('extradevicecolor2',self.qmc.extradevicecolor2)
        settings.setValue('extraLCDvisibility1',self.extraLCDvisibility1)
        settings.setValue('extraLCDvisibility2',self.extraLCDvisibility2)
        settings.setValue('extraCurveVisibility1',self.extraCurveVisibility1)
        settings.setValue('extraCurveVisibility2',self.extraCurveVisibility2)
        settings.setValue('extraDelta1',self.extraDelta1)
        settings.setValue('extraDelta2',self.extraDelta2)
        settings.setValue('extraFill1',self.extraFill1)
        settings.setValue('extraFill2',self.extraFill2)

    def setExtraDeviceCurveStyles(self, settings):
        settings.setValue('extralinestyles1',self.qmc.extralinestyles1)
        settings.setValue('extralinestyles2',self.qmc.extralinestyles2)
        settings.setValue('extradrawstyles1',self.qmc.extradrawstyles1)
        settings.setValue('extradrawstyles2',self.qmc.extradrawstyles2)
        settings.setValue('extralinewidths1',self.qmc.extralinewidths1)
        settings.setValue('extralinewidths2',self.qmc.extralinewidths2)
        settings.setValue('extramarkers1',self.qmc.extramarkers1)
        settings.setValue('extramarkers2',self.qmc.extramarkers2)
        settings.setValue('extramarkersizes1',self.qmc.extramarkersizes1)
        settings.setValue('extramarkersizes2',self.qmc.extramarkersizes2)

    def setExtraDeviceCommSettings(self, settings):
        settings.setValue('extracomport',self.extracomport)
        settings.setValue('extrabaudrate',self.extrabaudrate)
        settings.setValue('extrabytesize',self.extrabytesize)
        settings.setValue('extraparity',self.extraparity)
        settings.setValue('extrastopbits',self.extrastopbits)
        settings.setValue('extratimeout',self.extratimeout)

    def createExtraDeviceSettingsBackup(self):
        _log.debug('createExtraDeviceSettingsBackup()')
        if not(bool(self.simulator)):
            try:
                filename = self.getExtraDeviceSettingsPath()
                if not os.path.isfile(filename):
                    # we only backup the extra device settings if there is not an older available
                    settings = QSettings(filename, QSettings.Format.IniFormat)

                    settings.beginGroup('ExtraDev')
                    self.setExtraDeviceSettings(settings)
                    settings.endGroup()

                    settings.beginGroup('CurveStyles')
                    self.setExtraDeviceCurveStyles(settings)
                    settings.endGroup()

                    #save extra serial comm ports settings
                    settings.beginGroup('ExtraComm')
                    self.setExtraDeviceCommSettings(settings)
                    settings.endGroup()

                    #save custom event names
                    settings.beginGroup('events')
                    settings.setValue('etypes',self.qmc.etypes)
                    settings.endGroup()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    def clearExtraDeviceSettingsBackup(self, filename=None):
        _log.debug('clearExtraDeviceSettingsBackup()')
        if filename is None:
            filename = self.getExtraDeviceSettingsPath()
        try:
            os.unlink(filename)
        except Exception: # pylint: disable=broad-except
            pass

    def getExtraDeviceSettings(self, settings):
        self.qmc.extradevices = [toInt(x) for x in toList(settings.value('extradevices',self.qmc.extradevices))]
        self.qmc.extraname1 = list(map(str,list(toStringList(settings.value('extraname1',self.qmc.extraname1)))))
        self.qmc.extraname2 = list(map(str,list(toStringList(settings.value('extraname2',self.qmc.extraname2)))))
        self.qmc.extramathexpression1 = list(map(str,list(toStringList(settings.value('extramathexpression1',self.qmc.extramathexpression1)))))
        self.qmc.extramathexpression2 = list(map(str,list(toStringList(settings.value('extramathexpression2',self.qmc.extramathexpression2)))))
        self.qmc.extradevicecolor1 = list(map(str,list(toStringList(settings.value('extradevicecolor1',self.qmc.extradevicecolor1)))))
        self.qmc.extradevicecolor2 = list(map(str,list(toStringList(settings.value('extradevicecolor2',self.qmc.extradevicecolor2)))))
        if settings.contains('extraLCDvisibility1'):
            self.extraLCDvisibility1 = [toBool(x) for x in toList(settings.value('extraLCDvisibility1',self.extraLCDvisibility1))]
        if settings.contains('extraLCDvisibility2'):
            self.extraLCDvisibility2 = [toBool(x) for x in toList(settings.value('extraLCDvisibility2',self.extraLCDvisibility2))]
        if settings.contains('extraCurveVisibility1'):
            self.extraCurveVisibility1 = [toBool(x) for x in toList(settings.value('extraCurveVisibility1',self.extraCurveVisibility1))]
        if settings.contains('extraCurveVisibility2'):
            self.extraCurveVisibility2 = [toBool(x) for x in toList(settings.value('extraCurveVisibility2',self.extraCurveVisibility2))]
        if settings.contains('extraDelta1'):
            self.extraDelta1 = [toBool(x) for x in toList(settings.value('extraDelta1',self.extraDelta1))]
        if settings.contains('extraDelta2'):
            self.extraDelta2 = [toBool(x) for x in toList(settings.value('extraDelta2',self.extraDelta2))]
        if settings.contains('extraFill1'):
            self.extraFill1 = [toInt(x) for x in toList(settings.value('extraFill1',self.extraFill1))]
        if settings.contains('extraFill2'):
            self.extraFill2 = [toInt(x) for x in toList(settings.value('extraFill2',self.extraFill2))]

    def getExtraDeviceCurveStyles(self, settings):
        self.qmc.extralinestyles1 = list(map(str,list(toStringList(settings.value('extralinestyles1',self.qmc.extralinestyles1)))))
        self.qmc.extralinestyles2 = list(map(str,list(toStringList(settings.value('extralinestyles2',self.qmc.extralinestyles2)))))
        self.qmc.extradrawstyles1 = list(map(str,list(toStringList(settings.value('extradrawstyles1',self.qmc.extradrawstyles1)))))
        self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default if s=='-' else s for s in self.qmc.extradrawstyles1]
        self.qmc.extradrawstyles2 = list(map(str,list(toStringList(settings.value('extradrawstyles2',self.qmc.extradrawstyles2)))))
        self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default if s=='-' else s for s in self.qmc.extradrawstyles2]
        self.qmc.extralinewidths1 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value('extralinewidths1',self.qmc.extralinewidths1))]
        self.qmc.extralinewidths2 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value('extralinewidths2',self.qmc.extralinewidths2))]
        self.qmc.extramarkers1 = list(map(str,list(toStringList(settings.value('extramarkers1',self.qmc.extramarkers1)))))
        self.qmc.extramarkers2 = list(map(str,list(toStringList(settings.value('extramarkers2',self.qmc.extramarkers2)))))
        self.qmc.extramarkersizes1 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value('extramarkersizes1',self.qmc.extramarkersizes1))]
        self.qmc.extramarkersizes2 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value('extramarkersizes2',self.qmc.extramarkersizes2))]

    def getExtraDeviceCommSettings(self, settings):
        self.extracomport = list(map(str,list(toStringList(settings.value('extracomport',self.extracomport)))))
        self.extrabaudrate = [toInt(x) for x in toList(settings.value('extrabaudrate',self.extrabaudrate))]
        self.extrabytesize = [toInt(x) for x in toList(settings.value('extrabytesize',self.extrabytesize))]
        self.extraparity = list(map(str,list(toStringList(settings.value('extraparity',self.extraparity)))))
        self.extrastopbits = [toInt(x) for x in toList(settings.value('extrastopbits',self.extrastopbits))]
        self.extratimeout = [aw.float2float(toFloat(x)) for x in toList(settings.value('extratimeout',self.extratimeout))]
        lenextraports = len(self.extracomport)
        self.extraser = [None]*lenextraports
        #populate aw.extraser
        for i in range(lenextraports):
            self.extraser[i] = serialport(self)
            self.extraser[i].comport = str(self.extracomport[i])
            self.extraser[i].baudrate = self.extrabaudrate[i]
            self.extraser[i].bytesize = self.extrabytesize[i]
            self.extraser[i].parity = str(self.extraparity[i])
            self.extraser[i].stopbits = self.extrastopbits[i]
            self.extraser[i].timeout = self.extratimeout[i]

    # this should only be called from reset()
    def restoreExtraDeviceSettingsBackup(self):
        _log.debug('restoreExtraDeviceSettingsBackup()')
        if not(bool(self.simulator)):
            try:
                filename = self.getExtraDeviceSettingsPath()
                if os.path.isfile(filename):
                    settings = QSettings(filename, QSettings.Format.IniFormat)
                    settings.beginGroup('ExtraDev')
                    self.getExtraDeviceSettings(settings)
                    settings.endGroup()

                    settings.beginGroup('CurveStyles')
                    self.getExtraDeviceCurveStyles(settings)
                    settings.endGroup()

                    # ensure that extra list length are of the size of the extradevices:
                    self.ensureCorrectExtraDeviceListLenght()
                    self.updateExtradeviceSettings()

                    settings.beginGroup('ExtraComm')
                    self.getExtraDeviceCommSettings(settings)
                    settings.endGroup()

                    settings.beginGroup('events')
                    self.qmc.etypes = toStringList(settings.value('etypes',self.qmc.etypes))
                    settings.endGroup()
                    # now remove the settings file
                    self.clearExtraDeviceSettingsBackup(filename)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    #called by fileLoad() and various import functions
    # we assume that before a reset action was issues and among others timeindex got initialized to its defaults
    def setProfile(self,filename,profile,quiet=False,reset=True):
        try:
            updateRender = False
            #extra devices load and check
            if profile and 'extratimex' in profile:
                if 'extradevices' in profile:
                    updateRender = False
                    # check for difference in the Data values between the profile and current settings
                    settingdev = ''.join([str(self.qmc.extradevices), str([encodeLocal(n) for n in self.qmc.extraname1]), str([encodeLocal(n) for n in self.qmc.extraname2]),
                                        str([encodeLocal(x) for x in self.qmc.extramathexpression1]), str([encodeLocal(x) for x in self.qmc.extramathexpression2]),
                                        str([encodeLocal(x) for x in self.qmc.etypes])
                                        ])
                    # fix missing extramathexpression arrays on import
                    if 'extramathexpression1' not in profile:
                        profile['extramathexpression1'] = ['']*len(profile['extraname1'])
                    if 'extramathexpression2' not in profile:
                        profile['extramathexpression2'] = ['']*len(profile['extraname2'])
                    try:
                        profiledev = ''.join([str(profile['extradevices']), str(profile['extraname1']), str(profile['extraname2']),
                                            str(profile['extramathexpression1']), str(profile['extramathexpression2']),
                                            str(profile['etypes'])
                                            ])
                    except Exception: # pylint: disable=broad-except
                        profiledev = ''
                    if settingdev != profiledev:

# we don't ask the user to adjust or not the extra device setup. Instead, now we backup the current settings via createExtraDeviceSettingsBackup() always and reset back to the original state
# on reset, thus we default to StandardButton.Yes instead of asking in the dialog:

                        if bool(aw.simulator):
                            # loading files with different extra device settings will not alter those and not mess up an potentially already existing settings backup
                            reply = QMessageBox.StandardButton.No
                        else:
                            reply = QMessageBox.StandardButton.Yes

#                        string = QApplication.translate("Message","To fully load this profile the extra device configuration needs to be modified.\n\nOverwrite your extra device definitions using the values from the profile?\n\nIt is advisable to save your current settings beforehand via menu Help >> Save Settings.")
#                        if quiet:
#                            reply = QMessageBox.StandardButton.Yes
#                        else:
#                            reply = QMessageBox.question(aw,QApplication.translate("Message", "Found a different set of extra devices"), string,
#                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel, QMessageBox.StandardButton.No)

                        if reply == QMessageBox.StandardButton.Yes:
                            if not reset or self.qmc.reset(redraw=False): # operation not canceled by the user in the save dirty state dialog
                                self.createExtraDeviceSettingsBackup() # we make a backup of the core extra device settings before loading the profile, to be restored on next RESET
                                updateRender = True
                                aw.qmc.resetlinecountcaches()
                                self.qmc.extradevices = profile['extradevices']
                            else:
                                return False
                        elif reply == QMessageBox.StandardButton.No:
                            pass
                        else:
                            return False

                    # we remove the extra device elements that do not fit
                        if reply == QMessageBox.StandardButton.No:
                            #if (len(self.qmc.extradevices) < len(profile["extradevices"])):
                            l =len(self.qmc.extradevices)
                            for k in ['extratimex','extratemp1','extratemp2']:
                                profile[k] = profile[k][:l]
                            profile['extradevices'] = self.qmc.extradevices
                            profile['extraname1'] = self.qmc.extraname1
                            profile['extraname2'] = self.qmc.extraname2
                            profile['extramathexpression1'] = self.qmc.extramathexpression1
                            profile['extramathexpression2'] = self.qmc.extramathexpression2
                            profile['extradevicecolor1'] = self.qmc.extradevicecolor1
                            profile['extradevicecolor2'] = self.qmc.extradevicecolor2
                            profile['extramarkersizes1'] = self.qmc.extramarkersizes1
                            profile['extramarkersizes2'] = self.qmc.extramarkersizes2
                            profile['extramarkers1'] = self.qmc.extramarkers1
                            profile['extramarkers2'] = self.qmc.extramarkers2
                            profile['extralinewidths1'] = self.qmc.extralinewidths1
                            profile['extralinewidths2'] = self.qmc.extralinewidths2
                            profile['extralinestyles1'] = self.qmc.extralinestyles1
                            profile['extralinestyles2'] = self.qmc.extralinestyles2
                            profile['extradrawstyles1'] = self.qmc.extradrawstyles1
                            profile['extradrawstyles2'] = self.qmc.extradrawstyles2
                            profile['extraLCDvisibility1'] = self.extraLCDvisibility1
                            profile['extraLCDvisibility2'] = self.extraLCDvisibility2
                            profile['extraCurveVisibility1'] = self.extraCurveVisibility1
                            profile['extraCurveVisibility2'] = self.extraCurveVisibility2
                            profile['extraDelta1'] = self.extraDelta1
                            profile['extraDelta2'] = self.extraDelta2
                            profile['extraFill1'] = self.extraFill1
                            profile['extraFill2'] = self.extraFill2

                # adjust extra serial device table
                # a) remove superfluous extra serial settings
                self.extraser = self.extraser[:len(self.qmc.extradevices)]
                self.extracomport = self.extracomport[:len(self.qmc.extradevices)]
                self.extrabaudrate = self.extrabaudrate[:len(self.qmc.extradevices)]
                self.extrabytesize = self.extrabytesize[:len(self.qmc.extradevices)]
                self.extraparity = self.extraparity[:len(self.qmc.extradevices)]
                self.extrastopbits = self.extrastopbits[:len(self.qmc.extradevices)]
                self.extratimeout = self.extratimeout[:len(self.qmc.extradevices)]
                # b) add missing extra serial settings
                for _ in range(len(self.qmc.extradevices) - len(self.extraser)):
                    self.addSerialPort()
                # c) set extra temp curves and prepare empty extra smoothed temp curves
                if 'extratimex' in profile:
                    self.qmc.extratimex = profile['extratimex'] + [[]]*(len(self.qmc.extradevices) - len(profile['extratimex']))
                if 'extratemp1' in profile:
                    self.qmc.extratemp1 = profile['extratemp1'] + [[]]*(len(self.qmc.extradevices) - len(profile['extratimex']))
                    self.qmc.extrastemp1 = [[]]*len(self.qmc.extratemp1)
                    self.qmc.extractemp1 = [[]]*len(self.qmc.extratemp1)
                    self.qmc.extractimex1 = [[]]*len(self.qmc.extratemp1)
                if 'extratemp2' in profile:
                    self.qmc.extratemp2 = profile['extratemp2'] + [[]]*(len(self.qmc.extradevices) - len(profile['extratimex']))
                    self.qmc.extrastemp2 = [[]]*len(self.qmc.extratemp2)
                    self.qmc.extractemp2 = [[]]*len(self.qmc.extratemp2)
                    self.qmc.extractimex2 = [[]]*len(self.qmc.extratemp2)
                # d) set other extra curve attribute lists
                if 'extraname1' in profile:
                    self.qmc.extraname1 = [decodeLocal(x) for x in profile['extraname1']]
                if 'extraname2' in profile:
                    self.qmc.extraname2 = [decodeLocal(x) for x in profile['extraname2']]
                if 'extramathexpression1' in profile:
                    self.qmc.extramathexpression1 = [decodeLocal(x) for x in profile['extramathexpression1']]
                if 'extramathexpression2' in profile:
                    self.qmc.extramathexpression2 = [decodeLocal(x) for x in profile['extramathexpression2']]

                if updateRender:
                    if 'extradevicecolor1' in profile:
                        self.qmc.extradevicecolor1 = [decodeLocal(x) for x in profile['extradevicecolor1']]
                    if 'extradevicecolor2' in profile:
                        self.qmc.extradevicecolor2 = [decodeLocal(x) for x in profile['extradevicecolor2']]

                    if 'extraLCDvisibility1' in profile:
                        self.extraLCDvisibility1 = profile['extraLCDvisibility1']
                    else:
                        self.extraLCDvisibility1 = [False]*aw.nLCDS
                    if 'extraLCDvisibility2' in profile:
                        self.extraLCDvisibility2 = profile['extraLCDvisibility2']
                    else:
                        self.extraLCDvisibility2 = [False]*aw.nLCDS
                    if 'extraCurveVisibility1' in profile:
                        self.extraCurveVisibility1 = profile['extraCurveVisibility1']
                    else:
                        self.extraCurveVisibility1 = [False]*aw.nLCDS
                    if 'extraCurveVisibility2' in profile:
                        self.extraCurveVisibility2 = profile['extraCurveVisibility2']
                    else:
                        self.extraCurveVisibility2 = [False]*aw.nLCDS
                    if 'extraDelta1' in profile:
                        self.extraDelta1 = profile['extraDelta1']
                    else:
                        self.extraDelta1 = [False]*aw.nLCDS
                    if 'extraDelta2' in profile:
                        self.extraDelta2 = profile['extraDelta2']
                    else:
                        self.extraDelta2 = [False]*aw.nLCDS
                    if 'extraFill1' in profile:
                        self.extraFill1 = profile['extraFill1']
                    else:
                        self.extraFill1 = [0]*aw.nLCDS
                    if 'extraFill2' in profile:
                        self.extraFill2 = profile['extraFill2']
                    else:
                        self.extraFill2 = [0]*aw.nLCDS
                    if 'extramarkersizes1' in profile:
                        self.qmc.extramarkersizes1 = profile['extramarkersizes1']
                    else:
                        self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*len(self.qmc.extratemp1)
                    if 'extramarkersizes2' in profile:
                        self.qmc.extramarkersizes2 = profile['extramarkersizes2']
                    else:
                        self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*len(self.qmc.extratemp2)
                    if 'extramarkers1' in profile:
                        self.qmc.extramarkers1 = [decodeLocal(x) for x in profile['extramarkers1']]
                    else:
                        self.qmc.extramarkers1 = [self.qmc.marker_default]*len(self.qmc.extratemp1)
                    if 'extramarkers2' in profile:
                        self.qmc.extramarkers2 = [decodeLocal(x) for x in profile['extramarkers2']]
                    else:
                        self.qmc.extramarkers2 = [self.qmc.marker_default]*len(self.qmc.extratemp2)
                    if 'extralinewidths1' in profile:
                        self.qmc.extralinewidths1 = [int(w) for w in profile['extralinewidths1']]
                    else:
                        self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default]*len(self.qmc.extratemp1)
                    if 'extralinewidths2' in profile:
                        self.qmc.extralinewidths2 = [int(w) for w in profile['extralinewidths2']]
                    else:
                        self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default]*len(self.qmc.extratemp2)
                    if 'extralinestyles1' in profile:
                        self.qmc.extralinestyles1 = [decodeLocal(x) for x in profile['extralinestyles1']]
                    else:
                        self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*len(self.qmc.extratemp1)
                    if 'extralinestyles2' in profile:
                        self.qmc.extralinestyles2 = [decodeLocal(x) for x in profile['extralinestyles2']]
                    else:
                        self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*len(self.qmc.extratemp2)
                    if 'extradrawstyles1' in profile:
                        self.qmc.extradrawstyles1 = [decodeLocal(x) for x in profile['extradrawstyles1']]
                    else:
                        self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp1)
                    if 'extradrawstyles2' in profile:
                        self.qmc.extradrawstyles2 = [decodeLocal(x) for x in profile['extradrawstyles2']]
                    else:
                        self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp2)

                # ensure that extra list length are of the size of the extradevices:
                self.ensureCorrectExtraDeviceListLenght()

            self.updateExtraLCDvisibility()

# if auto-adjusted is ticked phases will automatically adjust to the set values in the profile
# we better not load the phases from the profile not to change the user defined phases settings
#            if "phases" in profile:
#                self.qmc.phases = profile["phases"]
            if 'flavors' in profile:
                self.qmc.flavors = [max(0,min(10,float(fl))) for fl in profile['flavors']]
            if 'flavorlabels' in profile:
                self.qmc.flavorlabels = toStringList([decodeLocal(x) for x in profile['flavorlabels']])
            if len(self.qmc.flavorlabels) > len(self.qmc.flavors):
                # fill with default 5. values
                self.qmc.flavors = self.qmc.flavors + [5.]*(len(self.qmc.flavorlabels)-len(self.qmc.flavors))
            elif len(self.qmc.flavorlabels) < len(self.qmc.flavors):
                # remove superfluous values
                self.qmc.flavors = self.qmc.flavors[:len(self.qmc.flavorlabels)]
            if 'flavorstartangle' in profile:
                self.qmc.flavorstartangle = int(profile['flavorstartangle'])
            if 'flavoraspect' in profile:
                self.qmc.flavoraspect = float(profile['flavoraspect'])
            else:
                self.qmc.flavoraspect = 1.
            if 'title' in profile:
                self.qmc.title = decodeLocal(profile['title'])
            else:
                self.qmc.title = QApplication.translate('Scope Title', 'Roaster Scope')

#PLUS
            if 'plus_store' in profile:
                self.qmc.plus_store = decodeLocal(profile['plus_store'])
                if 'plus_store_label' in profile:
                    self.qmc.plus_store_label = decodeLocal(profile['plus_store_label'])
                else:
                    self.qmc.plus_store_label = None
            else:
                self.qmc.plus_store = None
                self.qmc.plus_store_label = None
            if 'plus_coffee' in profile:
                self.qmc.plus_coffee = decodeLocal(profile['plus_coffee'])
                if 'plus_coffee_label' in profile:
                    self.qmc.plus_coffee_label = decodeLocal(profile['plus_coffee_label'])
                else:
                    self.qmc.plus_coffee_label = None
            else:
                self.qmc.plus_coffee = None
                self.qmc.plus_coffee_label = None
            if 'plus_blend_spec' in profile:
                # we convert the blend specification from its list to its internal dictionary representation
                self.qmc.plus_blend_spec = plus.stock.list2blend(profile['plus_blend_spec'])
                if 'plus_blend_label' in profile:
                    self.qmc.plus_blend_label = decodeLocal(profile['plus_blend_label'])
                else:
                    self.qmc.plus_blend_label = None
                if 'plus_blend_spec_labels' in profile:
                    self.qmc.plus_blend_spec_labels = [decodeLocal(l) for l in profile['plus_blend_spec_labels']]
                else:
                    self.qmc.plus_blend_spec_labels = None
            else:
                self.qmc.plus_blend_spec = None
                self.qmc.plus_blend_spec_labels = None
            if 'plus_sync_record_hash' in profile:
                self.qmc.plus_sync_record_hash = decodeLocal(profile['plus_sync_record_hash'])
            else:
                self.qmc.plus_sync_record_hash = None

            if 'beans' in profile:
                self.qmc.beans = decodeLocal(profile['beans'])
            else:
                self.qmc.beans = ''
            if 'weight' in profile:
                self.qmc.weight = [profile['weight'][0],profile['weight'][1],decodeLocal(profile['weight'][2])]
            else:
                self.qmc.weight = [0,0,'g']
            if 'volume' in profile:
                self.qmc.volume = profile['volume']
            else:
                self.qmc.volume = [0,0,'l']
            if 'density' in profile:
                self.qmc.density = [profile['density'][0],decodeLocal(profile['density'][1]),profile['density'][2],decodeLocal(profile['density'][3])]
            else:
                self.qmc.density = [0,'g',1,'l']
            if 'density_roasted' in profile:
                self.qmc.density_roasted = [profile['density_roasted'][0],decodeLocal(profile['density_roasted'][1]),profile['density_roasted'][2],decodeLocal(profile['density_roasted'][3])]
            else:
                self.qmc.density_roasted = [0,'g',1,'l']
            if 'roastertype' in profile:
                self.qmc.roastertype = decodeLocal(profile['roastertype'])
            else:
                self.qmc.roastertype = ''
            if 'roastersize' in profile:
                self.qmc.roastersize = profile['roastersize']
            else:
                self.qmc.roastersize = 0
            if 'roasterheating' in profile:
                self.qmc.roasterheating = profile['roasterheating']
            else:
                self.qmc.roastersize = 0
            if 'operator' in profile:
                self.qmc.operator = decodeLocal(profile['operator'])
            else:
                self.qmc.operator = ''
            if 'organization' in profile:
                self.qmc.organization = decodeLocal(profile['organization'])
            else:
                self.qmc.organization = ''
            if 'drumspeed' in profile:
                self.qmc.drumspeed = decodeLocal(profile['drumspeed'])
            else:
                self.qmc.drumspeed = ''
            if 'beansize' in profile:
                # we map beansize in mm to beansize_max in 1/64"
                try:
                    self.qmc.beansize_max = int(round(float(profile['beansize']) * 0.0393701 * 61))
                except Exception: # pylint: disable=broad-except
                    pass
            if 'beansize_min' in profile:
                self.qmc.beansize_min = float(profile['beansize_min'])
            else:
                self.qmc.beansize_min = 0
            if 'beansize_max' in profile:
                self.qmc.beansize_max = float(profile['beansize_max'])
            else:
                self.qmc.beansize_max = 0
            if 'heavyFC' in profile:
                self.qmc.heavyFC_flag = profile['heavyFC']
            if 'lowFC' in profile:
                self.qmc.lowFC_flag = profile['lowFC']
            if 'lightCut' in profile:
                self.qmc.lightCut_flag = profile['lightCut']
            if 'darkCut' in profile:
                self.qmc.darkCut_flag = profile['darkCut']
            if 'drops' in profile:
                self.qmc.drops_flag = profile['drops']
            if 'oily' in profile:
                self.qmc.oily_flag = profile['oily']
            if 'uneven' in profile:
                self.qmc.uneven_flag = profile['uneven']
            if 'tipping' in profile:
                self.qmc.tipping_flag = profile['tipping']
            if 'scorching' in profile:
                self.qmc.scorching_flag = profile['scorching']
            if 'divots' in profile:
                self.qmc.divots_flag = profile['divots']
            # color
            if 'whole_color' in profile:
                self.qmc.whole_color = profile['whole_color']
            if 'ground_color' in profile:
                self.qmc.ground_color = profile['ground_color']
            if 'color_system' in profile and profile['color_system'] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(profile['color_system'])
            if 'volumeCalcWeightIn' in profile:
                self.qmc.volumeCalcWeightInStr = profile['volumeCalcWeightIn']
            if 'volumeCalcWeightOut' in profile:
                self.qmc.volumeCalcWeightOutStr = profile['volumeCalcWeightOut']
            # for compatibility with older profiles:
            if 'roastdate' in profile:
                try:
                    date = QDate.fromString(decodeLocal(profile['roastdate']))
                    if not date.isValid():
                        date = QDate.currentDate()
                    if 'roasttime' in profile:
                        try:
                            time = QTime.fromString(decodeLocal(profile['roasttime']))
                            self.qmc.roastdate = QDateTime(date,time)
                        except Exception: # pylint: disable=broad-except
                            self.qmc.roastdate = QDateTime(date)
                    else:
                        self.qmc.roastdate = QDateTime(date)
                except Exception: # pylint: disable=broad-except
                    pass
            # the new dates have the locale independent isodate format:
            if 'roastisodate' in profile:
                try:
                    date = QDate.fromString(decodeLocal(profile['roastisodate']),Qt.DateFormat.ISODate)
                    if 'roasttime' in profile:
                        try:
                            time = QTime.fromString(decodeLocal(profile['roasttime']))
                            self.qmc.roastdate = QDateTime(date,time)
                        except Exception: # pylint: disable=broad-except
                            self.qmc.roastdate = QDateTime(date)
                    else:
                        self.qmc.roastdate = QDateTime(date)
                except Exception: # pylint: disable=broad-except
                    pass
            if 'roastepoch' in profile:
                try:
                    self.qmc.roastdate = QDateTime.fromSecsSinceEpoch(profile['roastepoch'])
                except Exception: # pylint: disable=broad-except
                    pass
            if 'roastUUID' in profile:
                self.qmc.roastUUID = decodeLocal(profile['roastUUID'])
            else:
                import uuid
                self.qmc.roastUUID = uuid.uuid4().hex # generate UUID
                self.qmc.fileDirtySignal.emit()
            if 'roastbatchnr' in profile:
                try:
                    self.qmc.roastbatchnr = int(profile['roastbatchnr'])
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    self.qmc.roastbatchprefix = decodeLocal(profile['roastbatchprefix'])
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    self.qmc.roastbatchpos = int(profile['roastbatchpos'])
                except Exception: # pylint: disable=broad-except
                    pass
            if 'specialevents' in profile:
                self.qmc.specialevents = profile['specialevents']
            else:
                self.qmc.specialevents = []
            if 'specialeventstype' in profile:
                self.qmc.specialeventstype = profile['specialeventstype']
            else:
                self.qmc.specialeventstype = []
            if 'specialeventsvalue' in profile:
                self.qmc.specialeventsvalue = profile['specialeventsvalue']
            else:
                self.qmc.specialeventsvalue = []
            if 'specialeventsStrings' in profile:
                self.qmc.specialeventsStrings = [decodeLocal(x) for x in profile['specialeventsStrings']]
            else:
                self.qmc.specialeventsStrings = []
            if 'etypes' in profile:
                self.qmc.etypes = [decodeLocal(x) for x in profile['etypes']]

            if 'roastingnotes' in profile:
                self.qmc.roastingnotes = decodeLocal(profile['roastingnotes'])
            else:
                self.qmc.roastingnotes = ''
            if 'cuppingnotes' in profile:
                self.qmc.cuppingnotes = decodeLocal(profile['cuppingnotes'])
            else:
                self.qmc.cuppingnotes = ''
            if 'timex' in profile:
                self.qmc.timex = profile['timex']

            # alarms
            if self.qmc.loadalarmsfromprofile and filename is not None:
                self.loadAlarmsFromProfile(filename,profile)

            if 'extraNoneTempHint1' in profile:
                self.qmc.extraNoneTempHint1 = profile['extraNoneTempHint1']
            else:
                self.qmc.extraNoneTempHint1 = []
            if 'extraNoneTempHint2' in profile:
                self.qmc.extraNoneTempHint2 = profile['extraNoneTempHint2']
            else:
                self.qmc.extraNoneTempHint2 = []

            if 'mode' in profile:
                m = str(profile['mode'])
            else:
                m = self.qmc.mode
            if 'temp1' in profile:
                self.qmc.temp1 = profile['temp1']
            if 'temp2' in profile:
                self.qmc.temp2 = profile['temp2']
            if 'ambientTemp' in profile:
                self.qmc.ambientTemp = profile['ambientTemp']
            if 'greens_temp' in profile:
                self.qmc.greens_temp = profile['greens_temp']
            else:
                self.qmc.greens_temp = 0.

            if self.qmc.mode == 'C' and m == 'F':
                self.qmc.temp1 = [fromFtoC(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [fromFtoC(t) for t in self.qmc.temp2]
                for e in range(len(self.qmc.extratimex)):
                    if self.extraDelta1[e]:
                        self.qmc.extratemp1[e] = [RoRfromFtoC(t) for t in self.qmc.extratemp1[e]]
                    else:
                        if not (len(self.qmc.extraNoneTempHint1) > e and self.qmc.extraNoneTempHint1[e]):
                            self.qmc.extratemp1[e] = [fromFtoC(t) for t in self.qmc.extratemp1[e]]
                    if self.extraDelta2[e]:
                        self.qmc.extratemp2[e] = [RoRfromFtoC(t) for t in self.qmc.extratemp2[e]]
                    else:
                        if not (len(self.qmc.extraNoneTempHint2) > e and self.qmc.extraNoneTempHint2[e]):
                            self.qmc.extratemp2[e] = [fromFtoC(t) for t in self.qmc.extratemp2[e]]
                try:
                    aw.calcVirtualdevices(update=True)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = fromFtoC(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and 'alarmtemperature' in profile:
                    self.qmc.alarmtemperature = [(fromFtoC(t) if t != 500 else t) for t in self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = fromFtoC(self.qmc.greens_temp)
                self.qmc.fileDirtySignal.emit()
            elif self.qmc.mode == 'F' and m == 'C':
                self.qmc.temp1 = [fromCtoF(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [fromCtoF(t) for t in self.qmc.temp2]
                for e in range(len(self.qmc.extratimex)):
                    if self.extraDelta1[e]:
                        self.qmc.extratemp1[e] = [RoRfromCtoF(t) for t in self.qmc.extratemp1[e]]
                    else:
                        if not (len(self.qmc.extraNoneTempHint1) > e and self.qmc.extraNoneTempHint1[e]):
                            self.qmc.extratemp1[e] = [fromCtoF(t) for t in self.qmc.extratemp1[e]]
                    if self.extraDelta2[e]:
                        self.qmc.extratemp2[e] = [RoRfromCtoF(t) for t in self.qmc.extratemp2[e]]
                    else:
                        if not (len(self.qmc.extraNoneTempHint2) > e and self.qmc.extraNoneTempHint2[e]):
                            self.qmc.extratemp2[e] = [fromCtoF(t) for t in self.qmc.extratemp2[e]]
                try:
                    aw.calcVirtualdevices(update=True)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = fromCtoF(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and 'alarmtemperature' in profile:
                    self.qmc.alarmtemperature = [fromCtoF(t) for t in self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = fromCtoF(self.qmc.greens_temp)
                self.qmc.fileDirtySignal.emit()
            elif self.qmc.loadaxisfromprofile:
                # only if the temperature mode of the profile equals to our current mode, and loadfromprofile is ticked, we respect the temp/RoR axis limits
                if 'zmax' in profile:
                    self.qmc.zlimit = min(int(profile['zmax']),self.qmc.zlimit_max)
                if 'zmin' in profile:
                    self.qmc.zlimit_min = max(min(int(profile['zmin']),self.qmc.zlimit),self.qmc.zlimit_min_max)
                if 'ymax' in profile:
                    self.qmc.ylimit = min(int(profile['ymax']),self.qmc.ylimit_max)
                if 'ymin' in profile:
                    self.qmc.ylimit_min = max(min(int(profile['ymin']),self.qmc.ylimit),self.qmc.ylimit_min_max)
            if not self.qmc.locktimex and self.qmc.loadaxisfromprofile:
                # otherwise don't let the users y/z min/max axis limits be overwritten by loading a profile
                if 'xmin' in profile:
                    self.qmc.startofx = float(profile['xmin'])
                if 'xmax' in profile:
                    self.qmc.endofx = float(profile['xmax'])
                else:
                    #Set the xlimits
                    if self.qmc.timex:
                        self.qmc.endofx = self.qmc.timex[-1] + 40
            if 'ambient_humidity' in profile:
                self.qmc.ambient_humidity = profile['ambient_humidity']
            if 'ambient_pressure' in profile:
                self.qmc.ambient_pressure = profile['ambient_pressure']
            if 'moisture_greens' in profile:
                self.qmc.moisture_greens = profile['moisture_greens']
            else:
                self.qmc.moisture_greens = 0.
            if 'moisture_roasted' in profile:
                self.qmc.moisture_roasted = profile['moisture_roasted']
            else:
                self.qmc.moisture_roasted = 0.

            # only load annotations position if the temperature mode did not change
            if 'anno_positions' in profile and self.qmc.mode == m:
                self.qmc.setAnnoPositions(profile['anno_positions'])
            else:
                self.qmc.l_annotations_pos_dict = {}
            if 'flag_positions' in profile and self.qmc.mode == m:
                self.qmc.setFlagPositions(profile['flag_positions'])
            else:
                self.qmc.l_event_flags_pos_dict = {}
            if 'legendloc_pos' in profile and self.qmc.loadaxisfromprofile:
                try:
                    # first set the profiles axis limits to have the transformations right
                    self.qmc.ax.set_xlim(self.qmc.startofx, self.qmc.endofx)
                    self.qmc.ax.set_ylim(self.qmc.ylimit_min, self.qmc.ylimit)
                    # if available we transform the custom legend position back from data into axis coordinates
                    legendloc_pos_data = numpy.array(profile['legendloc_pos'])
                    axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                    data_to_axis = axis_to_data.inverted()
                    pos = data_to_axis.transform(legendloc_pos_data)
                    self.qmc.legendloc_pos = (pos[0],pos[1])
                    self.qmc.legend = None
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

# we load external programs only from app settings
#            if "externalprogram" in profile:
#                self.ser.externalprogram = decodeLocal(profile["externalprogram"])
#            if "externaloutprogram" in profile:
#                self.ser.externaloutprogram = decodeLocal(profile["externaloutprogram"])
            if 'samplinginterval' in profile:
                # derive aw.qmc.deltaBTsamples from aw.qmc.deltaBTspan and the sampling interval of the profile
                self.qmc.profile_sampling_interval = profile['samplinginterval']
            else:
                if len(self.qmc.timex)>2:
                    self.qmc.profile_sampling_interval = (self.qmc.timex[-1] - self.qmc.timex[0])/(len(self.qmc.timex) -1)
            self.qmc.updateDeltaSamples()
            # Ramp/Soak Profiles
            if self.pidcontrol.loadRampSoakFromProfile:
                self.loadRampSoakFromProfile(filename,profile)

            # Energy
            self.loadEnergyFromProfile(profile)

            if 'timeindex' in profile:
                self.qmc.timeindex = [max(0,v) if i>0 else max(-1,v) for i,v in enumerate(profile['timeindex'])]
                if self.qmc.locktimex:
                    if self.qmc.timeindex[0] != -1:
                        self.qmc.startofx = self.qmc.timex[aw.qmc.timeindex[0]] + self.qmc.locktimex_start
                    else:
                        self.qmc.startofx = self.qmc.locktimex_start
                elif not self.qmc.loadaxisfromprofile and self.qmc.timeindex[0] != -1:
                    # we still need to adjust startx as it depends on timeindex[0] to keep x-axis min limit as is
                    # we assume here that the previous reset did initialize timeindex[0] and adjusted startx correctly
                    self.qmc.startofx += self.qmc.timex[self.qmc.timeindex[0]]
            elif len(profile) > 0 and ('startend' in profile or 'dryend' in profile or 'cracks' in profile):
                ###########      OLD PROFILE FORMAT
                if 'startend' in profile:
                    startend = [float(fl) for fl in profile['startend']]
                else:
                    startend = [0.,0.,0.,0.]
                if 'dryend' in profile:
                    dryend = profile['dryend']
                else:
                    dryend = [0.,0.]
                if 'cracks' in profile:
                    varC = [float(fl) for fl in profile['cracks']]
                else:
                    varC = [0.,0.,0.,0.,0.,0.,0.,0.]
                times = []
                times.append(startend[0])
                times.append(dryend[0])
                times.append(varC[0])
                times.append(varC[2])
                times.append(varC[4])
                times.append(varC[6])
                times.append(startend[2])
                #convert to new profile
                self.qmc.timeindexupdate(times)
                ###########      END OLD PROFILE FORMAT
            # update phases if phases are set to auto adjusted
            if aw.qmc.phasesbuttonflag:
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            # ensure that timeindex has the proper length
            self.qmc.timeindex = self.qmc.timeindex + [0 for _ in range(8-len(self.qmc.timeindex))]
            # reset linecount caches
            aw.qmc.resetlinecountcaches()
            # try to reload background profile
            if (not quiet) and 'backgroundpath' in profile and decodeLocal(profile['backgroundpath']) != '':
                self.qmc.backgroundpath = decodeLocal(profile['backgroundpath'])
                if os.path.isfile(self.qmc.backgroundpath):
                    try:
                        aw.loadbackground(self.qmc.backgroundpath)
                        aw.qmc.background = not aw.qmc.hideBgafterprofileload
                        aw.qmc.timealign(redraw=False) # there will be a later redraw triggered that also recomputes the deltas
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        self.deleteBackground() # delete a loaded background if any
                elif 'backgroundUUID' in profile and aw.qmc.backgroundUUID != profile['backgroundUUID']:
                    # background file path moved, we try to resolve via the UUID cache
                    background_path = plus.register.getPath(profile['backgroundUUID'])
                    if background_path is not None and os.path.isfile(background_path):
                        try:
                            aw.loadbackground(background_path)
                            aw.qmc.background = not aw.qmc.hideBgafterprofileload
                            aw.qmc.timealign(redraw=False) # there will be a later redraw triggered that also recomputes the deltas
                            self.qmc.backgroundpath = background_path
                            aw.qmc.fileDirtySignal.emit() # as we updated the background path we force a profile save
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                            self.deleteBackground() # delete a loaded background if any
                    else:
                        self.deleteBackground() # delete a loaded background if any
                else:
                    self.deleteBackground() # delete a loaded background if any
            aw.autoAdjustAxis()
            if 'devices' in profile:
                self.qmc.profile_meter = decodeLocal(profile['devices'][0])
            else:
                self.qmc.profile_meter = 'Unknown'
            _log.debug(self.profileQuality(m,True))
            return True
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            # we don't report errors on settingsLoad
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate('Error Message', 'Exception:') + ' setProfile()',str(ex) + '@line ' + str(getattr(exc_tb, 'tb_lineno', '?')))
            return False

    @staticmethod
    def profileQuality(profileMode='',checkDebugLevel=False):
        # immediately return when not at debug log level
        if checkDebugLevel and not debugLogLevelActive():
            return ''
        try:
            if len(aw.qmc.timex) >0:
                bt = numpy.array(aw.qmc.temp2)
                tx = numpy.array(aw.qmc.timex)
                profile_sampling_interval = aw.qmc.profile_sampling_interval

                # Meter
                # The meter is added to setProfile() as it was not previously read.  It useful here for trending.
                #    The Meter device is written to the profile whenever it is saved, meaning that it can be changed
                #     in the profile without warning and may not reflect the actual meter used to record the profile.
                meter = aw.qmc.profile_meter

                # Count the number of decimal places in a float
                def ndec(num):
                    return len(re.sub(r'(?:[{0}]+$)', '', str(num)).split('.')[1])

                # Total number of samples
                totalSamples = len(aw.qmc.timex)

                # Calculate the average number of decimals in an array of floats
                ndec_arr = numpy.array([ndec(x) for x in bt])
                avgDecimal = numpy.average(ndec_arr)
                maxDecimal = numpy.amax(ndec_arr)
                str_modeChanged = ''
                if profileMode in ['C','F'] and aw.qmc.mode != profileMode:
                    str_modeChanged = '*Result not reliable, the temperature mode was changed'

                # Count the number of consecutive duplicates
                markdup = numpy.diff(bt).astype(bool)  # False (or 0) marks a duplicate
                dups = numpy.count_nonzero(markdup==0)   # counts the 0s
                blank = numpy.count_nonzero(bt==-1)  # counts missing values

                # Count skipped samples (missing timex)
                tx_diff = numpy.diff(tx)
                avg_sample = numpy.average(tx_diff)
                longest_sample = numpy.max(tx_diff)
                shortest_sample = numpy.min(tx_diff)
                skipped_sample_time = 1.5*avg_sample
                skipped = numpy.count_nonzero(tx_diff > skipped_sample_time)
                bins = [0, 1*profile_sampling_interval, 1.5*profile_sampling_interval, 4*profile_sampling_interval, 9999]
                hist = numpy.histogram(tx_diff,bins=bins)
                std_sample = numpy.std(tx_diff)

                # Aperiodic sample ratio
                aperiodicRatio = avg_sample / profile_sampling_interval

                # Missing events
                missingEvents = 'Missing key events: '
                lenLabel = len(missingEvents)
                if aw.qmc.timeindex[0] == -1:
                    missingEvents += 'CHARGE '
                if aw.qmc.timeindex[2] == 0:
                    missingEvents += 'FCs '
                if aw.qmc.timeindex[6] == 0:
                    missingEvents += 'DROP '
                if len(missingEvents) == lenLabel:
                    missingEvents += 'None '

                # Are Special Events in order?
                flag = 0
                i = 1
                while i < len(aw.qmc.specialevents):
                    if(aw.qmc.specialevents[i] < aw.qmc.specialevents[i - 1]):
                        flag = 1
                        break
                    i += 1
                if flag:
                    speventsSorted = 'Special Events: Out of order'
                else:
                    speventsSorted = 'Special Events: In sorted order'

                # Output string
                output = (
                    f'Profile quality metrics'
                    f'\n  Title: {aw.qmc.title}'
                    f'\n  Meter: {meter}'
                    f'\n  Average decimals: {avgDecimal:.2f} {str_modeChanged}'
                    f'\n  Max decimals: {maxDecimal:.2f} {str_modeChanged}'
                    f'\n  Total Samples: {totalSamples}'
                    f'\n  Duplicate Samples: {dups}'
                    f'\n  Blank Samples: {blank}'
                    f'\n  Skipped Samples: {skipped}  (more than {skipped_sample_time:.2f} secs)'
                    f'\n  Histogram of Sample Times: {hist[0]}  Bins: <1x, 1x-1.5x, 1.5x-4x, >4x Profile Sampling Interval'
                    f'\n  Shortest Sample Interval: {shortest_sample:.2f}'
                    f'\n  Longest Sample Interval: {longest_sample:.2f}'
                    f'\n  Average Sample Time: {avg_sample:.2f}'
                    f'\n  Std Dev Sample Time: {std_sample:.2E}'
                    f'\n  Profile Sampling Interval: {profile_sampling_interval:.2f}'
                    f'\n  Aperiodic Samples Ratio: {aperiodicRatio:.2f}'
                    f'\n  {missingEvents}'
                    f'\n  {speventsSorted}'
                )
            else:
                output = 'Metrics not available: profile is zero length.'
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            output = 'Metrics not available: exception'
        return output

    @staticmethod
    def weightVolumeDigits(v):
        if v >= 1000:
            return 1
        if v >= 100:
            return 2
        if v >= 10:
            return 3
        return 4

    @staticmethod
    def float2floatWeightVolume(v):
        d = ApplicationWindow.weightVolumeDigits(v)
        return ApplicationWindow.float2float(v,d)

    # the int n specifies the number of digits
    @staticmethod
    def float2float(f, n=1):
        if f is None:
            return None
        f = float(f)
        if n==0:
            if math.isnan(f):
                return 0
            return int(round(f))
        res = float(f'%.{n}f'%f)
        if math.isnan(res):
            return 0.0
        return res

    # returns data that is computed by Artisan out of raw profile data using some formulas
    # and displayed to users e.g. as part of the Report to users and stored along profiles to be used by external programs
    # in case a value cannot be computed the corresponding entry is missing in the resulting dict
    def computedProfileInformation(self):
        computedProfile = {}
        TP_time_idx = None
        DRY_time_idx = None
        try:
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
                computedProfile['CHARGE_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[0]])
                computedProfile['CHARGE_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[0]])
            else:
                start = 0
            ######### TP #########
            # calc TP_time_idx (index of TP; is None if unknown)
            TP_index = self.findTP() # could return -1
            if TP_index > 0 and len(self.qmc.timex) > 0:
                TP_time_idx = TP_index
            else:
                if len(self.qmc.timex) > 0:
                    TP_time_idx = 0
                else:
                    TP_time_idx = None
            if TP_time_idx:
                computedProfile['TP_idx'] = TP_time_idx
                computedProfile['TP_time'] = self.float2float(self.qmc.timex[TP_time_idx] - start)
                computedProfile['TP_ET'] = self.float2float(self.qmc.temp1[TP_time_idx])
                computedProfile['TP_BT'] = self.float2float(self.qmc.temp2[TP_time_idx])
                if self.qmc.timeindex[6]:
                    relevant_ETs = self.qmc.temp1[TP_time_idx:self.qmc.timeindex[6]]
                    if relevant_ETs: # relevant_ETs might be the empty list!
                        computedProfile['MET'] = self.float2float(max(relevant_ETs))
            ######### DRY #########
            if self.qmc.timeindex[1]:
                computedProfile['DRY_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[1]] - start)
                computedProfile['DRY_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[1]])
                computedProfile['DRY_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[1]])
                DRY_time_idx = self.qmc.timeindex[1]
            ######### FC #########
            if self.qmc.timeindex[2]:
                computedProfile['FCs_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[2]] - start)
                computedProfile['FCs_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[2]])
                computedProfile['FCs_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[2]])
            if self.qmc.timeindex[3]:
                computedProfile['FCe_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[3]] - start)
                computedProfile['FCe_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[3]])
                computedProfile['FCe_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[3]])
            ######### SC #########
            if self.qmc.timeindex[4]:
                computedProfile['SCs_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[4]] - start)
                computedProfile['SCs_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[4]])
                computedProfile['SCs_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[4]])
            if self.qmc.timeindex[5]:
                computedProfile['SCe_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[5]] - start)
                computedProfile['SCe_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[5]])
                computedProfile['SCe_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[5]])
            ######### DROP #########
            if self.qmc.timeindex[6]:
                computedProfile['DROP_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[6]] - start)
                computedProfile['DROP_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[6]])
                computedProfile['DROP_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[6]])
            ######### COOL #########
            if self.qmc.timeindex[7]:
                computedProfile['COOL_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[7]] - start)
                computedProfile['COOL_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[7]])
                computedProfile['COOL_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[7]])
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### Phases #########
        try:
            # we calculate the statistics here as the profile might not have yet been rendered and thus the statistics are not yet computed
            _,statisticstimes = self.qmc.calcStatistics(TP_index)
            if statisticstimes[0]:
                computedProfile['totaltime'] = aw.float2float(statisticstimes[0],3)
            if statisticstimes[1]:
                computedProfile['dryphasetime'] = aw.float2float(statisticstimes[1],3)
            if statisticstimes[2]:
                computedProfile['midphasetime'] = aw.float2float(statisticstimes[2],3)
            if statisticstimes[3]:
                computedProfile['finishphasetime'] = aw.float2float(statisticstimes[3],3)
            if statisticstimes[4]:
                computedProfile['coolphasetime'] = aw.float2float(statisticstimes[4],3)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### RoR #########
        try:
            if TP_time_idx and DRY_time_idx:
                ror = self.RoR(TP_time_idx,DRY_time_idx)
                computedProfile['dry_phase_ror'] = self.float2float(ror[0])
                computedProfile['mid_phase_ror'] = self.float2float(ror[1])
                computedProfile['finish_phase_ror'] = self.float2float(ror[2])
                if 'TP_BT' in computedProfile and 'TP_time' in computedProfile and 'DROP_BT' in computedProfile and 'DROP_time' in computedProfile and \
                    (computedProfile['DROP_time']-computedProfile['TP_time']) != 0:
                    computedProfile['total_ror'] = self.float2float(((computedProfile['DROP_BT']-computedProfile['TP_BT'])/(computedProfile['DROP_time']-computedProfile['TP_time']))*60.)
                if aw.qmc.timeindex[2] > 0 and aw.qmc.delta2:
                    computedProfile['fcs_ror'] = self.float2float(aw.qmc.delta2[aw.qmc.timeindex[2]])
                computedProfile['dry_phase_delta_temp'] = self.float2float(ror[3])
                computedProfile['mid_phase_delta_temp'] = self.float2float(ror[4])
                computedProfile['finish_phase_delta_temp'] = self.float2float(ror[5])
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### ETBTarea #########
        try:
            ts,tse,tsb,_ = aw.ts(self.qmc.timeindex[0],self.qmc.timeindex[6])
            computedProfile['total_ts'] = self.float2float(ts,0)
            computedProfile['total_ts_ET'] = self.float2float(tse,0)
            computedProfile['total_ts_BT'] = self.float2float(tsb,0)
        except Exception: # pylint: disable=broad-except
            pass
        ######### AUC area #########
        try:
            _,_,tsb,_ = aw.ts()
            computedProfile['AUC'] = self.float2float(tsb,0)
            computedProfile['AUCbegin'] = ''
            computedProfile['AUCbase'] = self.float2float(aw.qmc.AUCbase,0)
            computedProfile['AUCfromeventflag'] = int(aw.qmc.AUCbaseFlag)
            if (aw.qmc.AUCbegin == 0):
                computedProfile['AUCbegin'] = 'CHARGE'
                if aw.qmc.AUCbaseFlag and 'CHARGE_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['CHARGE_BT']
            elif (aw.qmc.AUCbegin == 1):
                computedProfile['AUCbegin'] = 'TP'
                if aw.qmc.AUCbaseFlag and 'TP_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['TP_BT']
            elif (aw.qmc.AUCbegin == 2):
                computedProfile['AUCbegin'] = 'DE'
                if aw.qmc.AUCbaseFlag and 'DRY_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['DRY_BT']
            elif (aw.qmc.AUCbegin == 3):
                computedProfile['AUCbegin'] = 'FCs'
                if aw.qmc.AUCbaseFlag and 'FCs_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['FCs_BT']
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            _,_,ts1b,_ = aw.ts(self.qmc.timeindex[0],DRY_time_idx)
            computedProfile['dry_phase_AUC'] = self.float2float(ts1b,0)
        except Exception: # pylint: disable=broad-except
            pass
        try:
            _,_,ts2b,_ = aw.ts(DRY_time_idx,self.qmc.timeindex[2])
            computedProfile['mid_phase_AUC'] = self.float2float(ts2b,0)
        except Exception: # pylint: disable=broad-except
            pass
        try:
            _,_,ts3b,_ = aw.ts(self.qmc.timeindex[2],self.qmc.timeindex[6])
            computedProfile['finish_phase_AUC'] = self.float2float(ts3b,0)
        except Exception: # pylint: disable=broad-except
            pass
        ######### Weight, Volume, Loss, Gain, Density #########
        try:
            volumein = self.qmc.volume[0]
            volumeout = self.qmc.volume[1]
            weightin = self.qmc.weight[0]
            weightout = self.qmc.weight[1]
            weight_loss = self.weight_loss(weightin,weightout)
            volume_gain = self.volume_increase(volumein,volumeout)
            if weight_loss:
                computedProfile['weight_loss'] = self.float2float(weight_loss)
            if volume_gain:
                computedProfile['volume_gain'] = self.float2float(volume_gain)
            if self.qmc.moisture_greens and self.qmc.moisture_roasted:
                moisture_loss = self.qmc.moisture_greens - self.qmc.moisture_roasted
                computedProfile['moisture_loss'] = self.float2float(moisture_loss)
                if weight_loss:
                    computedProfile['organic_loss'] = self.float2float(weight_loss - moisture_loss)
            din = dout = 0
            # standardize unit of volume and weight to l and g
            if volumein != 0.0:
                volumein = self.float2float(aw.convertVolume(volumein,aw.qmc.volume_units.index(aw.qmc.volume[2]),0),4) # in l
            if volumeout != 0.0:
                volumeout = self.float2float(aw.convertVolume(volumeout,aw.qmc.volume_units.index(aw.qmc.volume[2]),0),4) # in l
            # store volume in l
            computedProfile['volumein'] = volumein
            computedProfile['volumeout'] = volumeout
            # store weight in kg
            if weightin != 0.0:
                weightin = self.float2float(aw.convertWeight(weightin,aw.qmc.weight_units.index(aw.qmc.weight[2]),0),1) # in g
            if weightout != 0.0:
                weightout = self.float2float(aw.convertWeight(weightout,aw.qmc.weight_units.index(aw.qmc.weight[2]),0),1) # in g
            computedProfile['weightin'] = weightin
            computedProfile['weightout'] = weightout
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                din = (weightin / volumein)
                dout = (weightout / volumeout)
            if din > 0.:
                computedProfile['green_density'] = self.float2float(din,1)
            if dout > 0.:
                computedProfile['roasted_density'] = self.float2float(dout,1)

            if (aw.qmc.density[0] != 0.0 and aw.qmc.density[2] != 0.0):
                setdensity = aw.qmc.density[0] /  aw.qmc.density[2]
                setdensity = aw.convertWeight(aw.qmc.density[0],aw.qmc.weight_units.index(aw.qmc.density[1]),0) / aw.convertVolume(aw.qmc.density[2],aw.qmc.volume_units.index(aw.qmc.density[3]),0)
                computedProfile['set_density'] = self.float2float(setdensity,1)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### Humidity / Pressure #########
        try:
            if aw.qmc.moisture_greens != 0.0 and not math.isnan(aw.qmc.moisture_greens):
                computedProfile['moisture_greens'] = self.float2float(aw.qmc.moisture_greens)
            if aw.qmc.moisture_roasted != 0.0 and not math.isnan(aw.qmc.moisture_roasted):
                computedProfile['moisture_roasted'] = self.float2float(aw.qmc.moisture_roasted)
            if aw.qmc.ambient_humidity != 0.0 and not math.isnan(aw.qmc.ambient_humidity):
                computedProfile['ambient_humidity'] = self.float2float(aw.qmc.ambient_humidity)
            if aw.qmc.ambient_pressure != 0.0 and not math.isnan(aw.qmc.ambient_pressure):
                computedProfile['ambient_pressure'] = self.float2float(aw.qmc.ambient_pressure)
            if aw.qmc.ambientTemp != 0.0 and not math.isnan(aw.qmc.ambientTemp):
                computedProfile['ambient_temperature'] = self.float2float(aw.qmc.ambientTemp)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### Similarity #########
        try:
            det,dbt = aw.curveSimilarity()
            if det is not None and not math.isnan(det):
                computedProfile['det'] = det
            if dbt is not None and not math.isnan(dbt):
                computedProfile['dbt'] = dbt
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        ######### Energy Use #########
        try:
            energymetrics,_ = self.qmc.calcEnergyuse()
            if 'BTU_preheat' in energymetrics:
                computedProfile['BTU_preheat'] = self.float2float(energymetrics['BTU_preheat'],1)
            if 'CO2_preheat' in energymetrics:
                computedProfile['CO2_preheat'] = self.float2float(energymetrics['CO2_preheat'],1)
            if 'BTU_bbp' in energymetrics:
                computedProfile['BTU_bbp'] = self.float2float(energymetrics['BTU_bbp'],1)
            if 'CO2_bbp' in energymetrics:
                computedProfile['CO2_bbp'] = self.float2float(energymetrics['CO2_bbp'],1)
            if 'BTU_cooling' in energymetrics:
                computedProfile['BTU_cooling'] = self.float2float(energymetrics['BTU_cooling'],1)
            if 'CO2_cooling' in energymetrics:
                computedProfile['CO2_cooling'] = self.float2float(energymetrics['CO2_cooling'],1)
            if 'BTU_LPG' in energymetrics:
                computedProfile['BTU_LPG'] = self.float2float(energymetrics['BTU_LPG'],1)
            if 'BTU_NG' in energymetrics:
                computedProfile['BTU_NG'] = self.float2float(energymetrics['BTU_NG'],1)
            if 'BTU_ELEC' in energymetrics:
                computedProfile['BTU_ELEC'] = self.float2float(energymetrics['BTU_ELEC'],1)
            if 'BTU_batch' in energymetrics:
                computedProfile['BTU_batch'] = self.float2float(energymetrics['BTU_batch'],1)
            if 'BTU_batch_per_green_kg' in energymetrics:
                computedProfile['BTU_batch_per_green_kg'] = self.float2float(energymetrics['BTU_batch_per_green_kg'],1)
            if 'BTU_roast' in energymetrics:
                computedProfile['BTU_roast'] = self.float2float(energymetrics['BTU_roast'],1)
            if 'BTU_roast_per_green_kg' in energymetrics:
                computedProfile['BTU_roast_per_green_kg'] = self.float2float(energymetrics['BTU_roast_per_green_kg'],1)
            if 'CO2_batch' in energymetrics:
                computedProfile['CO2_batch'] = self.float2float(energymetrics['CO2_batch'],1)
            if 'CO2_batch_per_green_kg' in energymetrics:
                computedProfile['CO2_batch_per_green_kg'] = self.float2float(energymetrics['CO2_batch_per_green_kg'],1)
            if 'CO2_roast' in energymetrics:
                computedProfile['CO2_roast'] = self.float2float(energymetrics['CO2_roast'],1)
            if 'CO2_roast_per_green_kg' in energymetrics:
                computedProfile['CO2_roast_per_green_kg'] = self.float2float(energymetrics['CO2_roast_per_green_kg'],1)
            if 'KWH_batch_per_green_kg' in energymetrics:
                computedProfile['KWH_batch_per_green_kg'] = self.float2float(energymetrics['KWH_batch_per_green_kg'],1)
            if 'KWH_roast_per_green_kg' in energymetrics:
                computedProfile['KWH_roast_per_green_kg'] = self.float2float(energymetrics['KWH_roast_per_green_kg'],1)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        ######### RETURN #########
        return computedProfile

    #used by filesave()
    #wrap values in unicode(.) if and only if those are of type string
    def getProfile(self):
        try:
            profile = {}
            profile['version'] = str(__version__)
            profile['revision'] = str(__revision__)
            profile['build'] = str(__build__)
            os_name,os_version,os_arch = self.get_os()
            profile['artisan_os'] = os_name
            profile['artisan_os_version'] = os_version
            profile['artisan_os_arch'] = os_arch
            profile['mode'] = self.qmc.mode
            profile['viewerMode'] = self.app.artisanviewerMode
            profile['timeindex'] = self.qmc.timeindex
            profile['flavors'] = self.qmc.flavors
            profile['flavorlabels'] = [encodeLocal(fl) for fl in self.qmc.flavorlabels]
            profile['flavorstartangle'] = self.qmc.flavorstartangle
            profile['flavoraspect'] = self.qmc.flavoraspect
            profile['title'] = encodeLocal(self.qmc.title)
            profile['locale'] = self.locale_str

#PLUS
            if self.qmc.plus_store is not None:
                profile['plus_store'] = encodeLocal(self.qmc.plus_store)
                if self.qmc.plus_store_label is not None:
                    profile['plus_store_label'] = encodeLocal(self.qmc.plus_store_label)
            if self.qmc.plus_coffee is not None:
                profile['plus_coffee'] = encodeLocal(self.qmc.plus_coffee)
                if self.qmc.plus_coffee_label is not None:
                    profile['plus_coffee_label'] = encodeLocal(self.qmc.plus_coffee_label)
            if self.qmc.plus_blend_spec is not None:
                # we convert the internal blend dictionary specification to the external list specification
                profile['plus_blend_spec'] = plus.stock.blend2list(self.qmc.plus_blend_spec)
                profile['plus_blend_label'] = encodeLocal(self.qmc.plus_blend_label)
                if self.qmc.plus_blend_spec_labels is not None:
                    profile['plus_blend_spec_labels'] = [encodeLocal(l) for l in self.qmc.plus_blend_spec_labels]

            profile['beans'] = encodeLocal(self.qmc.beans)
            profile['weight'] = [self.qmc.weight[0],self.qmc.weight[1],encodeLocal(self.qmc.weight[2])]
            profile['volume'] = [self.qmc.volume[0],self.qmc.volume[1],encodeLocal(self.qmc.volume[2])]
            profile['density'] = [self.qmc.density[0],encodeLocal(self.qmc.density[1]),self.qmc.density[2],encodeLocal(self.qmc.density[3])]
            profile['density_roasted'] = [self.qmc.density_roasted[0],encodeLocal(self.qmc.density_roasted[1]),self.qmc.density_roasted[2],encodeLocal(self.qmc.density_roasted[3])]
            profile['roastertype'] = encodeLocal(self.qmc.roastertype)
            profile['roastersize'] = self.qmc.roastersize
            profile['roasterheating'] = self.qmc.roasterheating
            profile['machinesetup'] = encodeLocal(self.qmc.machinesetup)
            profile['operator'] = encodeLocal(self.qmc.operator)
            profile['organization'] = encodeLocal(self.qmc.organization)
            profile['drumspeed'] = self.qmc.drumspeed
            profile['heavyFC'] = self.qmc.heavyFC_flag
            profile['lowFC'] = self.qmc.lowFC_flag
            profile['lightCut'] = self.qmc.lightCut_flag
            profile['darkCut'] = self.qmc.darkCut_flag
            profile['drops'] = self.qmc.drops_flag
            profile['oily'] = self.qmc.oily_flag
            profile['uneven'] = self.qmc.uneven_flag
            profile['tipping'] = self.qmc.tipping_flag
            profile['scorching'] = self.qmc.scorching_flag
            profile['divots'] = self.qmc.divots_flag
            profile['whole_color'] = self.qmc.whole_color
            profile['ground_color'] = self.qmc.ground_color
            profile['color_system'] = self.qmc.color_systems[self.qmc.color_system_idx]
            profile['volumeCalcWeightIn'] = str(self.qmc.volumeCalcWeightInStr)
            profile['volumeCalcWeightOut'] = str(self.qmc.volumeCalcWeightOutStr)
            # write roastdate that respects locale and potential cannot be read in under a different locale (just for compatibility to older versions)
            try:
                profile['roastdate'] = encodeLocal(self.qmc.roastdate.date().toString())
            except Exception: # pylint: disable=broad-except
                pass
            # write ISO roast date
            try:
                profile['roastisodate'] = encodeLocal(self.qmc.roastdate.date().toString(Qt.DateFormat.ISODate))
            except Exception: # pylint: disable=broad-except
                pass
            # write roast time
            try:
                profile['roasttime'] = encodeLocal(self.qmc.roastdate.time().toString())
                profile['roastepoch'] = int(self.qmc.roastdate.toSecsSinceEpoch())
                profile['roasttzoffset'] = self.qmc.roasttzoffset
            except Exception: # pylint: disable=broad-except
                pass
            profile['roastbatchnr'] = self.qmc.roastbatchnr
            profile['roastbatchprefix'] = encodeLocal(self.qmc.roastbatchprefix)
            profile['roastbatchpos'] = self.qmc.roastbatchpos
            if self.qmc.roastUUID is None:
                import uuid
                self.qmc.roastUUID = uuid.uuid4().hex # generate UUID
            profile['roastUUID'] = self.qmc.roastUUID
            profile['beansize'] = str(self.qmc.beansize)
            profile['beansize_min'] = str(self.qmc.beansize_min)
            profile['beansize_max'] = str(self.qmc.beansize_max)
            profile['specialevents'] = self.qmc.specialevents
            profile['specialeventstype'] = self.qmc.specialeventstype
            profile['specialeventsvalue'] = self.qmc.specialeventsvalue
            profile['specialeventsStrings'] = [encodeLocal(ses) for ses in self.qmc.specialeventsStrings]
            profile['etypes'] = [encodeLocal(et) for et in self.qmc.etypes]
            profile['roastingnotes'] = encodeLocal(self.qmc.roastingnotes)
            profile['cuppingnotes'] = encodeLocal(self.qmc.cuppingnotes)
            profile['timex'] = [self.float2float(x,10) for x in self.qmc.timex]
            profile['temp1'] = [self.float2float(x,8) for x in self.qmc.temp1]
            profile['temp2'] = [self.float2float(x,8) for x in self.qmc.temp2]
            profile['phases'] = self.qmc.phases
            profile['zmax'] = int(self.qmc.zlimit)
            profile['zmin'] = int(self.qmc.zlimit_min)
            profile['ymax'] = int(self.qmc.ylimit)
            profile['ymin'] = int(self.qmc.ylimit_min)
            profile['xmin'] = float(self.qmc.startofx)
            profile['xmax'] = float(self.qmc.endofx)
            profile['ambientTemp'] = self.qmc.ambientTemp
            profile['ambient_humidity'] = self.qmc.ambient_humidity
            profile['ambient_pressure'] = self.qmc.ambient_pressure
            profile['moisture_greens'] = self.qmc.moisture_greens
            profile['greens_temp'] = self.qmc.greens_temp
            profile['moisture_roasted'] = self.qmc.moisture_roasted
            profile['extradevices'] = self.qmc.extradevices
            profile['extraname1'] = [encodeLocal(n) for n in self.qmc.extraname1]
            profile['extraname2'] = [encodeLocal(n) for n in self.qmc.extraname2]
            profile['extratimex'] = [[self.float2float(t,10) for t in x] for x in self.qmc.extratimex]
            profile['extratemp1'] = [[self.float2float(t,8) for t in x] for x in self.qmc.extratemp1]
            profile['extratemp2'] = [[self.float2float(t,8) for t in x] for x in self.qmc.extratemp2]
            profile['extramathexpression1'] = [encodeLocal(x) for x in self.qmc.extramathexpression1]
            profile['extramathexpression2'] = [encodeLocal(x) for x in self.qmc.extramathexpression2]
            profile['extradevicecolor1'] = [encodeLocal(x) for x in self.qmc.extradevicecolor1]
            profile['extradevicecolor2'] = [encodeLocal(x) for x in self.qmc.extradevicecolor2]
            profile['extraLCDvisibility1']     = aw.extraLCDvisibility1
            profile['extraLCDvisibility2']     = aw.extraLCDvisibility2
            profile['extraCurveVisibility1']   = aw.extraCurveVisibility1
            profile['extraCurveVisibility2']   = aw.extraCurveVisibility2
            profile['extraDelta1']             = aw.extraDelta1
            profile['extraDelta2']             = aw.extraDelta2
            profile['extraFill1']              = aw.extraFill1
            profile['extraFill2']              = aw.extraFill2
            profile['extramarkersizes1'] = self.qmc.extramarkersizes1
            profile['extramarkersizes2'] = self.qmc.extramarkersizes2
            profile['extramarkers1'] = [encodeLocal(x) for x in self.qmc.extramarkers1]
            profile['extramarkers2'] = [encodeLocal(x) for x in self.qmc.extramarkers2]
            profile['extralinewidths1'] = self.qmc.extralinewidths1
            profile['extralinewidths2'] = self.qmc.extralinewidths2
            profile['extralinestyles1'] = [encodeLocal(x) for x in self.qmc.extralinestyles1]
            profile['extralinestyles2'] = [encodeLocal(x) for x in self.qmc.extralinestyles2]
            profile['extradrawstyles1'] = [encodeLocal(x) for x in self.qmc.extradrawstyles1]
            profile['extradrawstyles2'] = [encodeLocal(x) for x in self.qmc.extradrawstyles2]
            profile['externalprogram'] = encodeLocal(self.ser.externalprogram)
            profile['externaloutprogram'] = encodeLocal(self.ser.externaloutprogram)
            profile['extraNoneTempHint1'] = self.qmc.extraNoneTempHint1
            profile['extraNoneTempHint2'] = self.qmc.extraNoneTempHint2
            #alarms
            profile['alarmsetlabel'] = self.qmc.alarmsetlabel
            profile['alarmflag'] = self.qmc.alarmflag
            profile['alarmguard'] = self.qmc.alarmguard
            profile['alarmnegguard'] = self.qmc.alarmnegguard
            profile['alarmtime'] = self.qmc.alarmtime
            profile['alarmoffset'] = self.qmc.alarmoffset
            profile['alarmcond'] = self.qmc.alarmcond
            profile['alarmsource'] = self.qmc.alarmsource
            profile['alarmtemperature'] = self.qmc.alarmtemperature
            profile['alarmaction'] = self.qmc.alarmaction
            profile['alarmbeep'] = self.qmc.alarmbeep
            profile['alarmstrings'] = [encodeLocal(x) for x in self.qmc.alarmstrings]
            # remember background profile path and UUID
            profile['backgroundpath'] = encodeLocal(self.qmc.backgroundpath)
            if self.qmc.backgroundUUID is not None:
                profile['backgroundUUID'] = self.qmc.backgroundUUID
            #write only:
            profile['samplinginterval'] = self.qmc.profile_sampling_interval
            profile['svLabel'] = aw.pidcontrol.svLabel
            profile['svValues'] = aw.pidcontrol.svValues
            profile['svRamps'] = aw.pidcontrol.svRamps
            profile['svSoaks'] = aw.pidcontrol.svSoaks
            profile['svActions'] = aw.pidcontrol.svActions
            profile['svBeeps'] = aw.pidcontrol.svBeeps
            profile['svDescriptions'] = aw.pidcontrol.svDescriptions
            try:
                ds = list(self.qmc.extradevices)
                ds.insert(0,self.qmc.device)
                profile['devices'] = [('PID' if d==0 else self.qmc.devices[d-1]) for d in ds]
            except Exception: # pylint: disable=broad-except
                pass
            profile['elevation'] = self.qmc.elevation
            profile['computed'] = self.computedProfileInformation()
            # add positions of main event annotations and custom event flags
            profile['anno_positions'] = self.qmc.getAnnoPositions()
            profile['flag_positions'] = self.qmc.getFlagPositions()
            if self.qmc.legend is not None and not isinstance(self.qmc.legend._loc, int): # pylint: disable=protected-access
                # if a legend is currently drawn and has a custom position we save its position in data coordinates
                try:
                    axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                    profile['legendloc_pos'] = axis_to_data.transform(self.qmc.legend._loc).tolist() # pylint: disable=protected-access
                except Exception: # pylint: disable=broad-except
                    pass

            # Energy Settings
            try:
                profile['loadlabels'] = self.qmc.loadlabels
                profile['loadratings'] = self.qmc.loadratings
                profile['ratingunits'] = self.qmc.ratingunits
                profile['sourcetypes'] = self.qmc.sourcetypes
                profile['load_etypes'] = self.qmc.load_etypes
                profile['presssure_percents'] = self.qmc.presssure_percents
                profile['loadevent_zeropcts'] = self.qmc.loadevent_zeropcts
                profile['loadevent_hundpcts'] = self.qmc.loadevent_hundpcts
                profile['preheatDuration'] = self.qmc.preheatDuration
                profile['preheatenergies'] = self.qmc.preheatenergies
                profile['betweenbatchDuration'] = self.qmc.betweenbatchDuration
                profile['betweenbatchenergies'] = self.qmc.betweenbatchenergies
                profile['coolingDuration'] = self.qmc.coolingDuration
                profile['coolingenergies'] = self.qmc.coolingenergies
                profile['betweenbatch_after_preheat'] = self.qmc.betweenbatch_after_preheat
                profile['electricEnergyMix'] = self.qmc.electricEnergyMix
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' getProfile(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))


            return profile
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' getProfile(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return None

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_current_action(self,_=False):
        self.fileSave(self.curFile)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_new_action(self,_=False):
        self.fileSave(None)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_copy_action(self,_=False):
        self.fileSave(None,copy=True)

    #saves recorded profile in hard drive. Called from file menu
    # returns True if file was saved successfully
    # if copy is True, a new UUID is generated to be saved along the file
    def fileSave(self,fname,copy=False):
        try:
            filename = fname
            if not filename:
                path = QDir()
                path.setPath(self.getDefaultPath())
                if aw.qmc.batchcounter > -1 and aw.qmc.roastbatchnr > 0 and self.qmc.autosaveprefix == '':
                    prefix = aw.qmc.batchprefix + str(aw.qmc.roastbatchnr)
                else:
                    prefix = self.qmc.autosaveprefix
                fname = path.absoluteFilePath(self.generateFilename(prefix=prefix))
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Profile'), path=fname)
            if filename:
                #write
                pf = self.getProfile()
                if pf:
                    # if the copy flag is set, we generate a new roastUUID
                    if copy:
                        import uuid
                        pf['roastUUID'] = uuid.uuid4().hex # generate UUID

                    sync_record_hash = plus.controller.updateSyncRecordHashAndSync()
                    if sync_record_hash is not None:
                        # we add the hash over the sync record to be able to detect offline changes
                        pf['plus_sync_record_hash'] = encodeLocal(sync_record_hash)

                    # we save the file and set the filename
                    self.serialize(filename,pf)
                    self.sendmessage(QApplication.translate('Message','Profile saved'))
                    _log.info('profile saved: %s', filename)
                    if not copy:
                        self.setCurrentFile(filename)
                        aw.curFile = filename
                        self.qmc.fileCleanSignal.emit()

                    # update plus data set modification date
                    self.qmc.plus_file_last_modified = plus.util.getModificationDate(filename)

                    if self.qmc.autosaveimage:
                        #
                        if QFileInfo(filename).suffix() == 'alog':
                            name_also = QFileInfo(filename).completeBaseName()
                        else:
                            name_also = QFileInfo(filename).fileName()
                        path_also = QDir()
                        if self.qmc.autosavealsopath != '':
                            path_also.setPath(self.qmc.autosavealsopath)
                        else:
                            path_also.setPath(QFileInfo(filename).path())
                        filename_also = path_also.absoluteFilePath(name_also)
                        if self.qmc.autosaveimageformat == 'PDF':
                            self.saveVectorGraph(extension='.pdf',fname=filename_also)
                        elif self.qmc.autosaveimageformat == 'SVG':
                            self.saveVectorGraph(extension='.svg',fname=filename_also)
                        elif self.qmc.autosaveimageformat == 'CSV':
                            self.exportCSV(filename_also + '.csv')
                        elif self.qmc.autosaveimageformat == 'JSON':
                            self.exportJSON(filename_also + '.json')
                        else:
                            self.resizeImgToSize(0,0,self.qmc.autosaveimageformat,fname=filename_also)
                    return True
                self.sendmessage(QApplication.translate('Message','Cancelled'))
                return False
            self.sendmessage(QApplication.translate('Message','Cancelled'))
            return False
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' filesave(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return False

    def fileExport(self,msg,ext,dumper):
        try:
            filename = self.ArtisanSaveFileDialog(msg=msg,ext=ext)
            if filename:
                res = dumper(filename)
                if res:
                    self.sendmessage(QApplication.translate('Message','Readings exported'))
            else:
                self.sendmessage(QApplication.translate('Message','Cancelled'))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' fileExport(): {0}').format(str(ex)))
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportExcel(self):
        self.fileExport(QApplication.translate('Message', 'Export Excel'),'*.xlsx',self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportCSV(self):
        self.fileExport(QApplication.translate('Message', 'Export CSV'),'*.csv',self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportJSON(self,_=False):
        self.fileExport(QApplication.translate('Message', 'Export JSON'),'*.json',self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportRoastLogger(self,_=False):
        self.fileExport(QApplication.translate('Message', 'Export RoastLogger'),'*.csv',self.exportRoastLogger)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportPilot(self,_=False):
        self.fileExport(QApplication.translate('Message', 'Export Probat Pilot'),'*.xml',self.exportPilot)

    def fileConvert(self,ext,dumper):
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                self.saveExtradeviceSettings()
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate('Message', 'Converting...'), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname + str(ext)))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=True)
                            aw.qmc.redraw() # we need to redraw to ensure populated delta lines
                            dumper(fconv)
                        else:
                            aw.sendmessage(QApplication.translate('Message','Target file {0} exists. {1} not converted.').format(fconv,fname + str(ext)))
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    aw.qmc.fileCleanSignal.emit()
                    aw.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile,quiet=True)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertExcel(self):
        self.fileConvert('.xlsx',self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertCSV(self,_=False):
        self.fileConvert('.csv',self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJSON(self,_=False):
        self.fileConvert('.json',self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertRoastLogger(self,_=False):
        self.fileConvert('.csv',self.exportRoastLogger)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPilot(self,_=False):
        self.fileConvert('.xml',self.exportPilot)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPNG(self,_=False):
        self.fileConvertBITMAP('PNG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJPEG(self,_=False):
        self.fileConvertBITMAP('JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertBMP(self,_=False):
        self.fileConvertBITMAP('BMP')

    def fileConvertBITMAP(self,filetype='PNG'):
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                self.saveExtradeviceSettings()
                fileext = '.png'
                if filetype == 'JPEG':
                    fileext = '.jpg'
                elif filetype == 'BMP':
                    fileext = '.bmp'
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate('Message', 'Converting...'), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname + str(fileext)))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=False)
                            self.qmc.redraw()
                            image = aw.qmc.grab()
                            if filetype in ['JPEG','BMP','PNG']:
                                # transparences are not supported by those file types and are rendered in black by default.
                                white_img = QPixmap(image.size())
                                white_img.fill() # fills by default with Qt.GlobalColor.white
                                painter = QPainter(white_img)
                                painter.drawPixmap(0,0,image.width(),image.height(),image)
                                image = white_img
                                painter.end()
                                del painter
                            image.save(fconv,filetype)
                        else:
                            aw.sendmessage(QApplication.translate('Message','Target file {0} exists. {1} not converted.').format(fconv,fname + str(fileext)))
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    aw.qmc.fileCleanSignal.emit()
                    aw.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile, quiet=True)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None

    @pyqtSlot()
    def fileConvertSVG(self):
        self.fileConvertIMG('.svg')

    @pyqtSlot()
    def fileConvertPDF(self):
        self.fileConvertIMG('.pdf')

    @pyqtSlot()
    def fileConvertReportPDF(self):
        self.fileConvertReport('.pdf')

    def fileConvertReport(self,ext):
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            self.saveExtradeviceSettings()
            outdir = self.ArtisanExistingDirectoryDialog()
            progress = QProgressDialog(QApplication.translate('Message', 'Converting...'), None, 0, len(files), self)
            progress.setCancelButton(None)
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setAutoClose(True)
            progress.show()
            i = 1
            flag_temp = aw.qmc.roastpropertiesflag
            for f in files:
                try:
                    progress.setValue(i)
                    QApplication.processEvents()
                    fname = str(QFileInfo(f).fileName())
                    fconv = str(QDir(outdir).filePath(fname + str(ext)))
                    if not os.path.exists(fconv):
                        aw.qmc.reset(redraw=False,soundOn=False)
                        self.setProfile(f,self.deserialize(f),quiet=True)
                        self.qmc.redraw()
                        self.roastReport(pdf_filename=fconv, batch_process=True)
                    else:
                        aw.sendmessage(QApplication.translate('Message','Target file {0} exists. {1} not converted.').format(fconv,fname + str(ext)))
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                i += 1
                aw.qmc.fileCleanSignal.emit()
                aw.qmc.reset(soundOn=False)
                self.restoreExtradeviceSettings()
            self.releaseQWebEngineView()
            if loaded_profile:
                self.loadFile(loaded_profile, quiet=True)
            aw.qmc.roastpropertiesflag = flag_temp
            progress.cancel()
            progress = None

    def fileConvertIMG(self,ext):
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            self.saveExtradeviceSettings()
            outdir = self.ArtisanExistingDirectoryDialog()
            progress = QProgressDialog(QApplication.translate('Message', 'Converting...'), None, 0, len(files), self)
            progress.setCancelButton(None)
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setAutoClose(True)
            progress.show()
            i = 1
            flag_temp = aw.qmc.roastpropertiesflag
            for f in files:
                try:
                    progress.setValue(i)
                    QApplication.processEvents()
                    fname = str(QFileInfo(f).fileName())
                    fconv = str(QDir(outdir).filePath(fname + str(ext)))
                    if not os.path.exists(fconv):
                        aw.qmc.reset(redraw=False,soundOn=False)
                        self.setProfile(f,self.deserialize(f),quiet=True)
                        self.qmc.redraw()
                        aw.qmc.fig.savefig(fconv,transparent=True,facecolor='none', edgecolor='none') # transparent=True is need to get the delta curves and legend drawn
                    else:
                        aw.sendmessage(QApplication.translate('Message','Target file {0} exists. {1} not converted.').format(fconv,fname + str(ext)))
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                i += 1
                aw.qmc.fileCleanSignal.emit()
                aw.qmc.reset(soundOn=False)
                self.restoreExtradeviceSettings()
            if loaded_profile:
                self.loadFile(loaded_profile, quiet=True)
            aw.qmc.roastpropertiesflag = flag_temp
            progress.cancel()
            progress = None

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToFahrenheit(self,_=False):
        self.fileConverToTemp('F')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToCelsius(self,_=False):
        self.fileConverToTemp('C')

    def fileConverToTemp(self,t):
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            self.saveExtradeviceSettings()
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate('Message', 'Converting...'), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=True)
                            aw.qmc.convertTemperature(t,True)
                            aw.fileSave(fconv)
                        else:
                            aw.sendmessage(QApplication.translate('Message','Target file {0} exists. {1} not converted.').format(fconv,fname))
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    aw.qmc.fileCleanSignal.emit()
                    aw.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile,quiet=True)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None

    def fileImport(self,msg,loader,reset=False,ext='*'):
        try:
            filename = self.ArtisanOpenFileDialog(msg=msg,ext=ext)
            if filename:
                if reset:
                    res = aw.qmc.reset(True,False)
                else:
                    res = True
                if res:
                    loader(filename)
                    self.sendmessage(QApplication.translate('Message','Readings imported'))
                    return
            self.sendmessage(QApplication.translate('Message','Cancelled'))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' fileImport(): {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def artisanURLextractor(url, _):
        import requests
        r = requests.get(url.toString(),
            allow_redirects=True,
            timeout=(4, 15),
            headers={'Accept-Encoding' : 'gzip'},
#            verify=False
            )
        return ast.literal_eval(r.text)

    @pyqtSlot()
    @pyqtSlot(bool)
    def urlImport(self,_=False):
        try:
            self.importExternalURL(self.artisanURLextractor,QApplication.translate('Message','Import Artisan URL'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportCSV(self,_=False):
        self.fileImport(QApplication.translate('Message', 'Import CSV'),self.importCSV,True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportJSON(self,_=False):
        self.fileImport(QApplication.translate('Message', 'Import JSON'),self.importJSON,True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportRoastLogger(self,_=False):
        self.fileImport(QApplication.translate('Message', 'Import RoastLogger'),self.importRoastLogger,True)

    #loads the settings at the start of application. See the oppposite closeEventSettings()
    def settingsLoad(self, filename=None, theme=False, machine=False, redraw=True):
        res = False
        try:
            updateBatchCounter = True
            if filename is not None:
                settings = QSettings(filename,QSettings.Format.IniFormat)

                # a proper artisan-settings.aset file needs at least to contain a Mode tag
                if not (theme or machine) and not settings.contains('Mode'):
                    aw.qmc.adderror(QApplication.translate('Error Message','Exception: {} not a valid settings file').format(str(filename)))
                    return False

                if aw.qmc.neverUpdateBatchCounter or app.artisanviewerMode:
                    updateBatchCounter = False
                else:
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        files_batchcounter = toInt(settings.value('batchcounter',aw.qmc.batchcounter))
                        if files_batchcounter != aw.qmc.batchcounter:
                            current_counter = str(aw.qmc.batchcounter)
                            files_counter = str(files_batchcounter)
                            if aw.qmc.batchcounter < 0:
                                string = QApplication.translate('Message','Your batch counter is currently turned off. Turn it on and set it to %s from the settings file to be imported?'%(files_counter))
                            elif files_batchcounter < 0:
                                string = QApplication.translate('Message','Your batch counter is set to %s. Turn it off as in the settings file to be imported?'%(current_counter))
                            else:
                                string = QApplication.translate('Message','Overwrite your current batch counter %s by %s from the settings file to be imported?'%(current_counter,files_counter))
                            reply = QMessageBox.question(aw,QApplication.translate('Message','Batch Counter'),string,
                                    QMessageBox.StandardButton.Cancel |QMessageBox.StandardButton.No|QMessageBox.StandardButton.Yes)
                            if reply == QMessageBox.StandardButton.Cancel:
                                aw.sendmessage(QApplication.translate('Message','Load Settings canceled'))
                                return False
                            if reply == QMessageBox.StandardButton.No:
                                updateBatchCounter = False
                            updateBatchCounter = True
                    settings.endGroup()
                self.clearExtraDeviceSettingsBackup() # on explicit settings load we remove the ExtraDeviceBackup to prevent later restoreExtraDeviceSettingsBackup()
            else:
                settings = QSettings()
            if settings.contains('resetqsettings'):
                self.resetqsettings = toInt(settings.value('resetqsettings',self.resetqsettings))
                if self.resetqsettings:
                    self.resetqsettings = 0
                    if 'canvas' in aw.qmc.palette:
                        aw.updateCanvasColors(checkColors=False)
                    # remove window geometry and splitter settings
                    for s in ['BlendGeometry','RoastGeometry','FlavorProperties','CalculatorGeometry','EventsGeometry', 'CompareGeometry',
                        'BackgroundGeometry','LCDGeometry','DeltaLCDGeometry','ExtraLCDGeometry','PhasesLCDGeometry','AlarmsGeometry','DeviceAssignmentGeometry','PortsGeometry',
                        'TransformatorPosition', 'CurvesPosition', 'StatisticsPosition', 'AxisPosition','PhasesPosition', 'BatchPosition',
                        'SamplingPosition', 'autosaveGeometry', 'PIDPosition', 'DesignerPosition','PIDLCDGeometry','ScaleLCDGeometry', 'MainSplitter']:
                        settings.remove(s)
                    #
                    aw.setFonts()
                    self.qmc.redraw()
                    try:
                        self.updateNewMenuRecentRoasts()
                    except Exception: # pylint: disable=broad-except
                        pass
                    _log.info('Factory reset')
                    return True  #don't load any more settings. They could be bad (corrupted). Stop here.

            # we remember from which location we loaded the last settings file
            # to be able to update the batch counter in this file from incBatchCounter()/decBatchCounter()
            # but not for loading of settings fragments like themes or machines
            if filename:
                if updateBatchCounter:
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        self.settingspath = filename
                    else:
                        self.settingspath = ''
                    settings.endGroup()
                else:
                    self.settingspath = ''
            else:
                # the neverUpdateBatchCounter flag is never changed on loading a settings file!
                settings.beginGroup('Batch')
                if settings.contains('neverUpdateBatchCounter'):
                    aw.qmc.neverUpdateBatchCounter = toBool(settings.value('neverUpdateBatchCounter',aw.qmc.neverUpdateBatchCounter))
                settings.endGroup()

            if filename is None and settings.contains('fullscreen'):
                self.full_screen_mode_active = bool(toBool(settings.value('fullscreen',self.full_screen_mode_active)))

            if filename is None and settings.contains('plus_account'):
                self.plus_account = settings.value('plus_account',self.plus_account)
                if settings.contains('plus_remember_credentials'):
                    self.plus_remember_credentials = bool(toBool(settings.value('plus_remember_credentials',self.plus_remember_credentials)))
                if settings.contains('plus_email'):
                    self.plus_email = settings.value('plus_email',self.plus_email)
                if settings.contains('plus_language'):
                    self.plus_language = settings.value('plus_language',self.plus_language)

            #remember swaplcds and swapdeltalcds
            old_swaplcds = self.qmc.swaplcds
            old_swapdeltalcds = self.qmc.swapdeltalcds
            #restore mode
            old_mode = self.qmc.mode
            self.qmc.mode = str(settings.value('Mode',self.qmc.mode))
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == 'F' and old_mode == 'C':
                self.qmc.fahrenheitMode()
            if self.qmc.mode == 'C' and old_mode == 'F':
                self.qmc.celsiusMode()

            if filename is None and settings.contains('DebugLogLevel'):
                try:
                    setDebugLogLevel(bool(toBool(settings.value('DebugLogLevel',False))))
                except Exception: # pylint: disable=broad-except
                    pass

            #restore device
            settings.beginGroup('Device')
            if filename is None and settings.contains('device_logging'):
                self.qmc.device_logging = bool(toBool(settings.value('device_logging',self.qmc.device_logging)))
                try:
                    setDeviceDebugLogLevel(self.aw.qmc.device_logging)
                except Exception: # pylint: disable=broad-except
                    pass
            if settings.contains('id'):
                self.qmc.device = toInt(settings.value('id',self.qmc.device))
            # Phidget configurations
            if settings.contains('phidget1048_types'):
                self.qmc.phidget1048_types = [toInt(x) for x in toList(settings.value('phidget1048_types',self.qmc.phidget1048_types))]
            if settings.contains('phidget1048_async'):
                self.qmc.phidget1048_async = [bool(toBool(x)) for x in toList(settings.value('phidget1048_async',self.qmc.phidget1048_async))]
                self.qmc.phidget1048_changeTriggers = [aw.float2float(toFloat(x)) for x in toList(settings.value('phidget1048_changeTriggers',self.qmc.phidget1048_changeTriggers))]
            if settings.contains('phidget1048_dataRate'):
                self.qmc.phidget1048_dataRate = toInt(settings.value('phidget1048_dataRate',self.qmc.phidget1048_dataRate))
            if settings.contains('phidget1046_gain'):
                self.qmc.phidget1046_gain = [toInt(x) for x in toList(settings.value('phidget1046_gain',self.qmc.phidget1046_gain))]
            if settings.contains('phidget1046_formula'):
                self.qmc.phidget1046_formula = [toInt(x) for x in toList(settings.value('phidget1046_formula',self.qmc.phidget1046_formula))]
            if settings.contains('phidget1046_async'):
                self.qmc.phidget1046_async = [bool(toBool(x)) for x in toList(settings.value('phidget1046_async',self.qmc.phidget1046_async))]
            if settings.contains('phidget1046_dataRate'):
                self.qmc.phidget1046_dataRate = toInt(settings.value('phidget1046_dataRate',self.qmc.phidget1046_dataRate))
            if settings.contains('phidget1045_async'):
                self.qmc.phidget1045_async = bool(toBool(settings.value('phidget1045_async',self.qmc.phidget1045_async)))
                self.qmc.phidget1045_changeTrigger = aw.float2float(toFloat(settings.value('phidget1045_changeTrigger',self.qmc.phidget1045_changeTrigger)))
            if settings.contains('phidget1045_emissivity'):
                self.qmc.phidget1045_emissivity = toFloat(settings.value('phidget1045_emissivity',self.qmc.phidget1045_emissivity))
            if settings.contains('phidget1045_dataRate'):
                self.qmc.phidget1045_dataRate = toInt(settings.value('phidget1045_dataRate',self.qmc.phidget1045_dataRate))
            if settings.contains('phidget1200_formula'):
                self.qmc.phidget1200_formula = toInt(settings.value('phidget1200_formula',self.qmc.phidget1200_formula))
                self.qmc.phidget1200_wire = toInt(settings.value('phidget1200_wire',self.qmc.phidget1200_wire))
                self.qmc.phidget1200_async = bool(toBool(settings.value('phidget1200_async',self.qmc.phidget1200_async)))
                self.qmc.phidget1200_changeTrigger = aw.float2float(toFloat(settings.value('phidget1200_changeTrigger',self.qmc.phidget1200_changeTrigger)))
                self.qmc.phidget1200_dataRate = toInt(settings.value('phidget1200_dataRate',self.qmc.phidget1200_dataRate))
            if settings.contains('phidget1200_2_formula'):
                self.qmc.phidget1200_2_formula = toInt(settings.value('phidget1200_2_formula',self.qmc.phidget1200_2_formula))
                self.qmc.phidget1200_2_wire = toInt(settings.value('phidget1200_2_wire',self.qmc.phidget1200_2_wire))
                self.qmc.phidget1200_2_async = bool(toBool(settings.value('phidget1200_2_async',self.qmc.phidget1200_2_async)))
                self.qmc.phidget1200_2_changeTrigger = aw.float2float(toFloat(settings.value('phidget1200_2_changeTrigger',self.qmc.phidget1200_2_changeTrigger)))
                self.qmc.phidget1200_2_dataRate = toInt(settings.value('phidget1200_2_dataRate',self.qmc.phidget1200_2_dataRate))
            if settings.contains('phidgetDAQ1400_powerSupply'):
                self.qmc.phidgetDAQ1400_powerSupply = toInt(settings.value('phidgetDAQ1400_powerSupply',self.qmc.phidgetDAQ1400_powerSupply))
                self.qmc.phidgetDAQ1400_inputMode = toInt(settings.value('phidgetDAQ1400_inputMode',self.qmc.phidgetDAQ1400_inputMode))
            if settings.contains('phidgetRemoteFlag'):
                self.qmc.phidgetRemoteFlag = bool(toBool(settings.value('phidgetRemoteFlag',self.qmc.phidgetRemoteFlag)))
                self.qmc.phidgetServerID = toString(settings.value('phidgetServerID',self.qmc.phidgetServerID))
                self.qmc.phidgetPassword = toString(settings.value('phidgetPassword',self.qmc.phidgetPassword))
                if settings.contains('phidgetPort'):
                    self.qmc.phidgetPort = toInt(settings.value('phidgetPort',self.qmc.phidgetPort))
                if settings.contains('phidgetRemoteOnlyFlag'):
                    self.qmc.phidgetRemoteOnlyFlag = bool(toBool(settings.value('phidgetRemoteOnlyFlag',self.qmc.phidgetRemoteOnlyFlag)))
            if settings.contains('phidget1018_async'):
                self.qmc.phidget1018_async = [bool(toBool(x)) for x in toList(settings.value('phidget1018_async',self.qmc.phidget1018_async))]
                self.qmc.phidget1018_dataRates = [toInt(x) for x in toList(settings.value('phidget1018_dataRates',self.qmc.phidget1018_dataRates))]
                self.qmc.phidget1018_changeTriggers = [toInt(x) for x in toList(settings.value('phidget1018_changeTriggers',self.qmc.phidget1018_changeTriggers))]
            if settings.contains('phidget1018_ratio'):
                self.qmc.phidget1018_ratio = [bool(toBool(x)) for x in toList(settings.value('phidget1018_ratio',self.qmc.phidget1018_ratio))]
            if settings.contains('phidgetVCP100x_voltageRanges'):
                self.qmc.phidgetVCP100x_voltageRanges = [toInt(x) for x in toList(settings.value('phidgetVCP100x_voltageRanges',self.qmc.phidgetVCP100x_voltageRanges))]
            if settings.contains('PIDbuttonflag'):
                self.qmc.PIDbuttonflag = bool(toBool(settings.value('PIDbuttonflag',self.qmc.PIDbuttonflag)))
            if settings.contains('Controlbuttonflag'):
                self.qmc.Controlbuttonflag = bool(toBool(settings.value('Controlbuttonflag',self.qmc.Controlbuttonflag)))
            if settings.contains('yoctoRemoteFlag'):
                self.qmc.yoctoRemoteFlag = bool(toBool(settings.value('yoctoRemoteFlag',self.qmc.yoctoRemoteFlag)))
                self.qmc.yoctoServerID = toString(settings.value('yoctoServerID',self.qmc.yoctoServerID))
            if settings.contains('YOCTO_emissivity'):
                self.qmc.YOCTO_emissivity = toFloat(settings.value('YOCTO_emissivity',self.qmc.YOCTO_emissivity))
            if settings.contains('YOCTO_async'):
                self.qmc.YOCTO_async = [bool(toBool(x)) for x in toList(settings.value('YOCTO_async',self.qmc.YOCTO_async))]
            if settings.contains('YOCTO_dataRate'):
                self.qmc.YOCTO_dataRate = toInt(settings.value('YOCTO_dataRate',self.qmc.YOCTO_dataRate))
            if settings.contains('ambient_temperature_device'):
                self.qmc.ambient_temperature_device = toInt(settings.value('ambient_temperature_device',self.qmc.ambient_temperature_device))
                self.qmc.ambient_humidity_device = toInt(settings.value('ambient_humidity_device',self.qmc.ambient_humidity_device))
                self.qmc.ambient_pressure_device = toInt(settings.value('ambient_pressure_device',self.qmc.ambient_pressure_device))
                self.qmc.elevation = toInt(settings.value('elevation',self.qmc.elevation))
            # activate CONTROL BUTTON
            aw.showControlButton()
            if settings.contains('controlETpid'):
                self.ser.controlETpid = [toInt(x) for x in toList(settings.value('controlETpid',self.ser.controlETpid))]
            if settings.contains('readBTpid'):
                self.ser.readBTpid = [toInt(x) for x in toList(settings.value('readBTpid',self.ser.readBTpid))]
            if settings.contains('arduinoETChannel'):
                self.ser.arduinoETChannel = s2a(toString(settings.value('arduinoETChannel',self.ser.arduinoETChannel)))
            if settings.contains('arduinoBTChannel'):
                self.ser.arduinoBTChannel = s2a(toString(settings.value('arduinoBTChannel',self.ser.arduinoBTChannel)))
            if settings.contains('arduinoATChannel'):
                self.ser.arduinoATChannel = s2a(toString(settings.value('arduinoATChannel',self.ser.arduinoATChannel)))
            if settings.contains('ArduinoFILT'):
                self.ser.ArduinoFILT = [toInt(x) for x in toList(settings.value('ArduinoFILT',self.ser.ArduinoFILT))]
            if settings.contains('useModbusPort'):
                self.ser.useModbusPort = bool(toBool(settings.value('useModbusPort',self.ser.useModbusPort)))
            if settings.contains('showFujiLCDs'):
                self.ser.showFujiLCDs = bool(toBool(settings.value('showFujiLCDs',self.ser.showFujiLCDs)))
            settings.endGroup()
            #restore x,y formatting mode
            if settings.contains('fmt_data_RoR'):
                self.qmc.fmt_data_RoR = bool(toBool(settings.value('fmt_data_RoR',self.qmc.fmt_data_RoR)))
            if settings.contains('fmt_data_ON'):
                self.qmc.fmt_data_ON = bool(toBool(settings.value('fmt_data_ON',self.qmc.fmt_data_ON)))
            if settings.contains('fmt_data_curve'):
                self.qmc.fmt_data_curve = toInt(settings.value('fmt_data_curve',self.qmc.fmt_data_curve))
            #restore playback aid
            if settings.contains('detectBackgroundEventTime'):
                self.qmc.detectBackgroundEventTime = toInt(settings.value('detectBackgroundEventTime',self.qmc.detectBackgroundEventTime))
            if settings.contains('backgroundReproduce'):
                self.qmc.backgroundReproduce = bool(toBool(settings.value('backgroundReproduce',self.qmc.backgroundReproduce)))
            if settings.contains('backgroundReproduceBeep'):
                self.qmc.backgroundReproduceBeep = bool(toBool(settings.value('backgroundReproduceBeep',self.qmc.backgroundReproduceBeep)))
            if settings.contains('backgroundPlaybackEvents'):
                self.qmc.backgroundPlaybackEvents = bool(toBool(settings.value('backgroundPlaybackEvents',self.qmc.backgroundPlaybackEvents)))
            if settings.contains('backgroundPlaybackDROP'):
                self.qmc.backgroundPlaybackDROP = bool(toBool(settings.value('backgroundPlaybackDROP',self.qmc.backgroundPlaybackDROP)))
            if settings.contains('replayType'):
                aw.qmc.replayType = toInt(settings.value('replayType',aw.qmc.replayType))
            if settings.contains('specialeventplaybackaid'):
                self.qmc.specialeventplaybackaid = [toBool(x) for x in toList(settings.value('specialeventplaybackaid'))]
            if settings.contains('specialeventplayback'):
                self.qmc.specialeventplayback = [toBool(x) for x in toList(settings.value('specialeventplayback'))]
            #restore phases
            if settings.contains('Phases'):
                self.qmc.phases = [toInt(x) for x in toList(settings.value('Phases',self.qmc.phases))]
            if settings.contains('phasesbuttonflag'):
                self.qmc.phasesbuttonflag = bool(toBool(settings.value('phasesbuttonflag',self.qmc.phasesbuttonflag)))
            if settings.contains('phasesfromBackgroundflag'):
                self.qmc.phasesfromBackgroundflag = bool(toBool(settings.value('phasesfromBackgroundflag',self.qmc.phasesfromBackgroundflag)))
            if settings.contains('watermarks'):
                self.qmc.watermarksflag = bool(toBool(settings.value('watermarks',self.qmc.watermarksflag)))
            if settings.contains('phasesLCDs'):
                self.qmc.phasesLCDflag = bool(toBool(settings.value('phasesLCDs',self.qmc.phasesLCDflag)))
            if settings.contains('phasesLCDmode'):
                self.qmc.phasesLCDmode = toInt(settings.value('phasesLCDmode',self.qmc.phasesLCDmode))
            if settings.contains('step100temp'):
                try:
                    self.qmc.step100temp = int(settings.value('step100temp',self.qmc.step100temp))
                except Exception: # pylint: disable=broad-except
                    self.qmc.step100temp = None
            # Important - this must come after the code that restores phasesLCDmode
            # Done this way with two variables to maintain forward and backward compatibility with settings since adding LCD mode by phase.
            if settings.contains('phasesLCDmode_l'):
                self.qmc.phasesLCDmode_l = [toInt(x) for x in toList(settings.value('phasesLCDmode_l',self.qmc.phasesLCDmode_l))]
            elif settings.contains('phasesLCDmode'):
                self.qmc.phasesLCDmode_l = [toInt(self.qmc.phasesLCDmode)]*3
            if settings.contains('phasesLCDmode_all'):
                self.qmc.phasesLCDmode_all = [bool(toBool(x)) for x in toList(settings.value('phasesLCDmode_all',self.qmc.phasesLCDmode_all))]
            if settings.contains('autoDry'):
                self.qmc.autoDRYflag = bool(toBool(settings.value('autoDry',self.qmc.autoDRYflag)))
            if settings.contains('autoFCs'):
                self.qmc.autoFCsFlag = bool(toBool(settings.value('autoFCs',self.qmc.autoFCsFlag)))
            #restore Events settings
            settings.beginGroup('events')
            if settings.contains('eventsbuttonflag'):
                self.eventsbuttonflag = toInt(settings.value('eventsbuttonflag',int(self.eventsbuttonflag)))
            if settings.contains('minieventsflags'):
                self.minieventsflags = [toInt(x) for x in toList(settings.value('minieventsflags',self.minieventsflags))]
            if settings.contains('eventsGraphflag'):
                self.qmc.eventsGraphflag = toInt(settings.value('eventsGraphflag',int(self.qmc.eventsGraphflag)))
            if settings.contains('etypes'):
                self.qmc.etypes = toStringList(settings.value('etypes',self.qmc.etypes))
                # update minieditor event type ComboBox
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(self.qmc.etypes)
            else:
                # etypes have not been saved in the setting to presever the translations, we have to reset those to their default
                self.qmc.etypes = [
                    QApplication.translate('ComboBox', 'Air'),
                    QApplication.translate('ComboBox', 'Drum'),
                    QApplication.translate('ComboBox', 'Damper'),
                    QApplication.translate('ComboBox', 'Burner')
                ]
            if settings.contains('eventsshowflag'):
                self.qmc.eventsshowflag = toInt(settings.value('eventsshowflag',int(self.qmc.eventsshowflag)))
            if settings.contains('clampEvents'):
                self.qmc.clampEvents = bool(toBool(settings.value('clampEvents',self.qmc.clampEvents)))
            if settings.contains('renderEventsDescr'):
                self.qmc.renderEventsDescr = bool(toBool(settings.value('renderEventsDescr',self.qmc.renderEventsDescr)))
            if settings.contains('eventslabelschars'):
                self.qmc.eventslabelschars = toInt(settings.value('eventslabelschars',int(self.qmc.eventslabelschars)))
            if settings.contains('annotationsflag'):
                self.qmc.annotationsflag = toInt(settings.value('annotationsflag',int(self.qmc.annotationsflag)))
            if settings.contains('showeventsonbt'):
                self.qmc.showeventsonbt = bool(toBool(settings.value('showeventsonbt',self.qmc.showeventsonbt)))
            if settings.contains('showEtypes'):
                self.qmc.showEtypes = [bool(toBool(x)) for x in toList(settings.value('showEtypes',self.qmc.showEtypes))]
            if settings.contains('autoChargeDrop'):
                self.qmc.autoChargeFlag = bool(toBool(settings.value('autoChargeDrop',False)))
                self.qmc.autoDropFlag = self.qmc.autoChargeFlag
            if settings.contains('chargeTimer'):
                self.qmc.chargeTimerFlag = bool(toBool(settings.value('chargeTimer',self.qmc.chargeTimerFlag)))
            if settings.contains('chargeTimerPeriod'):
                self.qmc.chargeTimerPeriod = toInt(settings.value('chargeTimerPeriod',int(self.qmc.chargeTimerPeriod)))
            if settings.contains('autoCharge'):
                self.qmc.autoChargeFlag = bool(toBool(settings.value('autoCharge',self.qmc.autoChargeFlag)))
            if settings.contains('autoDrop'):
                self.qmc.autoDropFlag = bool(toBool(settings.value('autoDrop',self.qmc.autoDropFlag)))
            if settings.contains('markTP'):
                self.qmc.markTPflag = bool(toBool(settings.value('markTP',self.qmc.markTPflag)))
            if settings.contains('EvalueColor'):
                self.qmc.EvalueColor = list(map(str,list(toStringList(settings.value('EvalueColor',self.qmc.EvalueColor)))))
                aw.updateSliderColors()
                self.qmc.EvalueMarker = list(map(str,list(toStringList(settings.value('EvalueMarker',self.qmc.EvalueMarker)))))
            if settings.contains('EvalueTextColor'):
                self.qmc.EvalueTextColor = list(map(str,list(toStringList(settings.value('EvalueTextColor',self.qmc.EvalueTextColor)))))
                aw.updateSliderColors()
            if settings.contains('Evaluelinethickness'):
                self.qmc.Evaluelinethickness = [toInt(x) for x in toList(settings.value('Evaluelinethickness',self.qmc.Evaluelinethickness))]
                self.qmc.Evaluealpha = [toFloat(x) for x in toList(settings.value('Evaluealpha',self.qmc.Evaluealpha))]
            if settings.contains('EvalueMarkerSize'):
                self.qmc.EvalueMarkerSize = [toInt(x) for x in toList(settings.value('EvalueMarkerSize',self.qmc.EvalueMarkerSize))]
            if settings.contains('specialeventannotations'):
                self.qmc.specialeventannotations = list(map(str,list(toStringList(settings.value('specialeventannotations',self.qmc.specialeventannotations)))))
            if settings.contains('specialeventannovisibilities'):
                self.qmc.specialeventannovisibilities = [toInt(x) for x in toList(settings.value('specialeventannovisibilities',self.qmc.specialeventannovisibilities))]
            if settings.contains('overlappct'):
                self.qmc.overlappct = toInt(settings.value('overlappct',int(self.qmc.overlappct)))
            settings.endGroup()
            #restore statistics
            if settings.contains('Statistics'):
                self.qmc.statisticsflags = [toInt(x) for x in toList(settings.value('Statistics',self.qmc.statisticsflags))]
                # extend statisticsflag len to the full size (for backward compatibility)
                for i in range(7 - len(self.qmc.statisticsflags)):
                    self.qmc.statisticsflags.append(0)
            if settings.contains('AnalysisResultsLoc'):
                self.qmc.analysisresultsloc = [toFloat(x) for x in toList(settings.value('AnalysisResultsLoc',self.qmc.analysisresultsloc))]
            if settings.contains('SegmentResultsLoc'):
                self.qmc.segmentresultsloc = [toFloat(x) for x in toList(settings.value('SegmentResultsLoc',self.qmc.segmentresultsloc))]
            if settings.contains('analysisstartchoice'):
                self.qmc.analysisstartchoice = toInt(settings.value('analysisstartchoice',int(self.qmc.analysisstartchoice)))
            if settings.contains('analysisoffset'):
                self.qmc.analysisoffset = toInt(settings.value('analysisoffset',int(self.qmc.analysisoffset)))
            if settings.contains('curvefitstartchoice'):
                self.qmc.curvefitstartchoice = toInt(settings.value('curvefitstartchoice',int(self.qmc.curvefitstartchoice)))
            if settings.contains('curvefitoffset'):
                self.qmc.curvefitoffset = toInt(settings.value('curvefitoffset',int(self.qmc.curvefitoffset)))
            if settings.contains('segmentsamplesthreshold'):
                self.qmc.segmentsamplesthreshold = toInt(settings.value('segmentsamplesthreshold',int(self.qmc.segmentsamplesthreshold)))
            if settings.contains('segmentdeltathreshold'):
                self.qmc.segmentdeltathreshold = aw.float2float(toFloat(settings.value('segmentdeltathreshold',self.qmc.segmentdeltathreshold)),4)
            if settings.contains('projectFlag'):
                self.qmc.projectFlag = bool(toBool(settings.value('projectFlag',int(self.qmc.projectFlag))))
            if settings.contains('projectDeltaFlag'):
                self.qmc.projectDeltaFlag = bool(toBool(settings.value('projectDeltaFlag',int(self.qmc.projectDeltaFlag))) )
            if settings.contains('projectionmode'):
                self.qmc.projectionmode = toInt(settings.value('projectionmode',int(self.qmc.projectionmode)))
            if settings.contains('AUCbegin'):
                self.qmc.AUCbegin = toInt(settings.value('AUCbegin',int(self.qmc.AUCbegin)))
                self.qmc.AUCbase = toInt(settings.value('AUCbase',int(self.qmc.AUCbase)))
                self.qmc.AUCbaseFlag = bool(toBool(settings.value('AUCbaseFlag',self.qmc.AUCbaseFlag)))
                self.qmc.AUCtarget = toInt(settings.value('AUCtarget',int(self.qmc.AUCtarget)))
                self.qmc.AUCtargetFlag = bool(toBool(settings.value('AUCtargetFlag',self.qmc.AUCtargetFlag)))
                self.qmc.AUCguideFlag = bool(toBool(settings.value('AUCguideFlag',self.qmc.AUCguideFlag)))
                self.qmc.AUClcdFlag = bool(toBool(settings.value('AUClcdFlag',self.qmc.AUClcdFlag)))
                self.qmc.AUCLCDmode = toInt(settings.value('AUCLCDmode',self.qmc.AUCLCDmode))
            if settings.contains('AUCshowFlag'):
                self.qmc.AUCshowFlag = bool(toBool(settings.value('AUCshowFlag',self.qmc.AUCshowFlag)))
            if settings.contains('keyboardmoveflag'):
                self.keyboardmoveflag = toInt(settings.value('keyboardmoveflag',int(self.keyboardmoveflag)))
            #restore ambient temperature source
            if settings.contains('AmbientTempSource'):
                aw.qmc.ambientTempSource = toInt(settings.value('AmbientTempSource',int(aw.qmc.ambientTempSource)))
            #restore delay
            if settings.contains('Delay'):
                self.qmc.delay = max(self.qmc.min_delay,toInt(settings.value('Delay',int(self.qmc.delay))))
            else:
                #self.qmc.delay = self.qmc.default_delay
                pass
            # restore keepON flag
            if settings.contains('KeepON'):
                self.qmc.flagKeepON = bool(toBool(settings.value('KeepON',self.qmc.flagKeepON)))
            if settings.contains('flagOpenCompleted'):
                self.qmc.flagOpenCompleted = bool(toBool(settings.value('flagOpenCompleted',self.qmc.flagOpenCompleted)))
            # restore extra event sampling interval
            if settings.contains('ExtraEventSamplingDelay'):
                self.qmc.extra_event_sampling_delay = toInt(settings.value('ExtraEventSamplingDelay',int(self.qmc.extra_event_sampling_delay)))
            #restore colors
            if settings.contains('Colors'):
                for (k, v) in list(toMap(settings.value('Colors')).items()):
                    self.qmc.palette[str(k)] = s2a(toString(v))
                if 'messages' in self.qmc.palette:
                    self.setLabelColor(aw.messagelabel,QColor(self.qmc.palette['messages']))
                if 'et' in self.qmc.palette:
                    self.setLabelColor(aw.label2,QColor(self.qmc.palette['et']))
                if 'bt' in self.qmc.palette:
                    self.setLabelColor(aw.label3,QColor(self.qmc.palette['bt']))
                if 'deltaet' in self.qmc.palette:
                    self.setLabelColor(aw.label4,QColor(self.qmc.palette['deltaet']))
                if 'deltabt' in self.qmc.palette:
                    self.setLabelColor(aw.label5,QColor(self.qmc.palette['deltabt']))
                if 'canvas' in self.qmc.palette:
                    if len(self.qmc.palette['canvas']) == 0:  #revert the canvas element to default if it is blank in the settings.
                        self.qmc.palette['canvas'] = '#F8F8F8'
                else:
                    self.qmc.palette['canvas'] = '#F8F8F8'  #revert the canvas element to default if it does not exist in the settings.
                if 'canvas_alt' in self.qmc.palette:
                    self.qmc.palette.pop('canvas_alt')  #remove the canvas_alt element if it somehow snuck into the settings
            if settings.contains('ETBColor'):
                self.qmc.backgroundmetcolor = s2a(toString(settings.value('ETBColor',self.qmc.backgroundmetcolor)))
            if settings.contains('BTBColor'):
                self.qmc.backgroundbtcolor = s2a(toString(settings.value('BTBColor',self.qmc.backgroundbtcolor)))
            if settings.contains('ETBdeltaColor'):
                self.qmc.backgrounddeltaetcolor = s2a(toString(settings.value('ETBdeltaColor',self.qmc.backgrounddeltaetcolor)))
            if settings.contains('BTBdeltaColor'):
                self.qmc.backgrounddeltabtcolor = s2a(toString(settings.value('BTBdeltaColor',self.qmc.backgrounddeltabtcolor)))
            if settings.contains('BackgroundAlpha'):
                self.qmc.backgroundalpha = min(0.5,aw.float2float(toFloat(settings.value('BackgroundAlpha',self.qmc.backgroundalpha))))
            if settings.contains('LCDColors'):
                for (k, v) in list(toMap(settings.value('LCDColors')).items()):
                    self.lcdpaletteB[str(k)] = s2a(toString(v))
            if settings.contains('LEDColors'):
                for (k, v) in list(toMap(settings.value('LEDColors')).items()):
                    self.lcdpaletteF[str(k)] = s2a(toString(v))
#?            self.qmc.palette["alpha"] = 'None'  #revert the canvas element to default if it does not exist in the settings.
            if settings.contains('Alphas'):
                for (k, v) in list(toMap(settings.value('Alphas')).items()):
                    self.qmc.alpha[str(k)] = (v)

            #restore colors
            self.lcd1.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['timer'],self.lcdpaletteB['timer']))
            self.lcd2.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['et'],self.lcdpaletteB['et']))
            self.lcd3.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['bt'],self.lcdpaletteB['bt']))
            self.lcd4.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['deltaet'],self.lcdpaletteB['deltaet']))
            self.lcd5.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['deltabt'],self.lcdpaletteB['deltabt']))
            self.lcd6.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
            self.lcd7.setStyleSheet('QLCDNumber { border-radius:4; color: %s; background: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))

            if settings.contains('readingslcdsflags'):
                self.readingslcdsflags = [toInt(x) for x in toList(settings.value('readingslcdsflags',self.readingslcdsflags))]

            #restore flavors
            self.qmc.flavorlabels = toStringList(settings.value('Flavors',self.qmc.flavorlabels))
            self.qmc.flavors = [5.]*len(self.qmc.flavorlabels)
            if settings.contains('flavorstartangle'):
                self.qmc.flavorstartangle = toInt(settings.value('flavorstartangle',int(self.qmc.flavorstartangle)))
            #restore roast color system
            if settings.contains('colorsystem'):
                self.qmc.color_system_idx = toInt(settings.value('colorsystem',int(self.qmc.color_system_idx)))
            #restore extra background curve color and index
            settings.beginGroup('XT')
            if settings.contains('color'):
                self.qmc.backgroundxtcolor = s2a(toString(settings.value('color',self.qmc.backgroundxtcolor)))
            if settings.contains('color2'):
                self.qmc.backgroundytcolor = s2a(toString(settings.value('color2',self.qmc.backgroundytcolor)))
            if settings.contains('index'):
                self.qmc.xtcurveidx = toInt(settings.value('index',int(self.qmc.xtcurveidx)))
            if settings.contains('index2'):
                self.qmc.ytcurveidx = toInt(settings.value('index2',int(self.qmc.ytcurveidx)))
            settings.endGroup()
            #restore units
            settings.beginGroup('Units')
            if settings.contains('weight'):
                self.qmc.weight[2] = s2a(toString(settings.value('weight',self.qmc.weight[2])))
                self.qmc.volume[2] = s2a(toString(settings.value('volume',self.qmc.volume[2])))
# density units are now fixed to g/l
#                self.qmc.density[1] = s2a(toString(settings.value("densityweight",self.qmc.density[1])))
#                self.qmc.density[3] = s2a(toString(settings.value("densityvolume",self.qmc.density[3])))
            if settings.contains('volumeCalcUnit'):
                self.qmc.volumeCalcUnit = aw.float2float(toFloat(settings.value('volumeCalcUnit',self.qmc.volumeCalcUnit)))
            settings.endGroup()
            settings.beginGroup('Tare')
            if settings.contains('names'):
                self.qmc.container_names = list(map(str,list(toStringList(settings.value('names',self.qmc.container_names)))))
            if settings.contains('weights'):
                self.qmc.container_weights = [toInt(x) for x in toList(settings.value('weights',self.qmc.container_weights))]
            if settings.contains('idx'):
                self.qmc.container_idx = toInt(settings.value('idx',int(self.qmc.container_idx)))
            settings.endGroup()
            #restore serial port
            settings.beginGroup('SerialPort')
            self.ser.comport = s2a(toString(settings.value('comport',self.ser.comport)))
            if settings.contains('baudrate'):
                self.ser.baudrate = toInt(settings.value('baudrate',int(self.ser.baudrate)))
            if settings.contains('bytesize'):
                self.ser.bytesize = toInt(settings.value('bytesize',self.ser.bytesize))
            if settings.contains('stopbits'):
                self.ser.stopbits = toInt(settings.value('stopbits',self.ser.stopbits))
            self.ser.parity = s2a(toString(settings.value('parity',self.ser.parity)))
            if settings.contains('timeout'):
                self.ser.timeout = aw.float2float(toFloat(settings.value('timeout',self.ser.timeout)))
            settings.endGroup()
            #restorer WebSocket port
            settings.beginGroup('WebSocket')
            self.ws.host = toString(settings.value('host',self.ws.host))
            self.ws.port = toInt(settings.value('port',self.ws.port))
            self.ws.path = toString(settings.value('path',self.ws.path))
            self.ws.machineID = toInt(settings.value('machineID',self.ws.machineID))
            self.ws.connect_timeout = toFloat(settings.value('connect_timeout',self.ws.connect_timeout))
            self.ws.request_timeout = toFloat(settings.value('request_timeout',self.ws.request_timeout))
            self.ws.reconnect_interval = toFloat(settings.value('reconnect_interval',self.ws.reconnect_interval))
            self.ws.id_node = toString(settings.value('id_node',self.ws.id_node))
            self.ws.machine_node = toString(settings.value('machine_node',self.ws.machine_node))
            self.ws.command_node = toString(settings.value('command_node',self.ws.command_node))
            self.ws.data_node = toString(settings.value('data_node',self.ws.data_node))
            self.ws.pushMessage_node = toString(settings.value('pushMessage_node',self.ws.pushMessage_node))
            self.ws.request_data_command = toString(settings.value('request_data_command',self.ws.request_data_command))
            self.ws.charge_message = toString(settings.value('charge_message',self.ws.charge_message))
            self.ws.drop_message = toString(settings.value('drop_message',self.ws.drop_message))
            self.ws.STARTonCHARGE = bool(toBool(settings.value('STARTonCHARGE',self.ws.STARTonCHARGE)))
            self.ws.OFFonDROP = bool(toBool(settings.value('OFFonDROP',self.ws.OFFonDROP)))
            self.ws.addEvent_message = toString(settings.value('addEvent_message',self.ws.addEvent_message))
            self.ws.event_node = toString(settings.value('event_node',self.ws.event_node))
            self.ws.DRY_node = toString(settings.value('DRY_node',self.ws.DRY_node))
            self.ws.FCs_node = toString(settings.value('FCs_node',self.ws.FCs_node))
            self.ws.FCe_node = toString(settings.value('FCe_node',self.ws.FCe_node))
            self.ws.SCs_node = toString(settings.value('SCs_node',self.ws.SCs_node))
            self.ws.SCe_node = toString(settings.value('SCe_node',self.ws.SCe_node))
            self.ws.channel_requests = [toString(x) for x in toList(settings.value('channel_requests',self.ws.channel_requests))]
            self.ws.channel_requests = self.ws.channel_requests + ['']*(max(0,aw.ws.channels - len(self.ws.channel_requests)))
            self.ws.channel_nodes = [toString(x) for x in toList(settings.value('channel_nodes',self.ws.channel_nodes))]
            self.ws.channel_nodes = self.ws.channel_nodes + ['']*(max(0,aw.ws.channels - len(self.ws.channel_nodes)))
            self.ws.channel_modes = [toInt(x) for x in toList(settings.value('channel_modes',self.ws.channel_modes))]
            self.ws.channel_modes = self.ws.channel_modes + [0]*(max(0,aw.ws.channels - len(self.ws.channel_modes)))
            settings.endGroup()
            #restore s7 port
            settings.beginGroup('S7')
            if settings.contains('area'):
                self.s7.area = [toInt(x) for x in toList(settings.value('area',self.s7.area))]
                self.s7.area = self.s7.area + [0]*(max(0,aw.s7.channels - len(self.s7.area)))
                self.s7.db_nr = [toInt(x) for x in toList(settings.value('db_nr',self.s7.db_nr))]
                self.s7.db_nr = self.s7.db_nr + [1]*(max(0,aw.s7.channels - len(self.s7.db_nr)))
                self.s7.start = [toInt(x) for x in toList(settings.value('start',self.s7.start))]
                self.s7.start = self.s7.start + [0]*(max(0,aw.s7.channels - len(self.s7.start)))
                self.s7.type = [toInt(x) for x in toList(settings.value('type',self.s7.type))]
                self.s7.type = self.s7.type + [0]*(max(0,aw.s7.channels - len(self.s7.type)))
                self.s7.mode = [toInt(x) for x in toList(settings.value('mode',self.s7.mode))]
                self.s7.mode = self.s7.mode + [0]*(max(0,aw.s7.channels - len(self.s7.mode)))
                self.s7.div = [toInt(x) for x in toList(settings.value('div',self.s7.div))]
                self.s7.div = self.s7.div + [0]*(max(0,aw.s7.channels - len(self.s7.div)))
                self.s7.host = toString(settings.value('host',self.s7.host))
                self.s7.port = toInt(settings.value('port',self.s7.port))
                self.s7.rack = toInt(settings.value('rack',self.s7.rack))
                self.s7.slot = toInt(settings.value('slot',self.s7.slot))
            if settings.contains('PIDmultiplier'):
                self.s7.PID_area = toInt(settings.value('PID_area',self.s7.PID_area))
                self.s7.PID_db_nr = toInt(settings.value('PID_db_nr',self.s7.PID_db_nr))
                self.s7.PID_SV_register = toInt(settings.value('PID_SV_register',self.s7.PID_SV_register))
                self.s7.PID_p_register = toInt(settings.value('PID_p_register',self.s7.PID_p_register))
                self.s7.PID_i_register = toInt(settings.value('PID_i_register',self.s7.PID_i_register))
                self.s7.PID_d_register = toInt(settings.value('PID_d_register',self.s7.PID_d_register))
                self.s7.PID_OFF_action = s2a(toString(settings.value('PID_OFF_action',self.s7.PID_OFF_action)))
                self.s7.PID_ON_action = s2a(toString(settings.value('PID_ON_action',self.s7.PID_ON_action)))
                self.s7.PIDmultiplier = toInt(settings.value('PIDmultiplier',self.s7.PIDmultiplier))
                self.s7.SVmultiplier = toInt(settings.value('SVmultiplier',self.s7.SVmultiplier))
            if settings.contains('SVtype'):
                self.s7.SVtype = toInt(settings.value('SVtype',self.s7.SVtype))
            if settings.contains('optimizer'):
                self.s7.optimizer = bool(toBool(settings.value('optimizer',self.s7.optimizer)))
            if settings.contains('fetch_max_blocks'):
                self.s7.fetch_max_blocks = bool(toBool(settings.value('fetch_max_blocks',self.s7.fetch_max_blocks)))
            settings.endGroup()
            #restore modbus port
            settings.beginGroup('Modbus')
            self.modbus.comport = s2a(toString(settings.value('comport',self.modbus.comport)))
            if settings.contains('baudrate'):
                self.modbus.baudrate = toInt(settings.value('baudrate',int(self.modbus.baudrate)))
            if settings.contains('bytesize'):
                self.modbus.bytesize = toInt(settings.value('bytesize',self.modbus.bytesize))
            if settings.contains('stopbits'):
                self.modbus.stopbits = toInt(settings.value('stopbits',self.modbus.stopbits))
            if settings.contains('parity'):
                self.modbus.parity = s2a(toString(settings.value('parity',self.modbus.parity)))
            if settings.contains('timeout'):
                self.modbus.timeout = aw.float2float(toFloat(settings.value('timeout',self.modbus.timeout)))
            if settings.contains('modbus_serial_extra_read_delay'):
                self.modbus.modbus_serial_extra_read_delay = toFloat(settings.value('modbus_serial_extra_read_delay',self.modbus.modbus_serial_extra_read_delay))
            if settings.contains('serial_readRetries'):
                self.modbus.serial_readRetries = toInt(settings.value('serial_readRetries',self.modbus.serial_readRetries))
            if settings.contains('IP_timeout'):
                self.modbus.IP_timeout = aw.float2float(toFloat(settings.value('IP_timeout',self.modbus.IP_timeout)))
            if settings.contains('IP_retries'):
                self.modbus.IP_retries = toInt(settings.value('IP_retries',self.modbus.IP_retries))
            if settings.contains('input1slave'):
                self.modbus.inputSlaves[0] = toInt(settings.value('input1slave',self.modbus.inputSlaves[0]))
            if settings.contains('input1register'):
                self.modbus.inputRegisters[0] = toInt(settings.value('input1register',self.modbus.inputRegisters[0]))
            if settings.contains('input2slave'):
                self.modbus.inputSlaves[1] = toInt(settings.value('input2slave',self.modbus.inputSlaves[1]))
            if settings.contains('input2register'):
                self.modbus.inputRegisters[1] = toInt(settings.value('input2register',self.modbus.inputRegisters[1]))
            if settings.contains('input3slave'):
                self.modbus.inputSlaves[2] = toInt(settings.value('input3slave',self.modbus.inputSlaves[2]))
            if settings.contains('input3register'):
                self.modbus.inputRegisters[2] = toInt(settings.value('input3register',self.modbus.inputRegisters[2]))
            if settings.contains('input4slave'):
                self.modbus.inputSlaves[3] = toInt(settings.value('input4slave',self.modbus.inputSlaves[3]))
            if settings.contains('input4register'):
                self.modbus.inputRegisters[3] = toInt(settings.value('input4register',self.modbus.inputRegisters[3]))
            if settings.contains('input5slave'):
                self.modbus.inputSlaves[4] = toInt(settings.value('input5slave',self.modbus.inputSlaves[4]))
            if settings.contains('input5register'):
                self.modbus.inputRegisters[4] = toInt(settings.value('input5register',self.modbus.inputRegisters[4]))
            if settings.contains('input6slave'):
                self.modbus.inputSlaves[5] = toInt(settings.value('input6slave',self.modbus.inputSlaves[5]))
            if settings.contains('input6register'):
                self.modbus.inputRegisters[5] = toInt(settings.value('input6register',self.modbus.inputRegisters[5]))
            if settings.contains('input7slave'):
                self.modbus.inputSlaves[6] = toInt(settings.value('input7slave',self.modbus.inputSlaves[6]))
            if settings.contains('input7register'):
                self.modbus.inputRegisters[6] = toInt(settings.value('input7register',self.modbus.inputRegisters[6]))
            if settings.contains('input8slave'):
                self.modbus.inputSlaves[7] = toInt(settings.value('input8slave',self.modbus.inputSlaves[7]))
            if settings.contains('input8register'):
                self.modbus.inputRegisters[7] = toInt(settings.value('input8register',self.modbus.inputRegisters[7]))
            #----
            if settings.contains('input1float'):
                self.modbus.inputFloats[0] = bool(toBool(settings.value('input1float',self.modbus.inputFloats[0])))
            if settings.contains('input1bcd'):
                self.modbus.inputBCDs[0] = bool(toBool(settings.value('input1bcd',self.modbus.inputBCDs[0])))
            if settings.contains('input1code'):
                self.modbus.inputCodes[0] = toInt(settings.value('input1code',self.modbus.inputCodes[0]))
            if settings.contains('input2float'):
                self.modbus.inputFloats[1] = bool(toBool(settings.value('input2float',self.modbus.inputFloats[1])))
            if settings.contains('input2bcd'):
                self.modbus.inputBCDs[1] = bool(toBool(settings.value('input2bcd',self.modbus.inputBCDs[1])))
            if settings.contains('input2code'):
                self.modbus.inputCodes[1] = toInt(settings.value('input2code',self.modbus.inputCodes[1]))
            if settings.contains('input3float'):
                self.modbus.inputFloats[2] = bool(toBool(settings.value('input3float',self.modbus.inputFloats[2])))
            if settings.contains('input3bcd'):
                self.modbus.inputBCDs[2] = bool(toBool(settings.value('input3bcd',self.modbus.inputBCDs[2])))
            if settings.contains('input3code'):
                self.modbus.inputCodes[2] = toInt(settings.value('input3code',self.modbus.inputCodes[2]))
            if settings.contains('input4float'):
                self.modbus.inputFloats[3] = bool(toBool(settings.value('input4float',self.modbus.inputFloats[3])))
            if settings.contains('input4bcd'):
                self.modbus.inputBCDs[3] = bool(toBool(settings.value('input4bcd',self.modbus.inputBCDs[3])))
            if settings.contains('input4code'):
                self.modbus.inputCodes[3] = toInt(settings.value('input4code',self.modbus.inputCodes[3]))
            if settings.contains('input5float'):
                self.modbus.inputFloats[4] = bool(toBool(settings.value('input5float',self.modbus.inputFloats[4])))
            if settings.contains('input5bcd'):
                self.modbus.inputBCDs[4] = bool(toBool(settings.value('input5bcd',self.modbus.inputBCDs[4])))
            if settings.contains('input5code'):
                self.modbus.inputCodes[4] = toInt(settings.value('input5code',self.modbus.inputCodes[4]))
            if settings.contains('input6float'):
                self.modbus.inputFloats[5] = bool(toBool(settings.value('input6float',self.modbus.inputFloats[5])))
            if settings.contains('input6bcd'):
                self.modbus.inputBCDs[5] = bool(toBool(settings.value('input6bcd',self.modbus.inputBCDs[5])))
            if settings.contains('input6code'):
                self.modbus.inputCodes[5] = toInt(settings.value('input6code',self.modbus.inputCodes[5]))
            if settings.contains('input7float'):
                self.modbus.inputFloats[6] = bool(toBool(settings.value('input7float',self.modbus.inputFloats[6])))
            if settings.contains('input7bcd'):
                self.modbus.inputBCDs[6] = bool(toBool(settings.value('input7bcd',self.modbus.inputBCDs[6])))
            if settings.contains('input7code'):
                self.modbus.inputCodes[6] = toInt(settings.value('input7code',self.modbus.inputCodes[6]))
            if settings.contains('input8float'):
                self.modbus.inputFloats[7] = bool(toBool(settings.value('input8float',self.modbus.inputFloats[7])))
            if settings.contains('input8bcd'):
                self.modbus.inputBCDs[7] = bool(toBool(settings.value('input8bcd',self.modbus.inputBCDs[7])))
            if settings.contains('input8code'):
                self.modbus.inputCodes[7] = toInt(settings.value('input8code',self.modbus.inputCodes[7]))
            if settings.contains('littleEndianFloats'):
                self.modbus.byteorderLittle = bool(toBool(settings.value('littleEndianFloats',self.modbus.byteorderLittle)))
            if settings.contains('wordorderLittle'):
                self.modbus.wordorderLittle = bool(toBool(settings.value('wordorderLittle',self.modbus.wordorderLittle)))
            if settings.contains('optimizer'):
                self.modbus.optimizer = bool(toBool(settings.value('optimizer',self.modbus.optimizer)))
            if settings.contains('fetch_max_blocks'):
                self.modbus.fetch_max_blocks = bool(toBool(settings.value('fetch_max_blocks',self.modbus.fetch_max_blocks)))
            if settings.contains('input1mode'):
                self.modbus.inputModes[0] = s2a(toString(settings.value('input1mode',self.modbus.inputModes[0])))
                self.modbus.inputModes[1] = s2a(toString(settings.value('input2mode',self.modbus.inputModes[1])))
                self.modbus.inputModes[2] = s2a(toString(settings.value('input3mode',self.modbus.inputModes[2])))
                self.modbus.inputModes[3] = s2a(toString(settings.value('input4mode',self.modbus.inputModes[3])))
                self.modbus.inputModes[4] = s2a(toString(settings.value('input5mode',self.modbus.inputModes[4])))
                self.modbus.inputModes[5] = s2a(toString(settings.value('input6mode',self.modbus.inputModes[5])))
                self.modbus.inputModes[6] = s2a(toString(settings.value('input7mode',self.modbus.inputModes[6])))
                self.modbus.inputModes[7] = s2a(toString(settings.value('input8mode',self.modbus.inputModes[7])))
            if settings.contains('input1div'):
                self.modbus.inputDivs[0] = toInt(settings.value('input1div',self.modbus.inputDivs[0]))
                self.modbus.inputDivs[1] = toInt(settings.value('input2div',self.modbus.inputDivs[1]))
                self.modbus.inputDivs[2] = toInt(settings.value('input3div',self.modbus.inputDivs[2]))
                self.modbus.inputDivs[3] = toInt(settings.value('input4div',self.modbus.inputDivs[3]))
                self.modbus.inputDivs[4] = toInt(settings.value('input5div',self.modbus.inputDivs[4]))
                self.modbus.inputDivs[5] = toInt(settings.value('input6div',self.modbus.inputDivs[5]))
                self.modbus.inputDivs[6] = toInt(settings.value('input7div',self.modbus.inputDivs[6]))
                self.modbus.inputDivs[7] = toInt(settings.value('input8div',self.modbus.inputDivs[7]))
            if settings.contains('input1FloatsAsInt'):
                self.modbus.inputFloatsAsInt[0] = bool(toBool(settings.value('input1FloatsAsInt',self.modbus.inputFloatsAsInt[0])))
                self.modbus.inputFloatsAsInt[1] = bool(toBool(settings.value('input2FloatsAsInt',self.modbus.inputFloatsAsInt[1])))
                self.modbus.inputFloatsAsInt[2] = bool(toBool(settings.value('input3FloatsAsInt',self.modbus.inputFloatsAsInt[2])))
                self.modbus.inputFloatsAsInt[3] = bool(toBool(settings.value('input4FloatsAsInt',self.modbus.inputFloatsAsInt[3])))
                self.modbus.inputFloatsAsInt[4] = bool(toBool(settings.value('input5FloatsAsInt',self.modbus.inputFloatsAsInt[4])))
                self.modbus.inputFloatsAsInt[5] = bool(toBool(settings.value('input6FloatsAsInt',self.modbus.inputFloatsAsInt[5])))
                self.modbus.inputFloatsAsInt[6] = bool(toBool(settings.value('input7FloatsAsInt',self.modbus.inputFloatsAsInt[6])))
                self.modbus.inputFloatsAsInt[7] = bool(toBool(settings.value('input8FloatsAsInt',self.modbus.inputFloatsAsInt[7])))
            if settings.contains('input1BCDsAsInt'):
                self.modbus.inputBCDsAsInt[0] = bool(toBool(settings.value('input1BCDsAsInt',self.modbus.inputBCDsAsInt[0])))
                self.modbus.inputBCDsAsInt[1] = bool(toBool(settings.value('input2BCDsAsInt',self.modbus.inputBCDsAsInt[1])))
                self.modbus.inputBCDsAsInt[2] = bool(toBool(settings.value('input3BCDsAsInt',self.modbus.inputBCDsAsInt[2])))
                self.modbus.inputBCDsAsInt[3] = bool(toBool(settings.value('input4BCDsAsInt',self.modbus.inputBCDsAsInt[3])))
                self.modbus.inputBCDsAsInt[4] = bool(toBool(settings.value('input5BCDsAsInt',self.modbus.inputBCDsAsInt[4])))
                self.modbus.inputBCDsAsInt[5] = bool(toBool(settings.value('input6BCDsAsInt',self.modbus.inputBCDsAsInt[5])))
                self.modbus.inputBCDsAsInt[6] = bool(toBool(settings.value('input7BCDsAsInt',self.modbus.inputBCDsAsInt[6])))
                self.modbus.inputBCDsAsInt[7] = bool(toBool(settings.value('input8BCDsAsInt',self.modbus.inputBCDsAsInt[7])))
            if settings.contains('input1Signed'):
                self.modbus.inputSigned[0] = bool(toBool(settings.value('input1Signed',self.modbus.inputSigned[0])))
                self.modbus.inputSigned[1] = bool(toBool(settings.value('input2Signed',self.modbus.inputSigned[1])))
                self.modbus.inputSigned[2] = bool(toBool(settings.value('input3Signed',self.modbus.inputSigned[2])))
                self.modbus.inputSigned[3] = bool(toBool(settings.value('input4Signed',self.modbus.inputSigned[3])))
                self.modbus.inputSigned[4] = bool(toBool(settings.value('input5Signed',self.modbus.inputSigned[4])))
                self.modbus.inputSigned[5] = bool(toBool(settings.value('input6Signed',self.modbus.inputSigned[5])))
                self.modbus.inputSigned[6] = bool(toBool(settings.value('input7Signed',self.modbus.inputSigned[6])))
                self.modbus.inputSigned[7] = bool(toBool(settings.value('input8Signed',self.modbus.inputSigned[7])))
            if settings.contains('PIDmultiplier'):
                self.modbus.PIDmultiplier = toInt(settings.value('PIDmultiplier',self.modbus.PIDmultiplier))
                self.modbus.SVmultiplier = toInt(settings.value('SVmultiplier',self.modbus.SVmultiplier))
            if settings.contains('PID_slave_ID'):
                self.modbus.PID_slave_ID = toInt(settings.value('PID_slave_ID',self.modbus.PID_slave_ID))
                self.modbus.PID_SV_register = toInt(settings.value('PID_SV_register',self.modbus.PID_SV_register))
                self.modbus.PID_p_register = toInt(settings.value('PID_p_register',self.modbus.PID_p_register))
                self.modbus.PID_i_register = toInt(settings.value('PID_i_register',self.modbus.PID_i_register))
                self.modbus.PID_d_register = toInt(settings.value('PID_d_register',self.modbus.PID_d_register))
            if settings.contains('PID_OFF_action'):
                self.modbus.PID_OFF_action = s2a(toString(settings.value('PID_OFF_action',self.modbus.PID_OFF_action)))
            if settings.contains('PID_ON_action'):
                self.modbus.PID_ON_action = s2a(toString(settings.value('PID_ON_action',self.modbus.PID_ON_action)))
            #restore MODBUS TCP/UDP settings
            if settings.contains('host'):
                self.modbus.type = toInt(settings.value('type',self.modbus.type))
                self.modbus.host = toString(settings.value('host',self.modbus.host))
                self.modbus.port = toInt(settings.value('port',self.modbus.port))
            if settings.contains('reset_socket'):
                self.modbus.reset_socket = bool(toBool(settings.value('reset_socket',self.modbus.reset_socket)))
            settings.endGroup()
            #restore scale port
            settings.beginGroup('Scale')
            self.scale.device = toString(settings.value('device',self.scale.device))
            self.scale.comport = s2a(toString(settings.value('comport',self.scale.comport)))
            self.scale.baudrate = toInt(settings.value('baudrate',int(self.scale.baudrate)))
            self.scale.bytesize = toInt(settings.value('bytesize',self.scale.bytesize))
            self.scale.stopbits = toInt(settings.value('stopbits',self.scale.stopbits))
            self.scale.parity = s2a(toString(settings.value('parity',self.scale.parity)))
            self.scale.timeout = aw.float2float(toFloat(settings.value('timeout',self.scale.timeout)))
            settings.endGroup()
            #restore color port
            settings.beginGroup('Color')
            self.color.device = toString(settings.value('device',self.color.device))
            self.color.comport = s2a(toString(settings.value('comport',self.color.comport)))
            self.color.baudrate = toInt(settings.value('baudrate',int(self.color.baudrate)))
            self.color.bytesize = toInt(settings.value('bytesize',self.color.bytesize))
            self.color.stopbits = toInt(settings.value('stopbits',self.color.stopbits))
            self.color.parity = s2a(toString(settings.value('parity',self.color.parity)))
            self.color.timeout = aw.float2float(toFloat(settings.value('timeout',self.color.timeout)))
            settings.endGroup()
            #restore alarms
            settings.beginGroup('Alarms')
            if settings.contains('alarmtime'):
                self.qmc.alarmflag = [toInt(x) for x in toList(settings.value('alarmflag',self.qmc.alarmflag))]
                if settings.contains('alarmsetlabel'):
                    self.qmc.alarmsetlabel = toString(settings.value('alarmsetlabel',self.qmc.alarmsetlabel))
                else:
                    self.qmc.alarmsetlabel = ''

                if settings.contains('alarmguard'):
                    self.qmc.alarmguard = [toInt(x) for x in toList(settings.value('alarmguard',self.qmc.alarmguard))]
                else:
                    self.qmc.alarmguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains('alarmnegguard'):
                    self.qmc.alarmnegguard = [toInt(x) for x in toList(settings.value('alarmnegguard',self.qmc.alarmnegguard))]
                else:
                    self.qmc.alarmnegguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains('alarmtime'):
                    self.qmc.alarmtime = [toInt(x) for x in toList(settings.value('alarmtime',self.qmc.alarmtime))]
                else:
                    self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
                if settings.contains('alarmoffset'):
                    self.qmc.alarmoffset = [max(0,toInt(x)) for x in toList(settings.value('alarmoffset',self.qmc.alarmoffset))]
                else:
                    self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
                if settings.contains('alarmcond'):
                    self.qmc.alarmcond = [toInt(x) for x in toList(settings.value('alarmcond',self.qmc.alarmcond))]
                else:
                    self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
                if settings.contains('alarmsource'):
                    self.qmc.alarmsource = [toInt(x) for x in toList(settings.value('alarmsource',self.qmc.alarmsource))]
                else:
                    self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
                if settings.contains('alarmtemperature'):
                    self.qmc.alarmtemperature = [toFloat(x) for x in toList(settings.value('alarmtemperature',self.qmc.alarmtemperature))]
                else:
                    self.qmc.alarmtemperature = [500.]*len(self.qmc.alarmflag)
                if settings.contains('alarmaction'):
                    self.qmc.alarmaction = [toInt(x) for x in toList(settings.value('alarmaction',self.qmc.alarmaction))]
                else:
                    self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
                if settings.contains('alarmbeep'):
                    self.qmc.alarmbeep = [toInt(x) for x in toList(settings.value('alarmbeep',self.qmc.alarmbeep))]
                else:
                    self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
                if settings.contains('alarmstrings'):
                    self.qmc.alarmstrings = list(toStringList(settings.value('alarmstrings',self.qmc.alarmstrings)))
                else:
                    self.qmc.alarmstrings = ['']*len(self.qmc.alarmflag)
                self.qmc.alarmstate = [-1]*len(self.qmc.alarmflag)
                if settings.contains('loadAlarmsFromProfile'):
                    self.qmc.loadalarmsfromprofile = bool(toBool(settings.value('loadAlarmsFromProfile',self.qmc.loadalarmsfromprofile)))
                if settings.contains('loadAlarmsFromBackground'):
                    self.qmc.loadalarmsfrombackground = bool(toBool(settings.value('loadAlarmsFromBackground',self.qmc.loadalarmsfrombackground)))
                if settings.contains('alarmsfile'):
                    self.qmc.alarmsfile = toString(settings.value('alarmsfile',self.qmc.alarmsfile))
                if settings.contains('alarm_popup_timout'):
                    self.qmc.alarm_popup_timout = toInt(settings.value('alarm_popup_timout',aw.qmc.alarm_popup_timout))
                if settings.contains('alarmtablecolumnwidths'):
                    self.qmc.alarmtablecolumnwidths = [toInt(x) for x in toList(settings.value('alarmtablecolumnwidths',self.qmc.alarmtablecolumnwidths))]
                if settings.contains('alarmsets'):
                    self.qmc.alarmsets = toList(settings.value('alarmsets',self.qmc.alarmsets))
                if settings.contains('alarmsetlabel'):
                    self.qmc.alarmsetlabel = toString(settings.value('alarmsetlabel',self.qmc.alarmsetlabel))
            settings.endGroup()
            #restore TC4/Arduino PID settings
            settings.beginGroup('ArduinoPID')
            if settings.contains('pidOnCHARGE'):
                aw.pidcontrol.pidOnCHARGE = bool(toBool(settings.value('pidOnCHARGE',aw.pidcontrol.pidOnCHARGE)))
                aw.pidcontrol.loadRampSoakFromProfile = bool(toBool(settings.value('loadRampSoakFromProfile',aw.pidcontrol.loadRampSoakFromProfile)))
                aw.pidcontrol.svValues = [toInt(x) for x in toList(settings.value('svValues',aw.pidcontrol.svValues))]
                aw.pidcontrol.svRamps = [toInt(x) for x in toList(settings.value('svRamps',aw.pidcontrol.svRamps))]
                aw.pidcontrol.svSoaks = [toInt(x) for x in toList(settings.value('svSoaks',aw.pidcontrol.svSoaks))]
                aw.pidcontrol.svActions = [toInt(x) for x in toList(settings.value('svActions',aw.pidcontrol.svActions))]
                aw.pidcontrol.svBeeps = [bool(toBool(x)) for x in toList(settings.value('svBeeps',aw.pidcontrol.svBeeps))]
                aw.pidcontrol.svDescriptions = list(toStringList(settings.value('svDescriptions',aw.pidcontrol.svDescriptions)))
                aw.pidcontrol.svSlider = bool(toBool(settings.value('svSlider',aw.pidcontrol.svSlider)))
                aw.pidcontrol.svButtons = bool(toBool(settings.value('svButtons',aw.pidcontrol.svButtons)))
                aw.pidcontrol.svMode = toInt(settings.value('svMode',aw.pidcontrol.svMode))
                aw.pidcontrol.svLookahead = toInt(settings.value('svLookahead',aw.pidcontrol.svLookahead))
                aw.pidcontrol.dutySteps = toInt(settings.value('dutySteps',aw.pidcontrol.dutySteps))
                aw.pidcontrol.svSliderMin = toInt(settings.value('svSliderMin',aw.pidcontrol.svSliderMin))
                aw.pidcontrol.svSliderMax = toInt(settings.value('svSliderMax',aw.pidcontrol.svSliderMax))
                aw.pidcontrol.svValue = toInt(settings.value('svValue',aw.pidcontrol.svValue))
                if settings.contains('loadRampSoakFromBackground'):
                    aw.pidcontrol.loadRampSoakFromBackground = bool(toBool(settings.value('loadRampSoakFromBackground',aw.pidcontrol.loadRampSoakFromBackground)))
                if settings.contains('svLabel'):
                    aw.pidcontrol.svLabel = toString(settings.value('svLabel',aw.pidcontrol.svLabel))

                aw.sliderSV.blockSignals(True)
                try:
                    if settings.contains('dutyMin'):
                        aw.pidcontrol.dutyMin = toInt(settings.value('dutyMin',aw.pidcontrol.dutyMin))
                    if settings.contains('dutyMax'):
                        aw.pidcontrol.dutyMax = toInt(settings.value('dutyMax',aw.pidcontrol.dutyMax))
                finally:
                    aw.sliderSV.blockSignals(False)

                aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider)
                aw.pidcontrol.pidKp = toFloat(settings.value('pidKp',aw.pidcontrol.pidKp))
                aw.pidcontrol.pidKi = toFloat(settings.value('pidKi',aw.pidcontrol.pidKi))
                aw.pidcontrol.pidKd = toFloat(settings.value('pidKd',aw.pidcontrol.pidKd))
                aw.pidcontrol.pidSource = toInt(settings.value('pidSource',aw.pidcontrol.pidSource))
                aw.pidcontrol.pidCycle = toInt(settings.value('pidCycle',aw.pidcontrol.pidCycle))
                if settings.contains('pidPositiveTarget'):
                    aw.pidcontrol.pidPositiveTarget = toInt(settings.value('pidPositiveTarget',aw.pidcontrol.pidPositiveTarget))
                    aw.pidcontrol.pidNegativeTarget = toInt(settings.value('pidNegativeTarget',aw.pidcontrol.pidNegativeTarget))
                    aw.pidcontrol.invertControl = bool(toBool(settings.value('invertControl',aw.pidcontrol.invertControl)))
                if settings.contains('pOnE'):
                    aw.pidcontrol.pOnE = bool(toBool(settings.value('pOnE',aw.pidcontrol.pOnE)))

                for n in range(aw.pidcontrol.RSLen):
                    svLabelLabel = 'RS_svLabel'+str(n)
                    if settings.contains(svLabelLabel):
                        aw.pidcontrol.RS_svLabels[n] = toString(settings.value(svLabelLabel,aw.pidcontrol.RS_svLabels[n]))
                    svValuesLabel = 'RS_svValues'+str(n)
                    if settings.contains(svValuesLabel):
                        aw.pidcontrol.RS_svValues[n] = [toInt(x) for x in toList(settings.value(svValuesLabel,aw.pidcontrol.RS_svValues[n]))]
                    svRampsLabel = 'RS_svRamps'+str(n)
                    if settings.contains(svRampsLabel):
                        aw.pidcontrol.RS_svRamps[n] = [toInt(x) for x in toList(settings.value(svRampsLabel,aw.pidcontrol.RS_svRamps[n]))]
                    svSoaksLabel = 'RS_svSoaks'+str(n)
                    if settings.contains(svSoaksLabel):
                        aw.pidcontrol.RS_svSoaks[n] = [toInt(x) for x in toList(settings.value(svSoaksLabel,aw.pidcontrol.RS_svSoaks[n]))]
                    svActionsLabel = 'RS_svActions'+str(n)
                    if settings.contains(svActionsLabel):
                        aw.pidcontrol.RS_svActions[n] = [toInt(x) for x in toList(settings.value(svActionsLabel,aw.pidcontrol.RS_svActions[n]))]
                    svBeepsLabel = 'RS_svBeeps'+str(n)
                    if settings.contains(svBeepsLabel):
                        aw.pidcontrol.RS_svBeeps[n] = [bool(toBool(x)) for x in toList(settings.value(svBeepsLabel,aw.pidcontrol.RS_svBeeps[n]))]
                    svDescriptionsLabel = 'RS_svDescriptions'+str(n)
                    if settings.contains(svDescriptionsLabel):
                        aw.pidcontrol.RS_svDescriptions[n] = list(toStringList(settings.value(svDescriptionsLabel,aw.pidcontrol.RS_svDescriptions[n])))

            settings.endGroup()

            #restore pid settings
            settings.beginGroup('PXR')
            for k in list(self.fujipid.PXR.keys()):
                if type(self.fujipid.PXR[k][0]) == type(float()):
                    self.fujipid.PXR[k][0] = toFloat(settings.value(k,self.fujipid.PXR[k][0]))
                elif type(self.fujipid.PXR[k][0]) == type(int()):
                    self.fujipid.PXR[k][0] = toInt(settings.value(k,self.fujipid.PXR[k][0]))
            settings.endGroup()
            settings.beginGroup('PXG4')
            for k in list(self.fujipid.PXG4.keys()):
                if type(self.fujipid.PXG4[k][0]) == type(float()):
                    self.fujipid.PXG4[k][0] = toFloat(settings.value(k,self.fujipid.PXG4[k][0]))
                elif type(self.fujipid.PXG4[k][0]) == type(int()):
                    self.fujipid.PXG4[k][0] = toInt(settings.value(k,self.fujipid.PXG4[k][0]))

            if self.fujipid.PXG4['selectsv'][0] < 1:
                self.fujipid.PXG4['selectsv'][0] = 1
            if settings.contains('followBackground'):
                self.fujipid.followBackground = bool(toBool(settings.value('followBackground',self.fujipid.followBackground)))
            if settings.contains('lookahead'):
                self.fujipid.lookahead = toInt(settings.value('lookahead',self.fujipid.lookahead))
            settings.endGroup()
            if settings.contains('deltaDTA'):
                settings.beginGroup('deltaDTA')
                for k in list(self.dtapid.dtamem.keys()):
                    if type(self.dtapid.dtamem[k][0]) == type(float()):
                        self.dtapid.dtamem[k][0] = toFloat(settings.value(k,self.dtapid.dtamem[k][0]))
                    elif type(self.dtapid.dtamem[k][0]) == type(int()):
                        self.dtapid.dtamem[k][0] = toInt(settings.value(k,self.dtapid.dtamem[k][0]))
                settings.endGroup()
            if settings.contains('filterDropOuts'):
                self.qmc.filterDropOuts = bool(toBool(settings.value('filterDropOuts',self.qmc.filterDropOuts)))
            if settings.contains('dropSpikes'):
                self.qmc.dropSpikes = bool(toBool(settings.value('dropSpikes',self.qmc.dropSpikes)))
            if settings.contains('dropDuplicates'):
                self.qmc.dropDuplicates = bool(toBool(settings.value('dropDuplicates',self.qmc.dropDuplicates)))
            if settings.contains('dropDuplicatesLimit'):
                self.qmc.dropDuplicatesLimit = toFloat(settings.value('dropDuplicatesLimit',self.qmc.dropDuplicatesLimit))
            if settings.contains('optimalSmoothing'):
                self.qmc.optimalSmoothing = bool(toBool(settings.value('optimalSmoothing',self.qmc.optimalSmoothing)))
            if settings.contains('polyfitRoRcalc'):
                self.qmc.polyfitRoRcalc = bool(toBool(settings.value('polyfitRoRcalc',self.qmc.polyfitRoRcalc)))
            if settings.contains('swapETBT'):
                self.qmc.swapETBT = bool(toBool(settings.value('swapETBT',self.qmc.swapETBT)))
            if settings.contains('minmaxLimits'):
                self.qmc.minmaxLimits = bool(toBool(settings.value('minmaxLimits',self.qmc.minmaxLimits)))
                self.qmc.filterDropOut_tmin = toInt(settings.value('minLimit',self.qmc.filterDropOut_tmin))
                self.qmc.filterDropOut_tmax = toInt(settings.value('maxLimit',self.qmc.filterDropOut_tmax))
            if settings.contains('foregroundShowFullflag'):
                self.qmc.foregroundShowFullflag = bool(toBool(settings.value('foregroundShowFullflag',self.qmc.foregroundShowFullflag)))
            settings.beginGroup('RoC')
            self.qmc.DeltaETflag = bool(toBool(settings.value('DeltaET',self.qmc.DeltaETflag)))
            self.qmc.DeltaBTflag = bool(toBool(settings.value('DeltaBT',self.qmc.DeltaBTflag)))
            self.qmc.deltaBTfilter = toInt(settings.value('deltafilter',self.qmc.deltaBTfilter))
            if settings.contains('deltaETfilter'):
                self.qmc.deltaETfilter = toInt(settings.value('deltaETfilter',self.qmc.deltaETfilter))
            else:
                self.qmc.deltaETfilter = self.qmc.deltaBTfilter
            if settings.contains('DeltaSpan'):
                self.qmc.deltaBTspan = toInt(settings.value('DeltaSpan',self.qmc.deltaBTspan))
                if settings.contains('DeltaETspan'):
                    self.qmc.deltaETspan = toInt(settings.value('DeltaETspan',self.qmc.deltaETspan))
                else:
                    self.qmc.deltaETspan = self.qmc.deltaBTspan
            self.qmc.LCDdecimalplaces = toInt(settings.value('LCDdecimalplaces',self.qmc.LCDdecimalplaces))
            if settings.contains('statisticsmode'):
                self.qmc.statisticsmode = toInt(settings.value('statisticsmode',self.qmc.statisticsmode))
            if settings.contains('DeltaETlcd'):
                self.qmc.DeltaETlcdflag = bool(toBool(settings.value('DeltaETlcd',self.qmc.DeltaETlcdflag)))
            if settings.contains('DeltaBTlcd'):
                self.qmc.DeltaBTlcdflag = bool(toBool(settings.value('DeltaBTlcd',self.qmc.DeltaBTlcdflag)))
            if settings.contains('swapdeltalcds'):
                self.qmc.swapdeltalcds = bool(toBool(settings.value('swapdeltalcds',self.qmc.swapdeltalcds)))
            settings.endGroup()
            if settings.contains('curvefilter'):
                self.qmc.curvefilter = toInt(settings.value('curvefilter',self.qmc.curvefilter))
#            if settings.contains("smoothingwindowsize"):
#                self.qmc.smoothingwindowsize = toInt(settings.value("smoothingwindowsize",self.qmc.smoothingwindowsize))
            if settings.contains('ETcurve'):
                self.qmc.ETcurve = bool(toBool(settings.value('ETcurve',self.qmc.ETcurve)))
            if settings.contains('BTcurve'):
                self.qmc.BTcurve = bool(toBool(settings.value('BTcurve',self.qmc.BTcurve)))
            if settings.contains('ETlcd'):
                self.qmc.ETlcd = bool(toBool(settings.value('ETlcd',self.qmc.ETlcd)))
            if settings.contains('BTlcd'):
                self.qmc.BTlcd = bool(toBool(settings.value('BTlcd',self.qmc.BTlcd)))
            if settings.contains('swaplcds'):
                self.qmc.swaplcds = bool(toBool(settings.value('swaplcds',self.qmc.swaplcds)))
            settings.beginGroup('DefaultButtons')
            if settings.contains('buttonvisibility'):
                self.qmc.buttonvisibility = [toBool(x) for x in toList(settings.value('buttonvisibility'))]
            if settings.contains('buttonactions'):
                self.qmc.buttonactions = [toInt(x) for x in toList(settings.value('buttonactions'))]
            if settings.contains('buttonactionstrings'):
                self.qmc.buttonactionstrings = list(map(str,list(toStringList(settings.value('buttonactionstrings',self.qmc.buttonactionstrings)))))
            if settings.contains('extrabuttonactions'):
                self.qmc.extrabuttonactions = [toInt(x) for x in toList(settings.value('extrabuttonactions'))]
            if settings.contains('extrabuttonactionstrings'):
                self.qmc.extrabuttonactionstrings = list(map(str,list(toStringList(settings.value('extrabuttonactionstrings',self.qmc.extrabuttonactionstrings)))))
            if settings.contains('xextrabuttonactions'):
                self.qmc.xextrabuttonactions = [toInt(x) for x in toList(settings.value('xextrabuttonactions'))]
            if settings.contains('xextrabuttonactionstrings'):
                self.qmc.xextrabuttonactionstrings = list(map(str,list(toStringList(settings.value('xextrabuttonactionstrings',self.qmc.xextrabuttonactionstrings)))))
            settings.endGroup()
            self.qmc.transMappingMode = toInt(settings.value('transMappingMode',self.qmc.transMappingMode))
            settings.beginGroup('Style')
            if settings.contains('patheffects'):
                self.qmc.patheffects = toInt(settings.value('patheffects',self.qmc.patheffects))
            if settings.contains('graphstyle'):
                self.qmc.graphstyle = toInt(settings.value('graphstyle',self.qmc.graphstyle))
            if settings.contains('graphfont'):
                self.qmc.graphfont = toInt(settings.value('graphfont',self.qmc.graphfont))
            if settings.contains('ETname'):
                self.ETname = settings.value('ETname')
                self.label2.setText('<big><b>' + self.ETname + '</b></big>')
                self.label4.setText(deltaLabelBigPrefix + self.ETname + '</b></big>')
            else:
                self.ETname = QApplication.translate('Label', 'ET')
            if settings.contains('BTname'):
                self.BTname = settings.value('BTname')
                self.label3.setText('<big><b>' + self.BTname + '</b></big>')
                self.label5.setText(deltaLabelBigPrefix + self.BTname + '</b></big>')
            else:
                self.BTname = QApplication.translate('Label', 'BT')
            settings.endGroup()
            settings.beginGroup('Sound')
            self.soundflag = toInt(settings.value('Beep',self.soundflag))
            settings.endGroup()
            if filename is None:
                settings.beginGroup('Notifications')
                if self.notificationManager:
                    try:
                        # reconstruct Notification objects from component lists
                        titles = [toString(x) for x in toList(settings.value('titles', []))]
                        messages = [toString(x) for x in toList(settings.value('messages', []))]
                        types = [toInt(x) for x in toList(settings.value('types', []))]
                        created = [toFloat(x) for x in toList(settings.value('created', []))]
                        self.notificationManager.clearNotificationQueue()
                        for i in range(len(titles)):
                            n = Notification(
                                titles[i],
                                messages[i],
                                NotificationType(types[i]),
                                created[i])
                            self.notificationManager.addNotificationItem(n)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                self.notificationsflag = toBool(settings.value('notificationsflag',self.notificationsflag))
                if self.notificationManager:
                    if self.notificationsflag:
                        self.notificationManager.showNotifications()
                    else:
                        self.notificationManager.hideNotifications()
                settings.endGroup()

            #loads max-min temp limits of graph
            settings.beginGroup('Axis')
            if settings.contains('loadAxisFromProfile'):
                self.qmc.loadaxisfromprofile = bool(toBool(settings.value('loadAxisFromProfile',self.qmc.loadaxisfromprofile)))
            try: # prevents some random exceptions in Windows!?
                self.qmc.startofx = toFloat(settings.value('xmin',self.qmc.startofx))
                self.qmc.endofx = toFloat(settings.value('xmax',self.qmc.endofx))
                #fixes Windows OS sometimes saving endofx as 0
                if self.qmc.endofx < 60 or self.qmc.endofx > 1800:
                    self.qmc.endofx = 60
            except Exception: # pylint: disable=broad-except
                pass
            self.qmc.ylimit = min(toInt(settings.value('ymax',self.qmc.ylimit)),self.qmc.ylimit_max)
            self.qmc.ylimit_min = max(min(toInt(settings.value('ymin',self.qmc.ylimit_min)),self.qmc.ylimit),self.qmc.ylimit_min_max)
            self.qmc.zlimit = min(toInt(settings.value('zmax',self.qmc.zlimit)),self.qmc.zlimit_max)
            self.qmc.zlimit_min = max(min(toInt(settings.value('zmin',self.qmc.zlimit_min)),self.qmc.zlimit),self.qmc.zlimit_min_max)
            if settings.contains('resetmaxtime'):
                self.qmc.resetmaxtime = toInt(settings.value('resetmaxtime',self.qmc.resetmaxtime))
            if settings.contains('lockmax'):
                self.qmc.fixmaxtime = bool(toBool(settings.value('lockmax',self.qmc.fixmaxtime)))
            if settings.contains('locktimex'):
                self.qmc.locktimex = bool(toBool(settings.value('locktimex',self.qmc.locktimex)))
            if settings.contains('autotimex'):
                self.qmc.autotimex = bool(toBool(settings.value('autotimex',self.qmc.autotimex)))
            if settings.contains('autotimexMode'):
                self.qmc.autotimexMode = toInt(settings.value('autotimexMode',self.qmc.autotimexMode))
            if settings.contains('autodeltaxET'):
                self.qmc.autodeltaxET = bool(toBool(settings.value('autodeltaxET',self.qmc.autodeltaxET)))
            if settings.contains('autodeltaxBT'):
                self.qmc.autodeltaxBT = bool(toBool(settings.value('autodeltaxBT',self.qmc.autodeltaxBT)))
            if settings.contains('locktimex_start'):
                self.qmc.locktimex_start = toInt(settings.value('locktimex_start',self.qmc.locktimex_start))
            if settings.contains('locktimex_end'):
                self.qmc.locktimex_end = toInt(settings.value('locktimex_end',self.qmc.locktimex_end))
            if settings.contains('chargemintime'):
                self.qmc.chargemintime = toInt(settings.value('chargemintime',self.qmc.chargemintime))
            self.qmc.legendloc = toInt(settings.value('legendloc',self.qmc.legendloc))
            if settings.contains('temp_grid'):
                self.qmc.temp_grid = bool(toBool(settings.value('temp_grid',self.qmc.temp_grid)))
            if settings.contains('time_grid'):
                self.qmc.time_grid = bool(toBool(settings.value('time_grid',self.qmc.time_grid)))
            settings.endGroup()

            # only set in (some) predefined machine setups:
            if filename and machine:
                settings.beginGroup('MachineSetup')
                if settings.contains('capacity'):
                    self.qmc.roastersize_setup = toFloat(settings.value('capacity',self.qmc.roastersize_setup))
                else:
                    self.qmc.roastersize_setup = 0
                if settings.contains('heating_type'):
                    self.qmc.roasterheating_setup = toInt(settings.value('heating_type',self.qmc.roasterheating_setup))
                else:
                    self.qmc.roasterheating_setup = 0
                settings.endGroup()

            if settings.contains('organization_setup'):
                self.qmc.organization_setup = toString(settings.value('organization_setup',self.qmc.organization_setup))
            if settings.contains('operator_setup'):
                self.qmc.operator_setup = toString(settings.value('operator_setup',self.qmc.operator_setup))
            if settings.contains('roastertype_setup'):
                self.qmc.roastertype_setup = toString(settings.value('roastertype_setup',self.qmc.roastertype_setup))
            if settings.contains('roastersize_setup'):
                self.qmc.roastersize_setup = toFloat(settings.value('roastersize_setup',self.qmc.roastersize_setup))
            if settings.contains('last_batchsize'):
                self.qmc.last_batchsize = toFloat(settings.value('last_batchsize',self.qmc.last_batchsize))
            # we set the default in-weight from the given last_batchsize
            self.qmc.weight = [self.qmc.last_batchsize,self.qmc.weight[1],self.qmc.weight[2]]
            if settings.contains('roasterheating_setup'):
                self.qmc.roasterheating_setup = toInt(settings.value('roasterheating_setup',self.qmc.roasterheating_setup))
            if settings.contains('drumspeed_setup'):
                self.qmc.drumspeed_setup = toString(settings.value('drumspeed_setup',self.qmc.drumspeed_setup))

            settings.beginGroup('EnergyUse')
            if settings.contains('loadlabels_setup'):
                self.qmc.loadlabels_setup = [toString(x) for x in toList(settings.value('loadlabels_setup'))]
            if settings.contains('loadratings_setup'):
                self.qmc.loadratings_setup = [toFloat(x) for x in toList(settings.value('loadratings_setup'))]
            if settings.contains('ratingunits_setup'):
                self.qmc.ratingunits_setup = [toInt(x) for x in toList(settings.value('ratingunits_setup'))]
            if settings.contains('sourcetypes_setup'):
                self.qmc.sourcetypes_setup = [toInt(x) for x in toList(settings.value('sourcetypes_setup'))]
            if settings.contains('load_etypes_setup'):
                self.qmc.load_etypes_setup = [toInt(x) for x in toList(settings.value('load_etypes_setup'))]
            if settings.contains('presssure_percents_setup'):
                self.qmc.presssure_percents_setup = [bool(toBool(x)) for x in toList(settings.value('presssure_percents_setup'))]
            if settings.contains('loadevent_zeropcts_setup'):
                self.qmc.loadevent_zeropcts_setup = [toInt(x) for x in toList(settings.value('loadevent_zeropcts_setup'))]
            if settings.contains('loadevent_hundpcts_setup'):
                self.qmc.loadevent_hundpcts_setup = [toInt(x) for x in toList(settings.value('loadevent_hundpcts_setup'))]
            if settings.contains('preheatDuration_setup'):
                self.qmc.preheatDuration_setup = toInt(settings.value('preheatDuration_setup',self.qmc.preheatDuration_setup))
            if settings.contains('preheatenergies_setup'):
                self.qmc.preheatenergies_setup = [toFloat(x) for x in toList(settings.value('preheatenergies_setup'))]
            if settings.contains('betweenbatchDuration_setup'):
                self.qmc.betweenbatchDuration_setup = toInt(settings.value('betweenbatchDuration_setup',self.qmc.betweenbatchDuration_setup))
            if settings.contains('betweenbatchenergies_setup'):
                self.qmc.betweenbatchenergies_setup = [toFloat(x) for x in toList(settings.value('betweenbatchenergies_setup'))]
            if settings.contains('coolingDuration_setup'):
                self.qmc.coolingDuration_setup = toInt(settings.value('coolingDuration_setup',self.qmc.coolingDuration_setup))
            if settings.contains('coolingenergies_setup'):
                self.qmc.coolingenergies_setup = [toFloat(x) for x in toList(settings.value('coolingenergies_setup'))]
            if settings.contains('betweenbatch_after_preheat_setup'):
                self.qmc.betweenbatch_after_preheat_setup = bool(toBool(settings.value('betweenbatch_after_preheat_setup',self.qmc.betweenbatch_after_preheat_setup)))
            if settings.contains('electricEnergyMix_setup'):
                self.qmc.electricEnergyMix_setup = toInt(settings.value('electricEnergyMix_setup',self.qmc.electricEnergyMix_setup))
            if settings.contains('energyresultunit_setup'):
                self.qmc.energyresultunit_setup = toInt(settings.value('energyresultunit_setup',self.qmc.energyresultunit_setup))
#            if settings.contains("energytablecolumnwidths"):
#                self.qmc.energytablecolumnwidths = [toInt(x) for x in toList(settings.value("energytablecolumnwidths",self.qmc.energytablecolumnwidths))]
            settings.endGroup()
            self.qmc.restoreEnergyLoadDefaults()
            self.qmc.restoreEnergyProtocolDefaults()

            settings.beginGroup('EnergyDefaults')
            if settings.contains('ratings'):
                self.qmc.machinesetup_energy_ratings = settings.value('ratings',self.qmc.machinesetup_energy_ratings)
            else:
                self.qmc.machinesetup_energy_ratings = None
            settings.endGroup()

            settings.beginGroup('RoastProperties')
            # copy setup from pre v1.4.6 RoastProperties organization,operator,roastertype,roastersize
            if self.qmc.organization_setup == '' and settings.contains('organization'):
                self.qmc.organization_setup = toString(settings.value('organization',self.qmc.organization_setup))
            if self.qmc.operator_setup == '' and settings.contains('operator'):
                self.qmc.operator_setup = toString(settings.value('operator',self.qmc.operator_setup))
            if self.qmc.roastertype_setup == '' and settings.contains('roastertype'):
                self.qmc.roastertype_setup = toString(settings.value('roastertype',self.qmc.roastertype_setup))
            if self.qmc.roastersize_setup == 0 and settings.contains('roastersize'):
                self.qmc.roastersize_setup = toFloat(settings.value('roastersize',self.qmc.roastersize_setup))
            if self.qmc.drumspeed_setup == '' and settings.contains('drumspeed'):
                self.qmc.drumspeed_setup = toString(settings.value('drumspeed',self.qmc.drumspeed_setup))
            # initialize profile setup values
            self.qmc.organization = self.qmc.organization_setup
            self.qmc.operator = self.qmc.operator_setup
            self.qmc.roastertype = self.qmc.roastertype_setup
            self.qmc.roastersize = self.qmc.roastersize_setup
            self.qmc.roasterheating = self.qmc.roasterheating_setup
            self.qmc.drumspeed = self.qmc.drumspeed_setup
            #
            if settings.contains('machinesetup'):
                self.qmc.machinesetup = toString(settings.value('machinesetup',self.qmc.machinesetup))
#            self.qmc.density[2] = toFloat(settings.value("densitySampleVolume",self.qmc.density[2])) # fixed to 1l now
            if settings.contains('beansize'):
                self.qmc.beansize = toFloat(settings.value('beansize',self.qmc.beansize))
            if settings.contains('beansize_min'):
                self.qmc.beansize_min = toInt(settings.value('beansize_min',self.qmc.beansize_min))
            if settings.contains('beansize_max'):
                self.qmc.beansize_max = toInt(settings.value('beansize_max',self.qmc.beansize_max))
            if filename is None and settings.contains('plus_default_store'):
                self.qmc.plus_default_store = toString(settings.value('plus_default_store',self.qmc.plus_default_store))
            if filename is None and settings.contains('plus_custom_blend_name'):
                # we don't import plus custom blend data from external settings file as the custom blend is considered temporary
                plus_custom_blend_name = toString(settings.value('plus_custom_blend_name',''))
                plus_custom_blend_coffees = [toString(x) for x in toList(settings.value('plus_custom_blend_coffees'))]
                plus_custom_blend_ratios = [toFloat(x) for x in toList(settings.value('plus_custom_blend_ratios'))]
                if plus_custom_blend_name != '' and len(plus_custom_blend_coffees)>1 and len(plus_custom_blend_ratios) == len(plus_custom_blend_coffees):
                    try:
                        plus_custom_blend_components = [plus.blend.Component(c,r) for (c,r) in zip(plus_custom_blend_coffees, plus_custom_blend_ratios)]
                        self.qmc.plus_custom_blend = plus.blend.Blend(
                            plus_custom_blend_name,
                            plus_custom_blend_components)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        self.qmc.plus_custom_blend = None
                else:
                    self.qmc.plus_custom_blend = None
            settings.endGroup()

            self.userprofilepath = toString(settings.value('profilepath',self.userprofilepath))
            if settings.contains('settingspath') and not filename:
                self.settingspath = toString(settings.value('settingspath',self.settingspath))
            if settings.contains('wheelpath'):
                self.wheelpath = toString(settings.value('wheelpath',self.wheelpath))
            if settings.contains('autosavepath'):
                self.qmc.autosavepath = toString(settings.value('autosavepath',self.qmc.autosavepath))
            if settings.contains('autosavealsopath'):
                self.qmc.autosavealsopath = toString(settings.value('autosavealsopath',self.qmc.autosavealsopath))
            if settings.contains('autosavealsopath'):
                self.simulatorpath = toString(settings.value('simulatorpath',self.simulatorpath))
            if settings.contains('externalprogram'):
                self.ser.externalprogram = toString(settings.value('externalprogram',self.ser.externalprogram))
            if settings.contains('externaloutprogram'):
                self.ser.externaloutprogram = toString(settings.value('externaloutprogram',self.ser.externaloutprogram))
            if settings.contains('externaloutprogramFlag'):
                self.ser.externaloutprogramFlag = bool(toBool(settings.value('externaloutprogramFlag',self.ser.externaloutprogramFlag)))
            if not theme:
                settings.beginGroup('ExtraDev')
                if settings.contains('extradevices'):
                    self.getExtraDeviceSettings(settings)
                if settings.contains('devicetablecolumnwidths'):
                    self.qmc.devicetablecolumnwidths = [toInt(x) for x in toList(settings.value('devicetablecolumnwidths',self.qmc.devicetablecolumnwidths))]
                settings.endGroup()

                # ensure that extra list length are of the size of the extradevices:
                self.ensureCorrectExtraDeviceListLenght()

                self.updateExtradeviceSettings()

            #restore curve styles
            settings.beginGroup('CurveStyles')
            if settings.contains('BTlinestyle'):
                self.qmc.BTlinestyle = s2a(toString(settings.value('BTlinestyle',self.qmc.BTlinestyle)))
                self.qmc.BTdrawstyle = s2a(toString(settings.value('BTdrawstyle',self.qmc.BTdrawstyle)))
                if self.qmc.BTdrawstyle == '-':
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = max(0.1,aw.float2float(toFloat(settings.value('BTlinewidth',self.qmc.BTlinewidth))))
                self.qmc.BTmarker = s2a(toString(settings.value('BTmarker',self.qmc.BTmarker)))
                self.qmc.BTmarkersize = max(0.1,aw.float2float(toFloat(settings.value('BTmarkersize',self.qmc.BTmarkersize))))
                self.qmc.ETlinestyle = s2a(toString(settings.value('ETlinestyle',self.qmc.ETlinestyle)))
                self.qmc.ETdrawstyle = s2a(toString(settings.value('ETdrawstyle',self.qmc.ETdrawstyle)))
                if self.qmc.ETdrawstyle == '-':
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = max(0.1,aw.float2float(toFloat(settings.value('ETlinewidth',self.qmc.ETlinewidth))))
                self.qmc.ETmarker = s2a(toString(settings.value('ETmarker',self.qmc.ETmarker)))
                self.qmc.ETmarkersize = max(0.1,aw.float2float(toFloat(settings.value('ETmarkersize',self.qmc.ETmarkersize))))
                self.qmc.BTdeltalinestyle = s2a(toString(settings.value('BTdeltalinestyle',self.qmc.BTdeltalinestyle)))
                self.qmc.BTdeltadrawstyle = s2a(toString(settings.value('BTdeltadrawstyle',self.qmc.BTdeltadrawstyle)))
                if self.qmc.BTdeltadrawstyle == '-':
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value('BTdeltalinewidth',self.qmc.BTdeltalinewidth))))
                self.qmc.BTdeltamarker = s2a(toString(settings.value('BTdeltamarker',self.qmc.BTdeltamarker)))
                self.qmc.BTdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value('BTdeltamarkersize',self.qmc.BTdeltamarkersize))))
                self.qmc.ETdeltalinestyle = s2a(toString(settings.value('ETdeltalinestyle',self.qmc.ETdeltalinestyle)))
                self.qmc.ETdeltadrawstyle = s2a(toString(settings.value('ETdeltadrawstyle',self.qmc.ETdeltadrawstyle)))
                if self.qmc.ETdeltadrawstyle == '-':
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value('ETdeltalinewidth',self.qmc.ETdeltalinewidth))))
                self.qmc.ETdeltamarker = s2a(toString(settings.value('ETdeltamarker',self.qmc.ETdeltamarker)))
                self.qmc.ETdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value('ETdeltamarkersize',self.qmc.ETdeltamarkersize))))
                self.qmc.BTbacklinestyle = s2a(toString(settings.value('BTbacklinestyle',self.qmc.BTbacklinestyle)))
                self.qmc.BTbackdrawstyle = s2a(toString(settings.value('BTbackdrawstyle',self.qmc.BTbackdrawstyle)))
                if self.qmc.BTbackdrawstyle == '-':
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value('BTbacklinewidth',self.qmc.BTbacklinewidth))))
                self.qmc.BTbackmarker = s2a(toString(settings.value('BTbackmarker',self.qmc.BTbackmarker)))
                self.qmc.BTbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value('BTbackmarkersize',self.qmc.BTbackmarkersize))))
                self.qmc.ETbacklinestyle = s2a(toString(settings.value('ETbacklinestyle',self.qmc.ETbacklinestyle)))
                self.qmc.ETbackdrawstyle = s2a(toString(settings.value('ETbackdrawstyle',self.qmc.ETbackdrawstyle)))
                if self.qmc.ETbackdrawstyle == '-':
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value('ETbacklinewidth',self.qmc.ETbacklinewidth))))
                self.qmc.ETbackmarker = s2a(toString(settings.value('ETbackmarker',self.qmc.ETbackmarker)))
                self.qmc.ETbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value('ETbackmarkersize',self.qmc.ETbackmarkersize))))

                self.qmc.XTbacklinestyle = s2a(toString(settings.value('XTbacklinestyle',self.qmc.XTbacklinestyle)))
                self.qmc.XTbackdrawstyle = s2a(toString(settings.value('XTbackdrawstyle',self.qmc.XTbackdrawstyle)))
                if self.qmc.XTbackdrawstyle == '-':
                    self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.XTbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value('XTbacklinewidth',self.qmc.XTbacklinewidth))))
                self.qmc.XTbackmarker = s2a(toString(settings.value('XTbackmarker',self.qmc.XTbackmarker)))
                self.qmc.XTbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value('XTbackmarkersize',self.qmc.XTbackmarkersize))))
                self.qmc.YTbacklinestyle = s2a(toString(settings.value('YTbacklinestyle',self.qmc.XTbacklinestyle)))
                self.qmc.YTbackdrawstyle = s2a(toString(settings.value('YTbackdrawstyle',self.qmc.YTbackdrawstyle)))
                if self.qmc.YTbackdrawstyle == '-':
                    self.qmc.YTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.YTbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value('YTbacklinewidth',self.qmc.YTbacklinewidth))))
                self.qmc.YTbackmarker = s2a(toString(settings.value('YTbackmarker',self.qmc.YTbackmarker)))
                self.qmc.YTbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value('YTbackmarkersize',self.qmc.YTbackmarkersize))))

                self.getExtraDeviceCurveStyles(settings)

                self.qmc.BTBdeltalinestyle = s2a(toString(settings.value('BTBdeltalinestyle',self.qmc.BTBdeltalinestyle)))
                self.qmc.BTBdeltadrawstyle = s2a(toString(settings.value('BTBdeltadrawstyle',self.qmc.BTBdeltadrawstyle)))

                self.qmc.BTBdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value('BTBdeltalinewidth',self.qmc.BTBdeltalinewidth))))
                self.qmc.BTBdeltamarker = s2a(toString(settings.value('BTBdeltamarker',self.qmc.BTBdeltamarker)))
                self.qmc.BTBdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value('BTBdeltamarkersize',self.qmc.BTBdeltamarkersize))))
                self.qmc.ETBdeltalinestyle = s2a(toString(settings.value('ETBdeltalinestyle',self.qmc.ETBdeltalinestyle)))
                self.qmc.ETBdeltadrawstyle = s2a(toString(settings.value('ETBdeltadrawstyle',self.qmc.ETBdeltadrawstyle)))

                self.qmc.ETBdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value('ETBdeltalinewidth',self.qmc.ETBdeltalinewidth))))
                self.qmc.ETBdeltamarker = s2a(toString(settings.value('ETBdeltamarker',self.qmc.ETBdeltamarker)))
                self.qmc.ETBdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value('ETBdeltamarkersize',self.qmc.ETBdeltamarkersize))))
            settings.endGroup()

            # Extra com ports
            settings.beginGroup('ExtraComm')
            if settings.contains('extracomport'):
                self.getExtraDeviceCommSettings(settings)
            settings.endGroup()
            if settings.contains('ChannelTares'):
                self.channel_tare_values = [toFloat(x) for x in toList(settings.value('ChannelTares',self.channel_tare_values))]
            if settings.contains('BTfunction'):
                self.qmc.BTfunction = s2a(toString(settings.value('BTfunction',self.qmc.BTfunction)))
            if settings.contains('ETfunction'):
                self.qmc.ETfunction = s2a(toString(settings.value('ETfunction',self.qmc.ETfunction)))
            if settings.contains('DeltaBTfunction'):
                self.qmc.DeltaBTfunction = s2a(toString(settings.value('DeltaBTfunction',self.qmc.DeltaBTfunction)))
                self.qmc.DeltaETfunction = s2a(toString(settings.value('DeltaETfunction',self.qmc.DeltaETfunction)))
            if settings.contains('plotcurves'):
                self.qmc.plotcurves = list(toStringList(settings.value('plotcurves',self.qmc.plotcurves)))
                self.qmc.plotcurvecolor = list(toStringList(settings.value('plotcurvecolor',self.qmc.plotcurvecolor)))
                for i in range(len(self.qmc.plotcurves)):
                    self.qmc.plotcurves[i] = str(self.qmc.plotcurves[i])
                    self.qmc.plotcurvecolor[i] = str(self.qmc.plotcurvecolor[i])
                #convert to 9
                if len(self.qmc.plotcurves) == 6:
                    self.qmc.plotcurves += ['','','']
                    self.qmc.plotcurvecolor += ['black','black','black']
            settings.beginGroup('RoRlimits')
            if settings.contains('RoRlimitFlag'):
                self.qmc.RoRlimitFlag = bool(toBool(settings.value('RoRlimitFlag',self.qmc.RoRlimitFlag)))
                self.qmc.RoRlimit = toInt(settings.value('RoRlimit',self.qmc.RoRlimit))
                self.qmc.RoRlimitm = toInt(settings.value('RoRlimitm',self.qmc.RoRlimitm))
            settings.endGroup()
            settings.beginGroup('grid')
            if settings.contains('xgrid'):
                self.qmc.xgrid = toInt(settings.value('xgrid',self.qmc.xgrid))
                self.qmc.ygrid = max(0,toInt(settings.value('ygrid',self.qmc.ygrid)))
                self.qmc.zgrid = max(0,toInt(settings.value('zgrid',self.qmc.zgrid)))
                self.qmc.gridthickness = toInt(settings.value('gridthickness',self.qmc.gridthickness))
#                self.qmc.xrotation = toInt(settings.value("xrotation",self.qmc.xrotation))
                self.qmc.gridlinestyle = toInt(settings.value('gridlinestyle',self.qmc.gridlinestyle))
                self.qmc.gridalpha = toFloat(settings.value('gridalpha',self.qmc.gridalpha))
            settings.endGroup()
            if settings.contains('titleshowalways'):
                self.qmc.title_show_always = bool(toBool(settings.value('titleshowalways',aw.qmc.title_show_always)))
            if settings.contains('roastpropertiesflag'):
                self.qmc.roastpropertiesflag = toInt(settings.value('roastpropertiesflag',self.qmc.roastpropertiesflag))
            if settings.contains('roastpropertiesAutoOpenFlag'):
                self.qmc.roastpropertiesAutoOpenFlag = toInt(settings.value('roastpropertiesAutoOpenFlag',self.qmc.roastpropertiesAutoOpenFlag))
            if settings.contains('roastpropertiesAutoOpenDropFlag'):
                self.qmc.roastpropertiesAutoOpenDropFlag = toInt(settings.value('roastpropertiesAutoOpenDropFlag',self.qmc.roastpropertiesAutoOpenDropFlag))
            if settings.contains('customflavorlabels'):
                self.qmc.customflavorlabels = list(map(str,list(toStringList(settings.value('customflavorlabels',self.qmc.customflavorlabels)))))
            #restore sliders
            settings.beginGroup('Sliders')
            if settings.contains('slidervisibilities'):
                self.eventslidervisibilities = [toInt(x) for x in toList(settings.value('slidervisibilities',self.eventslidervisibilities))]
                self.eventslideractions = [toInt(x) for x in toList(settings.value('slideractions',self.eventslideractions))]
                self.eventslidercommands = list(map(str,list(toStringList(settings.value('slidercommands',self.eventslidercommands)))))
                self.eventslideroffsets = [toFloat(x) for x in toList(settings.value('slideroffsets',self.eventslideroffsets))]
                self.eventsliderfactors = [toFloat(x) for x in toList(settings.value('sliderfactors',self.eventsliderfactors))]
            if settings.contains('slidermin'):
                self.eventslidermin = [toInt(x) for x in toList(settings.value('slidermin',self.eventslidermin))]
                self.eventslidermax = [toInt(x) for x in toList(settings.value('slidermax',self.eventslidermax))]
                aw.updateSliderMinMax()
            if settings.contains('eventslidersflags'):
                self.eventslidersflags = [toInt(x) for x in toList(settings.value('eventslidersflags',self.eventslidersflags))]
            if settings.contains('eventsliderBernoulli'):
                self.eventsliderBernoulli = [toInt(x) for x in toList(settings.value('eventsliderBernoulli',self.eventsliderBernoulli))]
            if settings.contains('eventslidercoarse'):
                self.eventslidercoarse = [toInt(x) for x in toList(settings.value('eventslidercoarse',self.eventslidercoarse))]
            if settings.contains('eventslidertemp'):
                self.eventslidertemp = [toInt(x) for x in toList(settings.value('eventslidertemp',self.eventslidertemp))]
            if settings.contains('eventsliderunits'):
                self.eventsliderunits = list(map(str,list(toStringList(settings.value('eventsliderunits',self.eventsliderunits)))))
            if settings.contains('ModeTempSliders'):
                self.qmc.mode_tempsliders = str(settings.value('ModeTempSliders',self.qmc.mode_tempsliders))
            settings.endGroup()
            self.qmc.adjustTempSliders() # adjust min/max slider limits of temperature sliders to correspond to the current temp mode
            aw.slidersAction.setEnabled(any(aw.eventslidervisibilities) or aw.pidcontrol.svSlider)
            if app.artisanviewerMode:
                aw.slidersAction.setEnabled(False)
            #restore quantifier
            settings.beginGroup('Quantifiers')
            if settings.contains('quantifieractive'):
                self.eventquantifieractive = [toInt(x) for x in toList(settings.value('quantifieractive',self.eventquantifieractive))]
                self.eventquantifiersource = [toInt(x) for x in toList(settings.value('quantifiersource',self.eventquantifiersource))]
                self.eventquantifiermin = [toInt(x) for x in toList(settings.value('quantifiermin',self.eventquantifiermin))]
                self.eventquantifiermax = [toInt(x) for x in toList(settings.value('quantifiermax',self.eventquantifiermax))]
                if settings.contains('quantifiercoarse'):
                    self.eventquantifiercoarse = [toInt(x) for x in toList(settings.value('quantifiercoarse',self.eventquantifiercoarse))]
                    if settings.contains('clusterEventsFlag'):
                        self.clusterEventsFlag = bool(toBool(settings.value('clusterEventsFlag',aw.clusterEventsFlag)))
                if settings.contains('eventquantifieraction'):
                    self.eventquantifieraction = [toInt(x) for x in toList(settings.value('eventquantifieraction',self.eventquantifieraction))]
                if settings.contains('eventquantifierSV'):
                    self.eventquantifierSV = [toInt(x) for x in toList(settings.value('eventquantifierSV',self.eventquantifierSV))]
            settings.endGroup()
            settings.beginGroup('Batch')
            if settings.contains('batchcounter'):
                if updateBatchCounter:
                    aw.qmc.batchcounter = toInt(settings.value('batchcounter',aw.qmc.batchcounter))
                aw.qmc.batchprefix = toString(settings.value('batchprefix',aw.qmc.batchprefix))
                if filename is None:
                    # we do not load those two from setting files!
                    aw.qmc.batchsequence = toInt(settings.value('batchsequence',aw.qmc.batchsequence))
                    aw.qmc.lastroastepoch = toInt(settings.value('lastroastepoch',aw.qmc.lastroastepoch))
            settings.endGroup()
            self.computeLinespaces()
            self.updateSlidersProperties()
            #restore background profile settings
            settings.beginGroup('background')
            if settings.contains('backgrounddetails'):
                aw.qmc.backgroundDetails = bool(toBool(settings.value('backgrounddetails',aw.qmc.backgroundDetails)))
                aw.qmc.backgroundeventsflag = bool(toBool(settings.value('backgroundevents',aw.qmc.backgroundeventsflag)))
                aw.qmc.DeltaETBflag = bool(toBool(settings.value('DeltaETB',aw.qmc.DeltaETBflag)))
                aw.qmc.DeltaBTBflag = bool(toBool(settings.value('DeltaBTB',aw.qmc.DeltaBTBflag)))
                if settings.contains('alignEvent'):
                    aw.qmc.alignEvent = toInt(settings.value('alignEvent',aw.qmc.alignEvent))
                if settings.contains('movespeed'):
                    aw.qmc.backgroundmovespeed = toInt(settings.value('movespeed',aw.qmc.backgroundmovespeed))
            if settings.contains('ETBflag'):
                aw.qmc.backgroundETcurve = bool(toBool(settings.value('ETBflag',aw.qmc.backgroundETcurve)))
                aw.qmc.backgroundBTcurve = bool(toBool(settings.value('BTBflag',aw.qmc.backgroundBTcurve)))
            if settings.contains('backgroundShowFullflag'):
                aw.qmc.backgroundShowFullflag = bool(toBool(settings.value('backgroundShowFullflag',aw.qmc.backgroundShowFullflag)))
            if settings.contains('clearBgbeforeprofileload'):
                aw.qmc.clearBgbeforeprofileload = bool(toBool(settings.value('clearBgbeforeprofileload',aw.qmc.clearBgbeforeprofileload)))
            if settings.contains('hideBgafterprofileload'):
                aw.qmc.hideBgafterprofileload = bool(toBool(settings.value('hideBgafterprofileload',aw.qmc.hideBgafterprofileload)))
            settings.endGroup()
            if settings.contains('compareAlignEvent'):
                aw.qmc.compareAlignEvent = toInt(settings.value('compareAlignEvent',aw.qmc.compareAlignEvent))
            if settings.contains('compareEvents'):
                aw.qmc.compareEvents = toInt(settings.value('compareEvents',aw.qmc.compareEvents))
            if settings.contains('compareET'):
                self.qmc.compareET = bool(toBool(settings.value('compareET',self.qmc.compareET)))
            if settings.contains('compareBT'):
                self.qmc.compareBT = bool(toBool(settings.value('compareBT',self.qmc.compareBT)))
            if settings.contains('compareDeltaET'):
                self.qmc.compareDeltaET = bool(toBool(settings.value('compareDeltaET',self.qmc.compareDeltaET)))
            if settings.contains('compareDeltaBT'):
                self.qmc.compareDeltaBT = bool(toBool(settings.value('compareDeltaBT',self.qmc.compareDeltaBT)))
            if settings.contains('compareMainEvents'):
                self.qmc.compareMainEvents = bool(toBool(settings.value('compareMainEvents',self.qmc.compareMainEvents)))
            if settings.contains('compareBBP'):
                self.qmc.compareBBP = bool(toBool(settings.value('compareBBP',self.qmc.compareBBP)))
            if settings.contains('compareRoast'):
                self.qmc.compareRoast = bool(toBool(settings.value('compareRoast',self.qmc.compareRoast)))
            if settings.contains('autosaveflag'):
                self.qmc.autosaveflag = toInt(settings.value('autosaveflag',self.qmc.autosaveflag))
            if settings.contains('autosaveaddtorecentfilesflag'):
                self.qmc.autosaveaddtorecentfilesflag = bool(toBool(settings.value('autosaveaddtorecentfilesflag',self.qmc.autosaveaddtorecentfilesflag)))
            if settings.contains('autosavepdf'):
                self.qmc.autosaveimage = bool(toBool(settings.value('autosavepdf',self.qmc.autosaveimage)))
            if settings.contains('autosaveimageformat'):
                self.qmc.autosaveimageformat = toString(settings.value('autosaveimageformat',self.qmc.autosaveimageformat))
            if settings.contains('autosaveprefix'):
                self.qmc.autosaveprefix = toString(settings.value('autosaveprefix',self.qmc.autosaveprefix))
            # WebLCDs
            settings.beginGroup('WebLCDs')
            if settings.contains('active'):
                self.WebLCDs = bool(toBool(settings.value('active',self.WebLCDs)))
                self.WebLCDsPort = toInt(settings.value('port',self.WebLCDsPort))
                self.WebLCDsAlerts = bool(toBool(settings.value('alerts',self.WebLCDsAlerts)))
            settings.endGroup()
            if settings.contains('LargeLCDs'):
                self.LargeLCDsFlag = toBool(settings.value('LargeLCDs',self.LargeLCDsFlag))
            if self.LargeLCDsFlag:
                self.largeLCDs()
            if settings.contains('LargeDeltaLCDs'):
                self.LargeDeltaLCDsFlag = toBool(settings.value('LargeDeltaLCDs',self.LargeDeltaLCDsFlag))
            if self.LargeDeltaLCDsFlag:
                self.largeDeltaLCDs()
            if settings.contains('LargePIDLCDs'):
                self.LargePIDLCDsFlag = toBool(settings.value('LargePIDLCDs',self.LargePIDLCDsFlag))
            if self.LargePIDLCDsFlag:
                self.largePIDLCDs()
            if settings.contains('LargeScaleLCDs'):
                self.LargeScaleLCDsFlag = toBool(settings.value('LargeScaleLCDs',self.LargeScaleLCDsFlag))
            if self.LargeScaleLCDsFlag:
                self.largeScaleLCDs()
            if settings.contains('LargeExtraLCDs'):
                self.LargeExtraLCDsFlag = toBool(settings.value('LargeExtraLCDs',self.LargeExtraLCDsFlag))
            if self.LargeExtraLCDsFlag:
                self.largeExtraLCDs()
            if settings.contains('LargePhasesLCDs'):
                self.LargePhasesLCDsFlag = toBool(settings.value('LargePhasesLCDs',self.LargePhasesLCDsFlag))
            if self.LargePhasesLCDsFlag:
                self.largePhasesLCDs()
            # start server if needed
            if self.WebLCDs:
                self.startWebLCDs(force=True)
            #restore buttons
            settings.beginGroup('ExtraEventButtons')
            if settings.contains('extraeventsactions'):
                if settings.contains('buttonlistmaxlen'):
                    self.buttonlistmaxlen = toInt(settings.value('buttonlistmaxlen',self.buttonlistmaxlen))
                if settings.contains('extraeventsbuttonsflags'):
                    self.extraeventsbuttonsflags = [toInt(x) for x in toList(settings.value('extraeventsbuttonsflags',self.extraeventsbuttonsflags))]
                self.extraeventstypes = [toInt(x) for x in toList(settings.value('extraeventstypes',self.extraeventstypes))]
                self.extraeventsvalues = [toFloat(x) for x in toList(settings.value('extraeventsvalues',self.extraeventsvalues))]
                self.extraeventsactions = [toInt(x) for x in toList(settings.value('extraeventsactions',self.extraeventsactions))]
                self.extraeventsvisibility = [toInt(x) for x in toList(settings.value('extraeventsvisibility',self.extraeventsvisibility))]
                self.extraeventsactionstrings = list(toStringList(settings.value('extraeventsactionstrings',self.extraeventsactionstrings)))
                self.extraeventslabels = list(toStringList(settings.value('extraeventslabels',self.extraeventslabels)))
                self.extraeventsdescriptions= list(toStringList(settings.value('extraeventsdescriptions',self.extraeventsdescriptions)))
                if settings.contains('extraeventbuttoncolor'):
                    self.extraeventbuttoncolor = list(toStringList(settings.value('extraeventbuttoncolor',self.extraeventbuttoncolor)))
                    self.extraeventbuttontextcolor = list(toStringList(settings.value('extraeventbuttontextcolor',self.extraeventbuttontextcolor)))
                else:
                    self.extraeventbuttoncolor = ['yellow']*len(self.extraeventstypes)
                    self.extraeventbuttontextcolor = ['black']*len(self.extraeventstypes)
                if settings.contains('buttonpalette'):
                    self.buttonpalettemaxlen = [min(30,max(6,toInt(x))) for x in toList(settings.value('buttonpalettemaxlen',self.buttonpalettemaxlen))]
                    self.buttonpalette = toList(settings.value('buttonpalette',self.buttonpalette))
                    if self.buttonpalette is None:
                        self.buttonpalette = [[],[],[],[],[],[],[],[],[],[]] # initialize empty palettes
                    else:
                        self.buttonpalette = self.buttonpalette[:10] # maximal 10 palettes are supported
                    for i in range(len(self.buttonpalette)):
                        if self.buttonpalette[i] is None:
                            self.buttonpalette[i] = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],'']
                        if len(self.buttonpalette[i]) != 26:
                            self.buttonpalette[i] = self.buttonpalette[i] + [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],''][len(self.buttonpalette[i]):]
                for i in range(len(self.extraeventsactionstrings)):
                    self.extraeventsactionstrings[i] = self.extraeventsactionstrings[i]
                    self.extraeventslabels[i] = self.extraeventslabels[i]
                    self.extraeventsdescriptions[i] = self.extraeventsdescriptions[i]
                    self.extraeventbuttoncolor[i] = str(self.extraeventbuttoncolor[i])
                    self.extraeventbuttontextcolor[i] = str(self.extraeventbuttontextcolor[i])
                if settings.contains('buttonpalette_shortcuts'):
                    self.buttonpalette_shortcuts = bool(toBool(settings.value('buttonpalette_shortcuts',self.buttonpalette_shortcuts)))
                if settings.contains('eventbuttontablecolumnwidths'):
                    self.eventbuttontablecolumnwidths = [toInt(x) for x in toList(settings.value('eventbuttontablecolumnwidths',self.eventbuttontablecolumnwidths))]
                if settings.contains('buttonsize'):
                    self.buttonsize = toInt(settings.value('buttonsize',self.buttonsize))
                if settings.contains('buttonpalette_label'):
                    self.buttonpalette_label = toString(settings.value('buttonpalette_label',self.buttonpalette_label))
            settings.endGroup()
            # Extras more info
            settings.beginGroup('ExtrasMoreInfo')
            if settings.contains('showmet'):
                self.qmc.showmet = bool(toBool(settings.value('showmet',self.qmc.showmet)))
            if settings.contains('statssummary'):
                self.qmc.statssummary = bool(toBool(settings.value('statssummary')))
                if self.qmc.statssummary:
                    self.savestatisticsAction.setEnabled(True)
                else:
                    self.savestatisticsAction.setEnabled(False)
            if settings.contains('statsmaxchrperline'):
                self.qmc.statsmaxchrperline = int(settings.value('statsmaxchrperline', aw.qmc.statsmaxchrperline))
            if settings.contains('showtimeguide'):
                self.qmc.showtimeguide = bool(toBool(settings.value('showtimeguide',self.qmc.showtimeguide)))
            settings.endGroup()

            # recent roasts
            if settings.contains('recentRoasts'):
                try:
                    rr = settings.value('recentRoasts',self.recentRoasts)
                    if rr is not None:
                        self.recentRoasts = rr
                    else:
                        self.recentRoasts = []
                except Exception: # pylint: disable=broad-except
                    pass
            try:
                self.updateNewMenuRecentRoasts()
            except Exception: # pylint: disable=broad-except
                pass

#            #update axis limits
#            if not self.qmc.locktimex:
#                self.qmc.startofx = self.qmc.chargemintime # self.qmc.locktimex_start
#                self.qmc.endofx = self.qmc.locktimex_end
#            if self.qmc.endofx < 1:
#                self.qmc.endofx = 60

            # used on startup to reload previous loaded profiles
            if settings.contains('lastLoadedProfile'):
                aw.lastLoadedProfile = toString(settings.value('lastLoadedProfile',aw.curFile))
            if settings.contains('lastLoadedBackground'):
                aw.lastLoadedBackground = toString(settings.value('lastLoadedBackground',aw.qmc.backgroundpath))

            #watermark image
            if settings.contains('logoimgalpha'):
                self.logoimgalpha = toFloat(settings.value('logoimgalpha'))
            if settings.contains('logoimgflag'):
                self.logoimgflag = bool(toBool(settings.value('logoimgflag', self.logoimgflag)))
            if settings.contains('logofilename'):
                self.logofilename = toString(settings.value('logofilename'))

            res = True

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            res = False
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate('Error Message', 'Error'),QApplication.translate('Error Message', 'Exception:') + '  settingsLoad()  @line ' + str(getattr(exc_tb, 'tb_lineno', '?')))

#--------------------------------
        try:
            aw.setFonts(redraw=redraw) # this one triggers a redraw by default to establish the correct fonts
            # only after this the correct aspect ratio of the qmc canvas is set

            if len(self.logofilename) > 0:
                self.qmc.logoloadfile(self.logofilename)

            # set window appearances (style)
            if settings.contains('appearance'):
                try:
                    available = list(map(str, list(QStyleFactory.keys())))
                    i = list(map(lambda x:x.lower(),available)).index(toString(settings.value('appearance')))
                    app.setStyle(available[i])
                    aw.appearance = available[i].lower()
                except Exception: # pylint: disable=broad-except
                    pass # appearance not in list of available once on this platform

            # set dpi
            if filename is not None and settings.contains('dpi'):
                # if filename is None (ie. setting is not explicitly loaded from file, but from default location on app start),
                # the dpi is set on creating the FigureCanvas
                try:
                    if aw.dpi != toInt(settings.value('dpi',aw.dpi)):
                        aw.setdpi(toInt(settings.value('dpi',aw.dpi)),moveWindow=True)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            #restore geometry
            if settings.contains('Geometry'):
                self.restoreGeometry(settings.value('Geometry'))
            if not filename: # only if an external settings file is loaded
                FigureCanvas.updateGeometry(aw.qmc)  #@UndefinedVariable

            #update visibility of main event button, extra event buttons and
            self.applyStandardButtonVisibility()

            self.updateExtraButtonsVisibility()

            #update individual visibility of each buttons
            self.realignbuttons()

            # swap BT/ET lcds if needed
            if self.qmc.swaplcds != old_swaplcds:
                tmp = QWidget()
                tmp.setLayout(self.LCD2frame.layout())
                self.LCD2frame.setLayout(self.LCD3frame.layout())
                self.LCD3frame.setLayout(tmp.layout())
                if self.largeLCDs_dialog is not None:
                    self.largeLCDs_dialog.reLayout()
            # swap DeltaBT/ET lcds if needed
            if self.qmc.swapdeltalcds != old_swapdeltalcds:
                tmp = QWidget()
                tmp.setLayout(self.LCD4frame.layout())
                self.LCD4frame.setLayout(self.LCD5frame.layout())
                self.LCD5frame.setLayout(tmp.layout())

            self.qmc.clearLCDs()

            self.updateSlidersVisibility() # update visibility of sliders based on the users preference
            self.update_minieventline_visibility()
            self.updateReadingsLCDsVisibility() # update visibility of reading LCD based on the users preference

            if filename is None and self.full_screen_mode_active:
                self.showFullScreen()
                if not (platf == 'Darwin' and self.qmc.locale_str == 'en'):
                    aw.fullscreenAction.setChecked(True)

            if filename is None and self.plus_account is not None:
                try:
                    plus.controller.start(aw)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

            # this one has done here, if it is done on start of the section the slider title colors are not set correctly on Linux and macOS
            if 'canvas' in aw.qmc.palette:
                aw.updateCanvasColors(checkColors=False)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            res = False
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate('Error Message', 'Error'),QApplication.translate('Error Message', 'Exception:') + ' settingsLoad()  @line ' + str(getattr(exc_tb, 'tb_lineno', '?')))
        return res

    def startWebLCDs(self,force=False):
        try:
            if not app.artisanviewerMode and not self.WebLCDs or force:
                from artisanlib.weblcds import startWeb
                res = startWeb(
                    self.WebLCDsPort,
                    str(getResourcePath()),
                    ('&nbsp;&nbsp;-.-' if aw.qmc.LCDdecimalplaces else '&nbsp;--'),
                    aw.lcdpaletteF['timer'],
                    aw.lcdpaletteB['timer'],
                    aw.lcdpaletteF['bt'],
                    aw.lcdpaletteB['bt'],
                    aw.lcdpaletteF['et'],
                    aw.lcdpaletteB['et'],
                    aw.qmc.ETlcd,
                    aw.qmc.BTlcd)
                if res:
                    self.WebLCDs = True
                    return True
                self.stopWebLCDs()
                self.WebLCDs = False
                return False
            return False
        except ModuleNotFoundError:
            aw.qmc.adderror(QApplication.translate('Error Message','Exception: WebLCDs not supported by this build'))
            self.stopWebLCDs()
            self.WebLCDs = False
            return False
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' startWebLCDs() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            self.stopWebLCDs()
            self.WebLCDs = False
            return False

    def stopWebLCDs(self):
        try:
            from artisanlib.weblcds import stopWeb
            stopWeb()
            self.WebLCDs = False
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def applyStandardButtonVisibility(self):
        if self.eventsbuttonflag:
            self.buttonEVENT.setVisible(True)
        else:
            self.buttonEVENT.setVisible(False)
        #set default button visibility
        for i in range(8):
            self.keyboardButtonList[i].setVisible(bool(self.qmc.buttonvisibility[i]))
            self.keyboardButtonList[i].setSelected(False)

    @staticmethod
    def getColor(line):
        c = line.get_color()
        if isinstance(c, (list, tuple)):
            c = mpl.colors.rgb2hex(c)
        return c

    def fetchCurveStyles(self):
        try:
            if self.qmc.l_temp1 is not None:
                self.qmc.ETlinestyle = self.qmc.l_temp1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                # otherwise the drawingstyle cannot be set back to default!
                if self.qmc.ETlinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdrawstyle = self.qmc.l_temp1.get_drawstyle()
                else:
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = self.qmc.l_temp1.get_linewidth()
                m = self.qmc.l_temp1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETmarker = m
                self.qmc.palette['et'] = self.getColor(self.qmc.l_temp1)
            if self.qmc.l_temp2 is not None:
                self.qmc.BTlinestyle = self.qmc.l_temp2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTlinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdrawstyle = self.qmc.l_temp2.get_drawstyle()
                else:
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = self.qmc.l_temp2.get_linewidth()
                m = self.qmc.l_temp2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTmarker = m
                self.qmc.BTmarkersize = self.qmc.l_temp2.get_markersize()
                self.qmc.palette['bt'] = self.getColor(self.qmc.l_temp2)
            if self.qmc.l_delta1 is not None:
                self.qmc.ETdeltalinestyle = self.qmc.l_delta1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdeltadrawstyle = self.qmc.l_delta1.get_drawstyle()
                else:
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = self.qmc.l_delta1.get_linewidth()
                m = self.qmc.l_delta1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETdeltamarker = m
                self.qmc.ETdeltamarkersize = self.qmc.l_delta1.get_markersize()
                self.qmc.palette['deltaet'] = self.getColor(self.qmc.l_delta1)
            if self.qmc.l_delta2 is not None:
                self.qmc.BTdeltalinestyle = self.qmc.l_delta2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdeltadrawstyle = self.qmc.l_delta2.get_drawstyle()
                else:
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = self.qmc.l_delta2.get_linewidth()
                m = self.qmc.l_delta2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTdeltamarker = m
                self.qmc.BTdeltamarkersize = self.qmc.l_delta2.get_markersize()
                self.qmc.palette['deltabt'] = self.getColor(self.qmc.l_delta2)
            if self.qmc.l_back1 is not None:
                self.qmc.ETbacklinestyle = self.qmc.l_back1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.ETbackdrawstyle = self.qmc.l_back1.get_drawstyle()
                else:
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = self.qmc.l_back1.get_linewidth()
                m = self.qmc.l_back1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETbackmarker = m
                self.qmc.ETbackmarkersize = self.qmc.l_back1.get_markersize()
                self.qmc.backgroundmetcolor = self.getColor(self.qmc.l_back1)
            if self.qmc.l_back2 is not None:
                self.qmc.BTbacklinestyle = self.qmc.l_back2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.BTbackdrawstyle = self.qmc.l_back2.get_drawstyle()
                else:
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = self.qmc.l_back2.get_linewidth()
                m = self.qmc.l_back2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTbackmarker = m
                self.qmc.BTbackmarkersize = self.qmc.l_back2.get_markersize()
                self.qmc.backgroundbtcolor = self.getColor(self.qmc.l_back2)
            if self.qmc.l_back3 is not None:
                self.qmc.XTbacklinestyle = self.qmc.l_back3.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.XTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.XTbackdrawstyle = self.qmc.l_back3.get_drawstyle()
                else:
                    self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.XTbacklinewidth = self.qmc.l_back3.get_linewidth()
                m = self.qmc.l_back3.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.XTbackmarker = m
                self.qmc.XTbackmarkersize = self.qmc.l_back3.get_markersize()
                self.qmc.backgroundxtcolor = self.getColor(self.qmc.l_back3)
            if self.qmc.l_back4 is not None:
                self.qmc.YTbacklinestyle = self.qmc.l_back4.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.YTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.YTbackdrawstyle = self.qmc.l_back4.get_drawstyle()
                else:
                    self.qmc.YTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.YTbacklinewidth = self.qmc.l_back4.get_linewidth()
                m = self.qmc.l_back4.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.YTbackmarker = m
                self.qmc.YTbackmarkersize = self.qmc.l_back4.get_markersize()
                self.qmc.backgroundytcolor = self.getColor(self.qmc.l_back4)
            if self.qmc.l_delta1B is not None:
                self.qmc.ETBdeltalinestyle = self.qmc.l_delta1B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETBdeltadrawstyle = self.qmc.l_delta1B.get_drawstyle()
                else:
                    self.qmc.ETBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETBdeltalinewidth = self.qmc.l_delta1B.get_linewidth()
                m = self.qmc.l_delta1B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETBdeltamarker = m
                self.qmc.ETBdeltamarkersize = self.qmc.l_delta1B.get_markersize()
                self.qmc.backgrounddeltaetcolor = self.getColor(self.qmc.l_delta1B)
            if self.qmc.l_delta2B is not None:
                self.qmc.BTBdeltalinestyle = self.qmc.l_delta2B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTBdeltadrawstyle = self.qmc.l_delta2B.get_drawstyle()
                else:
                    self.qmc.BTBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTBdeltalinewidth = self.qmc.l_delta2B.get_linewidth()
                m = self.qmc.l_delta2B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTBdeltamarker = m
                self.qmc.BTBdeltamarkersize = self.qmc.l_delta2B.get_markersize()
                self.qmc.backgrounddeltabtcolor = self.getColor(self.qmc.l_delta2B)
            x1 = x2 = 0
            for i in range(len(self.qmc.extradevices)):
                if len(self.extraCurveVisibility1)> i and self.extraCurveVisibility1[i] and len(self.qmc.extratemp1lines) > x1:
                    l1 = self.qmc.extratemp1lines[x1]
                    self.qmc.extralinestyles1[i] = l1.get_linestyle()
                    if self.qmc.extralinestyles1[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles1[i] = l1.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles1[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths1[i] = l1.get_linewidth()
                    m = l1.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers1[i] = m
                    self.qmc.extramarkersizes1[i] = l1.get_markersize()
                    self.qmc.extradevicecolor1[i] = self.getColor(l1)
                    self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                    self.qmc.extraname1[i] = l1.get_label()
                    x1 = x1 + 1
                if len(self.extraCurveVisibility2)> i and self.extraCurveVisibility2[i] and len(self.qmc.extratemp2lines) > x2:
                    l2 = self.qmc.extratemp2lines[x2]
                    self.qmc.extralinestyles2[i] = l2.get_linestyle()
                    if self.qmc.extralinestyles2[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles2[i] = l2.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles2[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths2[i] = l2.get_linewidth()
                    m = l2.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers2[i] = m
                    self.qmc.extramarkersizes2[i] = l2.get_markersize()
                    self.qmc.extradevicecolor2[i] = self.getColor(l2)
                    self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
                    self.qmc.extraname2[i] = l2.get_label()
                    x2 = x2 + 1
            if self.qmc.eventsGraphflag in [2,3,4]:
                m = self.qmc.l_eventtype1dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[0] = m
                m = self.qmc.l_eventtype2dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[1] = m
                m = self.qmc.l_eventtype3dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[2] = m
                m = self.qmc.l_eventtype4dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[3] = m
                self.qmc.EvalueMarkerSize[0] = int(round(self.qmc.l_eventtype1dots.get_markersize()))
                self.qmc.EvalueMarkerSize[1] = int(round(self.qmc.l_eventtype2dots.get_markersize()))
                self.qmc.EvalueMarkerSize[2] = int(round(self.qmc.l_eventtype3dots.get_markersize()))
                self.qmc.EvalueMarkerSize[3] = int(round(self.qmc.l_eventtype4dots.get_markersize()))
                self.qmc.EvalueColor[0] = self.getColor(self.qmc.l_eventtype1dots)
                self.qmc.EvalueColor[1] = self.getColor(self.qmc.l_eventtype2dots)
                self.qmc.EvalueColor[2] = self.getColor(self.qmc.l_eventtype3dots)
                self.qmc.EvalueColor[3] = self.getColor(self.qmc.l_eventtype4dots)
                self.qmc.Evaluelinethickness[0] = int(round(self.qmc.l_eventtype1dots.get_linewidth()))
                self.qmc.Evaluelinethickness[1] = int(round(self.qmc.l_eventtype2dots.get_linewidth()))
                self.qmc.Evaluelinethickness[2] = int(round(self.qmc.l_eventtype3dots.get_linewidth()))
                self.qmc.Evaluelinethickness[3] = int(round(self.qmc.l_eventtype4dots.get_linewidth()))
                self.qmc.etypes[0] = self.qmc.l_eventtype1dots.get_label()
                self.qmc.etypes[1] = self.qmc.l_eventtype2dots.get_label()
                self.qmc.etypes[2] = self.qmc.l_eventtype3dots.get_label()
                self.qmc.etypes[3] = self.qmc.l_eventtype4dots.get_label()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' fetchCurveStyles() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    #Saves the settings when closing application. See the oppposite settingsLoad()
    def closeEvent(self,event):
        res = self.closeApp()
        if res:
            event.accept()
        else:
            event.ignore()

    # returns OS name, version and architecture as strings
    # ex: "macOS", "11.6",
    @staticmethod
    @functools.lru_cache(maxsize=None) #we cache the result to avoid re-compuation #for Python >=3.9 can use @functools.cache
    def get_os():
        def get_macOS_version():
            # platform.mac_ver() returns 10.16-style version info on BigSur
            # and is likely to do so until Python is compiled with the macOS 11 SDK
            # which may not happen for a while. And Apple's odd tricks mean that even
            # reading /System/Library/CoreServices/SystemVersion.plist is unreliable.
            try:
                import subprocess
                os_version_tuple = subprocess.check_output(
                    ('/usr/bin/sw_vers', '-productVersion'),
                    env={'SYSTEM_VERSION_COMPAT': '0'}
                ).decode('UTF-8').rstrip().split('.')
            except subprocess.CalledProcessError:
                os_version_tuple = platform.mac_ver()[0].split('.')
            os_version_tuple = os_version_tuple[0:2]
            return '.'.join(os_version_tuple)
        def get_macOS_arch():
            # platform.machine() returns x86_64 on M1 macs running Artisan under Rossetta2
            try:
                import cpuinfo
                manufacturer = cpuinfo.get_cpu_info().get('brand_raw')
                return 'm1' if 'm1' in manufacturer.lower() else 'x86_64'
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                return platform.machine()
        try:
            if platform.system().startswith('Darwin'):
#                return "macOS", platform.mac_ver()[0], platform.machine() # reports wrong version on macOS 12 on older Python versions
                return 'macOS', get_macOS_version(), get_macOS_arch()
            if platform.system().startswith('Windows'):
                return 'Windows', platform.release(), platform.machine()
            # we assume Linux
            if os.uname()[4][:3] == 'arm':
                return 'RPi',platform.release(),os.uname()[4]
            try:
                lib,version = platform.libc_ver()
                return 'Linux',f'{lib} {version}', platform.machine()
            except Exception: # pylint: disable=broad-except
                return '',''
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            return '',''


    def closeEventSettings(self, filename=None):
        #save window geometry and position. See QSettings documentation.
        #This information is often stored in the system registry on Windows,
        #and in XML preferences files on Mac OS X. On Unix systems, in the absence of a standard,
        #many applications (including the KDE applications) use INI text files

        try:
            if filename is not None and filename:
                settings = QSettings(filename,QSettings.Format.IniFormat)
            else:
                settings = QSettings()
            #save window geometry if not in fullscreen mode
            if filename is None or not (self.full_screen_mode_active or self.isFullScreen()):
                settings.setValue('Geometry',self.saveGeometry())

            if filename is None:
                settings.setValue('fullscreen', self.full_screen_mode_active or self.isFullScreen())
                settings.setValue('plus_account',self.plus_account)
                settings.setValue('plus_remember_credentials',self.plus_remember_credentials)
                settings.setValue('plus_email',self.plus_email)
                settings.setValue('plus_language',self.plus_language)

            #on OS X we prevent the reopening of windows
            # as done by defaults write com.google.code.p.Artisan NSQuitAlwaysKeepsWindows -bool false
            # resulting in the entry <key>NSQuitAlwaysKeepsWindows</key><false/> in the app settings
            # file com.google.code.p.Artisan.plist under ~/Library/Preferences/
            if sys.platform.startswith('darwin'):
                settings.setValue('NSQuitAlwaysKeepsWindows',False)
            #save mode
            settings.setValue('Mode',self.qmc.mode)
            try:
                settings.setValue('DebugLogLevel',debugLogLevelActive())
            except Exception: # pylint: disable=broad-except
                pass
            #save system
            settings.beginGroup('System')
            settings.setValue('artisan_version',__version__)
            settings.setValue('artisan_revision',__revision__)
            settings.setValue('artisan_build',__build__)
            os_name,os_version,os_arch = self.get_os()
            settings.setValue('artisan_os',os_name)
            settings.setValue('artisan_os_version',os_version)
            settings.setValue('artisan_os_arch',os_arch)
            settings.endGroup()
            #save device
            settings.beginGroup('Device')
            settings.setValue('device_logging',self.qmc.device_logging)
            settings.setValue('id',self.qmc.device)
            settings.setValue('phidget1048_types',self.qmc.phidget1048_types)
            settings.setValue('phidget1048_async',self.qmc.phidget1048_async)
            settings.setValue('phidget1048_changeTriggers',self.qmc.phidget1048_changeTriggers)
            settings.setValue('phidget1048_dataRate',self.qmc.phidget1048_dataRate)
            settings.setValue('phidget1046_async',self.qmc.phidget1046_async)
            settings.setValue('phidget1046_gain',self.qmc.phidget1046_gain)
            settings.setValue('phidget1046_formula',self.qmc.phidget1046_formula)
            settings.setValue('phidget1046_dataRate',self.qmc.phidget1046_dataRate)
            settings.setValue('phidget1045_async',self.qmc.phidget1045_async)
            settings.setValue('phidget1045_changeTrigger',self.qmc.phidget1045_changeTrigger)
            settings.setValue('phidget1045_emissivity',self.qmc.phidget1045_emissivity)
            settings.setValue('phidget1045_dataRate',self.qmc.phidget1045_dataRate)
            settings.setValue('phidget1200_formula',self.qmc.phidget1200_formula)
            settings.setValue('phidget1200_wire',self.qmc.phidget1200_wire)
            settings.setValue('phidget1200_async',self.qmc.phidget1200_async)
            settings.setValue('phidget1200_changeTrigger',self.qmc.phidget1200_changeTrigger)
            settings.setValue('phidget1200_dataRate',self.qmc.phidget1200_dataRate)
            settings.setValue('phidget1200_2_formula',self.qmc.phidget1200_2_formula)
            settings.setValue('phidget1200_2_wire',self.qmc.phidget1200_2_wire)
            settings.setValue('phidget1200_2_async',self.qmc.phidget1200_2_async)
            settings.setValue('phidget1200_2_changeTrigger',self.qmc.phidget1200_2_changeTrigger)
            settings.setValue('phidget1200_2_dataRate',self.qmc.phidget1200_2_dataRate)
            settings.setValue('phidgetDAQ1400_powerSupply',self.qmc.phidgetDAQ1400_powerSupply)
            settings.setValue('phidgetDAQ1400_inputMode',self.qmc.phidgetDAQ1400_inputMode)
            settings.setValue('phidgetRemoteFlag',self.qmc.phidgetRemoteFlag)
            settings.setValue('phidgetServerID',self.qmc.phidgetServerID)
            settings.setValue('phidgetPassword',self.qmc.phidgetPassword)
            settings.setValue('phidgetPort',self.qmc.phidgetPort)
            settings.setValue('phidgetRemoteOnlyFlag',self.qmc.phidgetRemoteOnlyFlag)
            settings.setValue('phidget1018_async',self.qmc.phidget1018_async)
            settings.setValue('phidget1018_ratio',self.qmc.phidget1018_ratio)
            settings.setValue('phidget1018_dataRates',self.qmc.phidget1018_dataRates)
            settings.setValue('phidget1018_changeTriggers',self.qmc.phidget1018_changeTriggers)
            settings.setValue('phidgetVCP100x_voltageRanges',self.qmc.phidgetVCP100x_voltageRanges)
            settings.setValue('controlETpid',self.ser.controlETpid)
            settings.setValue('readBTpid',self.ser.readBTpid)
            settings.setValue('arduinoETChannel',self.ser.arduinoETChannel)
            settings.setValue('arduinoBTChannel',self.ser.arduinoBTChannel)
            settings.setValue('arduinoATChannel',self.ser.arduinoATChannel)
            settings.setValue('ArduinoFILT',self.ser.ArduinoFILT)
            settings.setValue('useModbusPort',self.ser.useModbusPort)
            settings.setValue('showFujiLCDs',self.ser.showFujiLCDs)
            settings.setValue('PIDbuttonflag',self.qmc.PIDbuttonflag)
            settings.setValue('Controlbuttonflag',self.qmc.Controlbuttonflag)
            settings.setValue('yoctoRemoteFlag',self.qmc.yoctoRemoteFlag)
            settings.setValue('yoctoServerID',self.qmc.yoctoServerID)
            settings.setValue('YOCTO_emissivity',self.qmc.YOCTO_emissivity)
            settings.setValue('YOCTO_async',self.qmc.YOCTO_async)
            settings.setValue('YOCTO_dataRate',self.qmc.YOCTO_dataRate)
            settings.setValue('ambient_temperature_device',self.qmc.ambient_temperature_device)
            settings.setValue('ambient_humidity_device',self.qmc.ambient_humidity_device)
            settings.setValue('ambient_pressure_device',self.qmc.ambient_pressure_device)
            settings.setValue('elevation',self.qmc.elevation)
            settings.endGroup()
            settings.setValue('fmt_data_RoR',self.qmc.fmt_data_RoR)
            settings.setValue('fmt_data_ON',self.qmc.fmt_data_ON)
            settings.setValue('fmt_data_curve',self.qmc.fmt_data_curve)
            settings.setValue('detectBackgroundEventTime',self.qmc.detectBackgroundEventTime)
            settings.setValue('backgroundReproduce',self.qmc.backgroundReproduce)
            settings.setValue('backgroundReproduceBeep',self.qmc.backgroundReproduceBeep)
            settings.setValue('backgroundPlaybackEvents',self.qmc.backgroundPlaybackEvents)
            settings.setValue('backgroundPlaybackDROP',self.qmc.backgroundPlaybackDROP)
            settings.setValue('replayType',self.qmc.replayType)
            settings.setValue('specialeventplaybackaid',self.qmc.specialeventplaybackaid)
            settings.setValue('specialeventplayback',self.qmc.specialeventplayback)
            settings.setValue('Phases',self.qmc.phases)
            #save phasesbuttonflag
            settings.setValue('phasesbuttonflag',self.qmc.phasesbuttonflag)
            settings.setValue('phasesfromBackgroundflag',self.qmc.phasesfromBackgroundflag)
            #save phases watermarks flag
            settings.setValue('watermarks',self.qmc.watermarksflag)
            #save phases LCDs on recording flag
            settings.setValue('phasesLCDs',self.qmc.phasesLCDflag)
            settings.setValue('phasesLCDmode',self.qmc.phasesLCDmode)
            settings.setValue('phasesLCDmode_l', self.qmc.phasesLCDmode_l)
            settings.setValue('phasesLCDmode_all', self.qmc.phasesLCDmode_all)
            settings.setValue('step100temp',self.qmc.step100temp)
            #phase triggered DRY and FCs
            settings.setValue('autoDry',self.qmc.autoDRYflag)
            settings.setValue('autoFCs',self.qmc.autoFCsFlag)
            #save statistics
            settings.setValue('Statistics',self.qmc.statisticsflags)
            settings.setValue('AnalysisResultsLoc',aw.qmc.analysisresultsloc)
            settings.setValue('SegmentResultsLoc',aw.qmc.segmentresultsloc)
            settings.setValue('analysisstartchoice',aw.qmc.analysisstartchoice)
            settings.setValue('analysisoffset',aw.qmc.analysisoffset)
            settings.setValue('curvefitstartchoice',aw.qmc.curvefitstartchoice)
            settings.setValue('curvefitoffset',aw.qmc.curvefitoffset)
            settings.setValue('segmentsamplesthreshold',aw.qmc.segmentsamplesthreshold)
            settings.setValue('segmentdeltathreshold',aw.qmc.segmentdeltathreshold)
            #projection
            settings.setValue('projectFlag',self.qmc.projectFlag)
            settings.setValue('projectDeltaFlag',self.qmc.projectDeltaFlag)
            settings.setValue('projectionmode',self.qmc.projectionmode)
            #save AUC
            settings.setValue('AUCbegin',self.qmc.AUCbegin)
            settings.setValue('AUCbase',self.qmc.AUCbase)
            settings.setValue('AUCbaseFlag',self.qmc.AUCbaseFlag)
            settings.setValue('AUCtarget',self.qmc.AUCtarget)
            settings.setValue('AUCtargetFlag',self.qmc.AUCtargetFlag)
            settings.setValue('AUCguideFlag',self.qmc.AUCguideFlag)
            settings.setValue('AUClcdFlag',self.qmc.AUClcdFlag)
            settings.setValue('AUCLCDmode',self.qmc.AUCLCDmode)
            settings.setValue('AUCshowFlag',self.qmc.AUCshowFlag)
            settings.setValue('keyboardmoveflag',self.keyboardmoveflag)
            #save Events settings
            settings.beginGroup('events')
            settings.setValue('eventsbuttonflag',self.eventsbuttonflag)
            settings.setValue('minieventsflags',self.minieventsflags)
            settings.setValue('eventsGraphflag',self.qmc.eventsGraphflag)
            # we only store etype names if they have been modified by the user to allow automatic translations otherwise
            if ((self.qmc.etypes[0] != QApplication.translate('ComboBox', 'Air')) or
                (self.qmc.etypes[1] != QApplication.translate('ComboBox', 'Drum')) or
                (self.qmc.etypes[2] != QApplication.translate('ComboBox', 'Damper')) or
                (self.qmc.etypes[3] != QApplication.translate('ComboBox', 'Burner'))):
                settings.setValue('etypes',self.qmc.etypes)
            else:
                settings.remove('etypes')
            settings.setValue('eventsshowflag',self.qmc.eventsshowflag)
            settings.setValue('clampEvents',self.qmc.clampEvents)
            settings.setValue('renderEventsDescr',self.qmc.renderEventsDescr)
            settings.setValue('eventslabelschars',self.qmc.eventslabelschars)
            settings.setValue('annotationsflag',self.qmc.annotationsflag)
            settings.setValue('showeventsonbt',self.qmc.showeventsonbt)
            settings.setValue('showEtypes',self.qmc.showEtypes)
            settings.setValue('chargeTimer',self.qmc.chargeTimerFlag)
            settings.setValue('chargeTimerPeriod',self.qmc.chargeTimerPeriod)
            settings.setValue('autoCharge',self.qmc.autoChargeFlag)
            settings.setValue('autoDrop',self.qmc.autoDropFlag)
            settings.setValue('markTP',self.qmc.markTPflag)
            settings.setValue('EvalueColor',self.qmc.EvalueColor)
            settings.setValue('EvalueTextColor',self.qmc.EvalueTextColor)
            settings.setValue('EvalueMarker',self.qmc.EvalueMarker)
            settings.setValue('Evaluelinethickness',self.qmc.Evaluelinethickness)
            settings.setValue('EvalueMarkerSize',self.qmc.EvalueMarkerSize)
            settings.setValue('Evaluealpha',self.qmc.Evaluealpha)
            settings.setValue('specialeventannotations', self.qmc.specialeventannotations)
            settings.setValue('specialeventannovisibilities', self.qmc.specialeventannovisibilities)
            settings.setValue('overlappct', self.qmc.overlappct)
            settings.endGroup()
            #save ambient temperature source
            settings.setValue('AmbientTempSource',aw.qmc.ambientTempSource)
            #save delay (sampling interval)
            settings.setValue('Delay',self.qmc.delay)
            # save keepON flag
            settings.setValue('KeepON',self.qmc.flagKeepON)
            settings.setValue('flagOpenCompleted',self.qmc.flagOpenCompleted)
            # save extra event sampling interval
            settings.setValue('ExtraEventSamplingDelay',self.qmc.extra_event_sampling_delay)
            #save colors
            settings.setValue('Colors',self.qmc.palette)
            settings.setValue('Alphas',self.qmc.alpha)
            settings.setValue('LCDColors',self.lcdpaletteB)
            settings.setValue('LEDColors',self.lcdpaletteF)
            settings.setValue('ETBColor',self.qmc.backgroundmetcolor)
            settings.setValue('BTBColor',self.qmc.backgroundbtcolor)
            settings.setValue('ETBdeltaColor',self.qmc.backgrounddeltaetcolor)
            settings.setValue('BTBdeltaColor',self.qmc.backgrounddeltabtcolor)
            settings.setValue('BackgroundAlpha',self.qmc.backgroundalpha)
            #save readings LCDs status flags
            settings.setValue('readingslcdsflags',self.readingslcdsflags)
            #save flavors
            settings.setValue('Flavors',self.qmc.flavorlabels)
            settings.setValue('flavorstartangle',self.qmc.flavorstartangle)
            #save roast color system
            settings.setValue('colorsystem',self.qmc.color_system_idx)
            #watermark image
            settings.setValue('logofilename', self.logofilename)
            settings.setValue('logoimgalpha', self.logoimgalpha)
            settings.setValue('logoimgflag', self.logoimgflag)
            settings.beginGroup('Tare')
            settings.setValue('names',self.qmc.container_names)
            settings.setValue('weights',self.qmc.container_weights)
            settings.setValue('idx',self.qmc.container_idx)
            settings.endGroup()
            #save serial port
            settings.beginGroup('SerialPort')
            settings.setValue('comport',self.ser.comport)
            settings.setValue('baudrate',self.ser.baudrate)
            settings.setValue('bytesize',self.ser.bytesize)
            settings.setValue('stopbits',self.ser.stopbits)
            settings.setValue('parity',self.ser.parity)
            settings.setValue('timeout',self.ser.timeout)
            settings.endGroup()
            #save WebSocket port
            settings.beginGroup('WebSocket')
            settings.setValue('host',self.ws.host)
            settings.setValue('port',self.ws.port)
            settings.setValue('path',self.ws.path)
            settings.setValue('machineID',self.ws.machineID)
            settings.setValue('connect_timeout',self.ws.connect_timeout)
            settings.setValue('request_timeout',self.ws.request_timeout)
            settings.setValue('reconnect_interval',self.ws.reconnect_interval)
            settings.setValue('id_node',self.ws.id_node)
            settings.setValue('machine_node',self.ws.machine_node)
            settings.setValue('command_node',self.ws.command_node)
            settings.setValue('data_node',self.ws.data_node)
            settings.setValue('pushMessage_node',self.ws.pushMessage_node)
            settings.setValue('request_data_command',self.ws.request_data_command)
            settings.setValue('charge_message',self.ws.charge_message)
            settings.setValue('drop_message',self.ws.drop_message)
            settings.setValue('STARTonCHARGE',self.ws.STARTonCHARGE)
            settings.setValue('OFFonDROP',self.ws.OFFonDROP)
            settings.setValue('addEvent_message',self.ws.addEvent_message)
            settings.setValue('event_node',self.ws.event_node)
            settings.setValue('DRY_node',self.ws.DRY_node)
            settings.setValue('FCs_node',self.ws.FCs_node)
            settings.setValue('FCe_node',self.ws.FCe_node)
            settings.setValue('SCs_node',self.ws.SCs_node)
            settings.setValue('SCe_node',self.ws.SCe_node)
            settings.setValue('channel_requests',self.ws.channel_requests)
            settings.setValue('channel_nodes',self.ws.channel_nodes)
            settings.setValue('channel_modes',self.ws.channel_modes)
            settings.endGroup()
            #save s7 port
            settings.beginGroup('S7')
            settings.setValue('area',self.s7.area)
            settings.setValue('db_nr',self.s7.db_nr)
            settings.setValue('start',self.s7.start)
            settings.setValue('type',self.s7.type)
            settings.setValue('mode',self.s7.mode)
            settings.setValue('div',self.s7.div)
            settings.setValue('host',self.s7.host)
            settings.setValue('port',self.s7.port)
            settings.setValue('rack',self.s7.rack)
            settings.setValue('slot',self.s7.slot)
            settings.setValue('PID_area',self.s7.PID_area)
            settings.setValue('PID_db_nr',self.s7.PID_db_nr)
            settings.setValue('PID_SV_register',self.s7.PID_SV_register)
            settings.setValue('PID_p_register',self.s7.PID_p_register)
            settings.setValue('PID_i_register',self.s7.PID_i_register)
            settings.setValue('PID_d_register',self.s7.PID_d_register)
            settings.setValue('PID_OFF_action',self.s7.PID_OFF_action)
            settings.setValue('PID_ON_action',self.s7.PID_ON_action)
            settings.setValue('PIDmultiplier',self.s7.PIDmultiplier)
            settings.setValue('SVtype',self.s7.SVtype)
            settings.setValue('SVmultiplier',self.s7.SVmultiplier)
            settings.setValue('optimizer',self.s7.optimizer)
            settings.setValue('fetch_max_blocks',self.s7.fetch_max_blocks)
            settings.endGroup()
            #save modbus port
            settings.beginGroup('Modbus')
            settings.setValue('comport',self.modbus.comport)
            settings.setValue('baudrate',self.modbus.baudrate)
            settings.setValue('bytesize',self.modbus.bytesize)
            settings.setValue('stopbits',self.modbus.stopbits)
            settings.setValue('parity',self.modbus.parity)
            settings.setValue('timeout',self.modbus.timeout)
            settings.setValue('modbus_serial_extra_read_delay',self.modbus.modbus_serial_extra_read_delay)
            settings.setValue('serial_readRetries',self.modbus.serial_readRetries)
            settings.setValue('IP_timeout',self.modbus.IP_timeout)
            settings.setValue('IP_retries',self.modbus.IP_retries)
            settings.setValue('PID_slave_ID',self.modbus.PID_slave_ID)
            settings.setValue('PID_SV_register',self.modbus.PID_SV_register)
            settings.setValue('PID_p_register',self.modbus.PID_p_register)
            settings.setValue('PID_i_register',self.modbus.PID_i_register)
            settings.setValue('PID_d_register',self.modbus.PID_d_register)
            settings.setValue('PID_OFF_action',self.modbus.PID_OFF_action)
            settings.setValue('PID_ON_action',self.modbus.PID_ON_action)
            settings.setValue('input1slave',self.modbus.inputSlaves[0])
            settings.setValue('input1register',self.modbus.inputRegisters[0])
            settings.setValue('input1float',self.modbus.inputFloats[0])
            settings.setValue('input1bcd',self.modbus.inputBCDs[0])
            settings.setValue('input1code',self.modbus.inputCodes[0])
            settings.setValue('input1div',self.modbus.inputDivs[0])
            settings.setValue('input1mode',self.modbus.inputModes[0])
            settings.setValue('input1FloatsAsInt',self.modbus.inputFloatsAsInt[0])
            settings.setValue('input1BCDsAsInt',self.modbus.inputBCDsAsInt[0])
            settings.setValue('input1Signed',self.modbus.inputSigned[0])
            settings.setValue('input2slave',self.modbus.inputSlaves[1])
            settings.setValue('input2register',self.modbus.inputRegisters[1])
            settings.setValue('input2float',self.modbus.inputFloats[1])
            settings.setValue('input2bcd',self.modbus.inputBCDs[1])
            settings.setValue('input2code',self.modbus.inputCodes[1])
            settings.setValue('input2div',self.modbus.inputDivs[1])
            settings.setValue('input2mode',self.modbus.inputModes[1])
            settings.setValue('input2FloatsAsInt',self.modbus.inputFloatsAsInt[1])
            settings.setValue('input2BCDsAsInt',self.modbus.inputBCDsAsInt[1])
            settings.setValue('input2Signed',self.modbus.inputSigned[1])
            settings.setValue('input3slave',self.modbus.inputSlaves[2])
            settings.setValue('input3register',self.modbus.inputRegisters[2])
            settings.setValue('input3float',self.modbus.inputFloats[2])
            settings.setValue('input3bcd',self.modbus.inputBCDs[2])
            settings.setValue('input3code',self.modbus.inputCodes[2])
            settings.setValue('input3div',self.modbus.inputDivs[2])
            settings.setValue('input3mode',self.modbus.inputModes[2])
            settings.setValue('input3FloatsAsInt',self.modbus.inputFloatsAsInt[2])
            settings.setValue('input3BCDsAsInt',self.modbus.inputBCDsAsInt[2])
            settings.setValue('input3Signed',self.modbus.inputSigned[2])
            settings.setValue('input4slave',self.modbus.inputSlaves[3])
            settings.setValue('input4register',self.modbus.inputRegisters[3])
            settings.setValue('input4float',self.modbus.inputFloats[3])
            settings.setValue('input4bcd',self.modbus.inputBCDs[3])
            settings.setValue('input4code',self.modbus.inputCodes[3])
            settings.setValue('input4div',self.modbus.inputDivs[3])
            settings.setValue('input4mode',self.modbus.inputModes[3])
            settings.setValue('input4FloatsAsInt',self.modbus.inputFloatsAsInt[3])
            settings.setValue('input4BCDsAsInt',self.modbus.inputBCDsAsInt[3])
            settings.setValue('input4Signed',self.modbus.inputSigned[3])
            settings.setValue('input5slave',self.modbus.inputSlaves[4])
            settings.setValue('input5register',self.modbus.inputRegisters[4])
            settings.setValue('input5float',self.modbus.inputFloats[4])
            settings.setValue('input5bcd',self.modbus.inputBCDs[4])
            settings.setValue('input5code',self.modbus.inputCodes[4])
            settings.setValue('input5div',self.modbus.inputDivs[4])
            settings.setValue('input5mode',self.modbus.inputModes[4])
            settings.setValue('input5FloatsAsInt',self.modbus.inputFloatsAsInt[4])
            settings.setValue('input5BCDsAsInt',self.modbus.inputBCDsAsInt[4])
            settings.setValue('input5Signed',self.modbus.inputSigned[4])
            settings.setValue('input6slave',self.modbus.inputSlaves[5])
            settings.setValue('input6register',self.modbus.inputRegisters[5])
            settings.setValue('input6float',self.modbus.inputFloats[5])
            settings.setValue('input6bcd',self.modbus.inputBCDs[5])
            settings.setValue('input6code',self.modbus.inputCodes[5])
            settings.setValue('input6div',self.modbus.inputDivs[5])
            settings.setValue('input6mode',self.modbus.inputModes[5])
            settings.setValue('input6FloatsAsInt',self.modbus.inputFloatsAsInt[5])
            settings.setValue('input6BCDsAsInt',self.modbus.inputBCDsAsInt[5])
            settings.setValue('input6Signed',self.modbus.inputSigned[5])
            settings.setValue('input7slave',self.modbus.inputSlaves[6])
            settings.setValue('input7register',self.modbus.inputRegisters[6])
            settings.setValue('input7float',self.modbus.inputFloats[6])
            settings.setValue('input7bcd',self.modbus.inputBCDs[6])
            settings.setValue('input7code',self.modbus.inputCodes[6])
            settings.setValue('input7div',self.modbus.inputDivs[6])
            settings.setValue('input7mode',self.modbus.inputModes[6])
            settings.setValue('input7FloatsAsInt',self.modbus.inputFloatsAsInt[6])
            settings.setValue('input7BCDsAsInt',self.modbus.inputBCDsAsInt[6])
            settings.setValue('input7Signed',self.modbus.inputSigned[6])
            settings.setValue('input8slave',self.modbus.inputSlaves[7])
            settings.setValue('input8register',self.modbus.inputRegisters[7])
            settings.setValue('input8float',self.modbus.inputFloats[7])
            settings.setValue('input8bcd',self.modbus.inputBCDs[7])
            settings.setValue('input8code',self.modbus.inputCodes[7])
            settings.setValue('input8div',self.modbus.inputDivs[7])
            settings.setValue('input8mode',self.modbus.inputModes[7])
            settings.setValue('input8FloatsAsInt',self.modbus.inputFloatsAsInt[7])
            settings.setValue('input8BCDsAsInt',self.modbus.inputBCDsAsInt[7])
            settings.setValue('input8Signed',self.modbus.inputSigned[7])

            settings.setValue('PIDmultiplier',self.modbus.PIDmultiplier)
            settings.setValue('SVmultiplier',self.modbus.SVmultiplier)
            settings.setValue('littleEndianFloats',self.modbus.byteorderLittle)
            settings.setValue('wordorderLittle',self.modbus.wordorderLittle)
            settings.setValue('optimizer',self.modbus.optimizer)
            settings.setValue('fetch_max_blocks',self.modbus.fetch_max_blocks)
            settings.setValue('type',self.modbus.type)
            settings.setValue('host',self.modbus.host)
            settings.setValue('port',self.modbus.port)
            settings.setValue('reset_socket',self.modbus.reset_socket)
            settings.endGroup()
            #save scale port
            settings.beginGroup('Scale')
            settings.setValue('device',self.scale.device)
            settings.setValue('comport',self.scale.comport)
            settings.setValue('baudrate',self.scale.baudrate)
            settings.setValue('bytesize',self.scale.bytesize)
            settings.setValue('stopbits',self.scale.stopbits)
            settings.setValue('parity',self.scale.parity)
            settings.setValue('timeout',self.scale.timeout)
            settings.endGroup()
            #save color port
            settings.beginGroup('Color')
            settings.setValue('device',self.color.device)
            settings.setValue('comport',self.color.comport)
            settings.setValue('baudrate',self.color.baudrate)
            settings.setValue('bytesize',self.color.bytesize)
            settings.setValue('stopbits',self.color.stopbits)
            settings.setValue('parity',self.color.parity)
            settings.setValue('timeout',self.color.timeout)
            settings.endGroup()
            #save pid settings (only key and value[0])
            settings.beginGroup('ArduinoPID')
            settings.setValue('pidOnCHARGE',aw.pidcontrol.pidOnCHARGE)
            settings.setValue('loadRampSoakFromProfile',aw.pidcontrol.loadRampSoakFromProfile)
            settings.setValue('loadRampSoakFromBackground',aw.pidcontrol.loadRampSoakFromBackground)
            settings.setValue('svLabel',aw.pidcontrol.svLabel)
            settings.setValue('svValues',aw.pidcontrol.svValues)
            settings.setValue('svRamps',aw.pidcontrol.svRamps)
            settings.setValue('svSoaks',aw.pidcontrol.svSoaks)
            settings.setValue('svActions',aw.pidcontrol.svActions)
            settings.setValue('svBeeps',aw.pidcontrol.svBeeps)
            settings.setValue('svDescriptions',aw.pidcontrol.svDescriptions)
            settings.setValue('svSlider',aw.pidcontrol.svSlider)
            settings.setValue('svButtons',aw.pidcontrol.svButtons)
            settings.setValue('svMode',aw.pidcontrol.svMode)
            settings.setValue('svLookahead',aw.pidcontrol.svLookahead)
            settings.setValue('dutySteps',aw.pidcontrol.dutySteps)
            settings.setValue('svSliderMin',aw.pidcontrol.svSliderMin)
            settings.setValue('svSliderMax',aw.pidcontrol.svSliderMax)
            settings.setValue('svValue',aw.pidcontrol.svValue)
            settings.setValue('dutyMin',aw.pidcontrol.dutyMin)
            settings.setValue('dutyMax',aw.pidcontrol.dutyMax)
            settings.setValue('pidKp',aw.pidcontrol.pidKp)
            settings.setValue('pidKi',aw.pidcontrol.pidKi)
            settings.setValue('pidKd',aw.pidcontrol.pidKd)
            settings.setValue('pidSource',aw.pidcontrol.pidSource)
            settings.setValue('pidCycle',aw.pidcontrol.pidCycle)
            settings.setValue('pidPositiveTarget',aw.pidcontrol.pidPositiveTarget)
            settings.setValue('pidNegativeTarget',aw.pidcontrol.pidNegativeTarget)
            settings.setValue('invertControl',aw.pidcontrol.invertControl)
            settings.setValue('pOnE',aw.pidcontrol.pOnE)
            for n in range(aw.pidcontrol.RSLen):
                settings.setValue('RS_svLabel'+str(n),aw.pidcontrol.RS_svLabels[n])
                settings.setValue('RS_svValues'+str(n),aw.pidcontrol.RS_svValues[n])
                settings.setValue('RS_svRamps'+str(n),aw.pidcontrol.RS_svRamps[n])
                settings.setValue('RS_svSoaks'+str(n),aw.pidcontrol.RS_svSoaks[n])
                settings.setValue('RS_svActions'+str(n),aw.pidcontrol.RS_svActions[n])
                settings.setValue('RS_svBeeps'+str(n),aw.pidcontrol.RS_svBeeps[n])
                settings.setValue('RS_svDescriptions'+str(n),aw.pidcontrol.RS_svDescriptions[n])
            settings.endGroup()
            settings.beginGroup('PXR')
            for k in list(self.fujipid.PXR.keys()):
                settings.setValue(k,self.fujipid.PXR[k][0])
            settings.endGroup()
            settings.beginGroup('PXG4')
            for k in list(self.fujipid.PXG4.keys()):
                settings.setValue(k,self.fujipid.PXG4[k][0])
            settings.setValue('followBackground',self.fujipid.followBackground)
            settings.setValue('lookahead',self.fujipid.lookahead)
            settings.endGroup()
            settings.beginGroup('deltaDTA')
            for k in list(self.dtapid.dtamem.keys()):
                settings.setValue(k,self.dtapid.dtamem[k][0])
            settings.endGroup()
            settings.setValue('filterDropOuts',self.qmc.filterDropOuts)
            settings.setValue('dropSpikes',self.qmc.dropSpikes)
            settings.setValue('dropDuplicates',self.qmc.dropDuplicates)
            settings.setValue('dropDuplicatesLimit',self.qmc.dropDuplicatesLimit)
#            settings.setValue("altSmoothing",self.qmc.altsmoothing)
            settings.setValue('optimalSmoothing',self.qmc.optimalSmoothing)
            settings.setValue('polyfitRoRcalc',self.qmc.polyfitRoRcalc)
            settings.setValue('swapETBT',self.qmc.swapETBT)
            settings.setValue('minmaxLimits',self.qmc.minmaxLimits)
            settings.setValue('minLimit',self.qmc.filterDropOut_tmin)
            settings.setValue('maxLimit',self.qmc.filterDropOut_tmax)
            settings.setValue('foregroundShowFullflag',self.qmc.foregroundShowFullflag)
            settings.beginGroup('RoC')
            settings.setValue('DeltaET',self.qmc.DeltaETflag)
            settings.setValue('DeltaBT',self.qmc.DeltaBTflag)
            settings.setValue('DeltaETlcd',self.qmc.DeltaETlcdflag)
            settings.setValue('DeltaBTlcd',self.qmc.DeltaBTlcdflag)
            settings.setValue('deltaETfilter',self.qmc.deltaETfilter)
            settings.setValue('deltafilter',self.qmc.deltaBTfilter)
            settings.setValue('DeltaETspan',self.qmc.deltaETspan)
            settings.setValue('DeltaSpan',self.qmc.deltaBTspan)
            settings.setValue('LCDdecimalplaces',self.qmc.LCDdecimalplaces)
            settings.setValue('statisticsmode',self.qmc.statisticsmode)
            settings.setValue('swapdeltalcds',self.qmc.swapdeltalcds)
            settings.endGroup()
            settings.setValue('curvefilter',self.qmc.curvefilter)
#            settings.setValue("smoothingwindowsize",self.qmc.smoothingwindowsize)
            settings.setValue('ETcurve',self.qmc.ETcurve)
            settings.setValue('BTcurve',self.qmc.BTcurve)
            settings.setValue('ETlcd',self.qmc.ETlcd)
            settings.setValue('BTlcd',self.qmc.BTlcd)
            settings.setValue('swaplcds',self.qmc.swaplcds)
            settings.beginGroup('DefaultButtons')
            settings.setValue('buttonvisibility',self.qmc.buttonvisibility)
            settings.setValue('buttonactions',self.qmc.buttonactions)
            settings.setValue('buttonactionstrings',self.qmc.buttonactionstrings)
            settings.setValue('extrabuttonactions',self.qmc.extrabuttonactions)
            settings.setValue('extrabuttonactionstrings',self.qmc.extrabuttonactionstrings)
            settings.setValue('xextrabuttonactions',self.qmc.xextrabuttonactions)
            settings.setValue('xextrabuttonactionstrings',self.qmc.xextrabuttonactionstrings)
            settings.endGroup()
            settings.setValue('transMappingMode',self.qmc.transMappingMode)
            settings.beginGroup('Style')
            settings.setValue('patheffects',self.qmc.patheffects)
            settings.setValue('graphstyle',self.qmc.graphstyle)
            settings.setValue('graphfont',self.qmc.graphfont)
            settings.setValue('ETname', self.ETname)
            settings.setValue('BTname', self.BTname)
            settings.endGroup()
            settings.beginGroup('Sound')
            settings.setValue('Beep',self.soundflag)
            settings.endGroup()
            settings.beginGroup('Notifications')
            if self.notificationManager:
                try:
                    titles = []
                    messages = []
                    types = []
                    created = []
                    for n in self.notificationManager.getNotificationItems():
                        titles.append(n.title)
                        messages.append(n.message)
                        types.append(n.type.value)
                        created.append(n.created)
                    settings.setValue('titles', titles)
                    settings.setValue('messages', messages)
                    settings.setValue('types', types)
                    settings.setValue('created', created)
                except Exception as e:
                    _log.exception(e)
            settings.setValue('notificationsflag',self.notificationsflag)
            settings.endGroup()
            settings.beginGroup('Axis')
            settings.setValue('loadAxisFromProfile',self.qmc.loadaxisfromprofile)
            xmin = self.qmc.startofx
            if self.qmc.timeindex[0] != -1:
                xmin -= self.qmc.timex[self.qmc.timeindex[0]]
            settings.setValue('xmin',xmin)
            settings.setValue('xmax',self.qmc.endofx)
            settings.setValue('ymax',self.qmc.ylimit)
            settings.setValue('ymin',self.qmc.ylimit_min)
            settings.setValue('zmax',self.qmc.zlimit)
            settings.setValue('zmin',self.qmc.zlimit_min)
            settings.setValue('resetmaxtime',self.qmc.resetmaxtime)
            settings.setValue('lockmax',self.qmc.fixmaxtime)
            settings.setValue('locktimex',self.qmc.locktimex)
            settings.setValue('autotimex',self.qmc.autotimex)
            settings.setValue('autotimexMode',self.qmc.autotimexMode)
            settings.setValue('autodeltaxET',self.qmc.autodeltaxET)
            settings.setValue('autodeltaxBT',self.qmc.autodeltaxBT)
            settings.setValue('locktimex_start',self.qmc.locktimex_start)
            settings.setValue('locktimex_end',self.qmc.locktimex_end)
            settings.setValue('legendloc',self.qmc.legendloc)
            settings.setValue('chargemintime',self.qmc.chargemintime)
            settings.setValue('temp_grid',self.qmc.temp_grid)
            settings.setValue('time_grid',self.qmc.time_grid)
            settings.endGroup()
            settings.setValue('organization_setup',self.qmc.organization_setup)
            settings.setValue('operator_setup',self.qmc.operator_setup)
            settings.setValue('roastertype_setup',self.qmc.roastertype_setup)
            settings.setValue('roastersize_setup',self.qmc.roastersize_setup)
            settings.setValue('roasterheating_setup',self.qmc.roasterheating_setup)
            settings.setValue('drumspeed_setup',self.qmc.drumspeed_setup)
            settings.setValue('last_batchsize',self.qmc.last_batchsize)

            settings.beginGroup('EnergyUse')
            settings.setValue('loadlabels_setup',self.qmc.loadlabels_setup)
            settings.setValue('loadratings_setup',self.qmc.loadratings_setup)
            settings.setValue('ratingunits_setup',self.qmc.ratingunits_setup)
            settings.setValue('sourcetypes_setup',self.qmc.sourcetypes_setup)
            settings.setValue('load_etypes_setup',self.qmc.load_etypes_setup)
            settings.setValue('presssure_percents_setup',self.qmc.presssure_percents_setup)
            settings.setValue('loadevent_zeropcts_setup',self.qmc.loadevent_zeropcts_setup)
            settings.setValue('loadevent_hundpcts_setup',self.qmc.loadevent_hundpcts_setup)
            settings.setValue('preheatDuration_setup',self.qmc.preheatDuration_setup)
            settings.setValue('preheatenergies_setup',self.qmc.preheatenergies_setup)
            settings.setValue('betweenbatchDuration_setup',self.qmc.betweenbatchDuration_setup)
            settings.setValue('betweenbatchenergies_setup',self.qmc.betweenbatchenergies_setup)
            settings.setValue('coolingDuration_setup',self.qmc.coolingDuration_setup)
            settings.setValue('coolingenergies_setup',self.qmc.coolingenergies_setup)
            settings.setValue('betweenbatch_after_preheat_setup',self.qmc.betweenbatch_after_preheat_setup)
            settings.setValue('electricEnergyMix_setup',self.qmc.electricEnergyMix_setup)
            settings.setValue('energyresultunit_setup',self.qmc.energyresultunit_setup)
#            settings.setValue("energytablecolumnwidths",self.qmc.energytablecolumnwidths)
            settings.endGroup()

            settings.beginGroup('RoastProperties')
            settings.setValue('machinesetup',self.qmc.machinesetup)
#            settings.setValue("densitySampleVolume",self.qmc.density[2]) # fixed to 1l now
            settings.setValue('beansize',self.qmc.beansize)
            settings.setValue('beansize_min',self.qmc.beansize_min)
            settings.setValue('beansize_max',self.qmc.beansize_max)
            if filename is None:
                # we don't export plus default store and custom blend data to external settings file as the custom blend is considered temporary
                settings.setValue('plus_default_store',self.qmc.plus_default_store)
                if self.qmc.plus_custom_blend is not None:
                    settings.setValue('plus_custom_blend_name', self.qmc.plus_custom_blend.name)
                    settings.setValue('plus_custom_blend_coffees', [c.coffee for c in self.qmc.plus_custom_blend.components])
                    settings.setValue('plus_custom_blend_ratios',  [c.ratio for c in self.qmc.plus_custom_blend.components])
            settings.endGroup()
            settings.beginGroup('XT')
            settings.setValue('color',self.qmc.backgroundxtcolor)
            settings.setValue('color2',self.qmc.backgroundytcolor)
            settings.setValue('index',self.qmc.xtcurveidx)
            settings.setValue('index2',self.qmc.ytcurveidx)
            settings.endGroup()
            settings.beginGroup('Units')
            settings.setValue('weight',self.qmc.weight[2])
            settings.setValue('volume',self.qmc.volume[2])
            settings.setValue('densityweight',self.qmc.density[1])
            settings.setValue('densityvolume',self.qmc.density[3])
            settings.setValue('volumeCalcUnit',self.qmc.volumeCalcUnit)
            settings.endGroup()
            #save alarms
            settings.beginGroup('Alarms')
            settings.setValue('alarmsetlabel',self.qmc.alarmsetlabel)
            settings.setValue('alarmflag',self.qmc.alarmflag)
            settings.setValue('alarmguard',self.qmc.alarmguard)
            settings.setValue('alarmnegguard',self.qmc.alarmnegguard)
            settings.setValue('alarmtime',self.qmc.alarmtime)
            settings.setValue('alarmoffset',self.qmc.alarmoffset)
            settings.setValue('alarmcond',self.qmc.alarmcond)
            settings.setValue('alarmsource',self.qmc.alarmsource)
            settings.setValue('alarmtemperature',self.qmc.alarmtemperature)
            settings.setValue('alarmaction',self.qmc.alarmaction)
            settings.setValue('alarmbeep',self.qmc.alarmbeep)
            settings.setValue('alarmstrings',self.qmc.alarmstrings)
            settings.setValue('loadAlarmsFromProfile',self.qmc.loadalarmsfromprofile)
            settings.setValue('loadAlarmsFromBackground',self.qmc.loadalarmsfrombackground)
            settings.setValue('alarmsfile',self.qmc.alarmsfile)
            settings.setValue('alarm_popup_timout',self.qmc.alarm_popup_timout)
            settings.setValue('alarmtablecolumnwidths',self.qmc.alarmtablecolumnwidths)
            settings.setValue('alarmsets',self.qmc.alarmsets)
            settings.setValue('alarmsetlabel',self.qmc.alarmsetlabel)
            settings.endGroup()
            settings.setValue('profilepath',self.userprofilepath)
            settings.setValue('settingspath',self.settingspath)
            settings.setValue('wheelpath',self.wheelpath)
            settings.setValue('autosavepath',self.qmc.autosavepath)
            settings.setValue('autosavealsopath',self.qmc.autosavealsopath)
            settings.setValue('simulatorpath',self.simulatorpath)
            settings.setValue('externalprogram',self.ser.externalprogram)
            settings.setValue('externaloutprogram',self.ser.externaloutprogram)
            settings.setValue('externaloutprogramFlag',self.ser.externaloutprogramFlag)
            #save extra devices
            settings.beginGroup('ExtraDev')
            self.setExtraDeviceSettings(settings)
            settings.endGroup()
            #save extra serial comm ports settings
            settings.beginGroup('ExtraComm')
            self.setExtraDeviceCommSettings(settings)
            settings.endGroup()
            settings.setValue('ChannelTares',self.channel_tare_values)
            settings.setValue('BTfunction',self.qmc.BTfunction)
            settings.setValue('ETfunction',self.qmc.ETfunction)
            settings.setValue('DeltaBTfunction',self.qmc.DeltaBTfunction)
            settings.setValue('DeltaETfunction',self.qmc.DeltaETfunction)
            settings.setValue('resetqsettings',self.resetqsettings)
            settings.setValue('plotcurves',self.qmc.plotcurves)
            settings.setValue('plotcurvecolor',self.qmc.plotcurvecolor)
            #curve styles
            settings.beginGroup('CurveStyles')
            settings.setValue('BTlinestyle',self.qmc.BTlinestyle)
            settings.setValue('BTdrawstyle',self.qmc.BTdrawstyle)
            settings.setValue('BTlinewidth',self.qmc.BTlinewidth)
            settings.setValue('BTmarker',self.qmc.BTmarker)
            settings.setValue('BTmarkersize',self.qmc.BTmarkersize)
            settings.setValue('ETlinestyle',self.qmc.ETlinestyle)
            settings.setValue('ETdrawstyle',self.qmc.ETdrawstyle)
            settings.setValue('ETlinewidth',self.qmc.ETlinewidth)
            settings.setValue('ETmarker',self.qmc.ETmarker)
            settings.setValue('ETmarkersize',self.qmc.ETmarkersize)
            settings.setValue('BTdeltalinestyle',self.qmc.BTdeltalinestyle)
            settings.setValue('BTdeltadrawstyle',self.qmc.BTdeltadrawstyle)
            settings.setValue('BTdeltalinewidth',self.qmc.BTdeltalinewidth)
            settings.setValue('BTdeltamarker',self.qmc.BTdeltamarker)
            settings.setValue('BTdeltamarkersize',self.qmc.BTdeltamarkersize)
            settings.setValue('ETdeltalinestyle',self.qmc.ETdeltalinestyle)
            settings.setValue('ETdeltadrawstyle',self.qmc.ETdeltadrawstyle)
            settings.setValue('ETdeltalinewidth',self.qmc.ETdeltalinewidth)
            settings.setValue('ETdeltamarker',self.qmc.ETdeltamarker)
            settings.setValue('ETdeltamarkersize',self.qmc.ETdeltamarkersize)
            settings.setValue('BTbacklinestyle',self.qmc.BTbacklinestyle)
            settings.setValue('BTbackdrawstyle',self.qmc.BTbackdrawstyle)
            settings.setValue('BTbacklinewidth',self.qmc.BTbacklinewidth)
            settings.setValue('BTbackmarker',self.qmc.BTbackmarker)
            settings.setValue('BTbackmarkersize',self.qmc.BTbackmarkersize)
            settings.setValue('ETbacklinestyle',self.qmc.ETbacklinestyle)
            settings.setValue('ETbackdrawstyle',self.qmc.ETbackdrawstyle)
            settings.setValue('ETbacklinewidth',self.qmc.ETbacklinewidth)
            settings.setValue('ETbackmarker',self.qmc.ETbackmarker)
            settings.setValue('ETbackmarkersize',self.qmc.ETbackmarkersize)
            settings.setValue('XTbacklinestyle',self.qmc.XTbacklinestyle)
            settings.setValue('XTbackdrawstyle',self.qmc.XTbackdrawstyle)
            settings.setValue('XTbacklinewidth',self.qmc.XTbacklinewidth)
            settings.setValue('XTbackmarker',self.qmc.XTbackmarker)
            settings.setValue('XTbackmarkersize',self.qmc.XTbackmarkersize)
            settings.setValue('YTbacklinestyle',self.qmc.YTbacklinestyle)
            settings.setValue('YTbackdrawstyle',self.qmc.YTbackdrawstyle)
            settings.setValue('YTbacklinewidth',self.qmc.YTbacklinewidth)
            settings.setValue('YTbackmarker',self.qmc.YTbackmarker)
            settings.setValue('YTbackmarkersize',self.qmc.YTbackmarkersize)
            settings.setValue('BTBdeltalinestyle',self.qmc.BTBdeltalinestyle)
            settings.setValue('BTBdeltadrawstyle',self.qmc.BTBdeltadrawstyle)
            settings.setValue('BTBdeltalinewidth',self.qmc.BTBdeltalinewidth)
            settings.setValue('BTBdeltamarker',self.qmc.BTBdeltamarker)
            settings.setValue('BTBdeltamarkersize',self.qmc.BTBdeltamarkersize)
            settings.setValue('ETBdeltalinestyle',self.qmc.ETBdeltalinestyle)
            settings.setValue('ETBdeltadrawstyle',self.qmc.ETBdeltadrawstyle)
            settings.setValue('ETBdeltalinewidth',self.qmc.ETBdeltalinewidth)
            settings.setValue('ETBdeltamarker',self.qmc.ETBdeltamarker)
            settings.setValue('ETBdeltamarkersize',self.qmc.ETBdeltamarkersize)
            self.setExtraDeviceCurveStyles(settings)
            settings.setValue('devicetablecolumnwidths',self.qmc.devicetablecolumnwidths)
            settings.endGroup()
            #background settings
            settings.beginGroup('background')
            settings.setValue('backgrounddetails',aw.qmc.backgroundDetails)
            settings.setValue('backgroundevents',aw.qmc.backgroundeventsflag)
            settings.setValue('movespeed',aw.qmc.backgroundmovespeed)
            settings.setValue('DeltaETB',aw.qmc.DeltaETBflag)
            settings.setValue('DeltaBTB',aw.qmc.DeltaBTBflag)
            settings.setValue('alignEvent',aw.qmc.alignEvent)
            settings.setValue('ETBflag',aw.qmc.backgroundETcurve)
            settings.setValue('BTBflag',aw.qmc.backgroundBTcurve)
            settings.setValue('backgroundShowFullflag',aw.qmc.backgroundShowFullflag)
            settings.setValue('clearBgbeforeprofileload',aw.qmc.clearBgbeforeprofileload)
            settings.setValue('hideBgafterprofileload',aw.qmc.hideBgafterprofileload)
            settings.endGroup()
            settings.setValue('compareAlignEvent',self.qmc.compareAlignEvent)
            settings.setValue('compareEvents',self.qmc.compareEvents)
            settings.setValue('compareET',self.qmc.compareET)
            settings.setValue('compareBT',self.qmc.compareBT)
            settings.setValue('compareDeltaET',self.qmc.compareDeltaET)
            settings.setValue('compareDeltaBT',self.qmc.compareDeltaBT)
            settings.setValue('compareMainEvents',self.qmc.compareMainEvents)
            settings.setValue('compareBBP',self.qmc.compareBBP)
            settings.setValue('compareRoast',self.qmc.compareRoast)
            settings.setValue('autosaveflag',self.qmc.autosaveflag)
            settings.setValue('autosaveaddtorecentfilesflag',self.qmc.autosaveaddtorecentfilesflag)
            settings.setValue('autosavepdf',self.qmc.autosaveimage)
            settings.setValue('autosaveimageformat',self.qmc.autosaveimageformat)
            settings.setValue('autosaveprefix',self.qmc.autosaveprefix)
            settings.beginGroup('WebLCDs')
            settings.setValue('active',self.WebLCDs)
            settings.setValue('port',self.WebLCDsPort)
            settings.setValue('alerts',self.WebLCDsAlerts)
            settings.endGroup()
            settings.setValue('LargeLCDs',self.LargeLCDsFlag)
            settings.setValue('LargeDeltaLCDs',self.LargeDeltaLCDsFlag)
            settings.setValue('LargePIDLCDs',self.LargePIDLCDsFlag)
            settings.setValue('LargeScaleLCDs',self.LargeScaleLCDsFlag)
            settings.setValue('LargeExtraLCDs',self.LargeExtraLCDsFlag)
            settings.setValue('LargePhasesLCDs',self.LargePhasesLCDsFlag)
            #custom event buttons
            settings.beginGroup('ExtraEventButtons')
            settings.setValue('buttonlistmaxlen',self.buttonlistmaxlen)
            settings.setValue('extraeventstypes',self.extraeventstypes)
            settings.setValue('extraeventsvalues',self.extraeventsvalues)
            settings.setValue('extraeventsactionstrings',self.extraeventsactionstrings)
            settings.setValue('extraeventsactions',self.extraeventsactions)
            settings.setValue('extraeventsdescriptions',self.extraeventsdescriptions)
            settings.setValue('extraeventsvisibility',self.extraeventsvisibility)
            settings.setValue('extraeventslabels',self.extraeventslabels)
            settings.setValue('extraeventbuttoncolor',self.extraeventbuttoncolor)
            settings.setValue('extraeventbuttontextcolor',self.extraeventbuttontextcolor)
            settings.setValue('extraeventsbuttonsflags',self.extraeventsbuttonsflags)
            settings.setValue('buttonpalette',self.buttonpalette)
            settings.setValue('buttonpalettemaxlen',self.buttonpalettemaxlen)
            settings.setValue('buttonpalette_shortcuts',self.buttonpalette_shortcuts)
            settings.setValue('eventbuttontablecolumnwidths',self.eventbuttontablecolumnwidths)
            settings.setValue('buttonsize',self.buttonsize)
            settings.setValue('buttonpalette_label',self.buttonpalette_label)
            settings.endGroup()
            settings.beginGroup('RoRlimits')
            settings.setValue('RoRlimitFlag',self.qmc.RoRlimitFlag)
            settings.setValue('RoRlimit',self.qmc.RoRlimit)
            settings.setValue('RoRlimitm',self.qmc.RoRlimitm)
            settings.endGroup()
            settings.beginGroup('grid')
            settings.setValue('xgrid',self.qmc.xgrid)
            settings.setValue('ygrid',self.qmc.ygrid)
            settings.setValue('zgrid',self.qmc.zgrid)
            settings.setValue('gridlinestyle',self.qmc.gridlinestyle)
            settings.setValue('gridthickness',self.qmc.gridthickness)
            settings.setValue('gridalpha',self.qmc.gridalpha)
#            settings.setValue("xrotation",self.qmc.xrotation)
            settings.endGroup()
            settings.beginGroup('Sliders')
            settings.setValue('slidervisibilities',self.eventslidervisibilities)
            settings.setValue('slideractions',self.eventslideractions)
            settings.setValue('slidercommands',self.eventslidercommands)
            settings.setValue('slideroffsets',self.eventslideroffsets)
            settings.setValue('sliderfactors',self.eventsliderfactors)
            settings.setValue('slidermin',self.eventslidermin)
            settings.setValue('slidermax',self.eventslidermax)
            settings.setValue('eventslidersflags',self.eventslidersflags)
            settings.setValue('eventsliderBernoulli',self.eventsliderBernoulli)
            settings.setValue('eventslidercoarse',self.eventslidercoarse)
            settings.setValue('eventslidertemp',self.eventslidertemp)
            settings.setValue('eventsliderunits',self.eventsliderunits)
            settings.setValue('ModeTempSliders',self.qmc.mode_tempsliders)
            settings.endGroup()
            settings.beginGroup('Quantifiers')
            settings.setValue('quantifieractive',self.eventquantifieractive)
            settings.setValue('quantifiersource',self.eventquantifiersource)
            settings.setValue('eventquantifierSV',self.eventquantifierSV)
            settings.setValue('quantifiermin',self.eventquantifiermin)
            settings.setValue('quantifiermax',self.eventquantifiermax)
            settings.setValue('quantifiercoarse',self.eventquantifiercoarse)
            settings.setValue('eventquantifieraction',self.eventquantifieraction)
            settings.setValue('clusterEventsFlag',self.clusterEventsFlag)
            settings.endGroup()
            settings.setValue('titleshowalways',self.qmc.title_show_always)
            settings.setValue('roastpropertiesflag',self.qmc.roastpropertiesflag)
            settings.setValue('roastpropertiesAutoOpenFlag',self.qmc.roastpropertiesAutoOpenFlag)
            settings.setValue('roastpropertiesAutoOpenDropFlag',self.qmc.roastpropertiesAutoOpenDropFlag)
            settings.setValue('customflavorlabels',self.qmc.customflavorlabels)
            settings.beginGroup('Batch')
            settings.setValue('batchcounter',self.qmc.batchcounter)
            settings.setValue('batchsequence',self.qmc.batchsequence)
            settings.setValue('batchprefix',self.qmc.batchprefix)
            settings.setValue('lastroastepoch',self.qmc.lastroastepoch)
            settings.setValue('neverUpdateBatchCounter',self.qmc.neverUpdateBatchCounter)
            settings.endGroup()
            settings.beginGroup('ExtrasMoreInfo')
            settings.setValue('showmet',self.qmc.showmet)
            settings.setValue('statssummary',self.qmc.statssummary)
            settings.setValue('statsmaxchrperline', self.qmc.statsmaxchrperline)
            settings.setValue('showtimeguide',self.qmc.showtimeguide)
            settings.endGroup()
            try:
                settings.setValue('appearance',aw.appearance)
            except Exception: # pylint: disable=broad-except
                pass
            settings.setValue('dpi',aw.dpi)

            settings.setValue('recentRoasts',self.recentRoasts)

            if aw.curFile and filename is None:
                settings.setValue('lastLoadedProfile',aw.curFile)
            else:
                settings.setValue('lastLoadedProfile','')
            if aw.qmc.backgroundpath and filename is None:
                settings.setValue('lastLoadedBackground',aw.qmc.backgroundpath)
            else:
                settings.setValue('lastLoadedBackground','')
            # on exported settings we add the current timestamp
            if filename:
                settings.setValue('timestamp', QDateTime.currentDateTime().toString('yyyy-MM-ddThh:mm:ss'))

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate('Error Message', 'Error',None),QApplication.translate('Error Message', 'Exception:') + ' closeEvent()  @line ' + str(getattr(exc_tb, 'tb_lineno', '?')))

    def closeEventSettings_theme(self, filename=None):
        try:
            if filename:
                settings = QSettings(filename,QSettings.Format.IniFormat)
            else:
                settings = QSettings()
            #save Events settings
            settings.beginGroup('events')
            settings.setValue('EvalueColor',self.qmc.EvalueColor)
            settings.setValue('EvalueTextColor',self.qmc.EvalueTextColor)
            settings.setValue('EvalueMarker',self.qmc.EvalueMarker)
            settings.setValue('Evaluelinethickness',self.qmc.Evaluelinethickness)
            settings.setValue('EvalueMarkerSize',self.qmc.EvalueMarkerSize)
            settings.setValue('Evaluealpha',self.qmc.Evaluealpha)
            settings.endGroup()
            #save phases watermarks flag
            settings.setValue('watermarks',self.qmc.watermarksflag)
            #save colors
            settings.setValue('Colors',self.qmc.palette)
            settings.setValue('Alphas',self.qmc.alpha)
            settings.setValue('LCDColors',self.lcdpaletteB)
            settings.setValue('LEDColors',self.lcdpaletteF)
            settings.setValue('ETBColor',self.qmc.backgroundmetcolor)
            settings.setValue('BTBColor',self.qmc.backgroundbtcolor)
            settings.setValue('ETBdeltaColor',self.qmc.backgrounddeltaetcolor)
            settings.setValue('BTBdeltaColor',self.qmc.backgrounddeltabtcolor)
            settings.setValue('BackgroundAlpha',self.qmc.backgroundalpha)
            settings.beginGroup('XT')
            settings.setValue('color',self.qmc.backgroundxtcolor)
            settings.setValue('color2',self.qmc.backgroundytcolor)
            settings.setValue('index',self.qmc.xtcurveidx)
            settings.setValue('index2',self.qmc.ytcurveidx)
            settings.endGroup()
            settings.beginGroup('grid')
            settings.setValue('gridalpha',self.qmc.gridalpha)
            settings.endGroup()

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate('Error Message', 'Error',None),QApplication.translate('Error Message', 'Exception:') + ' closeEventSettings_theme()  @line ' + str(getattr(exc_tb, 'tb_lineno', '?')))

    def updateExtraLCDvisibility(self):
        n = len(self.qmc.extradevices)
        for i in range(n):
            if i < aw.nLCDS:
                if self.extraLCDvisibility1[i]:
                    if i < len(self.qmc.extraname1):
                        l1 = '<b>' + self.qmc.extraname1[i] + '</b>'
                        try:
                            l1 = l1.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3])
                        except Exception: # pylint: disable=broad-except
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel1[i].setText(l1)
                        self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                    self.extraLCDframe1[i].setVisible(True)
                    self.extraLCD1[i].setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
                else:
                    self.extraLCDframe1[i].setVisible(False)
                if self.extraLCDvisibility2[i]:
                    if i < len(self.qmc.extraname2):
                        l2 = '<b>' + self.qmc.extraname2[i] + '</b>'
                        try:
                            l2 = l2.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3])
                        except Exception: # pylint: disable=broad-except
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel2[i].setText(l2)
                        self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
                    self.extraLCDframe2[i].setVisible(True)
                    self.extraLCD2[i].setStyleSheet('QLCDNumber { border-radius: 4; color: %s; background-color: %s;}'%(self.lcdpaletteF['sv'],self.lcdpaletteB['sv']))
                else:
                    self.extraLCDframe2[i].setVisible(False)
        #hide the rest (just in case)
        for i in range(n,aw.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)

    def stopActivities(self):
        if self.full_screen_mode_active:
            if not (platf == 'Darwin' and self.qmc.locale_str == 'en'):
                self.fullscreenAction.setChecked(False)
            self.showNormal()
        if aw.qmc.device == 53:
            from artisanlib.hottop import stopHottop
            stopHottop()
        if self.qmc.flagon:
            self.qmc.ToggleMonitor()
        if self.WebLCDs:
            self.stopWebLCDs()
            self.WebLCDs = True # to ensure they are started again on restart
        if self.LargeLCDsFlag and self.largeLCDs_dialog:
            tmp_LargeLCDs = self.LargeLCDsFlag # we keep the state to properly store it in the settings
            self.largeLCDs_dialog.close()
            self.LargeLCDsFlag = tmp_LargeLCDs
        if self.LargeDeltaLCDsFlag and self.largeDeltaLCDs_dialog:
            tmp_LargeLCDs = self.LargeDeltaLCDsFlag # we keep the state to properly store it in the settings
            self.largeDeltaLCDs_dialog.close()
            self.LargeDeltaLCDsFlag = tmp_LargeLCDs
        if self.LargePIDLCDsFlag and self.largePIDLCDs_dialog:
            tmp_LargeLCDs = self.LargePIDLCDsFlag # we keep the state to properly store it in the settings
            self.largePIDLCDs_dialog.close()
            self.LargePIDLCDsFlag = tmp_LargeLCDs
        if self.LargeScaleLCDsFlag and self.largeScaleLCDs_dialog:
            tmp_LargeLCDs = self.LargeScaleLCDsFlag # we keep the state to properly store it in the settings
            self.largeScaleLCDs_dialog.close()
            self.LargeScaleLCDsFlag = tmp_LargeLCDs
        if self.LargeExtraLCDsFlag and self.largeExtraLCDs_dialog:
            tmp_LargeLCDs = self.LargeExtraLCDsFlag # we keep the state to properly store it in the settings
            self.largeExtraLCDs_dialog.close()
            self.LargeExtraLCDsFlag = tmp_LargeLCDs
        if self.LargePhasesLCDsFlag and self.largePhasesLCDs_dialog:
            tmp_LargeLCDs = self.LargePhasesLCDsFlag # we keep the state to properly store it in the settings
            self.largePhasesLCDs_dialog.close()
            self.LargePhasesLCDsFlag = tmp_LargeLCDs
        if self.comparator:
            self.comparator.close()
        # now wait until the current sampling thread is terminated
        while aw.qmc.flagsamplingthreadrunning:
            QApplication.processEvents()
            libtime.sleep(.1)
        if self.ser.R1 is not None:
            self.ser.R1 = None
        try:
            self.closeserialports()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            aw.qmc.closePhidgetOUTPUTs()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            aw.qmc.closePhidgetAMBIENTs()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        aw.qmc.stopPhidgetManager()

    # returns True if confirmed, False if canceled by the user
    def closeApp(self):
        aw.quitAction.setEnabled(False)
        try:
            unsaved_changes = bool(self.qmc.safesaveflag == True)
            if self.qmc.checkSaved(): # if not canceled
                flagKeepON = aw.qmc.flagKeepON
                self.qmc.flagKeepON = False # temporarily turn keepOn off
                self.stopActivities()
                self.qmc.flagKeepON = flagKeepON
                if unsaved_changes:
                    # in case we have unsaved changes and the user decided to discard those, we first reset to have the correct settings (like axis limits) saved
                    self.qmc.reset(redraw=False,soundOn=False,sampling=False,keepProperties=False,fireResetAction=False)
                self.closeEventSettings()
                gc.collect()
                QApplication.exit()
                return True
            self.quitAction.setEnabled(True)
            return False
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            aw.quitAction.setEnabled(True)
            return False

    @staticmethod
    def closeserialports():
        # close main instrument port
        aw.ser.closeport()
        # close extra device ports
        for i in range(len(aw.extraser)):
            try:
                if aw.extraser[i].SP.isOpen():
                    aw.extraser[i].SP.close()
                    libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port gets disabled
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        # close modbus port
        aw.modbus.disconnect()
        # close s7 port
        aw.s7.disconnect()
        # close scale port
        try:
            if aw.scale:
                aw.scale.closeport()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        # close color meter port
        try:
            if aw.color:
                aw.color.closeport()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileQuit(self,_=False):
        self.closeApp()

    @pyqtSlot()
    @pyqtSlot(bool)
    def filePrint(self,_=False):
        image = aw.qmc.grab().toImage() # a QImage on macOS
        if image.isNull():
            return
        if self.printer is None:
            self.printer = QPrinter(QPrinter.PrinterMode.HighResolution) # (QPrinter.PrinterMode.PrinterResolution)
            self.printer.setCreator(application_name)
#            self.printer.setResolution(300)
        form = QPrintDialog(self.printer, self)
        if form.exec():
            # painter coordinates
            painter = QPainter(self.printer)
            rect = painter.viewport()
            # image coordinates
            size = image.size()
            rect_size = rect.size()
            graph_height = size.height()
            rect_size.setHeight(int(round(rect_size.height()*aw.devicePixelRatio())))
            rect_size.setWidth(int(round(rect_size.width()*aw.devicePixelRatio())))
            size.scale(rect_size, Qt.AspectRatioMode.KeepAspectRatio)
            painter.setViewport(rect.x(), rect.y(), size.width(), size.height()) # sets device coordinate system
            image_rect = image.rect()
#            image_rect.setHeight(int(round(image_rect.height()/aw.devicePixelRatio())))
#            image_rect.setWidth(int(round(image_rect.width()/aw.devicePixelRatio())))
            painter.setWindow(image_rect) #scale to fit page # sets logical coordinate system
            if isinstance(image, QPixmap):
                painter.drawPixmap(0, 0, image)
            else:
                painter.drawImage(0, 0, image)
            if bool(self.comparator) and self.qpc and len(self.splitter.sizes())>1 and self.splitter.sizes()[1]>0:
                phases_image = aw.qpc.grab().toImage() # a QImage on macOS
                if not phases_image.isNull():
                    if self.printer.pageLayout().orientation() == QPageLayout.Orientation.Landscape:
                        self.printer.newPage()
                        offset = 0
                    else:
                        offset = int(round(graph_height/aw.devicePixelRatio())) # put the phases graph below the profile graph
                    size = phases_image.size()
                    rect_size = rect.size()
                    rect_size.setHeight(int(round(rect_size.height()*aw.devicePixelRatio())))
                    rect_size.setWidth(int(round(rect_size.width()*aw.devicePixelRatio())))
                    size.scale(rect_size, Qt.AspectRatioMode.KeepAspectRatio)
                    painter.setViewport(rect.x(), rect.y(), size.width(), size.height()) # sets device coordinate system
                    image_rect = phases_image.rect()
        #            image_rect.setHeight(int(round(image_rect.height()/aw.devicePixelRatio())))
        #            image_rect.setWidth(int(round(image_rect.width()/aw.devicePixelRatio())))
                    painter.setWindow(image_rect) #scale to fit page # sets logical coordinate system
                    if isinstance(phases_image, QPixmap):
                        painter.drawPixmap(0, 0, phases_image)
                    else:
                        painter.drawImage(0, offset, phases_image)
            painter.end()
            del painter

    # takes a production data generated by profileProductionData(profile) and extracts the following as keyed string values in a dict:
    #  . "id"
    #  . "time" (as string, rendered with data and time separated by a space)
    #  . "datetime" (epoch, not a string!)
    #  . "title"
    #  . "beans"
    #  . "weight_in"
    #  . "weight_out"
    #  . "weight_loss"
    #  . "weight_in_num" (numeric in g)
    #  . "weight_out_num" (numeric in g)
    #  . "weight_loss_num" (numeric in %)
    #  . "whole_color"
    #  . "ground_color"
    #  . "color_system"
    #  . "roastertype"
    #  . "roastersize"
    #  . "beansize_min"
    #  . "beansize_max"
    #  . "roastingnotes"
    #  . "cuppingnotes"
    @staticmethod
    def productionData2string(data, units = True):
        res = {}
        # id (prefix+nr)
        res['nr'] = str(data['batchnr'])
        res['id'] = ((data['batchprefix'] + str(data['batchnr'])) if (data['batchnr'] != 0) else '')
        # title
        res['title'] = data['title']
        # date and time
        res['time'] = ''
        res['date'] = ''
        if not 'roastdate' in data or not data['roastdate']:
            data['roastdate'] = QDateTime(QDate.currentDate()) # we just take the local time
        try:
            res['datetime'] = data['roastdate'].toPyDateTime() # toMSecsSinceEpoch()
        except Exception: # pylint: disable=broad-except
            data['roastdate'] = QDateTime(QDate.currentDate()) # we just take the local time
        date = data['roastdate'].date()
        time = data['roastdate'].time()
        if date:
            res['time'] = date.toString('yy-MM-dd') # Qt.DateFormat.SystemLocaleShortDate, Qt.DateFormat.ISODate
        if time:
            res['time'] += ' ' + time.toString('HH:mm') # Qt.DateFormat.SystemLocaleShortDate, Qt.DateFormat.ISODate
        # beans
        res['beans'] = data['beans']
        # weight
        if 'weight' in data:
            w = data['weight']
            unit = aw.qmc.weight[2]
            wi = aw.convertWeight(w[0],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index(unit))
            wo = aw.convertWeight(w[1],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index(unit))
            if unit in ['Kg','lb','oz']:
                res['weight_in'] = f'{wi:.3f}'
                res['weight_out'] = f'{wo:.3f}'
            else:
                res['weight_in'] = f'{wi:.0f}'
                res['weight_out'] = f'{wo:.0f}'
            un = aw.qmc.weight[2].lower()
            loss = aw.weight_loss(w[0],w[1])
            if 0 < loss < 100:
                res['weight_loss'] = f'{loss:.1f}'
            else:
                res['weight_loss'] = ''
            res['weight_in_num'] = aw.convertWeight(w[0],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index('g'))
            res['weight_out_num'] = aw.convertWeight(w[1],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index('g'))
            res['weight_loss_num'] = loss
            if units:
                if wi > 0:
                    res['weight_in'] += un
                if wo > 0:
                    res['weight_out'] += un
                if 0 < loss < 100:
                    res['weight_loss'] += '%'
        else:
            res['weight_in'] = ''
            res['weight_out'] = ''
            res['weight_loss'] = ''
            res['weight_in_num'] = 0
            res['weight_out_num'] = 0
            res['weight_loss_num'] = 0
        res['whole_color'] = (data['whole_color'] if 'whole_color' in data else '')
        res['ground_color'] = (data['ground_color'] if 'ground_color' in data else 0)
        res['color_system'] = (data['color_system'] if 'color_system' in data else 0)
        res['roastertype'] = (data['roastertype'] if 'roastertype' in data else '')
        res['roastersize'] = (data['roastersize'] if 'roastersize' in data else 0)
        res['beansize_min'] = (data['beansize_min'] if 'beansize_min' in data else 0)
        res['beansize_max'] = (data['beansize_max'] if 'beansize_max' in data else 0)
        res['roastingnotes'] = (data['roastingnotes'] if 'roastingnotes' in data else '')
        res['cuppingnotes'] = (data['cuppingnotes'] if 'cuppingnotes' in data else '')
        return res

    def productionData2htmlentry(self,data):
        import string as libstring
        HTML_REPORT_TEMPLATE = """<tr>
<td sorttable_customkey=\"$batch_num\">$batch</td>
<td>$time</td>
<td>$title</td>
<td>$beans</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$out_num\">$weightout</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
</tr>"""
        ds = self.productionData2string(data,units=False)
        batch_html = ds['id']
        time_html = ds['time']
        title_html = ds['title']
        beans_html = ds['beans']
        try:
            if 'roastUUID' in data and data['roastUUID'] is not None and data['roastUUID'] != '':
                roast_uuid = data['roastUUID']
#                if plus.register.getPath(roast_uuid):
#                    title_html = '<a href="artisan://roast/{0}">{1}</a>'.format(roast_uuid,title_html)
                title_html = f'<a href="artisan://roast/{roast_uuid}">{title_html}</a>'
                if bool(plus.sync.getSync(roast_uuid)):
                    time_html = f'<a href="{plus.util.roastLink(roast_uuid)}" target="_blank">{time_html}</a>'
                if 'plus_coffee' in data and data['plus_coffee'] is not None and data['plus_coffee'] != '':
                    beans_html = '<a href="{}" target="_blank">{}</a>'.format(plus.util.coffeeLink(data['plus_coffee']),beans_html)
        except Exception: # pylint: disable=broad-except
            pass
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            batch_num = ds['nr'],
            batch = batch_html,
            time = time_html,
            title = title_html,
            beans = beans_html,
            weightin = ds['weight_in'],
            weightout = ds['weight_out'],
            weightloss = ds['weight_loss'],
            in_num = '{:.0f}'.format(ds['weight_in_num']),
            out_num = '{:.0f}'.format(ds['weight_out_num']),
            loss_num = '{:.2f}'.format(ds['weight_loss_num']),
        )

    # extracts the following from a give profile dict in a new dict:
    #  . "batchprefix": string
    #  . "batchnr": int
    #  . "title": string
    #  . "roastdate": QDateTime
    #  . "beans": string
    #  . "weight": [<weight-in>:float,<weight-out>:float,<units>: string] or None
    @staticmethod
    def profileProductionData(profile):
        res = {}
        # id ("prefix+nr (sequence)")
        if 'roastbatchprefix' in profile:
            res['batchprefix'] = decodeLocal(profile['roastbatchprefix'])
        else:
            res['batchprefix'] = ''
        # batch number
        if 'roastbatchnr' in profile:
            res['batchnr'] = int(profile['roastbatchnr'])
        else:
            res['batchnr'] = 0
        # UUID
        if 'roastUUID' in profile:
            res['roastUUID'] = profile['roastUUID']
        # plus_coffee
        if 'plus_coffee' in profile:
            res['plus_coffee'] = profile['plus_coffee']
        # title
        if 'title' in profile:
            res['title'] = decodeLocal(profile['title'])
        else:
            res['title'] = ''
        # date and time
        res['roastdate'] = None
        if 'roastdate' in profile:
            try:
                date = QDate.fromString(decodeLocal(profile['roastdate']))
                if 'roasttime' in profile:
                    try:
                        time = QTime.fromString(decodeLocal(profile['roasttime']))
                        res['roastdate'] = QDateTime(date,time)
                    except Exception: # pylint: disable=broad-except
                        res['roastdate'] = QDateTime(date)
                else:
                    res['roastdate'] = QDateTime(date)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        if 'roastisodate' in profile:
            try:
                date = QDate.fromString(decodeLocal(profile['roastisodate']), Qt.DateFormat.ISODate)
                if 'roasttime' in profile:
                    try:
                        time = QTime.fromString(decodeLocal(profile['roasttime']))
                        res['roastdate'] = QDateTime(date,time)
                    except Exception: # pylint: disable=broad-except
                        res['roastdate'] = QDateTime(date)
                else:
                    res['roastdate'] = QDateTime(date)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        # beans
        if 'beans' in profile:
            res['beans'] = decodeLocal(profile['beans'])
        else:
            res['beans'] = ''
        # weight
        if 'weight' in profile:
            res['weight'] = [profile['weight'][0],profile['weight'][1],decodeLocal(profile['weight'][2])]
        if 'whole_color' in profile:
            res['whole_color'] = profile['whole_color']
        if 'ground_color' in profile:
            res['ground_color'] = profile['ground_color']
        if 'color_system' in profile:
            res['color_system'] = profile['color_system']
        if 'roastertype' in profile:
            res['roastertype'] = profile['roastertype']
        if 'roastersize' in profile:
            res['roastersize'] = profile['roastersize']
        if 'beansize_min' in profile:
            res['beansize_min'] = profile['beansize_min']
        if 'beansize_max' in profile:
            res['beansize_max'] = profile['beansize_max']
        if 'roastingnotes' in profile:
            res['roastingnotes'] = profile['roastingnotes']
        if 'cuppingnotes' in profile:
            res['whole_color'] = profile['whole_color']
        return res

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionPDFReport(self,_=False):
        self.productionReport(pdf=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionHTMLReport(self,_=False):
        self.productionReport()

    def productionReport(self, pdf=False):
        import string as libstring
        # get profile filenames
        files = self.reportFiles()
        try:
            if files and len(files) > 0:
                profiles = [self.deserialize(f) for f in files]
                # let's sort by isodate
                profiles = sorted(profiles,
                    key=lambda p: (QDateTime(QDate.fromString(p['roastisodate'], Qt.DateFormat.ISODate),QTime.fromString(p['roasttime'])).toMSecsSinceEpoch()
                         if 'roastisodate' in p and 'roasttime' in p else 0))
                with open(getResourcePath() + 'report-template.htm', encoding='utf-8') as myfile:
                    HTML_REPORT_TEMPLATE=myfile.read()
                entries = ''
                total_in = 0
                total_out = 0
                unit = aw.qmc.weight[2]
                # collect data
#                c = 1
                for p in profiles:
                    d = self.profileProductionData(p)
                    last_unit = d['weight'][2]
                    total_in += aw.convertWeight(d['weight'][0],aw.qmc.weight_units.index(last_unit),aw.qmc.weight_units.index(unit))
                    total_out += aw.convertWeight(d['weight'][1],aw.qmc.weight_units.index(last_unit),aw.qmc.weight_units.index(unit))
                    entries += self.productionData2htmlentry(d) + '\n'
#                    c += 1

                html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                    title = QApplication.translate('HTML Report Template', 'Roast Batches'),
                    entries = entries,
                    total_in = (f'{total_in:.2f}' if unit in ['Kg','lb', 'oz'] else f'{total_in:.0f}'),
                    total_out = (f'{total_out:.2f}' if unit in ['Kg','lb', 'oz'] else f'{total_out:.0f}'),
                    total_loss = f'{aw.weight_loss(total_in,total_out):.1f}',
                    resources = str(getResourcePath()),
                    batch = QApplication.translate('HTML Report Template', 'Batch'),
                    time = QApplication.translate('HTML Report Template', 'Date'),
                    profile = QApplication.translate('Label', 'Title'),
                    beans = QApplication.translate('HTML Report Template', 'Beans'),
                    weightin = QApplication.translate('HTML Report Template', 'In'),
                    weightout = QApplication.translate('HTML Report Template', 'Out'),
                    loss = QApplication.translate('HTML Report Template', 'Loss'),
                    sum = QApplication.translate('HTML Report Template', 'SUM'),
                    unit = unit.lower()
                )

                f = None
                try:
                    tmpdir = str(QDir.tempPath() + '/')
                    filename = str(QDir(tmpdir).filePath('ProductionReport.html'))
                    try:
                        os.remove(filename)
                    except OSError:
                        pass
                    import codecs
                    with codecs.open(filename, 'w', encoding='utf-8') as f:
                        for i in range(len(html)):
                            f.write(html[i])
                    if platf == 'Darwin':
                        full_path = 'file://' + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                    else:
                        full_path = 'file:///' + filename # Explorer refuses to start otherwise
                    if pdf:
                        # select file
                        filename = self.ArtisanSaveFileDialog(msg='Export PDF',ext='*.pdf')
                        if filename:
                            self.html2pdf(full_path, filename, landscape=True)
                    else:
                        QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

                except OSError as e:
                    aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' productionReport() {0}').format(str(e)))
                finally:
                    if f:
                        f.close()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' productionReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveStatistics(self,_=False):
        try:
            aw.qmc.redraw()
            QApplication.processEvents()
            # 0. MPL coordinate systems & transformations:
            #   https://matplotlib.org/3.1.1/tutorials/advanced/transforms_tutorial.html
            # 1.get bounding box in axis coordinates
            try:
                rect_extents = aw.qmc.stats_summary_rect.get_bbox()
            except Exception: # pylint: disable=broad-except
                aw.sendmessage(QApplication.translate('Message','No statistics found'))
                return
            # 2. convert those to display coordinates
            rect_extents_display = aw.qmc.ax.transData.transform(rect_extents)
            # 3. convert display coordinates to figure-inches
            rect_extents_bbox_inches = aw.qmc.fig.dpi_scale_trans.inverted().transform(rect_extents_display)
            # 4. generate
            rect_bbox_inches =  mpl.transforms.Bbox.from_extents(rect_extents_bbox_inches)
            # 5. fig.save
            # MPL 3.1.1 does not properly handle saving pdf on Windows when figure dpi not 72.  Maybe fixed in a future version.
            # ref: https://github.com/matplotlib/matplotlib/issues/15497#issuecomment-548072609
            if platf == 'Windows':
                ext = '*.png'
            else:
                ext = '*.pdf'
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Statistics'), ext=ext)
            if filename:
                aw.qmc.fig.set_tight_layout(False)
                aw.qmc.fig.savefig(filename,bbox_inches=rect_bbox_inches,pad_inches=0)
                aw.qmc.fig.set_tight_layout(aw.qmc.tight_layout_params)
                aw.sendmessage(QApplication.translate('Message','Statistics Saved'))

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' saveStatistics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionCSVReport(self,_=False):
        import csv
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export CSV',ext='*.csv')
            if filename:
                try:
                    # write header
                    with open(filename, 'w',newline='', encoding='utf-8') as outfile:
                        writer= csv.writer(outfile,delimiter='\t')
                        writer.writerow(['batch','time','profile','beans','in (g)','out (g)','loss (%)','date','time',
                            f'in ({aw.qmc.weight[2].lower()})',f'out ({aw.qmc.weight[2].lower()})',
                            'whole color', 'ground color', 'color system', 'machine', 'capacity (kg)', 'beansize min', 'beansize max', 'roasting notes', 'cupping notes'])
                        # write data
#                        c = 1
                        short_date_format = QLocale().dateFormat(QLocale.FormatType.ShortFormat)
                        for p in profiles:
                            try:
                                d = self.productionData2string(self.profileProductionData(self.deserialize(p)),units=False)
                                dt = QDateTime.fromMSecsSinceEpoch(int(round(d['datetime'].timestamp()*1000)))
                                writer.writerow([
                                    s2a(d['id']),
                                    s2a(d['time']),
                                    s2a(d['title']),
                                    s2a(d['beans']),
                                    '{:.0f}'.format(d['weight_in_num']),
                                    '{:.0f}'.format(d['weight_out_num']),
                                    '{:.1f}'.format(d['weight_loss_num']),
                                    s2a(dt.date().toString(short_date_format)),
                                    s2a(dt.time().toString(short_date_format)),
                                    s2a(d['weight_in']),
                                    s2a(d['weight_out']),
                                    d['whole_color'],
                                    d['ground_color'],
                                    s2a(d['color_system']),
                                    s2a(d['roastertype']),
                                    d['roastersize'],
                                    d['beansize_min'],
                                    d['beansize_max'],
                                    s2a(d['roastingnotes']),
                                    s2a(d['cuppingnotes']),
                                    ])
#                                c += 1
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    @staticmethod
    def excel_date(date_time):
        delta = date_time - datetime.datetime(1899, 12, 30)
        return float(delta.days  - 1462) + (float(delta.seconds) / 86400)

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionExcelReport(self,_=False):
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export Excel',ext='*.xlsx')
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook # pylint: disable=unused-import
                    from openpyxl.utils.cell import get_column_letter  # @UnusedImport # pylint: disable=unused-import
                    from openpyxl.styles import Font, Fill  # @UnusedImport # pylint: disable=unused-import
                    wb = Workbook()
                    ws = wb.active # wb.create_sheet()
                    ws.title = QApplication.translate('HTML Report Template', 'Production Report')

                    bf = Font(bold=True)
                    unit = aw.qmc.weight[2]

                    # write header
                    ws['A1'] = QApplication.translate('HTML Report Template', 'Batch')
                    ws['A1'].font = bf
                    ws['B1'] = QApplication.translate('HTML Report Template', 'Time')
                    ws['B1'].font = bf
                    ws.column_dimensions['B'].width = 18
                    ws['C1'] = QApplication.translate('HTML Report Template', 'Profile')
                    ws['C1'].font = bf
                    ws.column_dimensions['C'].width = 25
                    ws['D1'] = QApplication.translate('HTML Report Template', 'Beans')
                    ws['D1'].font = bf
                    ws.column_dimensions['D'].width = 25
                    ws['E1'] = QApplication.translate('HTML Report Template', 'In') + ' (' + str(unit.lower()) + ')'
                    ws['E1'].font = bf
                    ws['F1'] = QApplication.translate('HTML Report Template', 'Out') + ' (' + str(unit.lower()) + ')'
                    ws['F1'].font = bf
                    ws['G1'] = QApplication.translate('HTML Report Template', 'Loss')
                    ws['G1'].font = bf

                    def avgFormat(c,r1,r2):
                        e1 = f'{r1}{c}'
                        e2 =f'{r2}{c}'
                        return '=IF(' + e1 + '=0,0,(' + e1 + ' - ' + e2 + ') / ' + e1 + ')'

                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            raw_data = self.profileProductionData(self.deserialize(p))
                            c += 1
                            d = self.productionData2string(raw_data,units=False)
                            ws[f'A{c}'] = d['id']
                            ws[f'B{c}'] = QDateTime(d['datetime']).toPyDateTime()
                            ws[f'B{c}'].number_format = 'YYYY-MM-DD HH:MM'
                            ws[f'C{c}'] = d['title']
                            ws[f'D{c}'] = d['beans']
                            w_in = aw.convertWeight(raw_data['weight'][0],aw.qmc.weight_units.index(raw_data['weight'][2]),aw.qmc.weight_units.index(unit))
                            w_out = aw.convertWeight(raw_data['weight'][1],aw.qmc.weight_units.index(raw_data['weight'][2]),aw.qmc.weight_units.index(unit))
                            ws[f'E{c}'] = w_in
                            if unit in['Kg','lb','oz']:
                                num_format = '0.00'
                            else:
                                num_format = '0'
                            ws[f'E{c}'].number_format = num_format
                            ws[f'F{c}'] = w_out
                            ws[f'F{c}'].number_format = num_format
                            ws[f'G{c}'] = avgFormat(c,'E','F')
                            ws[f'G{c}'].number_format = '0.0%'
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    # write trailer
                    if c > 1:
                        ws[f'A{c+1}'] = QApplication.translate('HTML Report Template', 'SUM')
                        ws[f'A{c+1}'].font = bf
                        ws[f'E{c+1}'] = f'=SUM(E2:E{c})'
                        ws[f'E{c+1}'].font = bf
                        ws[f'E{c+1}'].number_format = num_format
                        ws[f'F{c+1}'] = f'=SUM(F2:F{c})'
                        ws[f'F{c+1}'].font = bf
                        ws[f'F{c+1}'].number_format = num_format
                        ws[f'G{c+1}'] = avgFormat(c+1,'E','F')
                        ws[f'G{c+1}'].font = bf
                        ws[f'G{c+1}'].number_format = '0.0%'
                    wb.save(filename)
                    aw.sendmessage(QApplication.translate('Message','Excel Production Report exported to {0}').format(filename))
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' productionExcelReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    # extracts the following from a give profile dict in a new dict:
    #  . "temp_unit": string (temperature unit, F or C)
    #  . "timex" : [] array of sample times
    #  . "temp2" : [] array of temperatures
    #  . "charge_temp": int
    #  . "FCs_time": int (in seconds)
    #  . "FCs_temp": string
    #  . "DROP_time": int (in seconds)
    #  . "DROP_temp": string
    #  . "DRY_percent": float (first phase percentage)
    #  . "MAI_percent": float (second phase percentage)
    #  . "DEV_percent": float (third phase percentage)
    #  . "DRY_time": int (in seconds)
    #  . "MAI_time": int (in seconds)
    #  . "DEV_time": int (in seconds)
    #  . "AUC": int
    #  . "color": int
    #  . "cup": int
    #  . "energy": float in kWh
    #  . "co2": float in g
    #  . "co2kg": float in g
    def profileRankingData(self,profile):
        res = {}
        # temp_unit
        res['temp_unit'] = profile['mode']
        timex = profile['timex']
        res['timex'] = timex
        timeindex = [max(0,v) if i>0 else max(-1,v) for i,v in enumerate(profile['timeindex'])]
        res['charge_idx'] = (timeindex[0] if timeindex[0] > -1 else 0)
        res['drop_idx'] = (timeindex[6] if timeindex[6] > 0 else len(timex))
        bt = profile['temp2']
        res['temp'] = bt
        # charge_temp
        if timeindex[0] > -1:
            start = timex[timeindex[0]]
            res['charge_temp'] = bt[timeindex[0]]
        else:
            start = 0
        if timeindex[2] > 0:
            # FCs_time
            res['FCs_time'] = timex[timeindex[2]] - start
            # FCs_temp
            res['FCs_temp'] = bt[timeindex[2]]
        if timeindex[6] > 0:
            # DROP_time
            res['DROP_time'] = timex[timeindex[6]] - start
            # DROP_temp
            res['DROP_temp'] = bt[timeindex[6]]
        if len(timex) > timeindex[6]:
            total_time = (timex[timeindex[6]] - start)
        else:
            total_time = 0
        # DRY_time
        if timeindex[1] > 0:
            # DRY_time
            dry_time = timex[timeindex[1]] - start
            # DRY_percent
            if total_time > 0:
                res['DRY_percent'] = (dry_time/total_time) * 100.
            else:
                res['DRY_percent'] = 0
            res['DRY_time'] = dry_time
        # MAI_time
        if timeindex[1] > 0 and timeindex[2] > 0:
            # MAI_time
            mai_time = timex[timeindex[2]] - timex[timeindex[1]]
            # MAI_percent
            if total_time > 0:
                res['MAI_percent'] = (mai_time/total_time) * 100.
            else:
                res['MAI_percent'] = 0
            res['MAI_time'] = mai_time
        if timeindex[2] > 0 and timeindex[6] > 0:
            # DEV_time
            dev_time = timex[timeindex[6]] - timex[timeindex[2]]
            # DEV_percent
            if total_time > 0:
                res['DEV_percent'] = (dev_time/total_time) * 100.
            else:
                res['DEV_percent'] = 0
            res['DEV_time'] = dev_time
        # AUC
        if 'computed' in profile:
            comp = profile['computed']
            if 'AUC' in comp:
                res['AUC'] = comp['AUC']
            if 'BTU_batch' in comp:
                res['energy'] = self.qmc.convertHeat(comp['BTU_batch'],0,3)
            if 'CO2_batch' in comp:
                res['co2'] = comp['CO2_batch']
            if 'CO2_batch_per_green_kg' in comp:
                res['co2kg'] = comp['CO2_batch_per_green_kg']
        # color
        if 'ground_color' in profile:
            res['color'] = profile['ground_color']
        # cup
        if 'flavors' in profile:
            res['cupping'],_ = self.cuppingSum(profile['flavors'])
        return res


    # takes ranking data generated by profileRankingData(profile) and extracts the following as keyed string values in a dict:
    #  . "charge_temp"
    #  . "FCs_time"
    #  . "FCs_temp"
    #  . "DROP_time"
    #  . "DROP_temp"
    #  . "DRY_percent"
    #  . "MAI_percent"
    #  . "DEV_percent"
    #  . "AUC"
    #  . "color"
    #  . "cupping"
    #  . "energy"
    #  . "co2"
    #  . "co2kg"
    def rankingData2string(self,data,units=True):
        res = {}
        res['charge_temp_num'] = (convertTemp(data['charge_temp'],(data['temp_unit'] if units else ''),aw.qmc.mode) if 'charge_temp' in data else 0)
        res['charge_temp'] = self.formatTemp(data,'charge_temp',data['temp_unit'],units)
        res['FCs_time_num'] = (data['FCs_time'] if 'FCs_time' in data else 0)
        res['FCs_time'] = (self.eventtime2string(data['FCs_time']) if 'FCs_time' in data else '')
        res['FCs_temp_num'] = (convertTemp(data['FCs_temp'],(data['temp_unit'] if units else ''),aw.qmc.mode) if 'FCs_temp' in data else 0)
        res['FCs_temp'] = self.formatTemp(data,'FCs_temp',data['temp_unit'],units)
        res['DROP_time_num'] = (data['DROP_time'] if 'DROP_time' in data else 0)
        res['DROP_time'] = (self.eventtime2string(data['DROP_time']) if 'DROP_time' in data else '')
        res['DROP_temp_num'] = (convertTemp(data['DROP_temp'],(data['temp_unit'] if units else ''),aw.qmc.mode) if 'DROP_temp' in data else 0)
        res['DROP_temp'] = self.formatTemp(data,'DROP_temp',data['temp_unit'],units)
        res['color_num'] = (data['color'] if 'color' in data else 0)
        res['color'] = (('#' if units else '' ) + str(data['color']) if 'color' in data and data['color'] != 0 else '')
        res['cupping'] = '{:.2f}'.format(data['cupping'])
        res['DRY_percent_num'] = ('{:.1f}'.format(data['DRY_percent']) if 'DRY_percent' in data else 0)
        res['DRY_percent'] = ('{:.1f}'.format(data['DRY_percent']) + ('%' if units else '') if 'DRY_percent' in data else '')
        res['MAI_percent_num'] = ('{:.1f}'.format(data['MAI_percent']) if 'MAI_percent' in data else 0)
        res['MAI_percent'] = ('{:.1f}'.format(data['MAI_percent']) + ('%' if units else '') if 'MAI_percent' in data else '')
        res['DEV_percent_num'] = ('{:.1f}'.format(data['DEV_percent']) if 'DEV_percent' in data else 0)
        res['DEV_percent'] = ('{:.1f}'.format(data['DEV_percent']) + ('%' if units else '') if 'DEV_percent' in data else '')
        res['AUC_num'] = (data['AUC'] if 'AUC' in data else 0)
        res['AUC'] = (data['AUC'] if 'AUC' in data else '')
        res['energy_num'] = ('{:.1f}'.format(data['energy']) if 'energy' in data else 0)
        res['energy'] = ('{:.1f}'.format(data['energy']) + ('kWh' if units else '') if 'energy' in data else '')
        res['co2_num'] = ('{:.1f}'.format(data['co2']) if 'co2' in data else 0)
        res['co2'] = ('{:.1f}'.format(data['co2']) + ('g' if units else '') if 'co2' in data else '')
        res['co2kg_num'] = ('{:.1f}'.format(data['co2kg']) if 'co2kg' in data else 0)
        res['co2kg'] = ('{:.1f}'.format(data['co2kg']) + ('g' if units else '') if 'co2kg' in data else '')
        return res

    @staticmethod
    def rankingdataDef():
        field_index = [
            'fld',     #field name as used in source list or an eval string
            'src',     #data source from where to pull fld [prof,comp,rank,prod,eval,]
            'typ',     #content type [text,int,float1,float2,float4,text2float1,text2float2,text2int,percent,time,bool,]
            'test0',   #test for a zero value and substitute an empty string
            'units',   #conversion units [temp,weight,volume,ror,] or maxlen when typ=="text"
            'name',    #translated field name for use in the header
        ]
        ranking_data_fields = [
            #fld,                   source,  typ,        test0,    units,   name
            ['id',                  'prod',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Batch')                ],
            ['datetime',            'prod',  'date',     'false',  '',      QApplication.translate('HTML Report Template','Time')                 ],
            ['title',               'prod',  'text',     'false',  '60',    QApplication.translate('HTML Report Template','Profile')              ],
            ['weightin',            'comp',  'float1',   'false',  'weight',QApplication.translate('HTML Report Template','Weight In')            ],
            ['CHARGE_BT',           'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','CHARGE BT')            ],
            ['FCs_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','FCs Time')             ],
            ['FCs_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','FCs BT')               ],
            ['DROP_time',           'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','DROP Time')            ],
            ['DROP_BT',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','DROP BT')              ],
            ['DRY_percent',         'rank',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Dry Percent')          ],
            ['MAI_percent',         'rank',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','MAI Percent')          ],
            ['DEV_percent',         'rank',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Dev Percent')          ],
            ['AUC',                 'comp',  'int',      'false',  '',      QApplication.translate('HTML Report Template','AUC')                  ],
            ['weight_loss',         'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Weight Loss')          ],
            ['color',               'rank',  'text2int', 'false',  '',      QApplication.translate('HTML Report Template','Color')                ],
            ['cupping',             'rank',  'text2int', 'false',  '',      QApplication.translate('HTML Report Template','Cupping')              ],
            ['roastertype',         'prof',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Roaster')              ],
            ['roastersize',         'prof',  'float1',   'true',   '',      QApplication.translate('HTML Report Template','Capacity')             ],
            ['operator',            'prof',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Operator')             ],
            ['organization',        'prof',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Organization')         ],
            ['drumspeed',           'prof',  'text2int', 'true' ,  '',      QApplication.translate('HTML Report Template','Drum Speed')           ],
            ['whole_color',         'prof',  'int',      'true' ,  '',      QApplication.translate('HTML Report Template','Whole Color')          ],
            ['ground_color',        'prof',  'int',      'true' ,  '',      QApplication.translate('HTML Report Template','Ground Color')         ],
            ['color_system',        'prof',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Color System')         ],
            ['beansize_min',        'prof',  'text2int', 'true' ,  '',      QApplication.translate('HTML Report Template','Screen Min')           ],
            ['beansize_max',        'prof',  'text2int', 'true' ,  '',      QApplication.translate('HTML Report Template','Screen Max')           ],
            ['greens_temp',         'prof',  'float1',   'true' ,  'temp',  QApplication.translate('HTML Report Template','Bean Temp')            ],
            ['CHARGE_ET',           'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','CHARGE ET')            ],
            ['CHARGE_BT',           'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','CHARGE BT')            ],
            ['TP_time',             'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','TP Time')              ],
            ['TP_ET',               'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','TP ET')                ],
            ['TP_BT',               'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','TP BT')                ],
            ['DRY_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','DRY Time')             ],
            ['DRY_ET',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','DRY ET')               ],
            ['DRY_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','DRY BT')               ],
            ['FCs_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','FCs Time')             ],
            ['FCs_ET',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','FCs ET')               ],
            ['FCs_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','FCs BT')               ],
            ['FCe_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','FCe Time')             ],
            ['FCe_ET',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','FCe ET')               ],
            ['FCe_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','FCe BT')               ],
            ['SCs_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','SCs Time')             ],
            ['SCs_ET',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','SCs ET')               ],
            ['SCs_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','SCs BT')               ],
            ['SCe_time',            'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','SCe Time')             ],
            ['SCe_ET',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','SCe ET')               ],
            ['SCe_BT',              'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','SCe BT')               ],
            ['DROP_time',           'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','DROP Time')            ],
            ['DROP_ET',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','DROP ET')              ],
            ['DROP_BT',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','DROP BT')              ],
            ['COOL_time',           'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','COOL Time')            ],
            ['COOL_ET',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','COOL ET')              ],
            ['COOL_BT',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','COOL BT')              ],
            ['totaltime',           'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','Total Time')           ],
            ['dryphasetime',        'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','Dry Phase Time')       ],
            ['midphasetime',        'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','Mid Phase Time')       ],
            ['finishphasetime',     'comp',  'time',     'false',  '',      QApplication.translate('HTML Report Template','Finish Phase Time')    ],
            ['dry_phase_ror',       'comp',  'float1',   'false',  'ror',   QApplication.translate('HTML Report Template','Dry Phase RoR')        ],
            ['mid_phase_ror',       'comp',  'float1',   'false',  'ror',   QApplication.translate('HTML Report Template','Mid Phase RoR')        ],
            ['finish_phase_ror',    'comp',  'float1',   'false',  'ror',   QApplication.translate('HTML Report Template','Finish Phase RoR')     ],
            ['dry_phase_delta_temp', 'comp',  'float1',   'false',  'tmep', QApplication.translate('HTML Report Template','Dry Phase Delta BT')   ],
            ['mid_phase_delta_temp', 'comp',  'float1',   'false',  'temp', QApplication.translate('HTML Report Template','Mid Phase Delta BT')   ],
            ['finish_phase_delta_temp', 'comp',  'float1',   'false',  'temp', QApplication.translate('HTML Report Template','Finish Phase Delta BT') ],
            ["dsd['computed']['finish_phase_ror'] * (dsd['computed']['finishphasetime'] / 60)", 'eval', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template','Finish Phase Rise')],
            ['total_ror',           'comp',  'float1',   'false',  'ror',   QApplication.translate('HTML Report Template','Total RoR')            ],
            ['fcs_ror',             'comp',  'float1',   'false',  'ror',   QApplication.translate('HTML Report Template','FCs RoR')              ],
            ['MET',                 'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','MET')                  ],
            ['AUC',                 'comp',  'int',      'false',  '',      QApplication.translate('HTML Report Template','AUC')                  ],
            ["(dsd['computed']['AUCbegin'] if ('AUCbegin' in dsd['computed'] and 'AUCfromeventflag' in dsd['computed'] and dsd['computed']['AUCfromeventflag']) else '')", 'eval', 'text', 'false', '', QApplication.translate('HTML Report Template','AUC Begin')  ],
            ['AUCbase',             'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','AUC Base')             ],
            ['dry_phase_AUC',       'comp',  'int',      'false',  '',      QApplication.translate('HTML Report Template','Dry Phase AUC')        ],
            ['mid_phase_AUC',       'comp',  'int',      'false',  '',      QApplication.translate('HTML Report Template','Mid Phase AUC')        ],
            ['finish_phase_AUC',    'comp',  'int',      'false',  '',      QApplication.translate('HTML Report Template','Finish Phase AUC')     ],
            ['weightin',            'comp',  'float1',   'false',  'weight',QApplication.translate('HTML Report Template','Weight In')            ],
            ['weightout',           'comp',  'float1',   'false',  'weight',QApplication.translate('HTML Report Template','Weight Out')           ],
            ['weight_loss',         'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Weight Loss')          ],
            ['volumein',            'comp',  'float1',   'false',  'volume',QApplication.translate('HTML Report Template','Volume In')            ],
            ['volumeout',           'comp',  'float1',   'false',  'volume',QApplication.translate('HTML Report Template','Volume Out')           ],
            ['volume_gain',         'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Volume Gain')          ],
            ['green_density',       'comp',  'float1',   'false',  '(g/l)', QApplication.translate('HTML Report Template','Green Density')        ],
            ['roasted_density',     'comp',  'float1',   'false',  '(g/l)', QApplication.translate('HTML Report Template','Roasted Density')      ],
            ['moisture_greens',     'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Moisture Greens')      ],
            ['moisture_roasted',    'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Moisture Roasted')     ],
            ['moisture_loss',       'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Moisture Loss')        ],
            ['organic_loss',        'comp',  'percent',  'false',  '',      QApplication.translate('HTML Report Template','Organic Loss')         ],
            ['ambient_humidity',    'comp',  'float1',   'false',  '',      QApplication.translate('HTML Report Template','Ambient Humidity')     ],
            ['ambient_pressure',    'comp',  'float1',   'false',  '',      QApplication.translate('HTML Report Template','Ambient Pressure')     ],
            ['ambient_temperature', 'comp',  'float1',   'false',  'temp',  QApplication.translate('HTML Report Template','Ambient Temperature')  ],
            ['beans',               'prof',  'text',     'false',  '90',    QApplication.translate('HTML Report Template','Beans')                ],
            ['roastingnotes',       'prof',  'text',     'false',  '90',    QApplication.translate('HTML Report Template','Roasting Notes')       ],
            ['cuppingnotes',        'prof',  'text',     'false',  '90',    QApplication.translate('HTML Report Template','Cupping Notes')        ],
            ['heavyFC',             'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Heavy FC')             ],
            ['lowFC',               'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Low FC')               ],
            ['lightCut',            'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Light Cut')            ],
            ['darkCut',             'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Dark Cut')             ],
            ['drops',               'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Drops')                ],
            ['oily',                'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Oily')                 ],
            ['uneven',              'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Uneven')               ],
            ['tipping',             'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Tipping')              ],
            ['scorching',           'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Scorching')            ],
            ['divots',              'prof',  'bool',     'false',  '',      QApplication.translate('HTML Report Template','Divots')               ],
            ['mode',                'prof',  'text',     'false',  '',      QApplication.translate('HTML Report Template','Mode')                 ],
            ['BTU_batch',           'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Batch')            ],
            ['BTU_batch_per_green_kg','comp','float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Batch per green kg')],
            ['CO2_batch',           'comp',  'float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 Batch').replace('CO2','CO')            ],
            ['BTU_preheat',         'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Preheat')          ],
            ['CO2_preheat',         'comp',  'float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 Preheat').replace('CO2','CO')          ],
            ['BTU_bbp',             'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU BBP')              ],
            ['CO2_bbp',             'comp',  'float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 BBP').replace('CO2','CO')              ],
            ['BTU_cooling',         'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Cooling')          ],
            ['CO2_cooling',         'comp',  'float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 Cooling').replace('CO2','CO')          ],
            ['BTU_roast',           'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Roast')            ],
            ['BTU_roast_per_green_kg','comp','float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU Roast per green kg')],
            ['CO2_roast',           'comp',  'float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 Roast').replace('CO2','CO')            ],
            ['CO2_batch_per_green_kg','comp','float1',   'false',  '(g)',   QApplication.translate('HTML Report Template','CO2 Batch per green kg').replace('CO2','CO')],
            ['BTU_LPG',             'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU LPG')              ],
            ['BTU_NG',              'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU NG')               ],
            ['BTU_ELEC',            'comp',  'float1',   'false',  '(BTU)', QApplication.translate('HTML Report Template','BTU ELEC')             ],
            ['KWH_batch_per_green_kg','comp','float1',   'false',  '(kWh/kg)', QApplication.translate('HTML Report Template','Efficiency Batch')  ],
            ['KWH_roast_per_green_kg','comp','float1',   'false',  '(kWh/kg)', QApplication.translate('HTML Report Template','Efficiency Roast')  ],
        ]
        return ranking_data_fields, field_index

    def extendedRankingData2List(self,dsd=None,rd=None,pd=None,header=False):
        if dsd is None:
            dsd = []
        if rd is None:
            rd = []
        if pd is None:
            pd = []
        res = []
        weight_unit = aw.qmc.weight[2]
        volume_unit = aw.qmc.volume[2]
        temperature_unit = aw.qmc.mode
        try:
            ranking_data_fields, field_index = self.rankingdataDef()
            if header:
                for i in range(len(ranking_data_fields)):
                    name = ranking_data_fields[i][field_index.index('name')]
                    units = ranking_data_fields[i][field_index.index('units')]
                    if units == 'temp':
                        suffix = f' ({temperature_unit})'
                    elif units == 'volume':
                        suffix = f' ({volume_unit})'
                    elif units == 'weight':
                        suffix = f' ({weight_unit})'
                    elif units == 'ror':
                        suffix = ' ({})'.format(temperature_unit + '/min')
                    elif units.startswith('('):
                        suffix = f' {units}'
                    else:
                        suffix = ''
                    hdr_name = f'{name}{suffix}'
                    res.append(hdr_name)
            else:
                for i in range(len(ranking_data_fields)):
                    name = ranking_data_fields[i][field_index.index('name')]
                    fld = ranking_data_fields[i][field_index.index('fld')]
                    src = ranking_data_fields[i][field_index.index('src')]
                    typ = ranking_data_fields[i][field_index.index('typ')]
                    test0 = ranking_data_fields[i][field_index.index('test0')]
                    units = ranking_data_fields[i][field_index.index('units')]
                    if src == 'comp' and fld in dsd['computed']:
                        res_fld = dsd['computed'][fld]
                    elif src == 'prof' and fld in dsd:
                        res_fld = dsd[fld]
                    elif src == 'rank' and fld in rd:
                        res_fld = rd[fld]
                    elif src == 'prod' and fld in pd:
                        res_fld = pd[fld]
                    elif src == 'eval':
                        res_fld = eval(fld) # pylint: disable=eval-used
                        if res_fld in ['None', None]:
                            res.append('')
                            continue
                    else:
                        res.append('')
                        continue

                    if (test0 == 'true' and aw.float2float(toFloat(res_fld)) > 0) or test0 == 'false':
                        if units == 'temp':
                            conv_fld = convertTemp(res_fld,dsd['mode'],temperature_unit)
                        elif units == 'ror':
                            conv_fld = convertRoR(res_fld,dsd['mode'],temperature_unit)
                        elif units == 'volume':
                            conv_fld = aw.convertVolume(res_fld,0,aw.qmc.volume_units.index(volume_unit))
                        elif units == 'weight':
                            conv_fld = aw.convertWeight(res_fld,0,aw.qmc.weight_units.index(weight_unit))
                        else:
                            conv_fld = res_fld

                        if typ == 'text':
                            res.append(f'{conv_fld}')
                        elif typ == 'int':
                            res.append(f'{conv_fld:d}')
                        elif typ == 'temp':
                            res.append(f'{conv_fld:.1f}')
                        elif typ == 'float1':
                            res.append(f'{conv_fld:.1f}')
                        elif typ == 'float2':
                            res.append(f'{conv_fld:.2f}')
                        elif typ == 'float4':
                            res.append(f'{conv_fld:.4f}')
                        elif typ == 'text2float1':
                            res.append(f'{toFloat(conv_fld):.1f}')
                        elif typ == 'text2float2':
                            res.append(f'{toFloat(conv_fld):.2f}')
                        elif typ == 'text2int':
                            res.append(f'{toInt(conv_fld):d}')
                        elif typ == 'percent':
                            res.append(f'{toFloat(conv_fld):.1f}')
                        elif typ == 'time':
                            m,s = divmod(conv_fld,60)
                            res.append(f'{int(m):d}:{int(s):02d}')
                        elif typ == 'date':
                            res.append(f'{QDateTime(conv_fld).toPyDateTime()}')
                        elif typ == 'bool':
                            res.append(str(conv_fld))
                        else:
                            res.append('')
                    else:
                        res.append('')
            return res
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' extendedRankingData2List() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return []

    @staticmethod
    def formatTemp(data, k, unit, units = True):
        if aw.qmc.LCDdecimalplaces:
            fmt = '{0:.1f}'
        else:
            fmt = '{0:.0f}'
        return (fmt.format(convertTemp(data[k],unit,aw.qmc.mode)) + (aw.qmc.mode if units else '') if k in data else '')

    def rankingData2htmlentry(self,production_data,ranking_data,plot_color=None):
        import string as libstring
        HTML_REPORT_TEMPLATE = """<tr>
<td$color_code>$batch</td>
<td>$time</td>
<td>$title</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$charge_temp_num\">$charge_temp</td>
<td sorttable_customkey=\"$FCs_time_num\">$FCs_time</td>
<td sorttable_customkey=\"$FCs_temp_num\">$FCs_temp</td>
<td sorttable_customkey=\"$DROP_time_num\">$DROP_time</td>
<td sorttable_customkey=\"$DROP_temp_num\">$DROP_temp</td>
<td sorttable_customkey=\"$DRY_percent_num\">$DRY_percent</td>
<td sorttable_customkey=\"$MAI_percent_num\">$MAI_percent</td>
<td sorttable_customkey=\"$DEV_percent_num\">$DEV_percent</td>
<td sorttable_customkey=\"$AUC_num\">$AUC</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
<td sorttable_customkey=\"$color_num\">$color</td>
<td>$cupping</td>
<td sorttable_customkey=\"$energy_num\">$energy</td>
<td sorttable_customkey=\"$co2_num\">$co2</td>
<td sorttable_customkey=\"$co2kg_num\">$co2kg</td>
</tr>"""
        pd = self.productionData2string(production_data,units=False)
        rd = self.rankingData2string(ranking_data,units=False)
        batch_td_color = ''
        if plot_color is not None:
            batch_color = [x * 100 for x in plot_color[0:3]]
            batch_color.append(0.7)
            batch_td_color = ' style="background-color: rgba(' + '%,'.join(map(str, batch_color)) + ')"'
        batch_html = pd['id']
        time_html = pd['time']
        title_html = pd['title']
        try:
            if 'roastUUID' in production_data and production_data['roastUUID'] is not None:
                roast_uuid = production_data['roastUUID']
#                if plus.register.getPath(roast_uuid):
#                    title_html = '<a href="artisan://roast/{0}">{1}</a>'.format(roast_uuid,title_html)
                title_html = f'<a href="artisan://roast/{roast_uuid}">{title_html}</a>'
                if bool(plus.sync.getSync(roast_uuid)):
                    time_html = f'<a href="{plus.util.roastLink(roast_uuid)}" target="_blank">{time_html}</a>'
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        weight_fmt = ('{0:.2f}' if aw.qmc.weight[2] in ['Kg', 'lb', 'oz'] else '{0:.0f}')
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            color_code = batch_td_color,
            batch = batch_html,
            time = time_html,
            title = title_html,
            in_num = weight_fmt.format(pd['weight_in_num']),
            weightin = pd['weight_in'],
            charge_temp_num = '{:.2f}'.format(rd['charge_temp_num']),
            charge_temp = rd['charge_temp'],
            FCs_time_num = rd['FCs_time_num'],
            FCs_time = rd['FCs_time'],
            FCs_temp_num = '{:.2f}'.format(rd['FCs_temp_num']),
            FCs_temp = rd['FCs_temp'],
            DROP_time_num = rd['DROP_time_num'],
            DROP_time = rd['DROP_time'],
            DROP_temp_num = '{:.2f}'.format(rd['DROP_temp_num']),
            DROP_temp = rd['DROP_temp'],
            DRY_percent_num = rd['DRY_percent_num'],
            DRY_percent = rd['DRY_percent'],
            MAI_percent_num = rd['MAI_percent_num'],
            MAI_percent = rd['MAI_percent'],
            DEV_percent_num = rd['DEV_percent_num'],
            DEV_percent = rd['DEV_percent'],
            AUC_num = rd['AUC_num'],
            AUC = rd['AUC'],
            loss_num = '{:.2f}'.format(pd['weight_loss_num']),
            weightloss = pd['weight_loss'],
            color_num = str(rd['color_num']),
            color = rd['color'],
            cupping = rd['cupping'],
            energy = rd['energy'],
            energy_num = rd['energy_num'],
            co2 = rd['co2'],
            co2_num = rd['co2_num'],
            co2kg = rd['co2kg'],
            co2kg_num = rd['co2kg_num'],
        )

    def reportFiles(self):
        import zipfile
        import tempfile
        # get profile filenames
        selected_files = self.ArtisanOpenFilesDialog(ext='*.alog *.zip')      # added zip files
        files = []
        for f in selected_files:
            if zipfile.is_zipfile(f):
                with zipfile.ZipFile(f) as zf:
                    ziptmpdir = tempfile.mkdtemp()
                    zf.extractall(ziptmpdir)
                    for n in zf.namelist():
                        nf = os.path.join(ziptmpdir,n)
                        if os.path.splitext(nf)[1] == '.alog':
                            files.append(nf)
            else: # a normal *.alog file
                files.append(f)
        return files

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingPDFReport(self,_=False):
        self.rankingReport(pdf=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingHTMLReport(self,_=False):
        self.rankingReport()

    def rankingReport(self, pdf=False):
        try:
            import string as libstring
            # get profile filenames
            files = self.reportFiles()
            if files and len(files) > 0:
                prev_foreground_profile_path = aw.curFile
                prev_backgroundpath = aw.qmc.backgroundpath
                prev_background = aw.qmc.background
                cont = aw.qmc.reset(soundOn=False)
                if cont:
                    profiles = [self.deserialize(f) for f in files]
                    # let's sort by isodate
                    profiles = sorted(profiles,
                        key=lambda p: (QDateTime(QDate.fromString(p['roastisodate'], Qt.DateFormat.ISODate),QTime.fromString(p['roasttime'])).toMSecsSinceEpoch()
                             if 'roastisodate' in p and 'roasttime' in p else 0))
                    with open(getResourcePath() + 'ranking-template.htm', encoding='utf-8') as myfile:
                        HTML_REPORT_TEMPLATE=myfile.read()
                    entries = ''
                    charges = 0
                    charges_count = 0
                    charges_temp = 0
                    charges_temp_count = 0
                    FCs_time = 0
                    FCs_time_count = 0
                    FCs_temp = 0
                    FCs_temp_count = 0
                    DROP_time = 0
                    DROP_time_count = 0
                    DROP_temp = 0
                    DROP_temp_count = 0
                    DRY_percent = 0
                    DRY_percent_count = 0
                    MAI_percent = 0
                    MAI_percent_count = 0
                    DEV_percent = 0
                    DEV_percent_count = 0
                    AUC = 0
                    AUC_count = 0
                    loss = 0
                    loss_count = 0
                    colors_list = 0
                    colors_count = 0
                    cuppings = 0
                    cuppings_count = 0
                    energies = 0
                    energies_count = 0
                    co2s = 0
                    co2s_count = 0
                    co2kgs = 0
                    co2kgs_count = 0
                    handles = []
                    labels = []
                    timex_list = []
                    stemp_list = []
                    cl_list = []
                    max_profiles = 20
                    color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                    # collect data
#                    c = 1
                    min_start_time = max_end_time = 0
                    first_profile = True
                    first_profile_event_time = 0
                    max_drop_time = 0
                    label_chr_nr = 0

                    delta_max = 1 # computed the delta max over all delta curves if visible

                    for p in profiles:
                        pd = self.profileProductionData(p)
#                        c += 1
                        try:
                            cl = next(color) # here to keep colors_list in sync with the pct graph colors_list
                        except Exception: # pylint: disable=broad-except
                            color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                            cl = next(color)
                        try:
                            rd = self.profileRankingData(p)
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception (probably due to an empty profile):') + ' rankingReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                            continue
                        i = aw.convertWeight(pd['weight'][0],aw.qmc.weight_units.index(pd['weight'][2]),aw.qmc.weight_units.index(aw.qmc.weight[2]))
                        #o = aw.convertWeight(pd["weight"][1],aw.qmc.weight_units.index(pd["weight"][2]),aw.qmc.weight_units.index(aw.qmc.weight[2]))
                        if i > 0:
                            charges += i
                            charges_count += 1
                        if 'charge_temp' in rd:
                            charges_temp += convertTemp(rd['charge_temp'],rd['temp_unit'],aw.qmc.mode)
                            charges_temp_count += 1
                        if 'FCs_time' in rd:
                            FCs_time += rd['FCs_time']
                            FCs_time_count += 1
                        if 'FCs_temp' in rd:
                            FCs_temp += convertTemp(rd['FCs_temp'],rd['temp_unit'],aw.qmc.mode)
                            FCs_temp_count += 1
                        if 'DROP_time' in rd:
                            if rd['DROP_time'] > max_drop_time:
                                max_drop_time = rd['DROP_time']
                            DROP_time += rd['DROP_time']
                            DROP_time_count += 1
                        if 'DROP_temp' in rd:
                            DROP_temp += convertTemp(rd['DROP_temp'],rd['temp_unit'],aw.qmc.mode)
                            DROP_temp_count += 1
                        if 'DRY_percent' in rd:
                            DRY_percent += rd['DRY_percent']
                            DRY_percent_count += 1
                        if 'MAI_percent' in rd:
                            MAI_percent += rd['MAI_percent']
                            MAI_percent_count += 1
                        if 'DEV_percent' in rd:
                            DEV_percent += rd['DEV_percent']
                            DEV_percent_count += 1
                        # -- recompute AUC with actual settings
                        try:
                            AUCidx = max(0,aw.AUCstartidx(p['timeindex'],p['computed']['TP_idx']))
                            if aw.qmc.AUCbaseFlag:
                                # we take the base temperature from the BT at st
                                rtbt = p['temp2'][AUCidx]
                            else:
                                rtbt = aw.qmc.AUCbase
                            rtbt = convertTemp(rtbt,aw.qmc.mode,'C')
                            ed = min(len(p['timex']),p['timeindex'][6])
                            BT_AUC = 0
                            for i in range(AUCidx,ed):
                                BT_AUC += self.calcAUC(rtbt,p['timex'],p['temp2'],i)
                            BT_AUC = int(round(BT_AUC/60.))
                            rd['AUC'] = BT_AUC
                        except Exception: # pylint: disable=broad-except
                            # 'TP_index' might not be in computedProfile and then we fail here
                            pass
                        # --
                        if 'AUC' in rd:
                            AUC += rd['AUC']
                            AUC_count += 1

                        if pd['weight'][0] > 0 and pd['weight'][1] > 0:
                            l = aw.weight_loss(pd['weight'][0],pd['weight'][1])
                            if 0 < l < 100:
                                loss += l
                                loss_count += 1
                        if 'color' in rd and rd['color'] > 0:
                            colors_list += rd['color']
                            colors_count += 1
                        if rd['cupping'] > 0:
                            cuppings += rd['cupping']
                            cuppings_count += 1
                        if 'energy' in rd and rd['energy'] > 0:
                            energies += rd['energy']
                            energies_count += 1
                        if 'co2' in rd and rd['co2'] > 0:
                            co2s += rd['co2']
                            co2s_count += 1
                        if 'co2kg' in rd and rd['co2kg'] > 0:
                            co2kgs += rd['co2kg']
                            co2kgs_count += 1
                        if len(profiles) > max_profiles:
                            entries += self.rankingData2htmlentry(pd,rd, cl) + '\n'
                        else:
                            # add BT curve to graph
                            try:

                                if pd['batchnr'] > 0:
                                    label = pd['batchprefix'] + str(pd['batchnr'])
                                elif label_chr_nr < 26:
                                    label = str(libstring.ascii_uppercase[label_chr_nr])
                                    pd['batchnr'] = ''
                                    pd['batchprefix'] = label
                                    label_chr_nr = label_chr_nr + 1
                                # suppress default description
    #                            if pd["title"] == QApplication.translate("Scope Title", "Roaster Scope"):
    #                                pd["title"] = ""

                                entries += self.rankingData2htmlentry(pd,rd, cl) + '\n'

                                temp = [convertTemp(t,rd['temp_unit'],self.qmc.mode) for t in rd['temp']]
                                timex = rd['timex']
                                stemp = self.qmc.smooth_list(timex,fill_gaps(temp),window_len=self.qmc.curvefilter,decay_smoothing=not aw.qmc.optimalSmoothing)
                                charge = max(0,rd['charge_idx']) # start of visible data
                                drop = rd['drop_idx'] # end of visible data
                                stemp = numpy.concatenate((
                                    numpy.full(charge, numpy.nan, dtype=numpy.double),
                                    stemp[charge:drop],
                                    numpy.full(len(timex)-drop, numpy.nan, dtype=numpy.double)))
                                timeindex = [max(0,v) if i>0 else max(-1,v) for i,v in enumerate(p['timeindex'])]
                                if len(timex) > rd['charge_idx']:
                                    if first_profile:
                                    # align with CHARGE
                                        delta = timex[rd['charge_idx']]
                                        # store relative time of align event of first profile
                                        # CHARGE, DRY, FCs, FCe, SCs, SCe, DROP
                                        first_profile_event_time = delta # CHARGE
                                        for j in range(6,0,-1):
                                            if aw.qmc.alignEvent in [j] and timeindex[j]:
                                                first_profile_event_time = timex[timeindex[j]] - timex[rd['charge_idx']]
                                                break
                                    else:
                                        delta = timex[rd['charge_idx']]
                                        for j in range(6,0,-1):
                                            if aw.qmc.alignEvent in [j] and timeindex[j]:
                                                delta = delta + (timex[timeindex[j]] - timex[rd['charge_idx']] - first_profile_event_time)
                                                break
                                else:
                                    delta = 0
                                timex = [t-delta for t in timex]
                                if len(timex) > charge:
                                    min_start_time = min(min_start_time,timex[charge])
                                if len(timex) > drop:
                                    max_end_time = max(max_end_time,timex[drop])
                                # cut-out only CHARGE to DROP

                                labels.append(label)
                                timex_list.append(timex)
                                stemp_list.append(stemp)
                                cl_list.append(cl)

                                if self.qmc.DeltaBTflag and self.qmc.delta_ax:
                                    tx = numpy.array(timex)
                                    cf = aw.qmc.curvefilter #*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                                    t1 = self.qmc.smooth_list(timex,fill_gaps(temp),window_len=cf,decay_smoothing=not aw.qmc.optimalSmoothing)
                                    if len(t1)>10 and len(tx) > 10:
                                        # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                                        RoR_start = min(rd['charge_idx']+10,len(tx)-1)
                                        _,delta = self.qmc.recomputeDeltas(tx,RoR_start,drop,None,t1,optimalSmoothing=aw.qmc.optimalSmoothing)
                                        delta_max = max(delta_max,self.calcAutoDelta([],delta,timeindex,False,True))
                                        if self.qmc.BTlinewidth > 1 and self.qmc.BTlinewidth == self.qmc.BTdeltalinewidth:
                                            dlinewidth = self.qmc.BTlinewidth-1 # we render the delta lines a bit thinner
                                            dlinestyle = self.qmc.BTdeltalinestyle
                                        else:
                                            dlinewidth = self.qmc.BTdeltalinewidth
                                            dlinestyle = self.qmc.BTdeltalinestyle
                                        trans = self.qmc.delta_ax.transData
                                        self.qmc.ax.plot(tx, delta,transform=trans,markersize=self.qmc.BTdeltamarkersize,marker=self.qmc.BTdeltamarker,
                                            sketch_params=None,path_effects=[],
                                            linewidth=dlinewidth,linestyle=dlinestyle,drawstyle=self.qmc.BTdeltadrawstyle,color=cl,alpha=0.7)

                                first_profile = False

                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                                _, _, exc_tb = sys.exc_info()
                                aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    # draw BT curves on top of all others
                    for i in range(len(timex_list)):
                        label = labels[i]
                        timex = timex_list[i]
                        stemp = stemp_list[i]
                        cl = cl_list[i]
                        l_temp, = self.qmc.ax.plot(timex,stemp,markersize=self.qmc.BTmarkersize,marker=self.qmc.BTmarker,
    #                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.qmc.BTlinewidth+aw.qmc.patheffects,foreground=path_effects_color)],
                            sketch_params=None,path_effects=[],
                            linewidth=self.qmc.BTlinewidth,linestyle=self.qmc.BTlinestyle,drawstyle=self.qmc.BTdrawstyle,color=cl,label=label)
                        handles.append(l_temp)

                    tmpdir = str(QDir.tempPath() + '/')
                    graph_image = ''
                    graph_image_pct = ''

                    prop = aw.mpl_fontproperties.copy()
                    prop.set_size('x-small')

                    if len(profiles) > max_profiles:
                        QMessageBox.information(aw,QApplication.translate('Message', 'Ranking Report'),
                                                  QApplication.translate('Message', 'Ranking graphs are only generated up to {0} profiles').format(str(max_profiles)))
                    else:
                        try:

                            # remove annotations, lines and other artists from background profile
                            try:
                                for l in aw.qmc.l_annotations + aw.qmc.l_background_annotations:
                                    if l:
                                        try:
                                            l.remove()
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                for l in [
                                        aw.qmc.l_back1,
                                        aw.qmc.l_back2,
                                        aw.qmc.l_back3,
                                        aw.qmc.l_back4,
                                        aw.qmc.l_delta1B,
                                        aw.qmc.l_delta2B
                                        ]:
                                    if l:
                                        try:
                                            aw.qmc.ax.lines.remove(l)
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                for a in [
                                        aw.qmc.l_eventtype1dots,
                                        aw.qmc.l_eventtype2dots,
                                        aw.qmc.l_eventtype3dots,
                                        aw.qmc.l_eventtype4dots,
                                        aw.qmc.l_backgroundeventtype1dots,
                                        aw.qmc.l_backgroundeventtype2dots,
                                        aw.qmc.l_backgroundeventtype3dots,
                                        aw.qmc.l_backgroundeventtype4dots]:
                                    if a:
                                        try:
                                            aw.qmc.ax.lines.remove(a)
                                        except Exception: # pylint: disable=broad-except
                                            pass

                                # we also have to remove those extra event annotations if in combo mode
                                if aw.qmc.eventsGraphflag == 4:
                                    for child in aw.qmc.ax.get_children():
                                        if isinstance(child, mpl.text.Annotation):
                                            try:
                                                aw.qmc.ax.texts.remove(child)
                                            except Exception: # pylint: disable=broad-except
                                                pass
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                            # we only adjust the upper limit of the delta axis automatically
                            if self.qmc.autodeltaxBT:
                                self.qmc.delta_ax.set_ylim(self.qmc.zlimit_min,delta_max)
                            # adjust zgrid
                            if aw.qmc.zgrid != 0:
                                d = delta_max - self.qmc.zlimit_min
                                steps = int(round(d/5))
                                if steps > 50:
                                    steps = int(round(steps/10))*10
                                elif steps > 10:
                                    steps = int(round(steps/5))*5
                                auto_grid = max(2,steps)
                                aw.qmc.zgrid = auto_grid
                                self.qmc.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(aw.qmc.zgrid))
                                self.qmc.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            # adjust time limits
                            aw.qmc.ax.set_xlim(min_start_time-15,max_end_time+15) # we adjust the min, max time scale to ensure all data is visible
                            graph_image = 'roastlog-graph'
                            self.qmc.setProfileTitle('')
                            self.qmc.fig.suptitle('')
                            rcParams['path.effects'] = []
                            if len(handles) > 7:
                                ncol = int(math.ceil(len(handles)/4.))
                            elif len(handles) > 3:
                                ncol = int(math.ceil(len(handles)/2.))
                            else:
                                ncol = int(math.ceil(len(handles)))
                            self.qmc.ax.legend(handles,labels,loc=self.qmc.legendloc,ncol=ncol,fancybox=True,prop=prop,shadow=False)

                            # Remove and update the logo image
                            try:
                                aw.qmc.ai.remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.qmc.placelogoimage()
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)

                            # generate graph
                            self.qmc.fig.set_tight_layout(False)
                            self.qmc.fig.canvas.draw()
                            # save graph
                            graph_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + '.svg')))
                            try:
                                os.remove(graph_image)
                            except OSError:
                                pass
                            self.qmc.fig.set_tight_layout(self.qmc.tight_layout_params)
                            self.qmc.fig.savefig(graph_image,transparent=True)

                            #add some random number to force HTML reloading
                            graph_image = path2url(graph_image)
                            graph_image = graph_image + '?dummy=' + str(int(libtime.time()))
                            graph_image = "<img alt='roast graph' style=\"width:100%;\" src='" + graph_image + "'>"

                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    try:
                        # Create a roast phase visualization graph

                        fig_height = 3.2       # in inches when there are 10 profiles, will be scaled for number of profiles
                        fig_width = 10         # in inches

                        # values that define the bars and spacing
                        barspacer =  2     # vertical space between bars
                        barheight =  18    # height of each bar
                        textoffset = 6     # shifts text annotations upward to toward middle of the bar
                        m = 10             # width of batch number field and drop time field
                        g = 2              # gap
                        n = m + g          # start of horiz stacked bar
                        ind = 7            # width of color legend indicator

                        # setup the font
                        if sys.platform.startswith('darwin') and darkdetect.isDark() and appFrozen():
                            headerfontcolor = '#B2B2B2'
                        else:
                            headerfontcolor = '#707070'
                        fontcolor = '#303030'
                        lightfontcolor = 'grey'
                        prop.set_family(mpl.rcParams['font.family'])

                        # generate graph  ( not written to support MPL < v2.0 )
                        fig = Figure(figsize=(fig_width, (fig_height * len(profiles)/10 + 0.2)))

                        ax = fig.add_subplot(111, frameon=False)
                        fig.subplots_adjust(left=0, right=1, top=1, bottom=0)

                        # no grid or tick marks
                        ax.grid(False)
                        ax.axes.get_xaxis().set_ticks([])
                        ax.axes.get_yaxis().set_ticks([])

                        # set graph xy limits
                        ylim = (barheight + barspacer) * (1 + len(profiles))
                        xlim = m+g+100+g+m +1
                        ax.set_ylim(0, ylim)
                        ax.set_xlim(0, xlim)

                        graph_image_pct = 'roastlog-graph-pct'

                        i = len(profiles)   # bar counter

                        # generate the legend at the top
                        facecolors = ('#00b950', '#ffb347', '#9f7960')
                        prop.set_size('medium')
                        ax.broken_barh( [ (n, g),                         #Dry indicator
                                          (n+g+ind, g),                   #MAI indicator
                                          (n+g+ind+g+ind, g)              #DEV indicator
                                        ],
                                        (i*(barheight + barspacer), barheight*0.75), facecolors=facecolors
                                      )
                        ax.text(    m/2,             i*(barheight + barspacer) + textoffset/3, 'Nr', ha='center', color=headerfontcolor, fontproperties=prop)
                        ax.text( 1+ n+g,             i*(barheight + barspacer) + textoffset/3, 'Dry', ha='left', color=headerfontcolor, fontproperties=prop)
                        ax.text( 1+ n+g+ind+g,       i*(barheight + barspacer) + textoffset/3, 'Mai', ha='left', color=headerfontcolor, fontproperties=prop)
                        ax.text( 1+ n+g+ind+g+ind+g, i*(barheight + barspacer) + textoffset/3, 'Dev', ha='left', color=headerfontcolor, fontproperties=prop)
                        ax.text(    n+100 + 10/2,    i*(barheight + barspacer) + textoffset/3, 'Drop', ha='center', color=headerfontcolor, fontproperties=prop)

                        # generate the bar graph
                        prop.set_size('small')
                        color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))    # @UndefinedVariable # pylint: disable=maybe-no-member
                        label_chr_nr = 0
                        for p in profiles:
                            i -= 1
                            try:
                                cl = mcolors.to_hex(next(color)), '#00b950', '#ffb347', '#9f7960'
                            except Exception: # pylint: disable=broad-except
                                color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))    # @UndefinedVariable # pylint: disable=maybe-no-member
                                cl = mcolors.to_hex(next(color)), '#00b950', '#ffb347', '#9f7960'
                            try:
                                rd = self.profileRankingData(p)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                                _, _, exc_tb = sys.exc_info()
                                aw.qmc.adderror((QApplication.translate('Error Message','Exception (probably due to an empty profile):') + ' rankingReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                                i += 1   #avoid a blank line
                                continue
                            pd = self.profileProductionData(p)
                            if pd['batchnr'] > 0:
                                label = (pd['batchprefix'] + str(pd['batchnr']))[:8]
                            elif label_chr_nr < 26:
                                label = str(libstring.ascii_uppercase[label_chr_nr])
                                label_chr_nr = label_chr_nr + 1
                            else:
                                label = ''
                            if 'DRY_percent' in rd and 'MAI_percent' in rd and 'DEV_percent' in rd:
                                ax.broken_barh( [ (0, m),
                                                  (n, rd['DRY_percent']),
                                                  (n+rd['DRY_percent'], rd['MAI_percent']),
                                                  (n+rd['DRY_percent'] + rd['MAI_percent'], rd['DEV_percent']),
                                                  (n+rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent'] + g, m*rd['DROP_time']/max_drop_time)
                                                ],
                                                (i*(barheight + barspacer), barheight), facecolors=cl
                                              )
                                ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + rd['DRY_percent']/2,                                               i*(barheight + barspacer) + textoffset, str(round(rd['DRY_percent'],1)) + '%  ' + stringfromseconds(rd['DRY_time']), ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + rd['DRY_percent'] + rd['MAI_percent']/2,                           i*(barheight + barspacer) + textoffset, str(round(rd['MAI_percent'],1)) + '%  ' + stringfromseconds(rd['MAI_time']), ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent']/2,       i*(barheight + barspacer) + textoffset, str(round(rd['DEV_percent'],1)) + '%  ' + stringfromseconds(rd['DEV_time']), ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent'] + g + 1, i*(barheight + barspacer) + textoffset, stringfromseconds(rd['DROP_time']), ha='left', color=fontcolor, fontproperties=prop)
                            elif 'DEV_percent' in rd:   # has FCs but no Dry event
                                cl = cl[0],'white',cl[3]
                                missingDryevent = QApplication.translate('Message', 'Profile missing DRY event')
                                ax.broken_barh( [ (0, m),
                                                  (n, 100 - rd['DEV_percent']),
                                                  (n+ 100 - rd['DEV_percent'], rd['DEV_percent']),
                                                  (n+ 100 + g, m*rd['DROP_time']/max_drop_time)
                                                ],
                                                (i*(barheight + barspacer), barheight), facecolors=cl
                                              )
                                ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + (100 - rd['DEV_percent'])/2,                                       i*(barheight + barspacer) + textoffset, missingDryevent, ha='center', color=lightfontcolor, fontproperties=prop)
                                ax.text( n + 100 - rd['DEV_percent'] + rd['DEV_percent']/2,                     i*(barheight + barspacer) + textoffset, str(round(rd['DEV_percent'],1)) + '%  ' + stringfromseconds(rd['DEV_time']), ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + 100 + g + 1, i*(barheight + barspacer) + textoffset, stringfromseconds(rd['DROP_time']), ha='left', color=fontcolor, fontproperties=prop)
                            else:    # no useful events
                                drop_time= rd.get('DROP_time', 0)
                                cl = cl[0],'white'
                                missingPhaseevents = QApplication.translate('Message', 'Profile missing phase events')
                                ax.broken_barh( [ (0, m),
                                                  (n, 100),
                                                  (n+ 100 + g, m*(0 if max_drop_time == 0 else drop_time/max_drop_time))
                                                ],
                                                (i*(barheight + barspacer), barheight), facecolors=cl
                                              )
                                ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                                ax.text( n + 100/2,                                                             i*(barheight + barspacer) + textoffset, missingPhaseevents, ha='center', color=lightfontcolor, fontproperties=prop)
                                ax.text( n + 100 + g + 1, i*(barheight + barspacer) + textoffset, stringfromseconds(drop_time), ha='left', color=fontcolor, fontproperties=prop)

                        # save graph
                        graph_image_pct = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image_pct + '.svg')))
                        try:
                            os.remove(graph_image_pct)
                        except OSError:
                            pass
                        fig.savefig(graph_image_pct,transparent=True)
                        #add some random number to force HTML reloading
                        graph_image_pct = path2url(graph_image_pct)
                        graph_image_pct = graph_image_pct + '?dummy=' + str(int(libtime.time()))
                        graph_image_pct = "<img alt='roast graph pct' style=\"width: 95%;\" src='" + graph_image_pct + "'>"

                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    try:
                        # redraw original graph
                        if prev_foreground_profile_path:
                            aw.loadFile(prev_foreground_profile_path)
                        if prev_backgroundpath:
                            aw.loadbackground(prev_backgroundpath)
                            aw.qmc.background = prev_background
                        self.qmc.timealign()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    weight_fmt = ('{0:.2f}' if aw.qmc.weight[2] in ['Kg', 'lb', 'oz'] else '{0:.0f}')
                    html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                        resources = str(getResourcePath()),
                        title = QApplication.translate('HTML Report Template', 'Roast Ranking'),
                        time = QApplication.translate('HTML Report Template', 'Date'),
                        profile = QApplication.translate('Label', 'Title'),
                        weightin = QApplication.translate('HTML Report Template', 'In'),
                        weightloss = QApplication.translate('HTML Report Template', 'Loss'),
                        colorHeader = QApplication.translate('HTML Report Template', 'Color'),
                        weight_unit = aw.qmc.weight[2].lower(),
                        temp_unit = aw.qmc.mode,
                        entries = entries,
                        charges_avg = (weight_fmt.format(charges / charges_count) if charges_count > 0 and charges > 0 else ''),
                        charges_temp_avg = (f'{charges_temp / charges_temp_count:.1f}' if charges_temp > 0 and charges_temp_count > 0 else ''),
                        FCs_time_avg = (self.eventtime2string(FCs_time / FCs_time_count) if FCs_time > 0 and FCs_time_count > 0 else ''),
                        FCs_temp_avg = (f'{FCs_temp / FCs_temp_count:.1f}' if FCs_temp > 0 and FCs_temp_count > 0 else ''),
                        DROP_time_avg = (self.eventtime2string(DROP_time / DROP_time_count) if DROP_time > 0 and DROP_time_count > 0 else ''),
                        DROP_temp_avg = (f'{DROP_temp / DROP_temp_count:.1f}' if DROP_temp > 0 and DROP_temp_count > 0 else ''),
                        DRY_percent_avg = (f'{DRY_percent / DRY_percent_count:.1f}' if DRY_percent > 0 and DRY_percent_count > 0 else ''),
                        MAI_percent_avg = (f'{MAI_percent / MAI_percent_count:.1f}' if MAI_percent > 0 and MAI_percent_count > 0 else ''),
                        DEV_percent_avg = (f'{DEV_percent / DEV_percent_count:.1f}' if DEV_percent > 0 and DEV_percent_count > 0 else ''),
                        AUC_avg = (f'{AUC / AUC_count:.1f}' if AUC > 0 and AUC_count > 0 else ''),
                        loss_avg = (f'{loss / loss_count:.1f}' if loss_count > 0 and loss > 0 else ''),
                        colors_avg = (f'{colors_list / colors_count:.1f}' if colors_list > 0 and colors_count > 0 else ''),
                        cup_avg = (f'{cuppings / cuppings_count:.2f}' if cuppings > 0 and cuppings_count > 0 else ''),
                        energy_avg = (f'{energies / energies_count:.2f}' if energies > 0 and energies_count > 0 else ''),
                        co2_avg = (f'{co2s / co2s_count:.2f}' if co2s > 0 and co2s_count > 0 else ''),
                        co2kg_avg = (f'{co2kgs / co2kgs_count:.2f}' if co2kgs > 0 and co2kgs_count > 0 else ''),
                        graph_image=graph_image,
                        graph_image_pct=graph_image_pct
                    )
                    try:
                        filename = str(QDir(tmpdir).filePath('RankingReport.html'))
                        try:
                            os.remove(filename)
                        except OSError:
                            pass
                        import codecs # @Reimport
                        with codecs.open(filename, 'w', encoding='utf-8') as f:
                            for i in range(len(html)):
                                f.write(html[i])
                        if platf == 'Darwin':
                            full_path = 'file://' + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                        else:
                            full_path = 'file:///' + filename # Explorer refuses to start otherwise

                        if pdf:
                            # select file
                            filename = self.ArtisanSaveFileDialog(msg='Export PDF',ext='*.pdf')
                            if filename:
                                self.html2pdf(full_path, filename, landscape=True)
                        else:
                            QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

                    except OSError as e:
                        aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' rankingReport() {0}').format(str(e)))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingCSVReport(self,_=False): # get profile filenames
        import csv
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export CSV',ext='*.csv')
            if filename:
                try:
                    # open file
                    try:
                        outfile = open(filename, 'w',newline='', encoding='utf-8') # pylint: disable=consider-using-with
                    except OSError as x:
                        aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' Err [{0}] Can not write to file, perhaps it is open in an application or is write protected?').format(x.errno))
                        QApplication.beep()
                        return
                    writer = csv.writer(outfile,delimiter='\t',quotechar='"')

                    # write header
                    extendedRankingHdr = self.extendedRankingData2List(header=True)
                    writer.writerow(extendedRankingHdr)

                    # write data
#                    c = 1
                    for p in profiles:
                        try:
#                            c += 1
                            dsd = self.deserialize(p)
                            pd = self.productionData2string(self.profileProductionData(dsd),units=False)
                            rd = self.rankingData2string(self.profileRankingData(dsd),units=False)
                            extendedRankingData = self.extendedRankingData2List(dsd,rd,pd)
                            writer.writerow(extendedRankingData)
                        except Exception as e: # pylint: disable=broad-except
                            _, _, exc_tb = sys.exc_info()
#                            traceback.print_exc(file=sys.stdout)
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingCSVReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                    # close file
                    outfile.close()
                    aw.sendmessage(QApplication.translate('Message','CSV Ranking Report exported to {0}').format(filename))
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingExcelReport(self,_=False):
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export Excel',ext='*.xlsx')
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook
                    from openpyxl.utils.cell import get_column_letter,column_index_from_string  # @UnusedImport # pylint: disable=unused-import
                    from openpyxl.styles import Font, Fill, Alignment # @UnusedImport # pylint: disable=unused-import
                    wb = Workbook()
                    ws = wb.active # wb.create_sheet()
                    ws.title = QApplication.translate('HTML Report Template', 'Ranking Report')
                    bf = Font(name='Calibri',size='11',bold=True)
                    ws.font = Font(name='Calibri',size='11')

                    #get the field definitions
                    ranking_data_fields, field_index = self.rankingdataDef()

                    # write header
                    widths = [10]*len(ranking_data_fields)
                    weight_unit = aw.qmc.weight[2]
                    volume_unit = aw.qmc.volume[2]
                    temperature_unit = aw.qmc.mode
                    cnum = col_ = 0
                    for i in range(len(ranking_data_fields)):
                        cnum += 1
                        name = ranking_data_fields[i][field_index.index('name')]
                        units = ranking_data_fields[i][field_index.index('units')]
                        if units == 'temp':
                            suffix = f' ({temperature_unit})'
                        elif units == 'volume':
                            suffix = f' ({volume_unit})'
                        elif units == 'weight':
                            suffix = f' ({weight_unit})'
                        elif units == 'ror':
                            suffix = ' ({})'.format(temperature_unit + '/min')
                        elif units.startswith('('):
                            suffix = f' {units}'
                        else:
                            suffix = ''
                        cell = ws.cell(column=cnum, row=1, value=f'{name}{suffix}')
                        cell.font = bf
                        cell.alignment = Alignment(horizontal='center')
                        width = (len(name + suffix) + 2.)
                        if width > widths[i]:
                            widths[i] = width
                            ws.column_dimensions[get_column_letter(cnum)].width = width

                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            c += 1
                            dsd = self.deserialize(p)
                            rd = self.profileRankingData(dsd)
                            pd = self.productionData2string(self.profileProductionData(dsd),units=False)
                            cnum = col_
                            for i in range(len(ranking_data_fields)):
                                cnum += 1
                                cr = f'{get_column_letter(cnum)}{c}'

                                name = ranking_data_fields[i][field_index.index('name')]
                                fld = ranking_data_fields[i][field_index.index('fld')]
                                src = ranking_data_fields[i][field_index.index('src')]
                                typ = ranking_data_fields[i][field_index.index('typ')]
                                test0 = ranking_data_fields[i][field_index.index('test0')]
                                units = ranking_data_fields[i][field_index.index('units')]
                                if src == 'comp' and fld in dsd['computed']:
                                    res_fld = dsd['computed'][fld]
                                elif src == 'prof' and fld in dsd:
                                    res_fld = dsd[fld]
                                elif src == 'rank' and fld in rd:
                                    res_fld = rd[fld]
                                elif src == 'prod' and fld in pd:
                                    res_fld = pd[fld]
                                elif src == 'eval':
                                    res_fld = eval(fld) # pylint: disable=eval-used
                                else:
                                    continue

                                if (test0 == 'true' and aw.float2float(toFloat(res_fld)) > 0) or test0 == 'false':
                                    if units == 'temp':
                                        conv_fld = convertTemp(res_fld,dsd['mode'],temperature_unit)
                                    elif units == 'ror':
                                        conv_fld = convertRoR(res_fld,dsd['mode'],temperature_unit)
                                    elif units == 'volume':
                                        conv_fld = aw.convertVolume(res_fld,0,aw.qmc.volume_units.index(volume_unit))
                                    elif units == 'weight':
                                        conv_fld = aw.convertWeight(res_fld,0,aw.qmc.weight_units.index(weight_unit))
                                    else:
                                        conv_fld = res_fld

                                    if typ == 'text':
                                        ws[cr] = conv_fld
                                        width = (len(conv_fld) + 2.)
                                        if re.match(r'[0-9]+',units):
                                            if width > float(units):
                                                width = float(units)
                                        if width > widths[i]:
                                            widths[i] = width
                                            ws.column_dimensions[get_column_letter(cnum)].width = width
                                        ws[cr].alignment = Alignment(wrap_text=True)
                                    elif typ == 'int':
                                        ws[cr] = conv_fld
                                    elif typ == 'float1':
                                        ws[cr] = conv_fld
                                        ws[cr].number_format = '0.0'
                                    elif typ == 'float2':
                                        ws[cr] = conv_fld
                                        ws[cr].number_format = '0.00'
                                    elif typ == 'float4':
                                        ws[cr] = conv_fld
                                        ws[cr].number_format = '0.0000'
                                    elif typ == 'text2float1':
                                        ws[cr] = aw.float2float(toFloat(conv_fld))
                                        ws[cr].number_format = '0.0'
                                    elif typ == 'text2float2':
                                        ws[cr] = aw.float2float(toFloat(conv_fld))
                                        ws[cr].number_format = '0.00'
                                    elif typ == 'text2int':
                                        ws[cr] = toInt(conv_fld)
                                        ws[cr].number_format = '0'
                                    elif typ == 'percent':
                                        ws[cr] = conv_fld/100.
                                        ws[cr].number_format = '0.0%'
                                    elif typ == 'time':
                                        h,m = divmod(conv_fld,60)
                                        dt = datetime.time(int(h),int(m),0) # note that rounding h and m might lead to failure of .time() as round(59.99) = 60 which is >59 thus not accepeted by .time()
                                        ws[cr] = dt
                                        ws[cr].number_format = 'H:MM'
                                    elif typ == 'date':
                                        ws[cr] = QDateTime(conv_fld).toPyDateTime()
                                        fmt = 'YYYY-MM-DD HH:MM'
                                        ws[cr].number_format = fmt
                                        width = (len(fmt) + 2.)
                                        if width > widths[i]:
                                            widths[i] = width
                                            ws.column_dimensions[get_column_letter(cnum)].width = width
                                    elif typ == 'bool':
                                        ws[cr] = str(conv_fld)

                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingExcelReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                    # write trailer
                    if c > 1:
                        def avgFormat(c,s,e):
                            rng = '{0}{1}:{0}{2}'.format(c,s,e)
                            return '=IF(SUMPRODUCT(--(' + rng + '<>""))=0,"",AVERAGE(' + rng + '))'

                        ws[f'A{c+1}'] = QApplication.translate('HTML Report Template', 'AVG')
                        ws[f'A{c+1}'].font = bf
                        cnum = col_
                        for i in range(len(ranking_data_fields)):
                            cnum += 1
                            fld = ranking_data_fields[i][field_index.index('fld')]
                            typ = ranking_data_fields[i][field_index.index('typ')]
                            test0 = ranking_data_fields[i][field_index.index('test0')]
                            cr = f'{get_column_letter(cnum)}{c+1}'
                            cltr = get_column_letter(cnum)

                            if typ == 'text':
                                pass
                            elif typ == 'int':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0'
                            elif typ == 'float1':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.0'
                            elif typ == 'float2':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.0'
                            elif typ == 'float4':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.0000'
                            elif typ == 'text2float1':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.0'
                            elif typ == 'text2float2':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.00'
                            elif typ == 'text2int':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0'
                            elif typ == 'percent':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = '0.0%'
                            elif typ == 'time':
                                ws[cr] = avgFormat(cltr,2,c)
                                ws[cr].font = bf
                                ws[cr].number_format = 'H:MM'
                            elif typ == 'bool':
                                pass

                    # close file
                    wb.save(filename)
                    aw.sendmessage(QApplication.translate('Message','Excel Ranking Report exported to {0}').format(filename))
                except OSError as x:
                    _log.exception(x)
                    aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' Err [{0}] Can not write to file, perhaps it is open in an application or is write protected?').format(x.errno))
                    QApplication.beep()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' rankingExcelReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def pdfReport(self,_=False):
        # select file
        filename = self.ArtisanSaveFileDialog(msg='Export PDF',ext='*.pdf')
        if filename:
            self.roastReport(pdf_filename=filename)

    @pyqtSlot()
    @pyqtSlot(bool)
    def htmlReport(self,_=False):
        self.roastReport()

    def releaseQWebEngineView(self):
        try: # sip not supported on older PyQt versions (RPi!)
            sip.delete(self.pdf_page_layout)
            #print(sip.isdeleted(self.pdf_page_layout))
        except Exception: # pylint: disable=broad-except
            pass
        self.pdf_page_layout = None
        try: # sip not supported on older PyQt versions (RPi!)
            sip.delete(self.html_loader)
            #print(sip.isdeleted(self.html_loader))
        except Exception: # pylint: disable=broad-except
            pass
        self.html_loader = None

    # if batch_process is True, the QWebEngineView() is created only if self.html_loader is not None and never deleted
    # the caller is responsible to release that self.html_loader via releaseQWebEngineView()
    def html2pdf(self, html_file, pdf_file, landscape=False, batch_process=False):
        def release():
            if batch_process and self.html_loader is not None:
                try:
                    self.html_loader.page().pdfPrintingFinished.disconnect()
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    self.html_loader.loadFinished.disconnect()
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    self.html_loader.renderProcessTerminated.disconnect()
                except Exception: # pylint: disable=broad-except
                    pass
            else:
                self.releaseQWebEngineView()
            self.pdf_rendering = False

        @pyqtSlot(str,bool)
        def printing_finished(_file:str, _success:bool):
            release()

        @pyqtSlot(bool)
        def emit_pdf(ok:bool):
            if ok:
                if self.html_loader is not None:
                    page = self.html_loader.page()
                    page.pdfPrintingFinished.connect(printing_finished)
                    page.printToPdf(pdf_file, self.pdf_page_layout)
                else:
                    self.pdf_rendering = False
            else:
                self.pdf_rendering = False

        @pyqtSlot('QWebEnginePage::RenderProcessTerminationStatus', int)
        def renderingTerminated(_terminationStatus, _exitCode):
            release()

        try:
            # we wait for a previous pdf conversion to terminate
            while self.pdf_rendering:
                QApplication.processEvents()
                libtime.sleep(0.001)
            self.pdf_rendering = True
            if self.html_loader is None:
                self.html_loader = QWebEngineView()
                self.html_loader.setZoomFactor(1)
            if self.pdf_page_layout is None:
                # lazy imports
                try:
                    #pylint: disable = E, W, R, C
                    from PyQt6.QtCore import QMarginsF  # @UnusedImport @Reimport  @UnresolvedImport
                    from PyQt6.QtGui import QPageLayout, QPageSize  # @UnusedImport @Reimport  @UnresolvedImport
                except:
                    #pylint: disable = E, W, R, C
                    from PyQt5.QtCore import QMarginsF  # @UnusedImport @Reimport  @UnresolvedImport
                    from PyQt5.QtGui import QPageLayout, QPageSize  # @UnusedImport @Reimport  @UnresolvedImport
                if QPrinter().pageLayout().pageSize().id() == QPageSize.PageSizeId.Letter:
                    # Letter
                    ps = QPageSize(QPageSize.PageSizeId.Letter)
                    pu = QPageLayout.Unit.Inch
                    pm = QMarginsF(0.7, 0.7, 0.7, 0.7)
                else:
                    # A4
                    ps = QPageSize(QPageSize.PageSizeId.A4)
                    pu = QPageLayout.Unit.Millimeter
                    pm = QMarginsF(15, 15, 15, 15)
                if landscape:
                    po = QPageLayout.Orientation.Landscape
                else:
                    po = QPageLayout.Orientation.Portrait
                self.pdf_page_layout = QPageLayout(ps, po, pm, pu)
            self.html_loader.renderProcessTerminated.connect(renderingTerminated)
            self.html_loader.loadFinished.connect(emit_pdf)
            self.html_loader.load(QUrl(html_file))
            # busy wait for the pdf conversion to terminate
            while self.pdf_rendering:
                QApplication.processEvents()
                libtime.sleep(0.001)
        except Exception as e:
            _log.exception(e)

    # if batch_process is True and pdf_filename is given, the caller needs to cleanup the QWebEngineView by calling self.releaseQWebEngineView() the after processing all reports
    def roastReport(self,pdf_filename=None, batch_process=False):
        import html as htmllib
        import string as libstring
        try:
            rcParams['path.effects'] = []
            with open(getResourcePath() + 'roast-template.htm', encoding='utf-8') as myfile:
                HTML_REPORT_TEMPLATE=myfile.read()
            beans_html = str(htmllib.escape(self.qmc.beans))
            if len(beans_html) > 43:
                beans_html = beans_html[:41] + '&hellip;'

            cp = aw.computedProfileInformation()

            if 'CHARGE_ET' in cp and 'CHARGE_BT' in cp:
                if self.qmc.mode == 'F':
                    charge = 'BT %.0fF <br>ET %.0fF'%(cp['CHARGE_BT'],cp['CHARGE_ET'])
                else:
                    charge = 'BT %.0f&deg;C <br>ET %.0f&deg;C'%(cp['CHARGE_BT'],cp['CHARGE_ET'])
            else:
                charge = '--'
            dryphase, midphase, finishphase, coolphase = self.phases2html(cp)
            etbta = '--'
            #Dave new way of presenting AUC
            if ('AUC' in cp and cp['AUC'] != 0):
                etbta = '%dC*min'%(cp['AUC'])
                if ('AUCbegin' in cp and cp['AUCbegin'] != '' and 'AUCbase' in cp):
                    etbta += ' [%s,%d%s]'%(cp['AUCbegin'],cp['AUCbase'],self.qmc.mode)
                elif ('AUCbase' in cp):
                    etbta += ' [%d]'%(cp['AUCbase'])
            tmpdir = str(QDir.tempPath() + '/')
            graph_image = 'roastlog-graph'
            graph_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + '.svg')))
            try:
                os.remove(graph_image)
            except OSError:
                pass

            org_patheffects = aw.qmc.patheffects
            if sys.platform.startswith('darwin') and darkdetect.isDark() and appFrozen():
                aw.qmc.patheffects = 0
            self.qmc.redraw(recomputeAllDeltas=False)

            self.qmc.fig.savefig(graph_image,transparent=True)
            #add some random number to force HTML reloading
            graph_image = path2url(graph_image)
            graph_image = graph_image + '?dummy=' + str(int(libtime.time()))

            #obtain flavor chart image
            self.qmc.flavorchart()
            flavor_image = 'roastlog-flavor'
            flavor_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(flavor_image + '.svg')))
            try:
                os.remove(flavor_image)
            except OSError:
                pass
            self.qmc.fig.savefig(flavor_image,transparent=True)
            flavor_image = path2url(flavor_image)
            flavor_image = flavor_image + '?dummy=' + str(int(libtime.time()))
            #return screen to GRAPH profile mode
            if sys.platform.startswith('darwin') and darkdetect.isDark() and appFrozen():
                aw.qmc.patheffects = org_patheffects

            self.qmc.fig.clf() # remove the flavorchart artists
            self.qmc.redraw(recomputeAllDeltas=False)
            met = '--'
            if 'MET' in cp:
                met = '%.0f'%cp['MET'] + '&deg;' + self.qmc.mode
            ror = '--'
            if 'total_ror' in cp:
                ror = '%d%s%s%s'%(cp['total_ror'],uchr(176),aw.qmc.mode,QApplication.translate('Label', '/m'))
            try:
                if  self.qmc.density[0] != 0.0 and self.qmc.density_roasted[0] != 0.0:
                    percent = -1 * aw.weight_loss(self.qmc.density[0], self.qmc.density_roasted[0])
                    density = self.volume_weight2html(self.qmc.density[0],self.qmc.density_roasted[0],'g/l',percent)
                elif 'set_density' in cp:
                    density = '%.1fg/l (set)'%cp['set_density']
                else:
                    density = '--'
            except Exception: # pylint: disable=broad-except
                density = '--'
            if  self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                weight = self.volume_weight2html(self.qmc.weight[0],self.qmc.weight[1],self.qmc.weight[2],cp['weight_loss'])
            else:
                weight = '--'
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0:
                volume = self.volume_weight2html(self.qmc.volume[0],self.qmc.volume[1],self.qmc.volume[2],cp['volume_gain'])
            else:
                volume = '--'
            moisture = ''
            if 'moisture_greens' in cp:
                moisture = '%d%%'%cp['moisture_greens']
                moisture += ' (' + QApplication.translate('Label','greens') + ')'
                if 'moisture_roasted' in cp:
                    moisture += '<br>'
            if 'moisture_roasted' in cp:
                moisture += '%d%%'%cp['moisture_roasted']
                moisture += ' (' + QApplication.translate('Label','roasted') + ')'

            humidity = ''
            if 'ambient_humidity' in cp:
                humidity += '%d%%'%cp['ambient_humidity']
                if 'ambient_temperature' in cp:
                    humidity += ' at %d%s'%(cp['ambient_temperature'],self.qmc.mode)
            else:
                if 'ambient_temperature' in cp:
                    humidity += '%d%s'%(cp['ambient_temperature'],self.qmc.mode)
            if 'ambient_pressure' in cp:
                if len(humidity) != 0:
                    humidity += ', '
                humidity += '%dhPa'%cp['ambient_pressure']
            if len(humidity) == 0:
                humidity = '--'
            if self.qmc.whole_color or self.qmc.ground_color:
                if self.qmc.whole_color:
                    wcolor = str(self.qmc.whole_color)
                else:
                    wcolor = '--'
                if self.qmc.ground_color:
                    gcolor = str(self.qmc.ground_color)
                else:
                    gcolor = '--'
                color = wcolor + '/' + gcolor
                if self.qmc.color_system_idx:
                    color = color + ' (' + self.qmc.color_systems[self.qmc.color_system_idx] + ')'
            else:
                color = '--'
            if 'BTU_batch' in cp and cp['BTU_batch']:
                energy = '%.1fkWh'%self.qmc.convertHeat(cp['BTU_batch'],0,3)
            else:
                energy = '--'
            if 'CO2_batch' in cp and cp['CO2_batch']:
                CO2 = '%.1fg'%cp['CO2_batch']
                if 'CO2_batch_per_green_kg' in cp:
                    CO2 += ' ({}g/kg)'.format(self.float2float(cp['CO2_batch_per_green_kg']))
            else:
                CO2 = '--'
            if 'det' in cp:
                cm_tuple = '{:.1f}/{:.1f}'.format(cp['det'],cp['dbt']) + uchr(176) + aw.qmc.mode
            else:
                cm_tuple = '--'
            if aw.qmc.titleB is None or aw.qmc.titleB == '':
                background_html = '--'
            else:
                if aw.qmc.roastbatchnrB == 0:
                    titleB = aw.qmc.titleB
                else:
                    titleB = aw.qmc.roastbatchprefixB + str(aw.qmc.roastbatchnrB) + ' ' + aw.qmc.titleB
                background_html = titleB
            if aw.qmc.alarmsfile:
                alarms = str(os.path.basename(aw.qmc.alarmsfile))
            else:
                alarms = '--'
            if aw.qmc.roastbatchnr == 0:
                batch = ''
            else:
                batch = aw.qmc.roastbatchprefix + str(aw.qmc.roastbatchnr) + ' '
            datetime_html=self.qmc.roastdate.date().toString() + ', ' + self.qmc.roastdate.time().toString()[:-3]
            # add artisan or artisan.plus links to title, background and beans if possible
            title_html = str(htmllib.escape(batch)) + str(htmllib.escape(self.qmc.title))
            if aw.qmc.roastUUID is not None and aw.qmc.roastUUID != '':
#                if plus.register.getPath(aw.qmc.roastUUID):
#                    title_html = '<a href="artisan://roast/' + aw.qmc.roastUUID + '">' + title_html + "</a>"
                title_html = '<a href="artisan://roast/' + aw.qmc.roastUUID + '">' + title_html + '</a>'
                if bool(plus.sync.getSync(aw.qmc.roastUUID)):
                    datetime_html = f'<a href="{plus.util.roastLink(aw.qmc.roastUUID)}" target="_blank">{datetime_html}</a>'
#            if aw.qmc.background and aw.qmc.titleB is not None and aw.qmc.titleB != "" and aw.qmc.backgroundUUID is not None and plus.register.getPath(aw.qmc.backgroundUUID):
#                background_html = '<a href="artisan://roast/' + aw.qmc.backgroundUUID + '">' + background_html + "</a>"
            if aw.qmc.background and aw.qmc.titleB is not None and aw.qmc.titleB != '' and aw.qmc.backgroundUUID is not None:
                background_html = '<a href="artisan://roast/' + aw.qmc.backgroundUUID + '">' + background_html + '</a>'
            if beans_html is not None and beans_html != '' and aw.qmc.plus_coffee is not None:
                beans_html = f'<a href="{plus.util.coffeeLink(aw.qmc.plus_coffee)}" target="_blank">{beans_html}</a>'
                # note that blends are hard to link back as it requires to link component by component
            cupping_score, cupping_all_default = self.cuppingSum(self.qmc.flavors)
            cupping_notes = self.note2html(self.qmc.cuppingnotes).strip()
            special_events = self.specialevents2html().strip()
            html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                title=title_html,
                titlecolor=QColor(aw.qmc.palette['title']).name(),
                doc=QApplication.translate('HTML Report Template', 'Roasting Report'),
                datatime_label=QApplication.translate('HTML Report Template', 'Date:'),
                datetime=datetime_html,
                beans_label=QApplication.translate('HTML Report Template', 'Beans:'),
                beans=beans_html,
                weight_label=QApplication.translate('HTML Report Template', 'Weight:'),
                weight=weight,
#                degree_label=QApplication.translate("HTML Report Template", "Degree:"),
#                degree=degree,
                volume_label=QApplication.translate('HTML Report Template', 'Volume:'),
                volume=volume,
                roaster_label=QApplication.translate('HTML Report Template', 'Roaster:'),
                roaster=str(htmllib.escape(self.qmc.roastertype)),
                operator_label=QApplication.translate('HTML Report Template', 'Operator:'),
                operator=str(htmllib.escape(self.qmc.operator)),
                organization_label=QApplication.translate('HTML Report Template', 'Organization:'),
                organization=str(htmllib.escape(self.qmc.organization)),
                cup_label=('' if cupping_all_default else QApplication.translate('HTML Report Template', 'Cupping:')),
                cup=('' if cupping_all_default else str(aw.float2float(cupping_score))),
                color_label=QApplication.translate('HTML Report Template', 'Color:'),
                color=color,
                energy_label=QApplication.translate('HTML Report Template', 'Energy:'),
                energy=energy,
                CO2_label=QApplication.translate('HTML Report Template', 'CO2:').replace('CO2','CO'),
                CO2=CO2,
                charge_label=QApplication.translate('HTML Report Template', 'CHARGE:'),
                charge=charge,
                size_label=QApplication.translate('HTML Report Template', 'Size:'),
                size='--' if (aw.qmc.beansize_max == 0 and aw.qmc.beansize_min == 0) else (str(round(int(aw.qmc.beansize_min))) if aw.qmc.beansize_min != 0 else ''
                    ) + ('/' if (aw.qmc.beansize_max != 0 and aw.qmc.beansize_min != 0) else '') + (str(round(int(aw.qmc.beansize_max))) if (aw.qmc.beansize_max != 0) else ''),
                density_label=QApplication.translate('HTML Report Template', 'Density:'),
                density=density,
                moisture_label=QApplication.translate('HTML Report Template', 'Moisture:'),
                moisture=moisture,
                humidity_label=QApplication.translate('HTML Report Template', 'Ambient:'),
                humidity=humidity,
                TP_label=QApplication.translate('HTML Report Template', 'TP:'),
                TP=self.event2html(cp,'TP_time','TP_BT'),
                DRY_label=QApplication.translate('HTML Report Template', 'DRY:'),
                DRY=self.event2html(cp,'DRY_time','DRY_BT'),
                FCs_label=QApplication.translate('HTML Report Template', 'FCs:'),
                FCs=self.event2html(cp,'FCs_time','FCs_BT'),
                FCe_label=QApplication.translate('HTML Report Template', 'FCe:'),
                FCe=self.event2html(cp,'FCe_time','FCe_BT'),
                SCs_label=QApplication.translate('HTML Report Template', 'SCs:'),
                SCs=self.event2html(cp,'SCs_time','SCs_BT'),
                SCe_label=QApplication.translate('HTML Report Template', 'SCe:'),
                SCe=self.event2html(cp,'SCe_time','SCe_BT'),
                drop_label=QApplication.translate('HTML Report Template', 'DROP:'),
                drop=self.event2html(cp,'DROP_time','DROP_BT'),
                cool_label=QApplication.translate('HTML Report Template', 'COOL:'),
                cool=self.event2html(cp,'COOL_time',None,'DROP_time'),
                met_label=QApplication.translate('HTML Report Template', 'MET:'),
                met=met,
                cm_label=QApplication.translate('HTML Report Template', 'CM:'),
                cm_tuple=cm_tuple,
                dry_phase_label=QApplication.translate('HTML Report Template', 'Drying:'),
                dry_phase=dryphase,
                mid_phase_label=QApplication.translate('HTML Report Template', 'Maillard:'),
                mid_phase=midphase,
                finish_phase_label=QApplication.translate('HTML Report Template', 'Finishing:'),
                finish_phase=finishphase,
                cool_phase_label=QApplication.translate('HTML Report Template', 'Cooling:'),
                cool_phase=coolphase,
                background_label=QApplication.translate('HTML Report Template', 'Background:'),
                background=background_html,
                alarms_label=QApplication.translate('HTML Report Template', 'Alarms:'),
                alarms=alarms,
                ror_label=QApplication.translate('HTML Report Template', 'RoR:'),
                ror= ror,
                etbta_label=QApplication.translate('HTML Report Template', 'AUC:'),
                etbta=etbta,
                roasting_notes_label=(QApplication.translate('HTML Report Template', 'Roasting Notes') if self.qmc.roastingnotes != '' else ''),
                roasting_notes=self.note2html(self.qmc.roastingnotes),
                roast_attributes=self.roastattributes(),
                graph_image=graph_image,
                flavor_image=flavor_image,
                show_cupping=('none' if cupping_all_default else 'inline'),
                specialevents_label=QApplication.translate('HTML Report Template', 'Events'),
                specialevents=special_events,
                show_special_events=('none' if special_events == '' else 'inline'),
                cupping_notes_label=(QApplication.translate('HTML Report Template', 'Cupping Notes') if self.qmc.cuppingnotes != '' else ''),
                cupping_notes=cupping_notes)
            f = None
            try:
                filename = str(QDir(tmpdir).filePath('Roastlog.html'))
                try:
                    os.remove(filename)
                except OSError:
                    pass
                import codecs # @Reimport
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    for i in range(len(html)):
                        f.write(html[i])
                if platf == 'Darwin':
                    full_path = 'file://' + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                else:
                    full_path = 'file:///' + filename # Explorer refuses to start otherwise
                if pdf_filename:
                    self.html2pdf(full_path,pdf_filename, batch_process=batch_process)
                else:
                    QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

            except OSError as e:
                _log.exception(e)
                aw.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' htmlReport() {0}').format(str(e)))
            finally:
                if f:
                    f.close()
                # we only trigger a redraw if a watermark is displayed to fix its aspect ratio
                if aw.logofilename != '':
                    aw.qmc.redraw(recomputeAllDeltas=False)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' htmlReport() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    # returns a string with all the activated roast attributes
    @staticmethod
    def roastattributes():
        res = []
        if aw.qmc.heavyFC_flag:
            res.append(QApplication.translate('CheckBox','Heavy FC'))
        if aw.qmc.lowFC_flag:
            res.append(QApplication.translate('CheckBox','Low FC'))
        if aw.qmc.lightCut_flag:
            res.append(QApplication.translate('CheckBox','Light Cut'))
        if aw.qmc.darkCut_flag:
            res.append(QApplication.translate('CheckBox','Dark Cut'))
        if aw.qmc.drops_flag:
            res.append(QApplication.translate('CheckBox','Drops'))
        if aw.qmc.oily_flag:
            res.append(QApplication.translate('CheckBox','Oily'))
        if aw.qmc.uneven_flag:
            res.append(QApplication.translate('CheckBox','Uneven'))
        if aw.qmc.tipping_flag:
            res.append(QApplication.translate('CheckBox','Tipping'))
        if aw.qmc.scorching_flag:
            res.append(QApplication.translate('CheckBox','Scorching'))
        if aw.qmc.divots_flag:
            res.append(QApplication.translate('CheckBox','Divots'))
        if len(res) > 0:
            return '\n<center><pre>' + ', '.join(res) + '</pre></center>'
        return ''

    # returns the overal cupping score and as second value a flag if True indicating that all individual ratings were set to their default value
    def cuppingSum(self, flavors):
        score = 0.
        all_default = True
        nflavors = len(flavors)
        for i in range(nflavors):
            score += flavors[i]
            if flavors[i] != self.qmc.flavors_default_value:
                all_default = False
        score /= (nflavors)
        score *= 10.
        return score, all_default

    @staticmethod
    def volume_weight2html(amount, out, unit, change):
        if amount:
            return str('%.1f'%amount) + unit + '<br>' + str(out) + unit + ' (' + '%.1f'%change + '%)'
        return '--'

    @staticmethod
    def phases2html(cp):
        dryphase = midphase = finishphase = coolphase = '--'
        if 'totaltime' in cp:
            totaltime = cp['totaltime']
            if totaltime:
                #dryphase
                if 'dryphasetime' in cp:
                    dryphasetime = cp['dryphasetime']
                    dryphase = '%s (%d%%)'%(stringfromseconds(cp['dryphasetime']),int(round(dryphasetime*100./totaltime)))
                    if 'dry_phase_ror' in cp:
                        dryphase += '<br>%.1f%s%s/min'%(cp['dry_phase_ror'],uchr(176),aw.qmc.mode)
                    if 'dry_phase_delta_temp' in cp:
                        dryphase += '<br>%.1f%s%s'%(cp['dry_phase_delta_temp'],uchr(176),aw.qmc.mode)
                #midphase
                if 'midphasetime' in cp:
                    midphasetime = cp['midphasetime']
                    midphase = '%s (%d%%)'%(stringfromseconds(cp['midphasetime']),int(round(midphasetime*100./totaltime)))
                    if 'mid_phase_ror' in cp:
                        midphase += '<br>%.1f%s%s/min'%(cp['mid_phase_ror'],uchr(176),aw.qmc.mode)
                    if 'mid_phase_delta_temp' in cp:
                        midphase += '<br>%.1f%s%s'%(cp['mid_phase_delta_temp'],uchr(176),aw.qmc.mode)
                #finishphase
                if 'finishphasetime' in cp:
                    finishphasetime = cp['finishphasetime']
                    finishphase = '%s (%d%%)'%(stringfromseconds(cp['finishphasetime']),int(round(finishphasetime*100./totaltime)))
                    if 'finish_phase_ror' in cp:
                        finishphase += '<br>%.1f%s%s/min'%(cp['finish_phase_ror'],uchr(176),aw.qmc.mode)
                    if 'finish_phase_delta_temp' in cp:
                        finishphase += '<br>%.1f%s%s'%(cp['finish_phase_delta_temp'],uchr(176),aw.qmc.mode)
                #coolphase
                if 'coolphasetime' in cp:
                    coolphasetime = cp['coolphasetime']
                    coolphase = '%s (%d%%)'%(stringfromseconds(cp['coolphasetime']),int(round(coolphasetime*100./totaltime)))
        return dryphase, midphase, finishphase, coolphase

    def event2html(self,cp,time_key,BT_key=None,prev_time_key=None):
        res = '--'
        if prev_time_key and prev_time_key in cp and time_key in cp:
            res = stringfromseconds(cp[time_key]) + ' (' + stringfromseconds(cp[time_key] - cp[prev_time_key]) + 'm)'
        elif time_key in cp and BT_key in cp:
            res = stringfromseconds(cp[time_key])+ ' (%.0f'%cp[BT_key] + '&deg;' + self.qmc.mode + ')'
        return res

    def specialevents2html(self):
        html = ''
        if self.qmc.specialevents and len(self.qmc.specialevents) > 0:
            html += '\n<table cellpadding="10" cellspacing="8">\n'
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
            else:
                start = 0
            # sort events by time/index
            sevents = sorted(zip(self.qmc.specialevents,range(len(self.qmc.specialevents))))
            seventsString = []
            seventsType = []
            seventsValue = []
            for i in range(len(sevents)):
                sorted_pos = sevents[i][1]
                seventsString.append(self.qmc.specialeventsStrings[sorted_pos])
                seventsType.append(self.qmc.specialeventstype[sorted_pos])
                seventsValue.append(self.qmc.specialeventsvalue[sorted_pos])
            for i in range(len(self.qmc.specialevents)):
                # add BT/ET
                temps = ''
                if self.qmc.mode == 'F':
                    formatString = '%.1fF'
                else:
                    formatString = '%.1f&deg;C'
                if self.qmc.temp1[sevents[i][0]] == -1 and self.qmc.temp2[sevents[i][0]] == -1:
                    temps += ' -- '
                elif self.qmc.temp1[sevents[i][0]] == -1:
                    temps += formatString%self.qmc.temp2[sevents[i][0]]
                elif self.qmc.temp2[sevents[i][0]] == -1:
                    temps += formatString%self.qmc.temp1[sevents[i][0]]
                else:
                    temps += formatString%self.qmc.temp2[sevents[i][0]] + ' / ' + formatString%self.qmc.temp1[sevents[i][0]]
                # add DeltaBT / DeltaET
                deltas = ''
                if self.qmc.mode == 'F':
                    formatString = '%.1fF/min'
                else:
                    formatString = '%.1f&deg;C/min'
                try:
                    if (self.qmc.delta1[sevents[i][0]] is None or self.qmc.delta1[sevents[i][0]] == -1) and \
                        (self.qmc.delta2[sevents[i][0]] is None or self.qmc.delta2[sevents[i][0]] == -1):
                        deltas += ' -- '
                    elif self.qmc.delta1[sevents[i][0]] is None or self.qmc.delta1[sevents[i][0]] == -1:
                        deltas += formatString%self.qmc.delta2[sevents[i][0]]
                    elif self.qmc.delta2[sevents[i][0]] is None or self.qmc.delta2[sevents[i][0]] == -1:
                        deltas += formatString%self.qmc.delta1[sevents[i][0]]
                    else:
                        deltas += formatString%self.qmc.delta2[sevents[i][0]] + ' / ' + formatString%self.qmc.delta1[sevents[i][0]]
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                html += ('<tr>'+
                     '\n<td>' + str(i+1) + '</td><td>' +
                     stringfromseconds(self.qmc.timex[sevents[i][0]] - start) +
                     "</td><td align='right'>" + temps + '</td><td>' +
                     "</td><td align='right'>" + deltas + '</td><td>' + seventsString[i] + ('</td></tr>\n' if seventsType[i] == 4 else ('</td><td>(' + str(self.qmc.etypesf(seventsType[i])) + ' ' + self.qmc.eventsvalues(seventsValue[i]) + ')</td></tr>\n')))
            html += '</table>\n'
        return html

    @staticmethod
    def note2html(notes):
        notes_html = ''
        for i in range(len(notes)):
            if str(notes[i]) == 9:
                notes_html += ' &nbsp&nbsp&nbsp&nbsp '
            elif str(notes[i]) == '\n':
                notes_html += '<br>\n'
            else:
                notes_html += str(notes[i])
        if notes_html != '':
            notes_html = '<br>' + notes_html
        return notes_html

    #returns the index of the lowest point in BT; return -1 if no such value found
    def findTP(self):
        return self.findTPint(aw.qmc.timeindex, aw.qmc.timex, aw.qmc.temp2)

    @staticmethod
    def findTPint(timeindex, timex, temp):
        TP = 1000
        idx = 0
        start = 0
        end = len(timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if timeindex[6]:
            EOR_index = timeindex[6]
        if start < EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if timeindex[2]:
            FCs_index = timeindex[2]
        if start < FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if timeindex[0] != -1:
            SOR_index = timeindex[0]
        if start < SOR_index < end:
            start = SOR_index
        for i in range(end - 1, start -1, -1):
            if temp[i] > 0 and temp[i] < TP:
                TP = temp[i]
                idx = i
        return idx

    #returns the index of the end of the dry phase (returns -1 if dry end cannot be determined)
    #if given, starts at TP_index and looks forward, otherwise it looks backwards from end of roast (EoR)
    #find index with smallest abs() difference between aw.qmc.phases[1] and BT (temp2)
    # phasesindex=1 => find DRY
    # phasesindex=2 => find FCs
    def findDryEnd(self,TP_index=None,phasesindex=1):
        sd = 1000
        nsd = 1000
        index = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if start < EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[2]
        if start < FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0]
        if start < SOR_index < end:
            start = SOR_index
        # try to consider only indices from TP of roast on and not before
        TP = TP_index
        # if TP not yet computed, let's try to compute it
        if TP is None:
            TP = self.findTP()
        if start < TP < end:
            start = TP
        for i in range(end -1, start -1, -1):
            nsd = abs(self.qmc.temp2[i]- self.qmc.phases[phasesindex])
            if nsd < sd:
                sd = nsd
                index = i
        return index

    @staticmethod
    def checkTop(offset, p0, p1, p2, p3, p4, p5):
#        print("->",p0,p1,p2,p3,p4,p5)
        d1 = p0 - p1
        d2 = p1 - p2
        #--
        d3 = p4 - p3
        d4 = p5 - p4
        dpre = (d1 + d2) / 2.0
        dpost = (d3 + d4) / 2.0
        if aw.qmc.mode == 'C':
            f = 2.5
        else:
            f = 2.8 * 1.8
#        print("checkTop",d3 < .0,d4 < .0,abs(dpost),(offset + (f * abs(dpre))))
        return bool(d3 < .0 and d4 < .0 and (abs(dpost) > (offset + (f * abs(dpre)))))


    # returns True if a BT break at i-2 is detected
    # idea:
    # . average delta before i-2 is not negative
    # . average delta after i-2 is negative and twice as high (absolute) as the one before
    def BTbreak(self,i,offset):
#        print("BTbreak",i,offset,self.qmc.temp2[i])
        res = 0
        if len(self.qmc.timex)>5 and i < len(self.qmc.timex):
            if self.checkTop(offset,self.qmc.temp2[i-5],self.qmc.temp2[i-4],self.qmc.temp2[i-3],self.qmc.temp2[i-2],self.qmc.temp2[i-1],self.qmc.temp2[i]):
                res = 3
            elif len(self.qmc.timex)>10 and self.checkTop(offset,self.qmc.temp2[i-10],self.qmc.temp2[i-8],self.qmc.temp2[i-6],self.qmc.temp2[i-4],self.qmc.temp2[i-2],self.qmc.temp2[i]):
                res = 6
        return res

    # this can be used to find the CHARGE index as well as the DROP index by using
    # 0 or the DRY index as start index, respectively
    def findBTbreak(self,start_index=0,end_index=0,offset=0.5):
        result = 0
        # determine average deltaBT wrt. the two previous measurements
        # the deltaBT values wrt. the next two measurements must by twice as high and negative
        # then our current measurement is the one of CHARGE/DROP
        for i in range(start_index,len(self.qmc.timex)):
            if end_index and i > end_index:
                break
            if i>3:
                if aw.qmc.mode == 'C':
                    o = offset
                else:
                    o = offset * 1.8
                b = self.BTbreak(i,o)
                if b > 0:
                    result = i + 1 - b
                    break
        return result

    # updates AUC guide (expected time to hit target AUC; aw.qmc.AUCguideTime) based on current AUC, target, base, and RoR
    def updateAUCguide(self):
        if (len(aw.qmc.delta2) > 0 and aw.qmc.delta2[-1] is not None and aw.qmc.delta2[-1] > 0 and # we have a positive BT RoR
            aw.qmc.TPalarmtimeindex is not None and  # we passed TP
            aw.qmc.AUCvalue > 0): # there is already some AUC available

            # so let's compute the AUCtarget
            if aw.qmc.AUCtargetFlag and aw.qmc.backgroundprofile is not None and aw.qmc.AUCbackground > 0:
                # background AUC as target
                target = aw.qmc.AUCbackground
            else:
                # use target AUC as specified by the user
                target = aw.qmc.AUCtarget
            if target > 0 and target > aw.qmc.AUCvalue:
                # only recompute AUC guid if a sensible target exists and the AUC target is not reached
                # so let's compute the AUCbase
                if aw.qmc.AUCbegin == 0 and aw.qmc.timeindex[0] > -1: # start after CHARGE
                    idx = aw.qmc.timeindex[0]
                elif aw.qmc.AUCbegin == 1 and aw.qmc.TPalarmtimeindex: # start ater TP
                    idx = aw.qmc.TPalarmtimeindex
                elif aw.qmc.AUCbegin == 2 and aw.qmc.timeindex[1] > 0: # DRY END
                    idx = aw.qmc.timeindex[1]
                elif aw.qmc.AUCbegin == 3 and aw.qmc.timeindex[2] > 0: # FC START
                    idx = aw.qmc.timeindex[2]
                else:
                    idx = -1
                if idx > -1: # we passed the AUCbegin event
                    if aw.qmc.AUCbaseFlag:
                        # we take the base temperature from the BT at st
                        tbase = self.qmc.temp2[idx]
                    else:
                        tbase = aw.qmc.AUCbase
                    tbase = convertTemp(tbase,aw.qmc.mode,'C')
                    if tbase > 0 and len(aw.qmc.temp2) > 0:
                        bt = convertTemp(aw.qmc.temp2[-1],aw.qmc.mode,'C')
                        if bt > tbase:
                            # the time (in minutes) to reach the AUC target under the given base and current BT RoR
                            # is the positive root of the following equation
                            #   RoR/2*t^2 + (BT - base)*t + (AUCcurrent - AUCtarget) = 0
                            ror = convertRoR(aw.qmc.delta2[-1],aw.qmc.mode,'C') # BT RoR
                            roots = [r for r in numpy.roots([ror/2.0,bt - tbase,aw.qmc.AUCvalue-target]) if r > 0]
                            if len(roots) > 0:
                                ts = aw.qmc.timeclock.elapsed()/1000.
                                aw.qmc.AUCguideTime = ts + roots[0]*60 # takes the first positive root and calculates the time in seconds until the target AUC is reached
                            if aw.qmc.l_AUCguide is not None:
                                if 0 < aw.qmc.AUCguideTime and aw.qmc.AUCguideTime < aw.qmc.endofx:
#                                    aw.qmc.l_AUCguide.set_data([aw.qmc.AUCguideTime,aw.qmc.AUCguideTime], [aw.qmc.ylimit_min, aw.qmc.ylimit])
                                    aw.qmc.l_AUCguide.set_xdata(aw.qmc.AUCguideTime)
                                    aw.qmc.l_AUCguide.set_visible(True)
                                else:
#                                    aw.qmc.l_AUCguide.set_data([],[])
                                    aw.qmc.l_AUCguide.set_visible(False)

    @staticmethod
    def AUCstartidx(timeindex, TPindex):
        if aw.qmc.AUCbegin == 0 and timeindex[0] > -1: # start after CHARGE
            idx = timeindex[0]
        elif aw.qmc.AUCbegin == 1 and TPindex: # start ater TP
            idx = TPindex
        elif aw.qmc.AUCbegin == 2 and timeindex[1] > 0: # DRY END
            idx = timeindex[1]
        elif aw.qmc.AUCbegin == 3 and timeindex[2] > 0: # FC START
            idx = timeindex[2]
        else:
            idx = -1
        return idx

    def thisAUC(self,idx,timex,temp,mode):
        if aw.qmc.AUCbaseFlag:
            # we take the base temperature from the BT at st
            tbase = temp[idx]
        else:
            tbase = aw.qmc.AUCbase
        tbase = convertTemp(tbase,mode,'C')
        return self.calcAUC(tbase,timex,temp)/60.

    # updates the running AUC variables aw.qmc.AUCvalue and aw.qmc.AUCsinceFCs during recording
    def updateAUC(self):
        idx = self.AUCstartidx(aw.qmc.timeindex,aw.qmc.TPalarmtimeindex)
        if idx > -1: # we passed the AUCbegin event
            thisAUC = self.thisAUC(idx,self.qmc.timex,self.qmc.temp2,aw.qmc.mode)
            aw.qmc.AUCvalue += thisAUC
            if aw.qmc.timeindex[2] > 0:
                aw.qmc.AUCsinceFCs += thisAUC
            else:
                aw.qmc.AUCsinceFCs = 0
        else:
            aw.qmc.AUCvalue = 0
            aw.qmc.AUCsinceFCs = 0

    # calculates the area underneath the temp curve between the last two measurements
    #  base: the base temperature in C
    #  timex: the list of time points
    #  temp: the list of temperature values
    #  i: index relative to i-1 the area is calculated. If omitted, the last elements in the list are used
    #  temp2: if temp2 is given, then the area between temp1 and temp2 is calculated, assuming temp1>temp2, and the base is ignored
    # result is in C*seconds
    @staticmethod
    def calcAUC(base, timex, temp, i=-1, temp2=None):
        if len(timex) > 1 and len(temp) > 1 and (i == -1 or (0 < i < min(len(timex),len(temp)))):
            # at least two readings available
            dt = (timex[i] - timex[i-1])
            t1 = convertTemp(temp[i],aw.qmc.mode,'C')
            if t1 > 500:
                t1 = 0
            t2 = convertTemp(temp[i-1],aw.qmc.mode,'C')
            if t2 > 500:
                t2 = 0
            ta = (max(0,t1) + max(0,t2)) / 2.0
            if temp2 is None or len(temp2) < 2 or (i != -1 and len(temp2) < i+1):
                return (max(0,ta-base) * dt)
            e1 = convertTemp(temp2[i],aw.qmc.mode,'C')
            if e1 > 500:
                e1 = 0
            e2 = convertTemp(temp2[i-1],aw.qmc.mode,'C')
            if e2 > 500:
                e2 = 0
            ea = (max(0,e1) + max(0,e2)) / 2.0
            return (max(0,ta - ea) * dt)
        return 0

    #calculate the AREA under BT and ET (always in C!)
    # from "start" to "end" (defaults to CHARGE to DROP)
    # and use "rt" as reference temperature (area above "rt" and below ET/BT)
    # if background=True, use the background time and temperature values
    # returns AUC(ET-BT), AUC(ET), AUC(BT), AUCbegin_idx
    def ts(self,start=None,end=None,tp=None,background=False):
        if background:
            timeindex = self.qmc.timeindexB[:]
            timex = self.qmc.timeB[:]
            temp1 = self.qmc.temp1B[:]
            temp2 = self.qmc.temp2B[:]
        else:
            timeindex = self.qmc.timeindex[:]
            timex = self.qmc.timex[:]
            temp1 = self.qmc.temp1[:]
            temp2 = self.qmc.temp2[:]
        return self.profileAUC(timeindex,timex,temp1,temp2,start,end,tp)

    def profileAUC(self,timeindex,timex,temp1,temp2,start=None,end=None,tp=None):
        delta = ET = BT = 0.0
        if (start == 0 and end == 0) or (start and (start < 0 or (start == 0 and timeindex[0] < 0))) or (len(timex) == 0):
            return 0,0,0,0
        try:
            if tp:
                TP_index = tp
            else:
                if aw.qmc.AUCbegin == 1:
                    if aw.qmc.TPalarmtimeindex:
                        TP_index = aw.qmc.TPalarmtimeindex
                    else:
                        TP_index = aw.findTPint(timeindex,timex,temp2)
                else:
                    TP_index = -1

            if aw.qmc.AUCbegin == 0 and timeindex[0] > -1: # CHARGE
                AUCbegin_idx = timeindex[0]
            elif aw.qmc.AUCbegin == 1 and TP_index > -1: # TP
                AUCbegin_idx = TP_index
            elif aw.qmc.AUCbegin == 2 and timeindex[1] > 0: # DRY END
                AUCbegin_idx = timeindex[1]
            elif aw.qmc.AUCbegin == 3 and timeindex[2] > 0: # FC START
                AUCbegin_idx = timeindex[2]
            else:
                AUCbegin_idx = 0

            if start is None:
                st = AUCbegin_idx
            else:
                st = start

            ed = min(len(timex),(end or timeindex[6]))

            if aw.qmc.AUCbaseFlag:
                # we take the base temperature from the BT at st
                rtet = temp1[AUCbegin_idx]
                rtbt = temp2[AUCbegin_idx]
            else:
                rtet = rtbt = aw.qmc.AUCbase
            rtet = convertTemp(rtet,aw.qmc.mode,'C')
            rtbt = convertTemp(rtbt,aw.qmc.mode,'C')

            for i in range(st,ed):
                ET += self.calcAUC(rtet,timex,temp1,i)
                BT += self.calcAUC(rtbt,timex,temp2,i)
                delta += self.calcAUC(rtbt,timex,temp1,i,temp2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' ts() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return int(round(delta/60.)), int(round(ET/60.)), int(round(BT/60.)), AUCbegin_idx

    #Find rate of change of each phase. TP_index (by aw.findTP()) is the index of the TP and dryEndIndex that of the end of drying (by aw.findDryEnd())
    #Note: For the dryphase, the RoR for the dryphase is calculated for the segment starting from TP ending at DE
    def RoR(self,TP_index,dryEndIndex):
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        BTdrycross = None
        rc1 = rc2 = rc3 = 0.
        dt1 = dt2 = dt3 = 0.
        divisor = 0
        if -1 < dryEndIndex < len(self.qmc.temp2):
            BTdrycross = self.qmc.temp2[dryEndIndex]
        if BTdrycross and self.qmc.greens_temp > 0:
            LP = self.qmc.greens_temp
            #avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[self.qmc.timeindex[0]]
        elif BTdrycross and -1 < TP_index < min(1000, len(self.qmc.temp2)) and dryEndIndex:
            LP = self.qmc.temp2[TP_index]
            #avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[TP_index]
        if divisor:
            rc1 = ((BTdrycross - LP) / divisor)*60.
            dt1 = BTdrycross - LP
        if self.qmc.timeindex[2]:
            if midphasetime and BTdrycross:
                rc2 = ((self.qmc.temp2[self.qmc.timeindex[2]] - BTdrycross)/midphasetime)*60.
                dt2 = self.qmc.temp2[self.qmc.timeindex[2]] - BTdrycross
            if finishphasetime:
                rc3 = ((self.qmc.temp2[self.qmc.timeindex[6]]- self.qmc.temp2[self.qmc.timeindex[2]])/finishphasetime)*60.
                dt3 = self.qmc.temp2[self.qmc.timeindex[6]]- self.qmc.temp2[self.qmc.timeindex[2]]
        return (rc1,rc2,rc3,dt1,dt2,dt3)

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewErrorLog(self,_=False):
        if self.error_dlg is None:
            self.error_dlg = errorDlg(self,self)
            self.error_dlg.setModal(False)
            self.error_dlg.show()
        self.error_dlg.raise_()
        self.error_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewSerialLog(self,_=False):
        if self.serial_dlg is None:
            self.serial_dlg = serialLogDlg(self,self)
            self.serial_dlg.setModal(False)
            self.serial_dlg.show()
        self.serial_dlg.raise_()
        self.serial_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewplatform(self,_=False):
        from artisanlib.platformdlg import platformDlg
        platformDLG = platformDlg(self,self)
        platformDLG.setModal(False)
        platformDLG.show()
        platformDLG.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewMessageLog(self,_=False):
        if self.message_dlg is None:
            self.message_dlg = messageDlg(self, self)
            self.message_dlg.setModal(False)
            self.message_dlg.show()
        self.message_dlg.raise_()
        self.message_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def helpAbout(self,_=False):
        coredevelopers = '<br>Rafael Cobo, Marko Luther, &amp; Dave Baxter'
        contribs = ['<br>' + uchr(199) + 'etin Barut, Marcio Carnerio, Bradley Collins, ',
                    'Sebastien Delgrande, Kalle Deligeorgakis, Jim Gall, ',
                    'Frans Goddijn, Rich Helms, Kyle Iseminger, Ingo, ',
                    'Savvas Kiretsis, Lukas Kolbe, David Lahoz, ',
                    'Runar Ostnes, Carlos Pascual, Claudia Raddatz, ',
                    'Matthew Sewell, Bertrand Souville, Minoru Yoshida, ',
                    "Wa'il, Alex Fan, Piet Dijk, Rubens Gardelli, ",
                    'David Trebilcock, Zolt' + uchr(225) + 'n Kis, Miroslav Stankovic, ',
                    'Barrie Fairley, Ziv Sade, Nicholas Seckar, ',
                    'Morten M' + uchr(252) + 'nchow',
                    ', Andrzej Kie' + uchr(322) + 'basi' + uchr(324) + 'ski, Marco Cremonese, Josef Gander',
                    ', Paolo Scimone, Google, eightbit11, Phidgets, Hottop, Yoctopuce, Taras Prokopyuk',
                    ', Reiss Gunson (Londinium), Ram Evgi (Coffee-Tech), Rob Gardner, Jaroslav Tu' + uchr(269) + 'ek (doubleshot)',
                    ', Nick Watson, Azis Nawawi, Rit Multi, Joongbae Dave Cho (the Chambers), Probat, Andreas Bader, Dario Ernst',
                    ', Nicolas (Marvell Street Coffee Roasters), Randy (Buckeye Coffee), Moshe Spinell',
                    ', Morris Beume (Morris.Coffee), Michael Herbert, Bill (San Franciscan Roaster), Chistopher Feran',
                    ', Coffed, Bono Gargolov, Rodrigo Ramos (King Caf' + uchr(233) + 's), Nico Bigler, Saeed Abdinasab, Lewis Li',
                    ', Fotis Lefas (Coffee Lovers, Editors & Trainers), Leo Huang (Rainforest Coffee Institute)<br>'
                    ]
        contributors = ''.join(contribs)
        box = QMessageBox(self)

        #create a html QString
        from scipy import __version__ as SCIPY_VERSION_STR # @UnresolvedImport
        from pymodbus import __version__ as PYMODBUS_VERSION_STR
        build = ''
        if __build__ != '0':
            build = ' build ' + __build__
        name = (application_viewer_name if app.artisanviewerMode else application_name)
        otherlibs = ''
        try:
            from Phidget22.Phidget import Phidget as PhidgetDriver
            phidgetlibversion = PhidgetDriver.getLibraryVersion()
            otherlibs += ', ' + phidgetlibversion
        except Exception as e: # pylint: disable=broad-except
            _log.debug(e)
        try:
            from Phidget22 import __version__ as phidget_lib_version # @UnresolvedImport
            otherlibs += f' ({phidget_lib_version})'
        except Exception: # pylint: disable=broad-except
            pass
        try:
            yocto_version = YAPI.GetAPIVersion()
            otherlibs += ', Yoctopuce ' + yocto_version
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        box.about(self,
                QApplication.translate('About', 'About'),
                """<h2>{0} {1}{16} ({2})</h2>
                <p>
                <small>Python {3}, Qt {4}, PyQt {5}, Matplotlib {6}, NumPy {7}, SciPy {8}, pymodbus {13}{17}</small>
                </p>
                <p>{18}</p>
                <p><b>{9}</b><small>{10}</small></p>
                <p><b>{11}</b><small>{12}</small></p>
                <p><b>{14}</b><br><small>{15}</small></p>
                """.format(
                name,
                str(__version__),
                str(__revision__),
                platform.python_version(),
                qVersion(),
                PYQT_VERSION_STR,
                mpl.__version__,
                numpy.__version__,
                SCIPY_VERSION_STR,
                QApplication.translate('About', 'Core Developers'),
                coredevelopers,
                QApplication.translate('About', 'Contributors'),
                contributors,
                PYMODBUS_VERSION_STR,
                QApplication.translate('About', 'License'),
                '<a href="http://www.gnu.org/copyleft/gpl.html">GNU Public Licence (GPLv3.0)</a>',
                build,
                otherlibs,
                '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def showAboutQt(self, _=False): # pylint: disable=no-self-use # used as slot
        QApplication.instance().aboutQt()

    @pyqtSlot()
    @pyqtSlot(bool)
    def helpHelp(self, _=False):  # pylint: disable=no-self-use # used as slot
        QDesktopServices.openUrl(QUrl('https://artisan-scope.org/help/', QUrl.ParsingMode.TolerantMode))

    @pyqtSlot()
    @pyqtSlot(bool)
    def checkUpdate(self, _=False):
        try:
            update_url = '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'
            import requests
            r = requests.get('https://api.github.com/repos/artisan-roaster-scope/artisan/releases/latest', timeout=(2,4))
            tag_name = r.json()['tag_name']
            latest = re.search(r'[\d\.]+',tag_name).group(0)
            if latest > __version__:
                update_str = QApplication.translate('About', 'A new release is available.')
                update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/blob/master/wiki/ReleaseHistory.md">'
                update_str +=  QApplication.translate('About', 'Show Change list')
                update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/releases/tag/' + str(tag_name) + '">'
                update_str +=  QApplication.translate('About', 'Download Release') + ' ' + str(tag_name)
            elif latest == __version__ :
                update_str = QApplication.translate('About', 'You are using the latest release.')
            elif latest < __version__:
                update_str = QApplication.translate('About', 'You are using a beta continuous build.')
                update_str += '<br/><br/>' + QApplication.translate('About', 'You will see a notice here once a new official release is available.')
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' checkUpdate() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            update_str = QApplication.translate('About', 'There was a problem retrieving the latest version information.  Please check your Internet connection, try again later, or check manually.')

        box = QMessageBox(self)
        box.about(self,
                QApplication.translate('About', 'Update status'),
                f"""<p>{update_str}</p>{update_url}""")

    def applicationscreenshot(self):
        imag = self.grab()
        fmt = 'png'
        initialPath = QDir.currentPath() + '/ArtisanScreenshot.' + fmt
        fileName = QFileDialog.getSaveFileName(self, 'Artisan ScreenShot',
                initialPath,
                '%s Files (*.%s);;All Files (*)'%(fmt.upper(),fmt))[0]
        if fileName:
            imag.save(fileName, fmt)

    def desktopscreenshot(self):
        screen = QApplication.primaryScreen()
        imag = screen.grabWindow(QApplication.desktop().winId())
        fmt = 'png'
        initialPath = QDir.currentPath() + '/DesktopScreenshot.' + fmt
        fileName = QFileDialog.getSaveFileName(self, 'Desktop ScreenShot',
                initialPath,
                '%s Files (*.%s);;All Files (*)'%(fmt.upper(),fmt))[0]
        if fileName:
            imag.save(fileName, fmt)

    @pyqtSlot()
    @pyqtSlot(bool)
    def calibratedelay(self,_=False):
        from artisanlib.sampling import SamplingDlg
        samplingDl = SamplingDlg(self,self)
        samplingDl.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def setcommport(self,_=False):
        from artisanlib.ports import comportDlg
        dialog = comportDlg(self,self)
        if dialog.exec():
            # set serial port
            self.ser.comport = str(dialog.comportEdit.getSelection())
            self.ser.baudrate = int(str(dialog.baudrateComboBox.currentText()))              #int changes QString to int
            self.ser.bytesize = int(str(dialog.bytesizeComboBox.currentText()))
            self.ser.stopbits = int(str(dialog.stopbitsComboBox.currentText()))
            self.ser.parity = str(dialog.parityComboBox.currentText())
            self.ser.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.timeoutEdit.text()))))
            # set modbus port
            self.modbus.comport = str(dialog.modbus_comportEdit.getSelection())
            self.modbus.baudrate = int(str(dialog.modbus_baudrateComboBox.currentText()))              #int changes QString to int
            self.modbus.bytesize = int(str(dialog.modbus_bytesizeComboBox.currentText()))
            self.modbus.stopbits = int(str(dialog.modbus_stopbitsComboBox.currentText()))
            self.modbus.parity = str(dialog.modbus_parityComboBox.currentText())
            self.modbus.timeout = aw.float2float(toFloat(str(dialog.modbus_timeoutEdit.text())))
            try:
                self.modbus.modbus_serial_extra_read_delay = toInt(dialog.modbus_Serial_delayEdit.text()) / 1000
            except Exception: # pylint: disable=broad-except
                pass
            self.modbus.serial_readRetries = dialog.modbus_Serial_retriesComboBox.currentIndex()
            try:
                self.modbus.IP_timeout = aw.float2float(toFloat(str(dialog.modbus_IP_timeoutEdit.text())))
            except Exception: # pylint: disable=broad-except
                pass
            self.modbus.IP_retries = dialog.modbus_IP_retriesComboBox.currentIndex()
            self.modbus.PID_slave_ID = int(str(dialog.modbus_PIDslave_Edit.text()))
            self.modbus.PID_SV_register = int(str(dialog.modbus_SVregister_Edit.text()))
            self.modbus.PID_p_register = int(str(dialog.modbus_Pregister_Edit.text()))
            self.modbus.PID_i_register = int(str(dialog.modbus_Iregister_Edit.text()))
            self.modbus.PID_d_register = int(str(dialog.modbus_Dregister_Edit.text()))
            self.modbus.PID_OFF_action = s2a(toString(dialog.modbus_pid_off.text()))
            self.modbus.PID_ON_action = s2a(toString(dialog.modbus_pid_on.text()))

            for i in range(aw.modbus.channels):
                self.modbus.inputSlaves[i] = int(str(dialog.modbus_inputSlaveEdits[i].text()))
                self.modbus.inputRegisters[i] = int(str(dialog.modbus_inputRegisterEdits[i].text()))
                self.modbus.inputCodes[i] = int(str(dialog.modbus_inputCodes[i].currentText()))
                self.modbus.inputDivs[i] = dialog.modbus_inputDivs[i].currentIndex()
                self.modbus.inputModes[i] = str(dialog.modbus_inputModes[i].currentText())
                if dialog.modbus_inputDecodes[i].currentIndex() == 4:
                    self.modbus.inputBCDsAsInt[i] = True
                    self.modbus.inputFloatsAsInt[i] = False
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = False
                elif dialog.modbus_inputDecodes[i].currentIndex() == 1:
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = True
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = False
                elif dialog.modbus_inputDecodes[i].currentIndex() == 6:
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = False
                    self.modbus.inputFloats[i] = True
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = False
                elif dialog.modbus_inputDecodes[i].currentIndex() == 5:
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = False
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = True
                    self.modbus.inputSigned[i] = False
                elif dialog.modbus_inputDecodes[i].currentIndex() == 2:
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = False
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = True
                elif dialog.modbus_inputDecodes[i].currentIndex() == 3:
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = True
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = True
                else: # index 0
                    self.modbus.inputBCDsAsInt[i] = False
                    self.modbus.inputFloatsAsInt[i] = False
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    self.modbus.inputSigned[i] = False

            self.modbus.SVmultiplier = dialog.modbus_SVmultiplier.currentIndex()
            self.modbus.PIDmultiplier = dialog.modbus_PIDmultiplier.currentIndex()
            self.modbus.byteorderLittle = bool(dialog.modbus_littleEndianBytes.isChecked())
            self.modbus.wordorderLittle = bool(dialog.modbus_littleEndianWords.isChecked())
            self.modbus.optimizer = bool(dialog.modbus_optimize.isChecked())
            self.modbus.fetch_max_blocks = bool(dialog.modbus_full_block.isChecked())
            self.modbus.reset_socket = bool(dialog.modbus_reset.isChecked())
            self.modbus.type = int(dialog.modbus_type.currentIndex())
            self.modbus.host = str(dialog.modbus_hostEdit.text())
            try:
                self.modbus.port = int(str(dialog.modbus_portEdit.text()))
            except Exception: # pylint: disable=broad-except
                pass

            # WebSocket Setup
            self.ws.host = str(dialog.ws_hostEdit.text()).strip()
            self.ws.port = int(str(dialog.ws_portEdit.text()))
            self.ws.path = str(dialog.ws_pathEdit.text()).strip()
            self.ws.machineID = int(str(dialog.ws_machineIDEdit.text()))
            self.ws.connect_timeout = float(dialog.ws_connect_timeout.value())
            self.ws.reconnect_interval = float(dialog.ws_reconnect_timeout.value())
            self.ws.request_timeout = float(dialog.ws_request_timeout.value())
            self.ws.id_node = str(dialog.ws_messageID.text()).strip()
            self.ws.machine_node = str(dialog.ws_machineID.text()).strip()
            self.ws.command_node = str(dialog.ws_command.text()).strip()
            self.ws.data_node = str(dialog.ws_data.text()).strip()
            self.ws.pushMessage_node = str(dialog.ws_message.text())
            self.ws.request_data_command = str(dialog.ws_data_request.text()).strip()
            self.ws.charge_message = str(dialog.ws_charge.text()).strip()
            self.ws.drop_message = str(dialog.ws_drop.text()).strip()
            self.ws.STARTonCHARGE = bool(dialog.ws_STARTonCHARGE.isChecked())
            self.ws.OFFonDROP = bool(dialog.ws_OFFonDROP.isChecked())
            self.ws.addEvent_message = str(dialog.ws_event_message.text()).strip()
            self.ws.event_node = str(dialog.ws_event.text()).strip()
            self.ws.DRY_node = str(dialog.ws_DRY.text()).strip()
            self.ws.FCs_node = str(dialog.ws_FCs.text()).strip()
            self.ws.FCe_node = str(dialog.ws_FCe.text()).strip()
            self.ws.SCs_node = str(dialog.ws_SCs.text()).strip()
            self.ws.SCe_node = str(dialog.ws_SCe.text()).strip()

            for i in range(self.ws.channels):
                self.ws.channel_requests[i] = str(dialog.ws_requestEdits[i].text()).strip()
                self.ws.channel_nodes[i] = str(dialog.ws_nodeEdits[i].text()).strip()
                self.ws.channel_modes[i] = int(dialog.ws_modeCombos[i].currentIndex())

            # S7 Setup
            self.s7.host = str(dialog.s7_hostEdit.text())
            self.s7.port = int(str(dialog.s7_portEdit.text()))
            self.s7.rack = int(str(dialog.s7_rackEdit.text()))
            self.s7.slot = int(str(dialog.s7_slotEdit.text()))
            for i in range(self.s7.channels):
                self.s7.area[i] = dialog.s7_areaCombos[i].currentIndex()
                self.s7.db_nr[i] = int(str(dialog.s7_dbEdits[i].text()))
                self.s7.start[i] = int(str(dialog.s7_startEdits[i].text()))
                self.s7.type[i] = dialog.s7_typeCombos[i].currentIndex()
                self.s7.div[i] = dialog.s7_divCombos[i].currentIndex()
                self.s7.mode[i] = dialog.s7_modeCombos[i].currentIndex()
            self.s7.PID_area = dialog.s7_PIDarea.currentIndex()
            self.s7.PID_db_nr = int(str(dialog.s7_PIDdb_nr_Edit.text()))
            self.s7.PID_SV_register = int(str(dialog.s7_SVregister_Edit.text()))
            self.s7.SVmultiplier = dialog.s7_SVmultiplier.currentIndex()
            self.s7.SVtype = dialog.s7_SVtype.currentIndex()
            self.s7.PIDmultiplier = dialog.s7_PIDmultiplier.currentIndex()
            self.s7.PID_p_register = int(str(dialog.s7_Pregister_Edit.text()))
            self.s7.PID_i_register = int(str(dialog.s7_Iregister_Edit.text()))
            self.s7.PID_d_register = int(str(dialog.s7_Dregister_Edit.text()))
            self.s7.PID_OFF_action = s2a(toString(dialog.s7_pid_off.text()))
            self.s7.PID_ON_action = s2a(toString(dialog.s7_pid_on.text()))
            self.s7.optimizer = bool(dialog.s7_optimize.isChecked())
            self.s7.fetch_max_blocks = bool(dialog.s7_full_block.isChecked())

            # set scale port
            self.scale.device = str(dialog.scale_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.scale.comport = str(dialog.scale_comportEdit.getSelection())
            self.scale.baudrate = int(str(dialog.scale_baudrateComboBox.currentText()))              #int changes QString to int
            self.scale.bytesize = int(str(dialog.scale_bytesizeComboBox.currentText()))
            self.scale.stopbits = int(str(dialog.scale_stopbitsComboBox.currentText()))
            self.scale.parity = str(dialog.scale_parityComboBox.currentText())
            self.scale.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.scale_timeoutEdit.text()))))
            # set color port
            self.color.device = str(dialog.color_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.color.comport = str(dialog.color_comportEdit.getSelection())
            self.color.baudrate = int(str(dialog.color_baudrateComboBox.currentText()))              #int changes QString to int
            self.color.bytesize = int(str(dialog.color_bytesizeComboBox.currentText()))
            self.color.stopbits = int(str(dialog.color_stopbitsComboBox.currentText()))
            self.color.parity = str(dialog.color_parityComboBox.currentText())
            self.color.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.color_timeoutEdit.text()))))
        # deleteLater() will not work here as the dialog is still bound via the parent
        dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
        # the following will immediately release the memory despite this parent link
        QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
        try:
            sip.delete(dialog)
            #print(sip.isdeleted(dialog))
        except Exception: # pylint: disable=broad-except
            pass
        self.closeEventSettings() # save all app settings

    def toggleHottopControl(self):
        if self.HottopControlActive:
            self.HottopControlOff()
        else:
            self.HottopControlOn()

    def HottopControlOff(self):
        from artisanlib.hottop import releaseHottopControl
        res = releaseHottopControl()
        if res:
            if self.HottopControlActive:
                aw.sendmessage(QApplication.translate('Message','Hottop control turned off'))
            self.HottopControlActive = False
            aw.buttonCONTROL.setStyleSheet(aw.pushbuttonstyles['PID'])

    def HottopControlOn(self):
        if aw.superusermode: # Hottop control mode can for now activated only in super user mode
            from artisanlib.hottop import isHottopLoopRunning
            if not isHottopLoopRunning():
                from artisanlib.hottop import startHottop
                startHottop(0.6,aw.ser.comport,aw.ser.baudrate,aw.ser.bytesize,aw.ser.parity,aw.ser.stopbits,aw.ser.timeout)
            from artisanlib.hottop import takeHottopControl
            res = takeHottopControl()
            if res:
                from artisanlib.hottop import setHottop
                setHottop(drum_motor=True)
                aw.buttonCONTROL.setStyleSheet(aw.pushbuttonstyles['PIDactive'])
                if not self.HottopControlActive:
                    aw.sendmessage(QApplication.translate('Message','Hottop control turned on'))
                self.HottopControlActive = True
        else:
            QMessageBox.warning(aw,QApplication.translate('Message', 'Warning'),QApplication.translate('Message',
                'To control a Hottop you need to activate the super user mode via a right click on the timer LCD first!'))

    @pyqtSlot(bool)
    def PIDcontrol(self,_=False):
        #FUJI/DELTA pid
        if self.qmc.device in (0, 26):
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier and self.qmc.device == 0:
                # a right-click on the Control button will toggle PID Standby on and off
                standby = aw.fujipid.getONOFFstandby()
                if standby == 0:
                    # standby is off (=0), turn it on (=1)
                    aw.fujipid.setONOFFstandby(1)
                    aw.sendmessage(QApplication.translate('Message','PID set to OFF'))
                elif standby == 1:
                    # standby is on (=1), turn it off (=0)
                    aw.fujipid.setONOFFstandby(0)
                    aw.sendmessage(QApplication.translate('Message','PID set to ON'))
            else:
                if self.ser.controlETpid[0] == 0:
                    dialog = PXG4pidDlgControl(self,self)
                elif self.ser.controlETpid[0] == 1:
                    dialog = PXRpidDlgControl(self,self)
                elif self.ser.controlETpid[0] == 2:
                    dialog = DTApidDlgControl(self,self)
                elif self.ser.controlETpid[0] == 4: # Fuji PXF
                    dialog = PXG4pidDlgControl(self,self)
                #modeless style dialog
                dialog.setModal(False)
                dialog.show()
                dialog.setFixedSize(dialog.size())
                QApplication.processEvents()
        # Hottop
        elif self.qmc.device == 53:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier:
                dialog = PID_DlgControl(self,self,self.PID_DlgControl_activeTab)
                #modeless style dialog
                dialog.show()
            else:
                #self.pidcontrol.togglePID()
                self.toggleHottopControl()
        # all other devices
        else:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier:
                self.pidcontrol.togglePID()
            else:
                dialog = PID_DlgControl(self,self,self.PID_DlgControl_activeTab)
                #modeless style dialog
                dialog.show()
#                dialog.setFixedSize(dialog.size())  # this badly interacts with keeping the window geometry in qsettings


    @pyqtSlot()
    @pyqtSlot(bool)
    def deviceassigment(self,_=False):
        from artisanlib.devices import DeviceAssignmentDlg
        dialog = DeviceAssignmentDlg(self,self,self.DeviceAssignmentDlg_activeTab)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def showstatistics(self,_=False):
        from artisanlib.statistics import StatisticsDlg
        dialog = StatisticsDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def Windowconfig(self,_=False):
        from artisanlib.axis import WindowsDlg
        dialog = WindowsDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def autosaveconf(self,_=False):
        from artisanlib.autosave import autosaveDlg
        dialog = autosaveDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def batchconf(self,_=False):
        from artisanlib.batches import batchDlg
        dialog = batchDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def calculator(self,_=False):
        from artisanlib.calculator import calculatorDlg
        dialog = calculatorDlg(self,self)
        dialog.setModal(False)
        dialog.show()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def loadSettings_triggered(self,_=False):
        _log.info('menu load settings')
        self.loadSettings()

    def loadSettings(self,fn=None,remember=True,reset=True,machine=False,theme=False,reload=True):
        try:
            if fn:
                filename = fn
            else:
                filename = self.ArtisanOpenFileDialog()
            if filename:
                try:
                    aw.stopActivities()
                    saveCurfile = aw.curFile
                    res = aw.settingsLoad(filename,machine=machine,theme=theme)
                    if res and reset:
                        flag_temp = aw.qmc.roastpropertiesflag
                        aw.qmc.roastpropertiesflag = 1 # ensure that all roast properties are reset!
                        aw.qmc.reset(soundOn=False,fireResetAction=False)
                        aw.qmc.roastpropertiesflag = flag_temp
                        if reload and saveCurfile is not None:
                            aw.loadFile(saveCurfile)
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                        self.sendmessage(QApplication.translate('Message',f'Settings loaded {aw.strippedName(filename)}'))
                    else:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentSettingList'))
                    try:
                        removeAll(files,filename)
                    except ValueError:
                        pass
                    settings.setValue('recentSettingList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentSettingActions()
            else:
                self.sendmessage(QApplication.translate('Message','Cancelled'))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadSettings() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def updateRecentSettingActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentSettingList'))
        strippedNames = list(map(self.strippedName,files))
        numRecentSettings = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentSettings):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = '&%s' % strippedName
            self.recentSettingActs[i].setText(text)
            self.recentSettingActs[i].setData(files[i])
            self.recentSettingActs[i].setVisible(True)

        for j in range(numRecentSettings, self.MaxRecentFiles):
            self.recentSettingActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentSetting(self, _checked:bool = False):
        action = self.sender()
        if action:
            fname = toString(action.data())
            if os.path.isfile(fname):
                _log.info('menu load recent settings: %s',fname)
                self.loadSettings(fn=fname)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentSettingList'))
                try:
                    removeAll(files,fname)
                except ValueError:
                    pass
                settings.setValue('recentSettingList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentSettingActions()
                self.sendmessage(QApplication.translate('Message','Settings not found'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveSettings(self,_=False):
        path = QDir()
        path.setPath(self.getDefaultPath())
        fname = path.absoluteFilePath(QApplication.translate('Message','artisan-settings'))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Settings'), path=fname, ext='*.aset')
        if filename:
            aw.settingspath = filename
            aw.closeEventSettings(filename)

            self.sendmessage(QApplication.translate('Message','Settings saved'))
            # update recentSettings menu
            settings = QSettings()
            files = toStringList(settings.value('recentSettingList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            files.insert(0, filename)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentSettingList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentSettingActions()
        else:
            self.sendmessage(QApplication.translate('Message','Cancelled'))

    def updateRecentThemeActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentThemeList'))
        files.sort()
        strippedNames = list(map(self.strippedName,files))
        numRecentThemes = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentThemes):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = '&%s' % strippedName
            self.recentThemeActs[i].setText(text)
            self.recentThemeActs[i].setData(files[i])
            self.recentThemeActs[i].setVisible(True)

        for j in range(numRecentThemes, self.MaxRecentFiles):
            self.recentThemeActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentTheme(self, _checked:bool = False):
        action = self.sender()
        if action:
            fname = toString(action.data())
            if os.path.isfile(fname):
                self.loadSettings_theme(fn=fname)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentThemeList'))
                try:
                    removeAll(files,fname)
                except ValueError:
                    pass
                settings.setValue('recentThemeList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentThemeActions()
                self.sendmessage(QApplication.translate('Message','Settings not found'))

    @pyqtSlot(bool)
    def saveSettings_theme(self,_=False):
        path = QDir()
        path.setPath(self.getDefaultPath())
        path.setPath(os.path.join(getResourcePath(),'Themes','User'))
        fname = path.absoluteFilePath(QApplication.translate('Message','artisan-theme'))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Theme'), path=fname, ext='*.athm')
        if filename:
            aw.closeEventSettings_theme(filename)
            self.sendmessage(QApplication.translate('Message','Theme saved'))
            # update recentTheme menu
            settings = QSettings()
            files = toStringList(settings.value('recentThemeList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            files.insert(0, filename)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentThemeList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentThemeActions()
            self.themeMenu.clear()
            self.populateThemeMenu()
        else:
            self.sendmessage(QApplication.translate('Message','Cancelled'))

    @pyqtSlot(bool)
    def loadSettings_theme_Slot(self,_=False):
        self.loadSettings_theme()

    def loadSettings_theme(self,fn=None,remember=True,reset=False):
        try:
            if fn:
                filename = fn
            else:
                filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Theme'),ext='*.athm')
            if filename:
                string = QApplication.translate('Message', 'Load theme {0}?').format(os.path.basename(filename))
                reply = QMessageBox.question(aw,QApplication.translate('Message', 'Adjust Theme Related Settings'),string,
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                try:
                    res = aw.settingsLoad(filename,theme=True)
                    self.sendmessage(QApplication.translate('Message','Loaded theme {0}').format(filename))
                    if reset:
                        aw.qmc.reset(soundOn=False)
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                                self.sendmessage(QApplication.translate('Message','Theme loaded'))
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                    else:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentThemeList'))
                    try:
                        removeAll(files,filename)
                    except ValueError:
                        pass
                    settings.setValue('recentThemeList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentThemeActions()
                    self.themeMenu.clear()
                    self.populateThemeMenu()
            else:
                self.sendmessage(QApplication.translate('Message','Cancelled'))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadSettings_theme() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))


    @pyqtSlot()
    @pyqtSlot(bool)
    def largeLCDs(self,_=False):
        if self.largeLCDs_dialog is None:
            self.largeLCDs_dialog = LargeMainLCDs(self,self)
            self.largeLCDs_dialog.setModal(False)
            self.LargeLCDsFlag = True
            self.lcdsAction.setChecked(True)
            self.largeLCDs_dialog.show()
        else:
            self.largeLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeDeltaLCDs(self,_=False):
        if self.largeDeltaLCDs_dialog is None:
            self.largeDeltaLCDs_dialog = LargeDeltaLCDs(self,self)
            self.largeDeltaLCDs_dialog.setModal(False)
            self.LargeDeltaLCDsFlag = True
            self.deltalcdsAction.setChecked(True)
            self.largeDeltaLCDs_dialog.show()
        else:
            self.largeDeltaLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePIDLCDs(self,_=False):
        if self.largePIDLCDs_dialog is None:
            self.largePIDLCDs_dialog = LargePIDLCDs(self,self)
            self.largePIDLCDs_dialog.setModal(False)
            self.LargePIDLCDsFlag = True
            self.pidlcdsAction.setChecked(True)
            self.largePIDLCDs_dialog.show()
        else:
            self.largePIDLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeScaleLCDs(self,_=False):
        if self.largeScaleLCDs_dialog is None:
            self.largeScaleLCDs_dialog = LargeScaleLCDs(self,self)
            self.largeScaleLCDs_dialog.setModal(False)
            self.LargeScaleLCDsFlag = True
            self.scalelcdsAction.setChecked(True)
            self.largeScaleLCDs_dialog.show()
        else:
            self.largeScaleLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeExtraLCDs(self,_=False):
        if self.largeExtraLCDs_dialog is None:
            self.largeExtraLCDs_dialog = LargeExtraLCDs(self,self)
            self.largeExtraLCDs_dialog.setModal(False)
            self.LargeExtraLCDsFlag = True
            self.extralcdsAction.setChecked(True)
            self.largeExtraLCDs_dialog.show()
        else:
            self.largeExtraLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePhasesLCDs(self,_=False):
        if self.largePhasesLCDs_dialog is None:
            self.largePhasesLCDs_dialog = LargePhasesLCDs(self,self)
            self.largePhasesLCDs_dialog.setModal(False)
            self.LargePhasesLCDsFlag = True
            self.phaseslcdsAction.setChecked(True)
            self.updatePhasesLCDs()
            self.largePhasesLCDs_dialog.show()
        else:
            self.largePhasesLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def graphwheel(self,_=False):
        if self.qmc.designerflag:
            self.stopdesigner()
        if self.wheeldialog is None:
            # remove the standard fig axis to trigger their recreation
            self.qmc.ax = None
            self.qmc.delta_ax = None
            from artisanlib.wheels import WheelDlg
            self.wheeldialog = WheelDlg(self,self)
        if self.qmc.wheelflag:
            aw.redrawOnResize = True
            self.qmc.exitviewmode()
            aw.enableEditMenus()
            aw.showControls()
            aw.updateReadingsLCDsVisibility()
            aw.updateSlidersVisibility()
            aw.update_minieventline_visibility()
            aw.updateExtraButtonsVisibility()
        else:
            aw.redrawOnResize = False
            aw.hideControls()
            aw.hideLCDs(False)
            aw.hideSliders(False)
            aw.hide_minieventline(False)
            aw.hideExtraButtons()
            aw.disableEditMenus(wheel=True)
            aw.qmc.connectWheel()
            if aw.wheelpath and aw.wheelpath != '':
                try:
                    aw.loadWheel(aw.wheelpath)
                    self.wheeldialog.createdatatable()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    aw.settingspath = ''
            aw.qmc.drawWheel()

    @pyqtSlot()
    @pyqtSlot(bool)
    def background(self,_=False):
        from artisanlib.background import backgroundDlg
        dialog = backgroundDlg(self,self,self.backgroundDlg_activeTab)
        dialog.show()

    def deleteBackground(self):
        self.qmc.background = False
        self.qmc.backgroundprofile = None
        self.qmc.backgroundprofile_moved_x = 0
        self.qmc.backgroundprofile_moved_y = 0
        self.qmc.backgroundpath = ''
        self.qmc.backgroundUUID = None
        self.qmc.titleB = ''
        self.qmc.roastbatchnrB = 0
        self.qmc.roastbatchprefixB = ''
        self.qmc.roastbatchposB = 1
        self.qmc.temp1B, self.qmc.temp2B, self.qmc.temp1BX, self.qmc.temp2BX, self.qmc.timeB = [],[],[],[],[]
        self.qmc.stemp1B,self.qmc.stemp2B,self.qmc.stemp1BX,self.qmc.stemp2BX = [],[],[],[] # smoothed versions of the background courves
        self.qmc.extraname1B,self.qmc.extraname2B = [],[]
        self.qmc.backgroundEvents, self.qmc.backgroundEtypes = [],[]
        self.qmc.backgroundEvalues, self.qmc.backgroundEStrings,self.qmc.backgroundFlavors = [],[],[]
        self.qmc.timeindexB = [-1,0,0,0,0,0,0,0]
        self.qmc.backmoveflag = 1
        self.qmc.TP_time_B_loaded = None
        self.qmc.AUCbackground = -1
        self.qmc.l_background_annotations = []
        self.qmc.analysisresultsstr = ''
        self.qmc.resetlinecountcaches()
        self.qmc.deleteAnnoPositions(foreground=False, background=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def switchETBT(self, _=False): # pylint: disable=no-self-use # used as slot
        t2 = aw.qmc.temp2
        aw.qmc.temp2 = aw.qmc.temp1
        aw.qmc.temp1 = t2
        aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
        aw.qmc.fileDirtySignal.emit()

    @pyqtSlot()
    @pyqtSlot(bool)
    def switch(self,_=False):
        if aw.qmc.checkSaved() == False:
            return
        try:
            foreground_profile_path = aw.curFile
            background_profile_path = aw.qmc.backgroundpath
            background_deleted = False
            if background_profile_path:
            # load background into foreground
                aw.loadFile(background_profile_path)
            # if there is a plotter or analyzer generated background curve bring it to the foreground
            elif len(aw.qmc.temp1B) > 2:
                _timex  = aw.qmc.timeB[:]
                _temp1 = aw.qmc.temp1B[:]
                _temp2 = aw.qmc.temp2B[:]
                _sampling_interval = aw.qmc.profile_sampling_interval
                # use foreground events if the background has no CHARGE
                if aw.qmc.timeindexB[0] == -1:
                    _timeindex = aw.qmc.timeindex[:]
                else:
                    _timeindex = aw.qmc.timeindexB[:]
                # clear the background
                aw.deleteBackground()
                background_deleted = True

                flag_temp = aw.qmc.roastpropertiesflag
                aw.qmc.roastpropertiesflag = 1 # ensure that all roast properties are reset!
                aw.qmc.reset(soundOn=False)
                aw.qmc.roastpropertiesflag = flag_temp
                aw.qmc.timex = _timex[:]
                aw.qmc.temp1 = _temp1[:]
                aw.qmc.temp2 = _temp2[:]
                aw.qmc.timeindex = _timeindex[:]
                for x in range(len(aw.qmc.extradevices)):
                    aw.qmc.extratemp1[x] = [-1]*len(aw.qmc.timex)
                    aw.qmc.extratemp2[x] = [-1]*len(aw.qmc.timex)
                    aw.qmc.extratimex[x] = aw.qmc.timex[:]
                aw.qmc.profile_sampling_interval = _sampling_interval
                if not foreground_profile_path:
                    aw.qmc.redraw(recomputeAllDeltas=True)
                aw.qmc.fileDirtySignal.emit()
            else:
                # reset
                aw.qmc.reset(soundOn=False)
            if foreground_profile_path:
                # load foreground into background
                aw.loadbackground(foreground_profile_path)
                aw.qmc.background = not aw.qmc.hideBgafterprofileload
                aw.qmc.timealign(redraw=True,recompute=True)
            else:
                # delete background
                if not background_deleted:
                    self.deleteBackground()
            if foreground_profile_path or background_profile_path:
                aw.qmc.redraw(recomputeAllDeltas=True)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def flavorchart(self,_=False):
        self.redrawOnResize = False # disable the redraw triggered on resize (eg. by hiding widgets) that replaces the logo icon
        self.hideControls()
        self.hideLCDs(False)
        self.hideSliders(False)
        self.hideExtraButtons()
        from artisanlib.cup_profile import flavorDlg
        dialog = flavorDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def designerTriggered(self,_=False):
        if self.qmc.designerflag:
            self.stopdesigner()
        else:
            if aw.qmc.ai:
                try:
                    aw.qmc.ai.remove()
                except Exception: # pylint: disable=broad-except
                    pass
            self.startdesigner()

    def startdesigner(self):
        self.qmc.designer()
        self.hideLCDs(False)
        self.hideSliders(False)
        self.hide_minieventline(False)
        self.hideExtraButtons()

    def stopdesigner(self):
        aw.enableEditMenus()
        self.qmc.convert_designer()
        self.updateReadingsLCDsVisibility()
        self.updateSlidersVisibility()
        self.update_minieventline_visibility()
        self.updateExtraButtonsVisibility()

    @pyqtSlot()
    @pyqtSlot(bool)
    def editgraph(self,_=False):
        if self.editgraphdialog != False: # Roast Properties dialog is not blocked!
            from artisanlib.roast_properties import editGraphDlg
            self.editgraphdialog = editGraphDlg(self,self,self.editGraphDlg_activeTab)
            self.editgraphdialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def editphases(self,_=False):
        from artisanlib.phases import phasesGraphDlg
        dialog = phasesGraphDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def eventsconf(self,_=False):
        from artisanlib.events import EventsDlg
        dialog = EventsDlg(self,self,self.EventsDlg_activeTab)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def alarmconfig(self,_=False):
        if self.qmc.device != 18 or aw.simulator is not None:
            from artisanlib.alarms import AlarmDlg
            dialog = AlarmDlg(self,self,self.AlarmDlg_activeTab)
            dialog.show()
        else:
            QMessageBox.information(aw,QApplication.translate('Message', 'Alarm Config'),
                                    QApplication.translate('Message', 'Alarms are not available for device None'))

    def switchLanguageFlag(self,loc,value):
        try:
            self.language_menu_actions[loc].setChecked(value)
        except Exception as e:
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def change_local_action(self,_=False):
        sender_action = self.sender()
        new_locale = next((local for local, action in self.language_menu_actions.items() if sender_action == action), 'en')
        self.changelocale(new_locale)

    def changelocale(self,languagelocale):
        if self.locale_str != languagelocale:
            string = QApplication.translate('Message','Switching the language needs a restart. Restart now?')
            reply = QMessageBox.warning(aw,QApplication.translate('Message','Restart'),string,
                              QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.Yes)
            if reply == QMessageBox.StandardButton.Yes:
                # switch old flag off
                self.switchLanguageFlag(self.locale_str, False)
                # check if etypes are unmodified by user and in that case, remove etypes from settings to avoid overwriting of translations:
                # switch new flag on
                self.switchLanguageFlag(languagelocale,True)
                settings = QSettings()
                settings.setValue('locale', languagelocale)
                self.close()
            else:
                self.switchLanguageFlag(languagelocale,False)
        else:
            # if the current selected language is selected it got unflagged. Tick it again!
            self.switchLanguageFlag(self.locale_str, True)

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    @staticmethod
    def weight_loss(green, roasted):
        if float(green) == 0.0 or float(green) < float(roasted):
            return 0.
        return 100. * ((float(green) - float(roasted)) / float(green))

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    @staticmethod
    def volume_increase(green, roasted):
        if float(green) == 0.0 or float(green) > float(roasted):
            return 0.
        return 100. * ((float(roasted) - float(green)) / float(green))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK202(self,_=False):
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Import K202 CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    csvReader = csv.DictReader(csvFile,['Date','Time','T1','T1unit','T2','T2unit'],delimiter='\t')
                    zero_t = None
                    roastdate = None
                    unit = None
                    for item in csvReader:
                        try:
                            #set date
                            if not roastdate:
                                roastdate = QDateTime(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                                self.qmc.roastdate = roastdate
                                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                                self.qmc.roasttzoffset = 0
                            #set zero
                            if not zero_t:
                                date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                                zero = QDateTime()
                                zero.setDate(date)
                                zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                                zero_t = zero.toSecsSinceEpoch()
                            #set temperature mode
                            if not unit:
                                unit = item['T1unit']
                                if unit == 'F' and self.qmc.mode == 'C':
                                    self.qmc.fahrenheitMode()
                                if unit == 'C' and self.qmc.mode == 'F':
                                    self.qmc.celsiusMode()
                            #add one measurement
                            dt = QDateTime()
                            dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                            dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            self.qmc.timex.append(float(dt.toSecsSinceEpoch() - zero_t))
                            self.qmc.temp1.append(float(item['T1'].replace(',','.')))
                            self.qmc.temp2.append(float(item['T2'].replace(',','.')))
                        except ValueError:
                            pass
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message','K202 file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' importK202(): {0}').format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' importK202(): {0}').format(str(ex)))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importK202() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK204(self,_=False):
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Import K204 CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    csvReader = csv.DictReader(csvFile,['Date','Time','T1','T2','T3','T4'],delimiter='\t')
                    zero_t = None
                    roastdate = None
                    # we add an extra device if needed
                    if len(self.qmc.extradevices) == 0:
                        self.addDevice()
                    for item in csvReader:
                        try:
                            #set date
                            if not roastdate:
                                roastdate = QDateTime(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                                self.qmc.roastdate = roastdate
                                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                                self.qmc.roasttzoffset = 0
                            #set zero
                            if not zero_t:
                                date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                                zero = QDateTime()
                                zero.setDate(date)
                                zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                                zero_t = zero.toSecsSinceEpoch()
        # The K204 export does not contain a trace of the temperature mode.
        # We have to assume here that the mode was set correctly before the import.
                            #add one measurement
                            dt = QDateTime()
                            dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                            dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            tx = float(dt.toSecsSinceEpoch() - zero_t)
                            self.qmc.timex.append(tx)
                            t1 = float(item['T1'].replace(',','.'))
                            if t1 > 800 or t1 < 0.0:
                                t1 = 0.0
                            self.qmc.temp1.append(t1)
                            t2 = float(item['T2'].replace(',','.'))
                            if t2 > 800 or t2 < 0.0:
                                t2 = 0.0
                            self.qmc.temp2.append(t2)
                            if len(self.qmc.extradevices) > 0:
                                self.qmc.extratimex[0].append(tx)
                                t3 = float(item['T3'].replace(',','.'))
                                if t3 > 800 or t3 < 0.0:
                                    t3 = 0.0
                                self.qmc.extratemp1[0].append(t3)
                                t4 = float(item['T4'].replace(',','.'))
                                if t4 > 800 or t4 < 0.0:
                                    t2 = 0.0
                                self.qmc.extratemp2[0].append(t4)
                        except ValueError:
                            pass
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message','K204 file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' importK204(): {0}').format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' importK204(): {0}').format(str(ex)))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importK204() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # normalize xml tags and attributes to lower case
    def normalize_tags(self,root):
        root.tag = root.tag.lower()
        for child in root:
            self.normalize_tags(child)
    def normalize_attr(self,root):
        for attr,value in root.attrib.items():
            norm_attr = attr.lower()
            if norm_attr != attr:
                root.set(norm_attr,value)
                root.attrib.pop(attr)
        for child in root:
            self.normalize_attr(child)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importPilot(self,_=False):
        try:
            import xml.etree.ElementTree as ET
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Import Probat Recipe'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                tree = ET.ElementTree(file=filename)
                root = tree.getroot()
                self.normalize_tags(root) # normalize tags to lower case
                self.normalize_attr(root) # normalize attributes to lower case

                if root.tag == 'history':
                    date = root.find('historydate')
                    time = root.find('historytime')
                    if date is not None and time is not None:
                        aw.qmc.roastdate = QDateTime(QDate.fromString(date.text,'M/d/yyyy'),QTime.fromString(time.text,'h:mm AP'))

                title = root.find('roasttype')
                if title is None:
                    aw.qmc.title = str(os.path.basename(filename))
                else:
                    aw.qmc.title = str(title.text)

                beans = root.find('coffeetype')
                if beans is not None:
                    if beans.text is not None:
                        aw.qmc.beans = str(beans.text)

                roaster = root.find('roaster')
                if roaster is not None:
                    if roaster.text is not None:
                        aw.qmc.roastertype = str(roaster.text)

                chargestr = root.find('charge')
                if chargestr is None:
                    chargestr = root.find('chargingcapacity')
                if chargestr is not None: # contains floating point number; default unit Kg
                    try:
                        aw.qmc.weight[0] = float(chargestr.text)
                        aw.qmc.weight[2] = 'Kg'
                    except Exception: # pylint: disable=broad-except
                        pass

                dischargestr = root.find('dischargingcapacity')
                if dischargestr is not None: # contains floating point number; default unit Kg
                    try:
                        aw.qmc.weight[1] = float(dischargestr.text)
                        aw.qmc.weight[2] = 'Kg'
                    except Exception: # pylint: disable=broad-except
                        pass

                colorstr = root.find('coffeecolor')
                if colorstr is not None:
                    c = None
                    if colorstr.text is not None:
                        for e in colorstr.text.strip().split():
                            try:
                                c = int(e)
                                break
                            except Exception: # pylint: disable=broad-except
                                pass
                    if c:
                        aw.qmc.ground_color = c

                notes = root.find('notes')
                if notes is not None:
                    if notes.text is not None:
                        self.qmc.roastingnotes = str(notes.text)

                recipedata = None
                historydata = None
                recipedata = tree.find('recipedata')
                if recipedata is not None:
                    m = recipedata.get('temp_unit')
                else:
                    m = tree.find('recipedata_temp_unit')
                    if m is not None:
                        m = m.text
                if m is None:
                    historydata = tree.find('historydata')
                    if historydata is not None:
                        m = historydata.get('temp_unit')
                    else:
                        m = tree.find('historydata_temp_unit')
                        if m is not None:
                            m = m.text
                if m is not None:
                    m = m.lower()
                    if m == 'c' and self.qmc.mode == 'F':
                        self.qmc.celsiusMode()
                    elif m == 'f' and self.qmc.mode == 'C':
                        self.qmc.fahrenheitMode()

                # add extra device if needed
                for _ in range(max(0,1 - len(self.qmc.extradevices))):
                    self.addDevice()
                if self.qmc.extraname1[0] == 'Extra 1':
                    self.qmc.extraname1[0] = 'Burner'

                diagrampoints = None
                if recipedata is not None:
                    diagrampoints = tree.find('recipedata/diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('historydata')
                last_timez = 0
                if diagrampoints is not None:
                    for elem in diagrampoints.findall('data'):
                        time_entry = elem.find('time')
                        if time_entry is None:
                            time_entry = elem.find('stime')
                        if time_entry is None or time_entry.text is None:
                            last_timez = last_timez + 1
                            timez = last_timez
                        else:
                            timez = float(stringtoseconds(time_entry.text))
                            last_timez = timez
                        self.qmc.timex.append(timez)
                        self.qmc.temp1.append(-1)
                        temp_entry = elem.find('temperature')
                        if temp_entry is None:
                            temp_entry = elem.find('ntemperature')
                        bt = temp_entry.text
                        bt = bt.replace(',','.')
                        self.qmc.temp2.append(float(bt))
                        self.qmc.extratimex[0].append(timez)
                        burner_entry = elem.find('burnercapacity')
                        if burner_entry is None:
                            burner_entry = elem.find('nburnercapacity')
                        burner = burner_entry.text
                        burner = burner.replace(',','.')
                        self.qmc.extratemp1[0].append(float(burner))
                        self.qmc.extratemp2[0].append(-1)

                if len(self.qmc.timex) > 2:
                    self.qmc.profile_sampling_interval = (self.qmc.timex[-1] - self.qmc.timex[0])/(len(self.qmc.timex) - 1)
                self.qmc.updateDeltaSamples()

                # set CHARGE and DROP
                self.qmc.timeindex[0] = 0
                self.qmc.timeindex[6] = max(0,len(self.qmc.timex) - 1)

                if recipedata is not None:
                    switchpoints = tree.find('recipedata/switchpoints')
                else:
                    switchpoints = tree.find('switchpoints')
                if switchpoints is not None:
                    for elem in switchpoints.findall('data'):
                        time_entry = elem.find('time')
                        if time_entry is None:
                            time_entry = elem.find('stime')
                        time = float(stringtoseconds(time_entry.text))
                        self.qmc.specialevents.append(self.qmc.time2index(time))
                        self.qmc.specialeventstype.append(3)
                        burner_entry = elem.find('burnercapacity')
                        if burner_entry is None:
                            burner_entry = elem.find('nburnercapacity')
                        self.qmc.specialeventsvalue.append(self.qmc.str2eventsvalue(burner_entry.text))
                        self.qmc.specialeventsStrings.append('')

                aw.autoAdjustAxis()

                self.sendmessage(QApplication.translate('Message','Probat Pilot data imported successfully'))
                self.qmc.redraw()
                aw.qmc.fileDirtySignal.emit()
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' importPilot(): {0}').format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' importPilot(): {0}').format(str(ex)))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.sendmessage(QApplication.translate('Message','Import Probat Pilot failed'))
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importPilot() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importBullet(self,_=False):
        try:
            from artisanlib.aillio import extractProfileRoasTime
            self.importExternal(extractProfileRoasTime,QApplication.translate('Message','Import Aillio RoasTime'),'*.json')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importBulletURL(self,_=False):
        try:
            from artisanlib.aillio import extractProfileRoastWorld
            self.importExternalURL(extractProfileRoastWorld, QApplication.translate('Message','Import Aillio Roast.World URL'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # url a QUrl
    def importExternalURL(self,extractor,message='',url=None):
        _log.info('importExternalURL(%s)', url)
        try:
            if url is None:
                url = self.ArtisanOpenURLDialog(msg=message)
            if url is None:
                return

            res = aw.qmc.reset(redraw=False,soundOn=False)
            if res:
                try:
                    obj = extractor(url,aw)
                    if obj:
                        res = self.setProfile(None,obj)
                    else:
                        res = None
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    res = None
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                # profiles was adjusted, ensure that it does not overwrite the original file on saving
                self.qmc.fileDirtySignal.emit()
                self.curFile = None
                # clear annotation cache
                self.qmc.l_annotations_dict = {}
                self.qmc.l_event_flags_dict = {}
                #Plot everything
                self.qmc.redraw()
                message = QApplication.translate('Message','{0} imported').format(url.toString())
                self.sendmessage(message)
            else:
                message = QApplication.translate('Message','an error occurred on importing {0}').format(url.toString())
                self.sendmessage(message)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' {1} {0}').format(str(ex),message),getattr(exc_tb, 'tb_lineno', '?'))

    def importExternal(self,extractor,message,extension):
        try:
            filename = self.ArtisanOpenFileDialog(msg=message,ext=extension)
            if len(filename) == 0:
                return
            res = aw.qmc.reset(redraw=False,soundOn=False)
            if res:
                obj = extractor(filename,aw)
                res = self.setProfile(filename,obj)

            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                # profiles was adjusted, ensure that it does not overwrite the original file on saving
                self.qmc.fileDirtySignal.emit()
                self.curFile = None
                # clear annotation cache
                self.qmc.l_annotations_dict = {}
                self.qmc.l_event_flags_dict = {}
                #Plot everything
                self.qmc.redraw()
                message = QApplication.translate('Message','{0} imported').format(filename)
                self.sendmessage(message)

        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' {1}: {0}').format(str(ex),message))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' {1}: {0}').format(str(ex),message))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' {1} {0}').format(str(ex),message),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importCropster(self,_=False):
        from artisanlib.cropster import extractProfileCropsterXLS
        self.importExternal(extractProfileCropsterXLS,QApplication.translate('Message','Import Cropster XLS'),'*.xls')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRoastLog(self,_=False):
        from artisanlib.roastlog import extractProfileRoastLog
        self.importExternalURL(extractProfileRoastLog,QApplication.translate('Message','Import RoastLog URL'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRoastPATH(self,_=False):
        from artisanlib.roastpath import extractProfileRoastPathHTML
        self.importExternalURL(extractProfileRoastPathHTML,QApplication.translate('Message','Import RoastPATH URL'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importGiesen(self,_=False):
        from artisanlib.giesen import extractProfileGiesenCSV
        self.importExternal(extractProfileGiesenCSV,QApplication.translate('Message','Import Giesen CSV'),'*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importPetroncini(self,_=False):
        from artisanlib.petroncini import extractProfilePetronciniCSV
        self.importExternal(extractProfilePetronciniCSV,QApplication.translate('Message','Import Petroncini CSV'),'*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importIkawa(self,_=False):
        from artisanlib.ikawa import extractProfileIkawaCSV
        self.importExternal(extractProfileIkawaCSV,QApplication.translate('Message','Import IKAWA CSV'),'*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importLoring(self,_=False):
        from artisanlib.loring import extractProfileLoringCSV
        self.importExternal(extractProfileLoringCSV,QApplication.translate('Message','Import Loring CSV'),'*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRubasse(self,_=False):
        from artisanlib.rubasse import extractProfileRubasseCSV
        self.importExternal(extractProfileRubasseCSV,QApplication.translate('Message','Import Rubasse CSV'),'*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importHH506RA(self,_=False):
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Import HH506RA CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    data = csv.reader(csvFile,delimiter='\t')
                    #read file header
                    header = next(data)
                    zero = QDateTime()
                    date = QDateTime(QDate.fromString(header[0].split('Date:')[1],"yyyy'/'MM'/'dd"))
                    self.qmc.roastdate = date
                    self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                    self.qmc.roasttzoffset = 0
                    zero.setDate(date)
                    zero.setTime(QTime.fromString(header[1].split('Time:')[1],"hh':'mm':'ss"))
                    zero_t = zero.toSecsSinceEpoch()
                    #read column headers
                    fields = next(data)
                    unit = None
                    #read data
                    for row in data:
                        items = list(zip(fields, row))
                        item = {}
                        for (name, value) in items:
                            item[name] = value.strip()
                        #set temperature mode
                        if not unit:
                            unit = item['Unit']
                            if unit == 'F' and self.qmc.mode == 'C':
                                self.qmc.fahrenheitMode()
                            if unit == 'C' and self.qmc.mode == 'F':
                                self.qmc.celsiusMode()
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"yyyy'/'MM'/'dd"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        self.qmc.timex.append(float(dt.toSecsSinceEpoch() - zero_t))
                        self.qmc.temp1.append(float(item['T1']))
                        self.qmc.temp2.append(float(item['T2']))
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message','HH506RA file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' importHH506RA(): {0}').format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' importHH506RA(): {0}').format(str(ex)))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' importHH506RA() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1(self,_=False):
        self.resizeImgToSize(0,0,'PNG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_JPEG(self,_=False):
        self.resizeImgToSize(0,0,'JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_BMP(self,_=False):
        self.resizeImgToSize(0,0,'BMP')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_1200_1(self,_=False):
        self.resizeImgToSize(1200,0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_800_1(self,_=False):
        self.resizeImgToSize(800,0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_700_1(self,_=False):
        self.resizeImgToSize(700,0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_620_1(self,_=False):
        self.resizeImgToSize(620,0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_600_1(self,_=False):
        self.resizeImgToSize(600,0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_500_1(self,_=False):
        self.resizeImgToSize(500,0)

    # Facebook
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImgSize_1200_628(self,_=False):
        self.resizeImgToSize(1200,628,'JPEG')

    # Instagram
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImgSize_1080_608(self,_=False):
        self.resizeImgToSize(1080,608,'JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_SVG(self,_=False):
        self.saveVectorGraph(extension='*.svg')

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_PDF(self,_=False):
        self.saveVectorGraph(extension='*.pdf')

    #resizes and saves graph to a new width w and h preserving maximal image quality independent of screen resolution
    def resizeImgToSize(self,w,h,filetype='PNG',fname=''):
        try:
            fileext = '.png'
            if filetype == 'JPEG':
                fileext = '.jpg'
            elif filetype == 'BMP':
                fileext = '.bmp'
            if fname == '' or fname is None:
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message','Save Graph as') + ' ' + filetype,ext='*'+fileext)
            else:
                filename = fname
            if filename:
                if not filename.endswith(fileext):
                    filename += fileext

                x,y = aw.qmc.fig.get_size_inches()

                adjust_fig_size = False
                if w == 0 and h == 0:
                    # high-res, keep aspect ratio as is
                    fig_dpi = 300
                elif w != 0:
                    # compute fig_dpi to achieve the requested width
                    fig_dpi = w / x
                if w != 0 and h != 0:
                    # fig_dpi is already computed to achieve the requested width
                    # now adjust the height
                    adjust_fig_size = True
                if adjust_fig_size:
                    self.qmc.fig.set_size_inches(w/fig_dpi, h/fig_dpi)
                    res_x = int(w)
                    res_y = int(h)
                else:
                    res_x = int(x*fig_dpi)
                    res_y = int(y*fig_dpi)
                if len(aw.logofilename) > 0 or self.qmc.logoimg is not None:
                    self.qmc.redraw()
                    self.qmc.placelogoimage()
                self.qmc.fig.savefig(filename,
                        dpi=fig_dpi,
                        backend='agg',
                        transparent=(aw.qmc.palette['canvas'] is None or aw.qmc.palette['canvas']=='None'),
                        #bbox_inches='tight',
                        #backend='pgf', # slow and fails on # characters in TeX backend
                        facecolor=str(aw.qmc.palette['canvas']),
                        edgecolor=None
                ) # transparent=True is need to get the delta curves and legend drawn

                if adjust_fig_size:
                    # reset figure size
                    self.qmc.fig.set_size_inches(x,y)
                    # and redraw
                    if self.qmc.wheelflag:
                        self.qmc.drawWheel()
                    else:
                        self.qmc.lazyredraw_on_resize_timer.start(2)

                self.sendmessage(QApplication.translate('Message','{0}  size({1},{2}) saved').format(str(filename),str(res_x),str(res_y)))

        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' resize() {0}').format(str(ex)))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def saveVectorGraph(self,extension='*.pdf',fname=''):
        try:
            if fname == '' or fname is None:
                if extension == '*.pdf':
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message','Save Graph as PDF'),ext=extension)
                else:
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message','Save Graph as SVG'),ext=extension)
            else:
                filename = fname
            extension = extension.replace('*','')
            if filename:
                if extension not in filename:
                    filename += extension
                    #mpl.rcParams['pdf.fonttype'] = 3   # 3 or 42
                    #mpl.rc('pdf', fonttype=3)
                aw.qmc.fig.savefig(filename,
                        transparent=(aw.qmc.palette['canvas'] is None or aw.qmc.palette['canvas']=='None'),
                        #bbox_inches='tight',
                        #backend='pgf', # slow and fails on # characters in TeX backend
                        facecolor=str(aw.qmc.palette['canvas']),
                        edgecolor=None
                        ) # transparent=True is need to get the delta curves and legend drawn
                aw.qmc.updateBackground() # that redraw is needed to avoid the "transparent flicker"

                self.sendmessage(QApplication.translate('Message','{0} saved').format(str(filename)))
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' saveVectorGraph() {0}').format(str(ex)))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    #displays Dialog for the setting of the curves parameters (like RoR, Filters,..)
    @pyqtSlot()
    @pyqtSlot(bool)
    def setCurves(self,_=False):
        from artisanlib.curves import CurvesDlg
        curvesDlg = CurvesDlg(self,self,self.CurveDlg_activeTab)
        curvesDlg.show()

    #used by WheelGraphDlg()
    #wrap values in unicode(.) if and only if those are of type string
    def getWheelGraph(self):
        wheel = {}
        #convert labels to unicode
        for i in range(len(self.qmc.wheelnames)):
            for x in range(len(self.qmc.wheelnames[i])):
                self.qmc.wheelnames[i][x]= self.qmc.wheelnames[i][x]
        #two dimension lists
        wheel['wheelnames'] = self.qmc.wheelnames
        wheel['segmentlengths'] = self.qmc.segmentlengths
        wheel['segmentsalpha'] = self.qmc.segmentsalpha
        wheel['wradii'] = self.qmc.wradii
        wheel['startangle'] = self.qmc.startangle
        wheel['projection'] = self.qmc.projection
        wheel['wheeltextsize'] = self.qmc.wheeltextsize
        wheel['wheelcolor'] = self.qmc.wheelcolor
        wheel['wheelparent'] = self.qmc.wheellabelparent
        wheel['wheeledge'] = self.qmc.wheeledge
        wheel['wheellinewidth'] = self.qmc.wheellinewidth
        wheel['wheellinecolor'] = self.qmc.wheellinecolor
        wheel['wheeltextcolor'] = self.qmc.wheeltextcolor
        wheel['wheelaspect'] = self.qmc.wheelaspect
        return wheel

    def loadWheel(self,filename):
        try:
            f = QFile(filename)
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                wheel = self.deserialize(filename)
                self.qmc.wheelnames = wheel['wheelnames']
                self.qmc.segmentlengths = wheel['segmentlengths']
                self.qmc.segmentsalpha = wheel['segmentsalpha']
                self.qmc.wradii = wheel['wradii']
                self.qmc.startangle = wheel['startangle']
                self.qmc.projection = wheel['projection']
                self.qmc.wheeltextsize = wheel['wheeltextsize']
                self.qmc.wheelcolor = wheel['wheelcolor']
                self.qmc.wheellabelparent = wheel['wheelparent']
                self.qmc.wheeledge = wheel['wheeledge']
                self.qmc.wheellinewidth = wheel['wheellinewidth']
                self.qmc.wheellinecolor = wheel['wheellinecolor']
                if 'wheeltextcolor' in wheel:
                    self.qmc.wheeltextcolor = wheel['wheeltextcolor']
                if 'wheelaspect' in wheel:
                    self.qmc.wheelaspect = wheel['wheelaspect']
                else:
                    self.qmc.wheelaspect = 1.0
                message =QApplication.translate('Message','Wheel {0} loaded').format(str(filename))
                self.sendmessage(message)
            else:
                message = QApplication.translate('Message','Invalid Wheel graph format')
                self.sendmessage(message)
                return
#            message =QApplication.translate("Message","Wheel Graph opened successfully")
#            self.sendmessage(message)
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' loadWheel() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Value Error:') + ' loadWheel() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadWheel() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return
        finally:
            if f:
                f.close()

    @staticmethod
    def standardButtonsVisibility():
        if aw.lowerbuttondialog.isVisible():
            aw.lowerbuttondialog.setVisible(False)
            aw.messagelabel.setVisible(False)
        else:
            aw.lowerbuttondialog.setVisible(True)
            aw.messagelabel.setVisible(True)

    @staticmethod
    def toggleextraeventrows():
        if aw.extrabuttondialogs.isVisible():
            aw.hideExtraButtons()
        else:
            aw.showExtraButtons()

    @staticmethod
    def clearBoxLayout(layout):
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()

    #orders extra event buttons based on max number of buttons
    def realignbuttons(self):
        #clear buttons
        self.clearBoxLayout(self.e1buttonbarLayout)
        self.clearBoxLayout(self.e2buttonbarLayout)
        self.clearBoxLayout(self.e3buttonbarLayout)
        self.clearBoxLayout(self.e4buttonbarLayout)

        self.extraeventbuttonround = []

        self.buttonlist = []
        self.buttonStates = []
        #hide all extra button rows
        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)

        row1count = 0
        row2count = 0
        row3count = 0
        row4count = 0

        for i in range(len(self.extraeventstypes)):

            # next button in this group is hidden
            next_hidden = (i%self.buttonlistmaxlen < self.buttonlistmaxlen -1 and  # at least one more places in the group
                    i+1 < len(self.extraeventstypes) and # there is one more button
                    not self.extraeventsvisibility[i+1]) # and the next one is hidden
            # previous button in this group is hidden
            prev_hidden = (i%self.buttonlistmaxlen > 0 and # at least one previous place in this group
                    i > 0 and # there is more than one button in total
                    not self.extraeventsvisibility[i-1]) # and the previous one is hidden

            if (i%self.buttonlistmaxlen) == 0: # left-most button in the row
                if i == len(self.extraeventstypes)-1 or next_hidden:
                    # a singleton button in a one element bar
                    self.extraeventbuttonround.append(3)
                else:
                    # the left-most button in this bar
                    self.extraeventbuttonround.append(1)
            elif ((i%self.buttonlistmaxlen) < self.buttonlistmaxlen-1) and i != len(self.extraeventstypes)-1:
                # a button in the middle of this bar
                if prev_hidden and next_hidden:
                    # we round both sides
                    self.extraeventbuttonround.append(3)
                elif prev_hidden:
                    # we start a new rounded-group
                    self.extraeventbuttonround.append(1)
                elif next_hidden:
                    self.extraeventbuttonround.append(2)
                else:
                    # squared button
                    self.extraeventbuttonround.append(0)
            else:
                # the right-most button in this bar
                if prev_hidden:
                    self.extraeventbuttonround.append(3)
                else:
                    self.extraeventbuttonround.append(2)

            p = QPushButton()
            p.setAutoDefault(False)
            p.setStyleSheet(self.extraEventButtonStyle(i))
            p.setMinimumHeight([self.standard_button_tiny_height,self.standard_button_small_height,self.standard_button_height][aw.buttonsize])

            p.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

            l = self.extraeventslabels[i]
            # event type et
            et = self.extraeventstypes[i]
            if et > 4:
                et = et - 5
            if et < 4:
                l = l.replace('\\t',self.qmc.etypes[et])
            p.setText(l)
            p.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            p.clicked.connect(self.recordextraevent_slot)
            self.buttonlist.append(p)
            self.buttonStates.append(0)
            #add button to row
            if row1count < self.buttonlistmaxlen:
                self.e1buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e1buttonbarLayout.addSpacing(5)
                row1count += 1
            elif row2count < self.buttonlistmaxlen:
                self.e2buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e2buttonbarLayout.addSpacing(5)
                row2count += 1
            elif row3count < self.buttonlistmaxlen:
                self.e3buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e3buttonbarLayout.addSpacing(5)
                row3count += 1
            else:
                self.e4buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e4buttonbarLayout.addSpacing(5)
                row4count += 1
        if self.e1buttonbarLayout.count() > 0:
            self.e1buttondialog.setVisible(True)
            self.e1buttonbarLayout.insertStretch(0)
            self.e1buttonbarLayout.insertStretch(self.e1buttonbarLayout.count())
        if self.e2buttonbarLayout.count() > 0:
            self.e2buttondialog.setVisible(True)
            self.e2buttonbarLayout.insertStretch(0)
            self.e2buttonbarLayout.insertStretch(self.e2buttonbarLayout.count())
        if self.e3buttonbarLayout.count() > 0:
            self.e3buttondialog.setVisible(True)
            self.e3buttonbarLayout.insertStretch(0)
            self.e3buttonbarLayout.insertStretch(self.e3buttonbarLayout.count())
        if self.e4buttonbarLayout.count() > 0:
            self.e4buttondialog.setVisible(True)
            self.e4buttonbarLayout.insertStretch(0)
            self.e4buttonbarLayout.insertStretch(self.e4buttonbarLayout.count())
        self.settooltip()
        aw.buttonsAction.setEnabled(bool(len(aw.extraeventslabels) > 0))
        if app.artisanviewerMode:
            aw.buttonsAction.setEnabled(False)
        self.update_extraeventbuttons_visibility()

    #assigns tooltips to extra event buttons
    def settooltip(self):
        for i in range(len(self.buttonlist)):
            try:
                tip = QApplication.translate('Tooltip','<b>Label</b>= ') + self.extraeventslabels[i] + '<br>'
                tip += QApplication.translate('Tooltip','<b>Description </b>= ') + self.extraeventsdescriptions[i] + '<br>'
                tip += QApplication.translate('Tooltip','<b>Type </b>= ') + self.qmc.etypesf(self.extraeventstypes[i]) + '<br>'
                if self.extraeventstypes[i] != 4: # no tips for 4: no event type set
                    tip += QApplication.translate('Tooltip','<b>Value </b>= ') + aw.qmc.eventsvalues(self.extraeventsvalues[i]) + '<br>'
                    #+ str(int(round((self.extraeventsvalues[i]-1)*10.)))  + "<br>"
                tip += QApplication.translate('Tooltip','<b>Documentation </b>= ') + self.extraeventsactionstrings[i] + '<br>'
                tip += QApplication.translate('Tooltip','<b>Button# </b>= ') + str(i+1)
                self.buttonlist[i].setToolTip(tip)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    def update_extraeventbuttons_visibility(self):
        for i in range(len(self.buttonlist)):
            try:
                if self.extraeventsvisibility[i]:
                    self.buttonlist[i].setVisible(True)
                else:
                    self.buttonlist[i].setVisible(False)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    # returns the palette named label or None
    def findPalette(self,label):
        for i in range(len(self.buttonpalette)):
            if self.buttonpalette[i][25] == label:
                return i
        return None

    #transfers current buttons to a palette number
    def transferbuttonsto(self,pindex):
        copy = []
        copy.append(self.extraeventstypes[:])
        copy.append(self.extraeventsvalues[:])
        copy.append(self.extraeventsactions[:])
        copy.append(self.extraeventsvisibility[:])
        copy.append(self.extraeventsactionstrings[:])
        copy.append(self.extraeventslabels[:])
        copy.append(self.extraeventsdescriptions[:])
        copy.append(self.extraeventbuttoncolor[:])
        copy.append(self.extraeventbuttontextcolor[:])
        # added slider settings
        copy.append(self.eventslidervisibilities[:])
        copy.append(self.eventslideractions[:])
        copy.append(self.eventslidercommands[:])
        copy.append(self.eventslideroffsets[:])
        copy.append(self.eventsliderfactors[:])
        # added quantifier settings
        copy.append(self.eventquantifieractive[:])
        copy.append(self.eventquantifiersource[:])
        copy.append(self.eventquantifiermin[:])
        copy.append(self.eventquantifiermax[:])
        copy.append(self.eventquantifiercoarse[:])
        # added slider min/max
        copy.append(self.eventslidermin[:])
        copy.append(self.eventslidermax[:])
        # added slider coarse
        copy.append(self.eventslidercoarse[:])
        # added slider temp
        copy.append(self.eventslidertemp[:])
        # added slider unit
        copy.append(self.eventsliderunits[:])
        # added slider Bernoulli
        copy.append(self.eventsliderBernoulli[:])
        # palette label
        copy.append(self.buttonpalette_label)
        # quantifier actions
        copy.append(self.eventquantifieraction[:])
        # quantifier SVs
        copy.append(self.eventquantifierSV[:])

        self.buttonpalette[pindex] = copy[:]
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen
        self.sendmessage(QApplication.translate('Message','Buttons copied to Palette #%i'%(pindex)))

    #restores a palette number to current buttons
    @pyqtSlot(int)
    def setbuttonsfrom(self,pindex):
        copy = self.buttonpalette[pindex][:]
        if len(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            # added slider settings
            if len(copy)>9 and len(copy[9]) == 4:
                self.eventslidervisibilities = copy[9][:]
            else:
                self.eventslidervisibilities = [0,0,0,0]
            if len(copy)>10 and len(copy[10]) == 4:
                self.eventslideractions = copy[10][:]
            else:
                self.eventslideractions = [0,0,0,0]
            if len(copy)>11 and len(copy[11]) == 4:
                self.eventslidercommands = copy[11][:]
            else:
                self.eventslidercommands = ['','','','']
            if len(copy)>12 and len(copy[12]) == 4:
                self.eventslideroffsets = copy[12][:]
            else:
                self.eventslideroffsets = [0,0,0,0]
            if len(copy)>13 and len(copy[13]) == 4:
                self.eventsliderfactors = copy[13][:]
            else:
                self.eventsliderfactors = [1.0,1.0,1.0,1.0]
            if len(copy)>14 and len(copy[14]) == 4:
                self.eventquantifieractive = copy[14][:]
            else:
                self.eventquantifieractive = [0,0,0,0]
            if len(copy)>15 and len(copy[15]) == 4:
                self.eventquantifiersource = copy[15][:]
            else:
                self.eventquantifiersource = [0,0,0,0]
            if len(copy)>16 and len(copy[16]) == 4:
                self.eventquantifiermin = copy[16][:]
            else:
                self.eventquantifiermin = [0,0,0,0]
            if len(copy)>17 and len(copy[17]) == 4:
                self.eventquantifiermax = copy[17][:]
            else:
                self.eventquantifiermax = [100,100,100,100]
            if len(copy)>18 and len(copy[18]) == 4:
                self.eventquantifiercoarse = copy[18][:]
            else:
                self.eventquantifiercoarse = [0,0,0,0]
            if len(copy)>19 and len(copy[19]) == 4:
                self.eventslidermin = copy[19][:]
            else:
                self.eventslidermin = [0,0,0,0]
            if len(copy)>20 and len(copy[20]) == 4:
                self.eventslidermax = copy[20][:]
            else:
                self.eventslidermax = [100,100,100,100]
            if len(copy)>21 and len(copy[21]) == 4:
                self.eventslidercoarse = copy[21][:]
            else:
                self.eventslidercoarse = [0,0,0,0]
            if len(copy)>22 and len(copy[22]) == 4:
                self.eventslidertemp = copy[22][:]
            else:
                self.eventslidertemp = [0,0,0,0]
            if len(copy)>23 and len(copy[23]) == 4:
                self.eventsliderunits = copy[23][:]
            else:
                self.eventsliderunits = ['','','','']
            if len(copy)>24 and len(copy[24]) == 4:
                self.eventsliderBernoulli = copy[24][:]
            else:
                self.eventsliderBernoulli = [0,0,0,0]
            # palette label
            if len(copy)>25:
                self.buttonpalette_label = copy[25]
            else:
                self.buttonpalette_label = self.buttonpalette_default_label
            # quantifier actions
            if len(copy)>26 and len(copy[26]) == 4:
                self.eventquantifieraction = copy[26][:]
            else:
                self.eventquantifieraction = [0,0,0,0]
            # quantifier SV
            if len(copy)>27 and len(copy[27]) == 4:
                self.eventquantifierSV = copy[27][:]
            else:
                self.eventquantifierSV = [0,0,0,0]

            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            self.realignbuttons()
            self.updateSlidersProperties()
            self.lastbuttonpressed = -1
            self.sendmessage(QApplication.translate('Message','Palette #%i restored'%(pindex)))
            return 1  #success
        self.sendmessage(QApplication.translate('Message','Palette #%i empty'%(pindex)))
        return 0  #failed

    def encodeTreeStrings(self,tree):
        return self.mapTree(tree,encodeLocal)

    def decodeTreeStrings(self,tree):
        return self.mapTree(tree,decodeLocal)

    def mapTree(self,tree,f):
        if isinstance(tree,(list,tuple)):
            return [self.mapTree(e,f) for e in tree]
        if stringp(tree):
            return f(tree)
        return tree

    def backuppaletteeventbuttons(self,pal,maxlen):
        palette = {}
        #convert labels to unicode
        for i in range(len(pal)):
            k = str(i)
            palette[k] = self.encodeTreeStrings(pal[i])
        palette['maxlen'] = maxlen
        try:
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message','Save Palettes'),ext='*.apal')
            if filename:
                #write
                self.serialize(filename,palette)
                self.sendmessage(QApplication.translate('Message','Palettes saved'))
        except OSError as ex:
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' backuppaletteeventbuttons(): {0}').format(str(ex)))
            return

    def getPalettes(self,filename,pal):
        maxlen = self.loadPalettes(filename,pal)
        if maxlen is not None:
            self.buttonpalettemaxlen = maxlen

    def loadPalettes(self,filename,pal):
        try:
            f = QFile(filename)
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                palette = self.deserialize(filename)
                buttonpalettemaxlen = list(map(int,palette['maxlen']))
                for i in range(10):  #10 palettes (0-9)
                    k = str(i)
                    nextpalette = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], self.buttonpalette_default_label]
                    palette[k] = self.decodeTreeStrings(palette[k])
                    if len(palette[k]):
                        for x in range(9):
                            if x < 4:
                                if x == 1:
                                    nextpalette[x] = list(map(float,palette[k][x]))     #  type double
                                else:
                                    nextpalette[x] = list(map(int,palette[k][x]))     #  type int
                            else:
                                nextpalette[x] = list(map(str,palette[k][x])) #  type unicode
                        # read in extended palette data containing slider settings:
                        if len(palette[k])>=14:
                            nextpalette[9] = list(map(int,palette[k][9]))     #  type int
                            nextpalette[10] = list(map(int,palette[k][10]))   #  type int
                            nextpalette[11] = list(map(str,palette[k][11]))   #  type unicode
                            nextpalette[12] = list(map(int,palette[k][12]))   #  type int
                            nextpalette[13] = list(map(float,palette[k][13])) #  type double
                        else:
                            for k in range(9,26):
                                if len(pal[i]) == k+1:
                                    nextpalette[k] = pal[i][k]

                        if len(palette[k])>=21:
                            nextpalette[14] = list(map(int,palette[k][14]))     #  type int
                            nextpalette[15] = list(map(int,palette[k][15]))     #  type int
                            nextpalette[16] = list(map(int,palette[k][16]))     #  type int
                            nextpalette[17] = list(map(int,palette[k][17]))     #  type int
                            nextpalette[18] = list(map(int,palette[k][18]))     #  type int
                            nextpalette[19] = list(map(int,palette[k][19]))     #  type int
                            nextpalette[20] = list(map(int,palette[k][20]))     #  type int
                        else:
                            for k in range(14,26):
                                if len(pal[i]) == k+1:
                                    nextpalette[k] = pal[i][k]

                        if len(palette[k])>=25:
                            nextpalette[21] = list(map(int,palette[k][21]))     #  type int
                            nextpalette[22] = list(map(int,palette[k][22]))     #  type int
                            nextpalette[23] = list(map(str,palette[k][23]))     #  type unicode
                            nextpalette[24] = list(map(int,palette[k][24]))     #  type int
                        else:
                            for k in range(21,26):
                                if len(pal[i]) == k+1:
                                    nextpalette[k] = pal[i][k]

                        if len(palette[k])==26:
                            nextpalette[25] = str(palette[k][25])               #  type unicode

                    pal[i] = nextpalette[:]
                message =QApplication.translate('Message','Palettes loaded')
                self.sendmessage(message)
                return buttonpalettemaxlen
            message = QApplication.translate('Message','Invalid palettes file format')
            self.sendmessage(message)
            return None
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' loadPalettes() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return None
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadPalettes() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return None

    def restorepaletteeventbuttons(self,pal):
        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Palettes'),path=self.profilepath)
        if filename:
            self.getPalettes(filename,pal)

    def loadAlarms(self,filename):
        try:
            from json import load as json_load
            with open(filename, encoding='utf-8') as infile:
                alarms = json_load(infile)
            aw.qmc.alarmflag = alarms['alarmflags']
            aw.qmc.alarmguard = alarms['alarmguards']
            aw.qmc.alarmnegguard = alarms['alarmnegguards']
            aw.qmc.alarmtime = alarms['alarmtimes']
            aw.qmc.alarmoffset = alarms['alarmoffsets']
            aw.qmc.alarmcond = alarms['alarmconds']
            aw.qmc.alarmsource = alarms['alarmsources']
            aw.qmc.alarmtemperature = alarms['alarmtemperatures']
            aw.qmc.alarmaction = alarms['alarmactions']
            aw.qmc.alarmbeep = alarms['alarmbeep']
            aw.qmc.alarmstrings = alarms['alarmstrings']
            try:
                aw.qmc.alarmsetlabel = alarms['alarmsetlabel']
            except Exception: # pylint: disable=broad-except
                aw.qmc.alarmsetlabel = ''
            message =QApplication.translate('Message','Alarms loaded')
            self.sendmessage(message)
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','IO Error:') + ' loadAlarms() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message','Exception:') + ' loadAlarms() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesALL(self,_=False):
        self.analysisfitCurves(-1)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesLN(self,_=False):
        self.analysisfitCurves(0)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX2(self,_=False):
        self.analysisfitCurves(2)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX3(self,_=False):
        self.analysisfitCurves(3)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesBkgnd(self,_=False):
        self.analysisfitCurves(4)
    @pyqtSlot()
    @pyqtSlot(bool)
    def clearResults(self,_=False):
        self.qmc.fig.canvas.mpl_disconnect(self.qmc.analyzer_connect_id)
        aw.autoAdjustAxis()
        aw.qmc.redraw(recomputeAllDeltas=True)

    def analysisfitCurves(self, exp=-1):
        # exp == 0 -> ln(), 1 -> unused, 2 -> quadratic, 3 -> cubic, 4 -> bkgnd, -1 -> all of 0,2,and 3
        #check for any roast data
        if not self.qmc.timeindex[0] > -1:
            self.sendmessage(QApplication.translate('Error Message', 'Analyze: CHARGE event required, none found'))
            return
        #check for finished roast
        if not self.qmc.timeindex[6]:
            self.sendmessage(QApplication.translate('Error Message', 'Analyze: DROP event required, none found'))
            return

        #Save the background annotations setting and then disable
        orig_backgroundDetails = self.qmc.backgroundDetails
        self.qmc.backgroundDetails = False

        #prevent accidental overwrite of the original file
        self.qmc.fileDirtySignal.emit()
        self.curFile = None

        # initialize progress dialog
        progress = QProgressDialog(QApplication.translate('Message', 'Fitting curves...'), None, 0, 3, self)
        progress.setCancelButton(None)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.show()
        QApplication.processEvents()

        try:
            #initialize the results
            resultstr = ''

            #run all analysis in celsius
            if aw.qmc.mode == 'F':
                restoreF = True
                self.qmc.convertTemperature('C', silent=True, setdefaultaxes=False)
                smooth=True
                sampling=False
                decay_smoothing_p = not aw.qmc.optimalSmoothing
                recomputeAllDeltas = True
                self.qmc.smoothETBT(smooth,recomputeAllDeltas,sampling,decay_smoothing_p)
                self.qmc.smoothETBTBkgnd(recomputeAllDeltas,decay_smoothing_p)
            else:
                restoreF = False

            chargetime = aw.qmc.timex[aw.qmc.timeindex[0]]

            #drytime is either the DRY event or as set in the Phases dialog
            if self.qmc.timeindex[1]:
                #use the DRY event
                drytime = self.qmc.timex[self.qmc.timeindex[1] -1] #one sample before DE
            else:
                #use the phases dialog value
                i = self.findDryEnd(phasesindex=1)
                drytime = self.qmc.timex[i -1]  #one sample before DE

            #fcstime is either the FCs event or as set in the Phases dialog
            #NOTE - if phases time is used the deltaRoR @FCs will return zeros.
            if self.qmc.timeindex[2]:
                #use the FCS event
                fcstime = self.qmc.timex[self.qmc.timeindex[2]]
            else:
                #use the phases dialog value
                i = self.findDryEnd(phasesindex=2)
                fcstime = self.qmc.timex[i]

            # set the interval of interest
            if self.qmc.analysisstartchoice == 1:   #120 sec before FCs
                analysis_starttime = fcstime - 120
            elif self.qmc.analysisstartchoice == 2: #Custom
                analysis_starttime = self.qmc.analysisoffset + chargetime
            else:                                   #DRY END
                analysis_starttime = drytime
            analysis_endtime = aw.qmc.timex[aw.qmc.timeindex[6]]

            # set the curve fit time
            if self.qmc.curvefitstartchoice == 1:   #120 sec before FCs
                curvefit_starttime = fcstime - 120
            elif self.qmc.curvefitstartchoice == 2: #Custom
                curvefit_starttime = self.qmc.curvefitoffset + chargetime
            else:
                curvefit_starttime = drytime
            curvefit_endtime = aw.qmc.timex[aw.qmc.timeindex[6]]

            # natural log needs a curve fit point sometime earlier than drytime.  Pick one after TP if it exists. Otherwise after CHARGE.
            tpidx = self.findTP()
            if tpidx > 1:
                tptime = self.qmc.timex[tpidx]
                curvefit_starttime_ln = .25 * (drytime - tptime) + tptime
            else:
                curvefit_starttime_ln = .33 * (drytime - chargetime) + chargetime

            # Parameters to curve fit the profile to the existing background.  Respects the background alignment set in the Background Dialog.
            if exp == 4:
                #check for finished background roast
                if not aw.qmc.background:
                    self.sendmessage(QApplication.translate('Error Message', 'Analyze: no background profile data available'))
                    return
                if not (self.qmc.timeindexB[0] > -1 and self.qmc.timeindexB[6]):
                    self.sendmessage(QApplication.translate('Error Message', 'Analyze: background profile requires CHARGE and DROP events'))
                    return

                # set curvefit_starttime to match analysis_starttime
                curvefit_starttime = analysis_starttime
                # set curvefit_starttime analysis_endtime to the earlier of DROP or background DROP
                droptime = aw.qmc.timex[aw.qmc.timeindex[6]]
                droptimeB = aw.qmc.timeB[aw.qmc.timeindexB[6]]
                if droptime > droptimeB:
                    curvefit_endtime = droptimeB
                    analysis_endtime = droptimeB

            # curve fit results
            cfr = {} #use dict to allow more flexible expansion

            # replace a nan value with '--'. returns a string
            def replNan(x):
                if type(x) in [str]:
                    return x
                return '--' if numpy.isnan(x) else f'{x:.2f}'

            # background
            if exp == 4:
                cfr['equ_background'] = QApplication.translate('Label','Bkgnd')
                res = self.analysisGetResults(exp=4, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                cfr['dbt_background'] = replNan(res['mse_BT'])
                cfr['dbt_background_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_background'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_background'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_background'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(3)
            # ln() or all
            if exp in [0,-1]:
                res = self.analysisGetResults(exp=0, curvefit_starttime=curvefit_starttime_ln, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                cfr['equ_naturallog'] = res['equ']
                cfr['dbt_naturallog'] = replNan(res['mse_BT'])
                cfr['dbt_naturallog_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_naturallog'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_naturallog'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_naturallog'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(1 if exp == -1 else 3)
            # cubic or all
            if exp in [3,-1]:
                res = self.analysisGetResults(exp=3, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                cfr['equ_cubic'] = res['equ']
                cfr['dbt_cubic'] = replNan(res['mse_BT'])
                cfr['dbt_cubic_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_cubic'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_cubic'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_cubic'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(2 if exp == -1 else 3)
            # quadratic or all
            if exp in [2,-1]:
                res = self.analysisGetResults(exp=2, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                cfr['equ_quadratic'] = res['equ']
                cfr['dbt_quadratic'] = replNan(res['mse_BT'])
                cfr['dbt_quadratic_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_quadratic'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_quadratic'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_quadratic'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(3)

            # build the results table
            import prettytable  # @UnresolvedImport
            tbl = prettytable.PrettyTable()
            tbl.field_names = [' ',
                               QApplication.translate('Label','RMSE BT'),
                               QApplication.translate('Label','MSE BT'),
                               QApplication.translate('Label','RoR') +  ' \u0394 ' + QApplication.translate('Label','@FCs'),
                               QApplication.translate('Label','Max+/Max- RoR') + ' \u0394']
            tbl.float_format = '5.2'
            if 'equ_background' in cfr and 'dbt_background' in cfr and 'ror_fcs_delta_background' in cfr and 'ror_maxmin_delta_background' in cfr:
                tbl.add_row([QApplication.translate('Label','Bkgnd'), cfr['dbt_background_r'], cfr['dbt_background'], cfr['ror_fcs_delta_background'], cfr['ror_maxmin_delta_background']])
            if 'equ_quadratic' in cfr and 'dbt_quadratic' in cfr and 'ror_fcs_delta_quadratic' in cfr and 'ror_maxmin_delta_quadratic' in cfr:
                tbl.add_row([QApplication.translate('Label','x') +'\u00b2', cfr['dbt_quadratic_r'], cfr['dbt_quadratic'], cfr['ror_fcs_delta_quadratic'], cfr['ror_maxmin_delta_quadratic']])
            if 'equ_cubic' in cfr and 'dbt_cubic' in cfr and 'ror_fcs_delta_cubic' in cfr and 'ror_maxmin_delta_cubic' in cfr:
                tbl.add_row([QApplication.translate('Label','x') + '\u00b3', cfr['dbt_cubic_r'], cfr['dbt_cubic'], cfr['ror_fcs_delta_cubic'], cfr['ror_maxmin_delta_cubic']])
            if 'equ_naturallog' in cfr and 'dbt_naturallog' in cfr and 'ror_fcs_delta_naturallog' in cfr and 'ror_maxmin_delta_naturallog' in cfr:
                tbl.add_row([QApplication.translate('Label','ln()'), cfr['dbt_naturallog_r'], cfr['dbt_naturallog'], cfr['ror_fcs_delta_naturallog'], cfr['ror_maxmin_delta_naturallog']])
            resultstr = 'Curve Fit Analysis\n'
            resultstr += tbl.get_string(sortby=None)

            cfr['segmentresultstr'] = res['segmentresultstr']

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' analysisfitCurves(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        try:
            # convert back to Fahrenheit if the profile was converted to Celsius
            if restoreF:
                self.qmc.convertTemperature('F', silent=True, setdefaultaxes=False)

            # create the results annotation and update the graph
            if len(resultstr) > 0:
                self.analysisShowResults(cfr, resultstr, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' analysisfitCurves(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        progress.cancel()
        progress = None
        #restore the background annotations setting
        self.qmc.backgroundDetails = orig_backgroundDetails

    # returns True as first result if draggable text box artist is contained in the given events region and
    # and it is the one in the region with the highest z-order, otherwise False
    # a dict of properties is returned as second argument
    def draggable_text_box_picker(self,artist, evt):
        try:
            if self.segmentresultsanno is not None and self.analysisresultsanno is not None:
                # in case the analyzer boxes are displayed
                seg_contained,seg_prop = self.segmentresultsanno.contains(evt)
                ana_contained,ana_prop = self.analysisresultsanno.contains(evt)
                segment_zorder = self.segmentresultsanno.get_zorder()
                analysis_zorder = self.analysisresultsanno.get_zorder()
                if artist == self.segmentresultsanno:
                    if  seg_contained and (not ana_contained or segment_zorder > analysis_zorder):
                        # a click on the segmentresult box, but not on the analysisresult box, or the segment box is in front
                        # ensure that the z-order of the segment box is higher than that of the analysis box as the bitblit brings the segment box to the front
                        self.segmentresultsanno.set_zorder(max(segment_zorder,analysis_zorder))
                        self.analysisresultsanno.set_zorder(min(segment_zorder,analysis_zorder))
                        return True, seg_prop
                    # no click on the the segment box, or the analysis box is clicked too and in front
                    return False, {}
                if artist == self.analysisresultsanno:
                    if ana_contained and (not seg_contained or segment_zorder < analysis_zorder):
                        # a click on the analysisresult box, but not on the segmentresult box, or the analyzer box is in front
                        # ensure that the z-order of the analyse box is higher than that of the segment box as the bitblit brings the segment box to the front
                        self.segmentresultsanno.set_zorder(min(segment_zorder,analysis_zorder))
                        self.analysisresultsanno.set_zorder(max(segment_zorder,analysis_zorder))
                        return True, ana_prop
                    # no click on the the analysis box, or the segment box is clicked too and in front
                    return False, {}
                if not seg_contained and not ana_contained:
                    # neither of the two analyzer boxes was clicked, check the given artist is contained in the event region
                    return artist.contains(evt)
                # one of the two analyzer boxes was clicked, we ignore all other artists that might be contained in the events region
                return False, {}
            # if analyzer boxes are not available we call the standard picker
            return artist.contains(evt)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            return False, {}

    def analysisShowResults(self,cfr,resultstr,curvefit_starttime=0, curvefit_endtime=0, analysis_starttime=0, analysis_endtime=0):
        self.qmc.redraw(recomputeAllDeltas = True)

        if len(resultstr) == 0:
            resultstr = self.qmc.analysisresultsstr
        else:
            self.qmc.analysisresultsstr = resultstr
        try:
            # draw analysis mask
            a = aw.qmc.alpha['analysismask']/2
            fc = aw.qmc.palette['analysismask']
            z = 20
            self.qmc.ax.axvspan(aw.qmc.ax.get_xlim()[0], curvefit_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_endtime, aw.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0.975, ymax=1.00,  facecolor=fc, alpha=a, zorder=z)

            self.qmc.ax.axvspan(aw.qmc.ax.get_xlim()[0], analysis_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_endtime, aw.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0.975, ymax=1.00,  facecolor=fc, alpha=a, zorder=z)

            # show warning if the analysis starts earlier than curve fit
            if curvefit_starttime > analysis_starttime:
                string = QApplication.translate('Message','Warning: The start of the analysis interval of interest is earlier than the start of curve fitting.\nCorrect this on the Config>Curves>Analyze tab.')
                QMessageBox.warning(self,QApplication.translate('Message','Analysis earlier than Curve fit'),string)

            #reset the annotation location if the origin is out of the screen
            for dim in self.qmc.analysisresultsloc:
                if dim >= 1 or dim <=0:
                    self.qmc.analysisresultsloc = self.qmc.analysisresultsloc_default

            #reset the annotation location if the origin is out of the screen
            for dim in self.qmc.segmentresultsloc:
                if dim >= 1 or dim <=0:
                    self.qmc.segmentresultsloc = self.qmc.segmentresultsloc_default

            if self.qmc.locale_str in ['ja', 'ko', 'zh_CN', 'zh_TW']:
                # monospace font with Chinese characters
                aw.set_mpl_fontproperties(getResourcePath() + 'WenQuanYiZenHeiMonoMedium.ttf')
                fontfamily = 'WenQuanYi Zen Hei Mono'
            else:
                fontfamily = 'monospace'

            # create the segment results annotation box
            a = aw.qmc.alpha['statsanalysisbkgnd']
            fc = aw.qmc.palette['statsanalysisbkgnd']
            tc = aw.labelBorW(fc)
            if 'segmentresultstr' in cfr:
                segmentresultstr = cfr['segmentresultstr']

                self.segmentresultsanno = self.qmc.ax.annotate(segmentresultstr, xy=self.qmc.segmentresultsloc, xycoords='axes fraction',
                           ha='left', va='center',
                           fontfamily=fontfamily,
                           fontsize='x-small',
                           color=tc,
                           zorder=30,
                           picker=False,
                           bbox=dict(boxstyle='round', fc=fc, alpha=a))
                try:
                    self.segmentresultsanno.set_in_layout(False) # remove from tight_layout calculation
                    self.segmentresultsanno.draggable(use_blit=True)
                    self.segmentresultsanno.set_picker(self.draggable_text_box_picker)
                except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass

            # create the analysis results annotation box
            a = aw.qmc.alpha['statsanalysisbkgnd']
            fc = aw.qmc.palette['statsanalysisbkgnd']
            tc = aw.labelBorW(fc)
            self.analysisresultsanno = self.qmc.ax.annotate(resultstr, xy=self.qmc.analysisresultsloc, xycoords='axes fraction',
                       ha='left', va='center',
                       fontfamily=fontfamily,
                       fontsize='x-small',
                       color=tc,
                       zorder=31,
                       picker=False,
                       bbox=dict(boxstyle='round', fc=fc, alpha=a))
            try:
                self.analysisresultsanno.set_in_layout(False) # remove from tight_layout calculation
                self.analysisresultsanno.draggable(use_blit=True)
                self.analysisresultsanno.set_picker(self.draggable_text_box_picker)
            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass
            self.qmc.analyzer_connect_id = self.qmc.fig.canvas.mpl_connect('button_release_event', self.qmc.onrelease)
            self.qmc.fig.canvas.draw()

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' analysisShowResults(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def analysisGetResults(self,exp=2, curvefit_starttime=0, curvefit_endtime=0, analysis_starttime=0, analysis_endtime=0):

        res = {}  #use dict for the results

        if exp != 4:  #not using existing background so perform a curve fit that sets the background
            res['equ'] = self.qmc.lnRegression(power=exp, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, plot=False)
            self.deleteBackground()
            self.setbackgroundequ(EQU=['',res['equ']],recomputeAllDeltas=True,doDraw=False)  #redraw() called from setbackgroundequ()
            _log.debug("res['equ'] %s", res['equ'])

        result = self.curveSimilarity2(exp=exp, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)

        retval = {**result, **res}
        return retval

    def setbackgroundequ(self,foreground=False,EQU=None,recomputeAllDeltas=False,doDraw=True):
        if EQU is None:
            EQU = ['','']
        # Check for incompatible vars from in the equations
        incompatiblevars = ['P','F','$','#']
        error = ''
        for i in range(len(incompatiblevars)):
            if incompatiblevars[i] in EQU[0]:
                error = 'P1: \n-%s\n\n[%s]'%(incompatiblevars[i],EQU[0])
            elif incompatiblevars[i] in EQU[1]:
                error = 'P2: \n-%s\n\n[%s]'%(incompatiblevars[i],EQU[1])

        if error:
            string = QApplication.translate('Message','Incompatible variables found in %s'%error)
            QMessageBox.warning(self,QApplication.translate('Message','Assignment problem'),string,
                                QMessageBox.StandardButton.Discard)
        else:
            try:
                equ = EQU[0]
                equ2 = EQU[1]
                if len(equ) or len(equ2):
                    aw.qmc.resetlines()
                    #create x range
                    if len(aw.qmc.timex) > 1:
                        x_range = aw.qmc.timex[:]
                        if not foreground and aw.qmc.timeindex[0] > -1:
                            toff = aw.qmc.timex[aw.qmc.timeindex[0]]
                        else:
                            toff = 0
                    else:
                        x_range = list(range(int(aw.qmc.startofx),int(aw.qmc.endofx)))
                        toff = 0
                    #create y range
                    y_range = []
                    y_range2 = []
                    for i in range(len(x_range)):
                        y_range.append(aw.qmc.eval_math_expression(equ,x_range[i],t_offset=toff))
                        y_range2.append(aw.qmc.eval_math_expression(equ2,x_range[i],t_offset=toff))

                    #if foreground flag passed, set EQUs as ET BT instead of background
                    if foreground:
                        aw.qmc.timex = x_range[:]
                        aw.qmc.temp1 = y_range[:]
                        aw.qmc.temp2 = y_range2[:]
                        aw.qmc.redraw(recomputeAllDeltas=True)
                        #make extra devices not visible
                        for x in range(len(aw.qmc.extradevices)):
                            aw.qmc.extratemp1[x] = [-1]*len(x_range)
                            aw.qmc.extratemp2[x] = [-1]*len(x_range)
                            aw.qmc.extratimex[x] = x_range[:]
                        aw.sendmessage(QApplication.translate('Message','Y1 = [%s] ; Y2 = [%s]'%(EQU[0],EQU[1])))

                    else:
                        aw.qmc.timeB = x_range[:]
                        aw.qmc.temp1B = y_range[:]
                        aw.qmc.stemp1B = y_range[:]
                        aw.qmc.temp2B = y_range2[:]
                        aw.qmc.stemp2B = aw.qmc.temp2B[:]
                        for i in range(8):
                            aw.qmc.timeindexB[i] = 0
                        aw.qmc.timeindexB[0] = -1
                        if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6]:
                            # we copy the CHARGE and DROP from the foreground to allow alignment
                            t1 = aw.qmc.timex[aw.qmc.timeindex[0]]
                            aw.qmc.timeindexB[0] = max(-1,aw.qmc.backgroundtime2index(t1))
                            if aw.qmc.timeindex[1]:
                                t_DE = aw.qmc.timex[aw.qmc.timeindex[1]]
                                aw.qmc.timeindexB[1] = max(0,aw.qmc.backgroundtime2index(t_DE))
                            if aw.qmc.timeindex[2]:
                                t_FCs = aw.qmc.timex[aw.qmc.timeindex[2]]
                                aw.qmc.timeindexB[2] = max(0,aw.qmc.backgroundtime2index(t_FCs))
                            t2 = aw.qmc.timex[aw.qmc.timeindex[6]]
                            aw.qmc.timeindexB[6] = max(0,aw.qmc.backgroundtime2index(t2))
                        aw.qmc.background = True
                        aw.qmc.backgroundprofile = {}
                        aw.qmc.backgroundprofile_moved_x = 0
                        aw.qmc.backgroundprofile_moved_y = 0
                        if doDraw:
                            aw.qmc.redraw(recomputeAllDeltas=recomputeAllDeltas)
                            aw.sendmessage(QApplication.translate('Message','B1 = [%s] ; B2 = [%s]'%(EQU[0],EQU[1])))
                        else:
                            decay_smoothing_p = not aw.qmc.optimalSmoothing
                            aw.qmc.smoothETBTBkgnd(recomputeAllDeltas,decay_smoothing_p)

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' setbackgroundequ(): {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def transform(self,_=False):
        from artisanlib.transposer import profileTransformatorDlg
        dialog = profileTransformatorDlg(self,self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def roastCompare(self,_=False):
        if bool(self.comparator):
            self.comparator.close()
        else:
            foreground = aw.curFile
            background = (aw.qmc.backgroundpath if aw.qmc.background else None)
            if self.qmc.reset():
                filenames = []
                if background is not None and background.strip() != '':
                    filenames.append(background)
                if foreground is not None and foreground.strip() != '':
                    filenames.append(foreground)
                if len(filenames) == 0:
                    filenames = aw.reportFiles()
                if filenames and len(filenames) > 0:
                    self.deleteBackground()
                    # disable "green flag" menu:
                    try:
                        aw.ntb.disable_edit_curve_parameters()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    from artisanlib.comparator import roastCompareDlg
                    self.comparator = roastCompareDlg(self,self,foreground,background)
                    self.comparator.addProfiles(filenames)
                    self.comparator.show()
            self.roastCompareAction.setChecked(bool(self.comparator))

    @pyqtSlot()
    @pyqtSlot(bool)
    def simulate(self,_=False):
        modifiers = QApplication.keyboardModifiers()
        control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier # command/apple key on macOS, Control key on Windows
        alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier # OPTION on macOS, ALT on Windows
        shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier # SHIFT
        if bool(self.simulator):
            if control_modifier or alt_modifier or shift_modifier:
                # if a modifier we change the speed instead of leaving the simulator (shift: 1x, alt: 2x, control: 4x):
                speed = 1
                if alt_modifier:
                    speed = 2
                elif control_modifier:
                    speed = 4
                self.qmc.timeclock.setBase(1000*speed)
                self.qmc.updateDeltaSamples() # to get the delta_spans right
                self.sendmessage(QApplication.translate('Message','Simulator started @{}x').format(speed))
                self.simulatorAction.setChecked(True)
            else:
                # we leave the simulator
                self.simulator = None
                self.qmc.timeclock.setBase(1000)
                self.sample_loop_running = True # we enable the sampling loop again that might have been stopped during the simulation via a timerLCD click
                aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles['OFF'])
                aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles['STOP'])
                self.qmc.updateDeltaSamples() # to get the delta_spans right
                self.sendmessage(QApplication.translate('Message','Simulator stopped'))
                self.updateWindowTitle()
                self.enableLoadImportConvertMenus()
                self.qmc.redraw(recomputeAllDeltas=False)
        else:
            try:
                if aw.curFile is None:
                    filename = self.ArtisanOpenFileDialog(ext='*.alog',path=self.simulatorpath)
                else:
                    filename = aw.curFile
                if filename:
                    self.disableLoadImportConvertMenus()
                    f = QFile(filename)
                    if not f.open(QFile.OpenModeFlag.ReadOnly):
                        raise OSError(f.errorString())
                    stream = QTextStream(f)
                    firstChar = stream.read(1)
                    if firstChar == '{':
                        f.close()
                        #meta_modifier = modifiers == Qt.KeyboardModifier.MetaModifier # Control on macOS, Meta/Windows on Windows
                        speed = 1
                        if alt_modifier:
                            speed = 2
                        elif control_modifier:
                            speed = 4
                        self.qmc.timeclock.setBase(1000*speed)
                        self.simulator = Simulator(self.qmc.mode, self.deserialize(filename))
                        self.simulatorpath = filename
                        aw.buttonONOFF.setStyleSheet(aw.pushbuttonstyles_simulator['OFF'])
                        aw.buttonSTARTSTOP.setStyleSheet(aw.pushbuttonstyles_simulator['STOP'])
                        self.qmc.updateDeltaSamples() # to get the delta_spans right
                        self.sendmessage(QApplication.translate('Message','Simulator started @{}x').format(speed))
                        self.updateWindowTitle()
                    else:
                        self.sendmessage(QApplication.translate('Message','Invalid artisan format'))
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.simulatorAction.setChecked(bool(self.simulator))


###########################################################################################################################################
###########################################################################################################################################


def excepthook(excType, excValue, tracebackobj):
    """
    Global function to catch unhandled exceptions.

    @param excType exception type
    @param excValue exception value
    @param tracebackobj traceback object
    """
    _log.error('Logging an uncaught exception',
                 exc_info=(excType, excValue, tracebackobj))
    import traceback
    separator = '-' * 80
    logFile = 'simple.log'
    notice = \
        """An unhandled exception occurred. Please report the problem on Github:\n"""\
        """https://github.com/artisan-roaster-scope/artisan/issues\n"""\
        """When reporting this issue, please include your settings file (export \n"""\
        """via menu Help >> Save Settings) and the details below.\n\n"""\
        """An entry has been written to the error log (menu Help >> Error).\n\n"""
    versionInfo= 'Version: ' + str(__version__) + ', revision: ' + str(__revision__) + '\n'
    timeString = libtime.strftime('%Y-%m-%d, %H:%M:%S')

    tbinfofile = io.StringIO()

    traceback.print_tb(tracebackobj, None, tbinfofile)
    tbinfofile.seek(0)
    tbinfo = tbinfofile.read()
    errmsg = f'{str(excType)}: \n{str(excValue)}'
    stack = []
    variables = ''
    tb = tracebackobj
    while tb:
        stack.append(tb.tb_frame)
        tb = tb.tb_next

    for frame in stack:
        variables += '{}::{}:{}\n'.format(frame.f_code.co_filename,
                                      frame.f_code.co_name,
                                      frame.f_lineno)
        for k, value in frame.f_locals.items():
            variables += '\t%20s = ' % k
            try:
                s = str(value)
            except Exception: # pylint: disable=broad-except
                s = '<???>'
            variables += '%s\n' % s
    sections = [timeString, separator, errmsg]
    msg = '\n'.join(sections)
    detailedmsg = '\n'.join([tbinfo, separator, variables])
    if aw is not None:
        aw.qmc.adderror('Error: ' + detailedmsg)
    try:
        with open(logFile, 'w', encoding='utf-8') as f:
            f.write(msg)
            f.write(detailedmsg)
            f.write(versionInfo)
    except OSError:
        pass
    errorbox = QMessageBox()
    errorbox.setIcon(QMessageBox.Icon.Critical)
    errorbox.setText(str(notice)+str(versionInfo)+str(msg))
    errorbox.setDetailedText(detailedmsg)
    errorbox.exec()

sys.excepthook = excepthook


# the following avoids the "No document could be created" dialog and the Console message
# "The Artisan Profile type doesn't map to any NSDocumentClass." on startup (since pyobjc-core 3.1.1)
if sys.platform.startswith('darwin'):
    from Cocoa import NSDocument  # @UnresolvedImport # pylint: disable=import-error
    class Document(NSDocument): # pylint: disable= too-few-public-methods
#        def windowNibName(self):
#            return None #"Document"
        def makeWindowControllers(self):
            pass

def qt_message_handler(_msg_type, _msg_log_context, _msg_string):
    pass


def initialize_locale(my_app) -> str:
    if QSettings().contains('resetqsettings') and not toInt(QSettings().value('resetqsettings')):
        locale = toString(QSettings().value('locale'))
        if locale is None or locale == 'en_US':
            locale = 'en'
    else:
        locale = ''

    supported_languages = [
        'ar',
        'da',
        'de',
        'el',
        'en',
        'es',
        'fa',
        'fi',
        'fr',
        'gd',
        'he',
        'hu',
        'id',
        'it',
        'ja',
        'ko',
        'lv',
        'nl',
        'no',
        'pt',
        'pt_BR',
        'pl',
#        "ru",
        'sk',
        'sv',
        'th',
        'tr',
        'uk',
        'vi',
        'zh',
        'zh_CN',
        'zh_TW',
    ]

    if len(locale) == 0:
        if platform.system() == 'Darwin':
            from Cocoa import NSUserDefaults # @UnresolvedImport # pylint: disable=import-error
            defs = NSUserDefaults.standardUserDefaults()
            langs = defs.objectForKey_('AppleLanguages')
            if langs.objectAtIndex_(0)[:3] == 'zh_' or langs.objectAtIndex_(0)[:3] == 'pt_':
                locale = langs.objectAtIndex_(0)[:5]
            else:
                locale = langs.objectAtIndex_(0)[:2]
        else:
            if QLocale.system().name()[:2] == 'zh_' or QLocale.system().name()[:2] == 'pt_':
                locale = QLocale.system().name()[:5]
            else:
                locale = QLocale.system().name()[:2]
        if locale in supported_languages:
            QSettings().setValue('locale', locale)

    if locale is None or len(locale) == 0:
        locale = 'en'

    #load Qt default translations from QLibrary
    qtTranslator = QTranslator(my_app)
    try:
        qt_trans_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)
    except Exception: # pylint: disable=broad-except
        qt_trans_path = QLibraryInfo.location(QLibraryInfo.TranslationsPath)
    if qtTranslator.load('qtbase_' + locale, qt_trans_path):
        my_app.installTranslator(qtTranslator)
    #find Qt default translations in Unix binaries
    elif qtTranslator.load('qtbase_' + locale, QApplication.applicationDirPath() + '/translations'):
        my_app.installTranslator(qtTranslator)
    #find Qt default translations in Mac binary
    elif qtTranslator.load('qtbase_' + locale, QApplication.applicationDirPath() + '/../translations'):
        my_app.installTranslator(qtTranslator)
    # qtbase_ translations added to the Artisan source as they are not in the official Qt builds
    elif qtTranslator.load('qtbase_' + locale, 'translations'):
        my_app.installTranslator(qtTranslator)

    #load Artisan translations
    appTranslator = QTranslator(my_app)
    #find application translations in source folder
    if appTranslator.load('artisan_' + locale, 'translations'):
        my_app.installTranslator(appTranslator)
    #find application translations in Unix binaries
    elif appTranslator.load('artisan_' + locale, QApplication.applicationDirPath() + '/translations'):
        my_app.installTranslator(appTranslator)
    #find application translations in Mac binary
    elif appTranslator.load('artisan_' + locale, QApplication.applicationDirPath() + '/../translations'):
        my_app.installTranslator(appTranslator)

    return locale

def main():
    global aw, artisanviewerFirstStart # pylint: disable=global-statement

    locale_str = initialize_locale(app)
    _log.info('locale: %s',locale_str)

    # suppress all Qt messages
    qInstallMessageHandler(qt_message_handler)

    # suppress all warnings
    warnings.filterwarnings('ignore')

    if app.artisanviewerMode:
        app.setApplicationName(application_viewer_name)     #needed by QSettings() to store windows geometry in operating system
        viewersettings = QSettings()
        if not viewersettings.contains('Mode'):
            artisanviewerFirstStart = True
        del viewersettings

    aw = None # this is to ensure that the variable aw is already defined during application initialization

    aw = ApplicationWindow(locale=locale_str, WebEngineSupport=QtWebEngineSupport)

    app.setActivationWindow(aw,activateOnMessage=False) # set the activation window for the QtSingleApplication


    # only here deactivating the app napping seems to have an effect
    if sys.platform.startswith('darwin'):
        appnope.nope()

    if locale_str in ['ar','he','fa']:
        QApplication.setLayoutDirection(Qt.LayoutDirection.RightToLeft)
    else:
        QApplication.setLayoutDirection(Qt.LayoutDirection.LeftToRight)
    aw.settingsLoad(redraw=False) # redraw is triggered later in the startup process again
    aw.restoreExtraDeviceSettingsBackup() # load settings backup if it exists (like on RESET)

    # inform the user the debug logging is on
    if debugLogLevelActive():
        aw.sendmessage(QApplication.translate('Message', 'debug logging ON'))

    aw.show()

    try:
        if sys.argv and len(sys.argv) > 1:
            argv_file = str(sys.argv[1])

            if platf in ['Windows', 'Linux']:
                # send argv_file to running instance and exit this one
                if app.isRunning():
                    # reformat a file path to a url form
                    if re.match(r'^.:',argv_file):
                        argv_file = QUrl.fromLocalFile(argv_file).toString() #here we don't want a local file, preserve the windows file:///
                    app.sendMessage(argv_file)
                    sys.exit(0)
                # otherwise if an artisan://roast url open it in this instance, if not a url do normal file processing
                elif re.match(r'artisan://[roast|profile]',argv_file):
                    url = QUrl()
                    url.setUrl(argv_file)
                    app.open_url(url)
            # on Linux (and RPi), local argv_file paths may contain percent encoded spaces %20 and a file:// URL prefix
            if platf == 'Linux':
                from urllib.parse import unquote_plus
                argv_file_decoded = unquote_plus(argv_file)
                u = QUrl(unquote_plus(argv_file_decoded))
                if u.isLocalFile():
                    argv_file = u.toLocalFile()
                else:
                    argv_file = argv_file_decoded

            qfile = QFileInfo(argv_file)
            file_suffix = qfile.suffix()
            if file_suffix == 'alog':
                # load Artisan profile on double-click on *.alog file
                aw.loadFile(argv_file)
            elif file_suffix == 'alrm':
                # load Artisan alarms on double-click on *.alrm file
                aw.loadAlarms(argv_file)
            elif file_suffix == 'apal':
                # load Artisan palettes on double-click on *.apal file
                aw.getPalettes(argv_file,aw.buttonpalette)
            elif file_suffix == 'aset':
                # load Artisan settings on double-click on *.aset file
                aw.loadSettings(fn=argv_file)
            elif file_suffix == 'athm':
                # load Artisan settings on double-click on *.athm file
                aw.loadSettings(fn=argv_file,reset=False)
        else:
            # we try to reload the last loaded profile or background
            if aw.lastLoadedProfile:
                try:
                    aw.loadFile(aw.lastLoadedProfile)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            elif aw.logofilename != '':  #ensure background image aspect ratio is calculated
                aw.qmc.reset(redraw=False, soundOn=False)
            if aw.lastLoadedBackground and aw.lastLoadedBackground != '' and not aw.curFile:
                try:
                    aw.loadbackground(aw.lastLoadedBackground)
                    aw.qmc.background = not aw.qmc.hideBgafterprofileload
                    if not aw.lastLoadedProfile and not(aw.logofilename != '' and aw.logoimgflag):
                        # this extra redraw is not needed if a watermark is loaded as it is triggered by the resize-redraw mechanism
                        aw.qmc.redraw()
                    else:
                        aw.qmc.timealign(redraw=True,recompute=True)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    aw.qmc.background = False
                    aw.qmc.backgroundprofile = None
                    aw.qmc.backgroundprofile_moved_x = 0
                    aw.qmc.backgroundprofile_moved_y = 0
            if not aw.lastLoadedBackground and not aw.lastLoadedProfile:
                # redraw once to get geometry right
                aw.qmc.redraw(False,sampling=False,smooth=aw.qmc.optimalSmoothing)
    except Exception as e: # pylint: disable=broad-except
        _log.exception(e)

    # write gc debug messages to stdout
#    gc.set_debug(gc.DEBUG_STATS)


#    if platf == 'Windows' and appFrozen():
#        try:
#            sys.stderr = sys.stdout
#        except Exception: # pylint: disable=broad-except
#            pass


    QTimer.singleShot(700, aw.qmc.startPhidgetManager)

    #the following line is to trap numpy warnings that occur in the Cup Profile dialog if all values are set to 0
    with numpy.errstate(invalid='ignore',divide='ignore',over='ignore',under='ignore'):
        # the next line is needed to capture MPL warnings (emitted through logging) of the format
        # "UserWarning: Glyph 231 (\N{LATIN SMALL LETTER C WITH CEDILLA}) missing from current font."
        logging.captureWarnings(True)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            with suppress_stdout_stderr():
                app.exec()
        # alternative:
        # ret = app.exec()
        # app = None
        # sys.exit()

# the following seems to create issue on Mac and Windows builds on exit
#    del aw
#    del app
#    sys.exit(0)

##############################################################################################################################################
##############################################################################################################################################
