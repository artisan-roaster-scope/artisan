#
# ABOUT
# Artisan Main Canvas

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later version. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.

# AUTHOR
# Marko Luther, 2023

from artisanlib import __version__
from artisanlib import __revision__
from artisanlib import __build__

from artisanlib import __release_sponsor_domain__
from artisanlib import __release_sponsor_url__

import gc
import time as libtime
import os
import sys  # @UnusedImport
import ast
import platform
import math
import warnings
import datetime
import numpy
import logging
import re
import textwrap
import functools
from bisect import bisect_right
import psutil
from psutil._common import bytes2human # pyright:ignore[reportPrivateImportUsage]

from typing import Final, Optional, List, Set, Dict, Callable, Tuple, Union, Any, Sequence, cast, TYPE_CHECKING  #for Python >= 3.9: can remove 'List' since type hints can now use the generic 'list'

if TYPE_CHECKING:
    from artisanlib.comm import serialport # pylint: disable=unused-import
    from artisanlib.atypes import ProfileData, EnergyMetrics, BTU, AlarmSet # pylint: disable=unused-import
    from artisanlib.main import ApplicationWindow # pylint: disable=unused-import
    from plus.stock import Blend # pylint: disable=unused-import
    from plus.blend import CustomBlend # pylint: disable=unused-import
    from matplotlib.collections import PolyCollection # pylint: disable=unused-import
    from matplotlib.axes import Axes # pylint: disable=unused-import
    from matplotlib.axes._base import _AxesBase # pyright:ignore[reportPrivateImportUsage] # pylint: disable=unused-import
    from matplotlib.image import AxesImage # pylint: disable=unused-import
    from matplotlib.legend import Legend # pylint: disable=unused-import
    from matplotlib.backend_bases import PickEvent, MouseEvent, Event # pylint: disable=unused-import
    from matplotlib.font_manager import FontProperties # pylint: disable=unused-import
    import numpy.typing as npt # pylint: disable=unused-import
    from PyQt6.QtGui import QResizeEvent # pylint: disable=unused-import

from artisanlib.util import (uchr, fill_gaps, deltaLabelPrefix, deltaLabelUTF8, deltaLabelMathPrefix, stringfromseconds,
        fromFtoC, fromFtoCstrict, fromCtoF, fromCtoFstrict, RoRfromFtoC, RoRfromFtoCstrict, RoRfromCtoF, toInt, toString,
        toFloat, application_name, getResourcePath, getDirectory, convertWeight, right_to_left,
        abbrevString, scaleFloat2String, is_proper_temp, weight_units, render_weight, volume_units, float2float)
from artisanlib import pid
from artisanlib.time import ArtisanTime
from artisanlib.filters import LiveMedian
from artisanlib.dialogs import ArtisanMessageBox
from artisanlib.atypes import SerialSettings, BTBreakParams, BbpCache

# import artisan.plus module
from plus.util import roastLink
from plus.queue import addRoast, sendLockSchedule

try:
    #pylint: disable-next = E, W, R, C
    from PyQt6.QtWidgets import (QApplication, QWidget, QMessageBox, # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error
                             QGraphicsEffect, # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, # @Reimport @UnresolvedImport @UnusedImport
                             QMenu) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtGui import (QAction, QImage, # @Reimport @UnresolvedImport @UnusedImport
                                QColor, QDesktopServices, # @Reimport @UnresolvedImport @UnusedImport
                                QCursor) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtCore import (QLocale, pyqtSignal, pyqtSlot, # @Reimport @UnresolvedImport @UnusedImport
                              QTimer, QSettings, # @Reimport @UnresolvedImport @UnusedImport
                              QUrl, QDir, Qt, QDateTime, QThread, QSemaphore, QObject) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6 import sip # @Reimport @UnresolvedImport @UnusedImport
except Exception: # pylint: disable=broad-except
    #pylint: disable = E, W, R, C
    from PyQt5.QtWidgets import (QAction, QApplication, QWidget, QMessageBox,  # type: ignore  # @Reimport @UnresolvedImport @UnusedImport
                             QGraphicsEffect, # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, # @Reimport @UnresolvedImport @UnusedImport
                             QMenu) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtGui import (QImage,  # type: ignore # @Reimport @UnresolvedImport @UnusedImport
                                QColor, QDesktopServices, # @Reimport @UnresolvedImport @UnusedImport
                                QCursor) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtCore import (QLocale, pyqtSignal, pyqtSlot, # type: ignore # @Reimport @UnresolvedImport @UnusedImport
                              QTimer, QSettings, # @Reimport @UnresolvedImport @UnusedImport
                              QUrl, QDir, Qt, QDateTime, QThread, QSemaphore, QObject) # @Reimport @UnresolvedImport @UnusedImport
    try:
        from PyQt5 import sip # type: ignore # @Reimport @UnresolvedImport @UnusedImport
    except Exception: # pylint: disable=broad-except
        import sip # type: ignore # @Reimport @UnresolvedImport @UnusedImport


from matplotlib.figure import Figure
from matplotlib import rcParams, patches, transforms, ticker
import matplotlib.patheffects as PathEffects
from matplotlib.patches import Polygon, Rectangle
from matplotlib.transforms import Bbox, Transform
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas  # @Reimport
from matplotlib.projections.polar import PolarAxes
from matplotlib.text import Annotation, Text
from matplotlib.lines import Line2D
from matplotlib.offsetbox import DraggableAnnotation
from matplotlib.colors import to_hex, to_rgba

from artisanlib.phidgets import PhidgetManager
from Phidget22.VoltageRange import VoltageRange # type: ignore

try:
    # spanning a second multiprocessing instance on macOS falils to import the YAPI interface
    from yoctopuce.yocto_api import YAPI # type: ignore
except Exception: # pylint: disable=broad-except
    pass



_log: Final[logging.Logger] = logging.getLogger(__name__)


#######################################################################################
#################### Ambient Data Collection  #########################################
#######################################################################################

class AmbientWorker(QObject): # pylint: disable=too-few-public-methods # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class
    finished = pyqtSignal()

    def __init__(self, aw:'ApplicationWindow') -> None:
        super().__init__()
        self.aw = aw

    def run(self) -> None:
        libtime.sleep(2.5) # wait a moment after ON until all other devices are attached
        try:
            if self.aw is not None and self.aw.qmc is not None:
                self.aw.qmc.getAmbientData()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        finally:
            self.finished.emit()


# NOTE: to have pylint to verify proper __slot__ definitions using pylint one has to remove the super class FigureCanvas here temporarily
#   as this does not has __slot__ definitions and thus __dict__ is contained which suppresses the warnings
#class tgraphcanvas():
class tgraphcanvas(FigureCanvas):
    updategraphicsSignal = pyqtSignal()
    updateLargeLCDsTimeSignal = pyqtSignal(str)
    updateLargeLCDsReadingsSignal = pyqtSignal(str,str)
    updateLargeLCDsSignal = pyqtSignal(str,str,str)
    setTimerLargeLCDcolorSignal = pyqtSignal(str,str)
    showAlarmPopupSignal = pyqtSignal(str,int)
    fileDirtySignal = pyqtSignal()
    fileCleanSignal = pyqtSignal()
    markChargeDelaySignal = pyqtSignal(int)
    markChargeSignal = pyqtSignal(bool)
    markTPSignal = pyqtSignal()
    markDRYSignal = pyqtSignal(bool)
    markFCsSignal = pyqtSignal(bool)
    markFCeSignal = pyqtSignal(bool)
    markSCsSignal = pyqtSignal(bool)
    markSCeSignal = pyqtSignal(bool)
    markDropSignal = pyqtSignal(bool)
    markCoolSignal = pyqtSignal(bool)
    onMonitorSignal = pyqtSignal()
    toggleMonitorSignal = pyqtSignal()
    toggleRecorderSignal = pyqtSignal()
    processAlarmSignal = pyqtSignal(int, bool, int, str)
    alarmsetSignal = pyqtSignal(int)
    moveBackgroundSignal = pyqtSignal(str, int)
    eventRecordSignal = pyqtSignal(int)
    eventRecordActionSignal = pyqtSignal(int,float,str,bool)
    showCurveSignal = pyqtSignal(str, bool)
    showExtraCurveSignal = pyqtSignal(int, str, bool)
    showEventsSignal = pyqtSignal(int, bool)
    showBackgroundEventsSignal = pyqtSignal(bool)
    redrawSignal = pyqtSignal(bool,bool,bool,bool,bool)
    redrawKeepViewSignal = pyqtSignal(bool,bool,bool,bool,bool)

    umlaute_dict : Final[Dict[str, str]] = {
       uchr(228): 'ae',  # U+00E4   \xc3\xa4
       uchr(246): 'oe',  # U+00F6   \xc3\xb6
       uchr(252): 'ue',  # U+00FC   \xc3\xbc
       uchr(196): 'AE',  # U+00C4   \xc3\x84
       uchr(214): 'OE',  # U+00D6   \xc3\x96
       uchr(220): 'UE',  # U+00DC   \xc3\x9c
       uchr(223): 'ss',  # U+00DF   \xc3\x9f
    }

    ALARMSET_COUNT: Final[int] = 10 # number of alarm sets
    ALARMSET_ITEMS: Final[int] = 12 # number of elements per alarm set

    __slots__ = [ 'aw', 'alignnames', 'locale_str', 'alpha', 'palette', 'palette1', 'EvalueColor_default', 'EvalueTextColor_default', 'artisanflavordefaultlabels', 'customflavorlabels',
        'SCAAflavordefaultlabels', 'SCAflavordefaultlabels', 'CQIflavordefaultlabels', 'SweetMariasflavordefaultlabels', 'Cflavordefaultlabels', 'Eflavordefaultlabels', 'coffeegeekflavordefaultlabels',
        'Intelligentsiaflavordefaultlabels', 'IstitutoInternazionaleAssaggiatoriCaffe', 'WorldCoffeeRoastingChampionship', 'ax1', 'ax2', 'ambiWorker', 'ambiThread', 'afterTP',
        'decay_weights', 'temp_decay_weights', 'flavorlabels', 'flavors', 'flavors_total_correction', 'flavorstartangle', 'flavoraspect', 'flavorchart_plotf', 'flavorchart_angles', 'flavorchart_plot',
        'flavorchart_fill', 'flavorchart_labels', 'flavorchart_total', 'mode', 'mode_tempsliders', 'errorlog', 'default_delay', 'delay', 'min_delay', 'extra_event_sampling_delay',
        'phases_fahrenheit_defaults', 'phases_celsius_defaults', 'phases', 'phasesbuttonflag', 'phasesfromBackgroundflag', 'watermarksflag', 'step100temp', 'phasesLCDflag',
        'phasesLCDmode', 'phasesLCDmode_l', 'phasesLCDmode_all', 'statisticsflags', 'statisticsmode', 'AUCbegin', 'AUCbase', 'AUCbaseFlag', 'AUCtarget', 'AUCbackground',
        'AUCtargetFlag', 'AUCguideFlag', 'AUClcdFlag', 'AUCLCDmode', 'AUCvalue', 'AUCsinceFCs', 'AUCguideTime', 'AUCshowFlag', 'statisticstimes', 'device', 'device_logging',
        'device_log_file_name', 'device_log_file', 'phidget_dataRatesStrings', 'phidget_dataRatesValues', 'phidget1048_types', 'phidget1048_async', 'phidget1048_changeTriggers',
        'phidget1048_changeTriggersValues', 'phidget1048_changeTriggersStrings', 'phidget1048_dataRate', 'phidget1045_async', 'phidget1045_changeTrigger', 'phidget1045_changeTriggersValues',
        'phidget1045_changeTriggersStrings', 'phidget1045_emissivity', 'phidget1045_dataRate', 'phidget1200_async', 'phidget1200_formula', 'phidget1200_formulaValues', 'phidget1200_wire',
        'phidget1200_wireValues', 'phidget1200_changeTrigger', 'phidget1200_changeTriggersValues', 'phidget1200_changeTriggersStrings', 'phidget1200_dataRate',
        'phidget1200_dataRatesStrings', 'phidget1200_dataRatesValues', 'phidget1200_2_async', 'phidget1200_2_formula', 'phidget1200_2_wire', 'phidget1200_2_changeTrigger',
        'phidget1200_2_dataRate', 'phidget1046_async', 'phidget1046_gain', 'phidget1046_gainValues', 'phidget1046_formula', 'phidget1046_formulaValues', 'phidget1046_dataRate',
        'phidgetRemoteFlag', 'phidgetRemoteOnlyFlag', 'phidgetServerID', 'phidgetPassword', 'phidgetPort', 'phidgetServerAdded', 'phidgetServiceDiscoveryStarted',
        'phidgetManager', 'yoctoRemoteFlag', 'yoctoServerID', 'YOCTOchanUnit', 'YOCTOchan1Unit', 'YOCTOchan2Unit', 'YOCTO_emissivity', 'YOCTO_async',
        'YOCTO_dataRate', 'YOCTO_dataRatesStrings', 'YOCTO_dataRatesValues', 'phidget1018valueFactor', 'phidget1018_async', 'phidget1018_ratio', 'phidget1018_dataRates',
        'phidget1018_changeTriggers', 'phidget1018_changeTriggersValues', 'phidget1018_changeTriggersStrings', 'phidgetVCP100x_voltageRanges', 'phidgetVCP100x_voltageRangeValues',
        'phidgetVCP100x_voltageRangeStrings', 'phidgetDAQ1400_powerSupplyStrings', 'phidgetDAQ1400_powerSupply', 'phidgetDAQ1400_inputModeStrings', 'phidgetDAQ1400_inputMode',
        'devices', 'phidgetDevices', 'nonSerialDevices', 'nonTempDevices', 'specialDevices', 'binaryDevices', 'extradevices', 'extratimex', 'extradevicecolor1', 'extradevicecolor2', 'extratemp1',
        'extratemp2', 'extrastemp1', 'extrastemp2', 'extractimex1', 'extractimex2', 'extractemp1', 'extractemp2', 'extratemp1lines', 'extratemp2lines',
        'extraname1', 'extraname2', 'extramathexpression1', 'extramathexpression2', 'extralinestyles1', 'extralinestyles2', 'extradrawstyles1', 'extradrawstyles2',
        'extralinewidths1', 'extralinewidths2', 'extramarkers1', 'extramarkers2', 'extramarkersizes1', 'extramarkersizes2', 'devicetablecolumnwidths', 'extraNoneTempHint1',
        'extraNoneTempHint2', 'plotcurves', 'plotcurvecolor', 'overlapList', 'tight_layout_params', 'fig', 'ax', 'delta_ax', 'legendloc', 'legendloc_pos', 'onclick_cid',
        'oncpick_cid', 'ondraw_cid', 'onmove_cid', 'rateofchange1', 'rateofchange2', 'flagon', 'flagstart', 'flagKeepON', 'flagOpenCompleted', 'flagsampling', 'flagsamplingthreadrunning',
        'manuallogETflag', 'zoom_follow', 'alignEvent', 'compareAlignEvent', 'compareEvents', 'compareET', 'compareBT', 'compareDeltaET', 'compareDeltaBT', 'compareMainEvents', 'compareBBP', 'compareRoast', 'compareExtraCurves1', 'compareExtraCurves2',
        'replayType', 'replayedBackgroundEvents', 'last_replayed_events', 'beepedBackgroundEvents', 'roastpropertiesflag', 'roastpropertiesAutoOpenFlag', 'roastpropertiesAutoOpenDropFlag',
        'title', 'title_show_always', 'ambientTemp', 'ambientTempSource', 'ambient_temperature_device', 'ambient_pressure', 'ambient_pressure_device', 'ambient_humidity',
        'ambient_humidity_device', 'elevation', 'temperaturedevicefunctionlist', 'humiditydevicefunctionlist', 'pressuredevicefunctionlist', 'moisture_greens', 'moisture_roasted',
        'greens_temp', 'beansize', 'beansize_min', 'beansize_max', 'whole_color', 'ground_color', 'color_systems', 'color_system_idx', 'heavyFC_flag', 'lowFC_flag', 'lightCut_flag',
        'darkCut_flag', 'drops_flag', 'oily_flag', 'uneven_flag', 'tipping_flag', 'scorching_flag', 'divots_flag', 'timex',
        'temp1', 'temp2', 'delta1', 'delta2', 'stemp1', 'stemp2', 'tstemp1', 'tstemp2', 'ctimex1', 'ctimex2', 'ctemp1', 'ctemp2', 'unfiltereddelta1', 'unfiltereddelta2',  'unfiltereddelta1_pure', 'unfiltereddelta2_pure',
        'on_timex', 'on_temp1', 'on_temp2', 'on_ctimex1', 'on_ctimex2', 'on_ctemp1', 'on_ctemp2','on_tstemp1', 'on_tstemp2', 'on_unfiltereddelta1',
        'on_unfiltereddelta2', 'on_delta1', 'on_delta2', 'on_extratemp1', 'on_extratemp2', 'on_extratimex', 'on_extractimex1', 'on_extractemp1', 'on_extractimex2', 'on_extractemp2', 'BTprojection_tx', 'BTprojection_temp', 'ETprojection_tx', 'ETprojection_temp', 'DeltaBTprojection_tx', 'DeltaBTprojection_temp', 'DeltaETprojection_tx', 'DeltaETprojection_temp',
        'timeindex', 'ETfunction', 'BTfunction', 'DeltaETfunction', 'DeltaBTfunction', 'safesaveflag', 'pid', 'background', 'backgroundprofile', 'backgroundprofile_moved_x', 'backgroundprofile_moved_y', 'backgroundDetails',
        'backgroundeventsflag', 'backgroundpath', 'backgroundUUID', 'backgroundUUID', 'backgroundShowFullflag', 'backgroundKeyboardControlFlag', 'titleB', 'roastbatchnrB', 'roastbatchprefixB',
        'roastbatchposB', 'temp1B', 'temp2B', 'temp1BX', 'temp2BX', 'timeB', 'abs_timeB', 'temp1Bdelta', 'temp2Bdelta',
        'stemp1B', 'stemp2B', 'stemp1BX', 'stemp2BX', 'extraname1B', 'extraname2B', 'extratimexB', 'xtcurveidx', 'ytcurveidx', 'delta1B', 'delta2B', 'timeindexB',
        'TP_time_B_loaded', 'backgroundEvents', 'backgroundEtypes', 'backgroundEvalues', 'backgroundEStrings', 'backgroundalpha', 'backgroundmetcolor',
        'backgroundbtcolor', 'backgroundxtcolor', 'backgroundytcolor', 'backgrounddeltaetcolor', 'backgrounddeltabtcolor', 'detectBackgroundEventTime',
        'backgroundReproduce', 'backgroundReproduceBeep', 'backgroundPlaybackEvents', 'backgroundPlaybackDROP', 'Betypes', 'backgroundFlavors', 'flavorbackgroundflag',
        'E1backgroundtimex', 'E2backgroundtimex', 'E3backgroundtimex', 'E4backgroundtimex', 'E1backgroundvalues', 'E2backgroundvalues', 'E3backgroundvalues',
        'E4backgroundvalues', 'l_backgroundeventtype1dots', 'l_backgroundeventtype2dots', 'l_backgroundeventtype3dots', 'l_backgroundeventtype4dots',
        'DeltaETBflag', 'DeltaBTBflag', 'clearBgbeforeprofileload', 'setBatchSizeFromBackground', 'hideBgafterprofileload', 'heating_types', 'operator', 'organization', 'roastertype', 'roastersize', 'roasterheating', 'drumspeed',
        'organization_setup', 'operator_setup', 'roastertype_setup', 'roastersize_setup', 'roastersize_setup_default', 'roasterheating_setup', 'roasterheating_setup_default', 'drumspeed_setup', 'last_batchsize', 'machinesetup_energy_ratings',
        'machinesetup', 'roastingnotes', 'cuppingnotes', 'roastdate', 'roastepoch', 'roastepoch_timeout', 'lastroastepoch', 'batchcounter', 'batchsequence', 'batchprefix', 'neverUpdateBatchCounter',
        'roastbatchnr', 'roastbatchprefix', 'roastbatchpos', 'roasttzoffset', 'roastUUID', 'scheduleID', 'scheduleDate', 'plus_default_store', 'plus_store', 'plus_store_label', 'plus_coffee',
        'plus_coffee_label', 'plus_blend_spec', 'plus_blend_spec_labels', 'plus_blend_label', 'plus_custom_blend', 'plus_sync_record_hash', 'plus_file_last_modified', 'beans', 'ETprojectFlag', 'BTprojectFlag', 'curveVisibilityCache', 'ETcurve', 'BTcurve',
        'ETlcd', 'BTlcd', 'swaplcds', 'LCDdecimalplaces', 'foregroundShowFullflag', 'interpolateDropsflag', 'DeltaETflag', 'DeltaBTflag', 'DeltaETlcdflag', 'DeltaBTlcdflag',
        'swapdeltalcds', 'PIDbuttonflag', 'Controlbuttonflag', 'deltaETfilter', 'deltaBTfilter', 'curvefilter', 'deltaETspan', 'deltaBTspan',
        'deltaETsamples', 'deltaBTsamples', 'profile_sampling_interval', 'background_profile_sampling_interval', 'profile_meter', 'optimalSmoothing', 'polyfitRoRcalc',
        'patheffects', 'graphstyle', 'graphfont', 'buttonvisibility', 'buttonactions', 'buttonactionstrings', 'extrabuttonactions', 'extrabuttonactionstrings',
        'xextrabuttonactions', 'xextrabuttonactionstrings', 'chargeTimerFlag', 'autoChargeFlag', 'autoDropFlag', 'autoChargeMode', 'autoDropMode', 'autoChargeIdx', 'autoDropIdx', 'markTPflag',
        'autoDRYflag', 'autoFCsFlag', 'autoCHARGEenabled', 'autoDRYenabled', 'autoFCsenabled', 'autoDROPenabled', 'autoDryIdx', 'projectionconstant',
        'projectionmode', 'transMappingMode', 'weight', 'volume', 'density', 'density_roasted', 'volumeCalcUnit', 'volumeCalcWeightInStr',
        'volumeCalcWeightOutStr', 'container_names', 'container_weights', 'container_idx', 'specialevents', 'etypes', 'etypesdefault',
        'alt_etypesdefault', 'default_etypes_set', 'specialeventstype',
        'specialeventsStrings', 'specialeventsvalue', 'eventsGraphflag', 'clampEvents', 'renderEventsDescr', 'eventslabelschars', 'eventsshowflag',
        'annotationsflag', 'showeventsonbt', 'showEtypes', 'E1timex', 'E2timex', 'E3timex', 'E4timex', 'E1values', 'E2values', 'E3values', 'E4values',
        'EvalueColor', 'EvalueTextColor', 'EvalueMarker', 'EvalueMarkerSize', 'Evaluelinethickness', 'Evaluealpha', 'eventpositionbars', 'specialeventannotations',
        'specialeventannovisibilities', 'specialeventplaybackaid', 'specialeventplayback', 'overlappct', 'linestyle_default', 'drawstyle_default', 'linewidth_min', 'markersize_min', 'linewidth_default', 'back_linewidth_default', 'delta_linewidth_default',
        'back_delta_linewidth_default', 'extra_linewidth_default', 'marker_default', 'markersize_default', 'BTlinestyle', 'BTdrawstyle', 'BTlinewidth', 'BTmarker',
        'BTmarkersize', 'ETlinestyle', 'ETdrawstyle', 'ETlinewidth', 'ETmarker', 'ETmarkersize', 'BTdeltalinestyle', 'BTdeltadrawstyle', 'BTdeltalinewidth',
        'BTdeltamarker', 'BTdeltamarkersize', 'ETdeltalinestyle', 'ETdeltadrawstyle', 'ETdeltalinewidth', 'ETdeltamarker', 'ETdeltamarkersize', 'BTbacklinestyle',
        'BTbackdrawstyle', 'BTbacklinewidth', 'BTbackmarker', 'BTbackmarkersize', 'ETbacklinestyle', 'ETbackdrawstyle', 'ETbacklinewidth', 'ETbackmarker',
        'ETbackmarkersize', 'XTbacklinestyle', 'XTbackdrawstyle', 'XTbacklinewidth', 'XTbackmarker', 'XTbackmarkersize', 'YTbacklinestyle', 'YTbackdrawstyle',
        'YTbacklinewidth', 'YTbackmarker', 'YTbackmarkersize', 'BTBdeltalinestyle', 'BTBdeltadrawstyle', 'BTBdeltalinewidth', 'BTBdeltamarker', 'BTBdeltamarkersize',
        'ETBdeltalinestyle', 'ETBdeltadrawstyle', 'ETBdeltalinewidth', 'ETBdeltamarker', 'ETBdeltamarkersize', 'alarmsetlabel', 'alarmflag', 'alarmguard', 'alarmnegguard', 'alarmtime', 'alarmoffset', 'alarmtime2menuidx', 'menuidx2alarmtime',
        'alarmcond', 'alarmstate', 'alarmsource', 'alarmtemperature', 'alarmaction', 'alarmbeep', 'alarmstrings', 'alarmtablecolumnwidths', 'silent_alarms',
        'alarmsets', 'loadalarmsfromprofile', 'loadalarmsfrombackground', 'alarmsfile', 'TPalarmtimeindex', 'rsfile',
        'loadaxisfromprofile', 'startofx_default', 'endofx_default', 'xgrid_default', 'ylimit_F_default',
        'ylimit_min_F_default', 'ygrid_F_default', 'zlimit_F_default', 'zlimit_min_F_default', 'zgrid_F_default', 'ylimit_C_default', 'ylimit_min_C_default',
        'ygrid_C_default', 'zlimit_C_default', 'zlimit_min_C_default', 'zgrid_C_default', 'temp_grid', 'time_grid', 'zlimit_max', 'zlimit_min_max',
        'ylimit_max', 'ylimit_min_max', 'ylimit', 'ylimit_min', 'zlimit', 'zlimit_min', 'RoRlimitFlag', 'RoRlimit', 'RoRlimitm', 'maxRoRlimit',
        'endofx', 'startofx', 'resetmaxtime', 'chargemintime', 'fixmaxtime', 'locktimex', 'autotimex', 'autotimexMode', 'autodeltaxET', 'autodeltaxBT', 'locktimex_start',
        'locktimex_end', 'xgrid', 'ygrid', 'zgrid', 'gridstyles', 'gridlinestyle', 'gridthickness', 'gridalpha', 'xrotation',
        'statisticsheight', 'statisticsupper', 'statisticslower', 'autosaveflag', 'autosaveprefix', 'autosavepath', 'autosavealsopath',
        'autosaveaddtorecentfilesflag', 'autosaveimage', 'autosaveimageformat', 'autoasaveimageformat_types', 'ystep_down', 'ystep_up', 'backgroundETcurve', 'backgroundBTcurve',
        'l_temp1', 'l_temp2', 'l_delta1', 'l_delta2', 'l_back1', 'l_back2', 'l_back3', 'l_back4', 'l_delta1B', 'l_delta2B', 'l_BTprojection', 'l_DeltaETprojection', 'l_DeltaBTprojection',
        'l_ETprojection', 'l_AUCguide', 'l_horizontalcrossline', 'l_verticalcrossline', 'l_timeline', 'legend', 'l_eventtype1dots', 'l_eventtype2dots',
        'l_eventtype3dots', 'l_eventtype4dots', 'l_eteventannos', 'l_bteventannos', 'l_eventtype1annos', 'l_eventtype2annos', 'l_eventtype3annos',
        'l_eventflagannos', 'l_eventflagbackannos',
        'l_eventtype4annos', 'l_annotations', 'l_background_annotations', 'l_annotations_dict', 'l_annotations_pos_dict', 'l_event_flags_dict',
        'l_eventtype1backannos', 'l_eventtype2backannos', 'l_eventtype3backannos', 'l_eventtype4backannos',
        'l_event_flags_pos_dict', 'ai', 'timeclock', 'threadserver', 'designerflag', 'designerconnections', 'mousepress', 'indexpoint',
        'workingline', 'eventtimecopy', 'etypescopy', 'specialeventsStringscopy', 'specialeventsvaluecopy', 'specialeventstypecopy', 'currentx', 'currenty',
        'designertimeinit', 'BTsplinedegree', 'ETsplinedegree', 'reproducedesigner', 'designertemp1init', 'designertemp2init', 'ax_background_designer', 'designer_timez', 'time_step_size',
        '_designer_orange_mark', '_designer_orange_mark_shown', '_designer_blue_mark', '_designer_blue_mark_shown', 'l_temp1_markers', 'l_temp2_markers',
        'l_stat1', 'l_stat2', 'l_stat3', 'l_div1', 'l_div2', 'l_div3', 'l_div4',
        'filterDropOut_replaceRoR_period', 'filterDropOut_spikeRoR_period', 'filterDropOut_tmin_C_default', 'filterDropOut_tmax_C_default',
        'filterDropOut_tmin_F_default', 'filterDropOut_tmax_F_default', 'filterDropOut_spikeRoR_dRoR_limit_C_default', 'filterDropOut_spikeRoR_dRoR_limit_F_default',
        'filterDropOuts', 'filterDropOut_tmin', 'filterDropOut_tmax', 'filterDropOut_spikeRoR_dRoR_limit', 'minmaxLimits', 'median_filter_factor_RoR',
        'dropSpikes', 'dropDuplicates', 'dropDuplicatesLimit', 'median_filter_factor', 'liveMedianETRoRfilter', 'liveMedianBTRoRfilter',
        'liveMedianETfilter', 'liveMedianBTfilter', 'interpolatemax', 'swapETBT', 'wheelflag', 'wheelnames', 'segmentlengths', 'segmentsalpha',
        'wheellabelparent', 'wheelcolor', 'wradii', 'startangle', 'projection', 'wheeltextsize', 'wheelcolorpattern', 'wheeledge',
        'wheellinewidth', 'wheellinecolor', 'wheeltextcolor', 'wheelconnections', 'wheelx', 'wheelz', 'wheellocationx', 'wheellocationz',
        'wheelaspect', 'samplingSemaphore', 'updateGraphicsSemaphore', 'profileDataSemaphore', 'messagesemaphore', 'errorsemaphore', 'serialsemaphore', 'seriallogsemaphore',
        'eventactionsemaphore', 'updateBackgroundSemaphore', 'alarmSemaphore', 'rampSoakSemaphore', 'crossmarker', 'crossmouseid', 'onreleaseid',
        'analyzer_connect_id', 'extra309T3', 'extra309T4', 'extra309TX', 'hottop_ET', 'hottop_BT', 'hottop_HEATER', 'hottop_MAIN_FAN', 'hottop_TX',
        'R1_DT', 'R1_BT', 'R1_BT_ROR', 'R1_EXIT_TEMP', 'R1_HEATER', 'R1_FAN', 'R1_DRUM', 'R1_VOLTAGE', 'R1_TX', 'R1_STATE', 'R1_FAN_RPM', 'R1_STATE_STR',
        'extraArduinoTX', 'extraArduinoT1', 'extraArduinoT2', 'extraArduinoT3', 'extraArduinoT4', 'extraArduinoT5', 'extraArduinoT6', 'program_t3', 'program_tx', 'program_t4', 'program_t5', 'program_t6',
        'program_t7', 'program_t8', 'program_t9', 'program_t10', 'dutycycle', 'dutycycleTX', 'currentpidsv', 'linecount', 'deltalinecount',
        'ax_background', 'block_update', 'fmt_data_RoR', 'fmt_data_curve', 'running_LCDs', 'plotterstack', 'plotterequationresults', 'plottermessage', 'alarm_popup_timout',
        'RTtemp1', 'RTtemp2', 'RTextratemp1', 'RTextratemp2', 'RTextratx', 'idx_met', 'showmet', 'met_annotate', 'met_timex_temp1_delta',
        'extendevents', 'statssummary', 'showtimeguide', 'statsmaxchrperline', 'energyunits', 'powerunits', 'sourcenames', 'loadlabels_setup',
        'loadratings_setup', 'ratingunits_setup', 'sourcetypes_setup', 'load_etypes_setup', 'presssure_percents_setup', 'loadevent_zeropcts_setup',
        'loadevent_hundpcts_setup', 'preheatDuration_setup', 'preheatenergies_setup', 'betweenbatchDuration_setup', 'betweenbatchenergies_setup',
        'coolingDuration_setup', 'coolingenergies_setup', 'betweenbatch_after_preheat_setup', 'electricEnergyMix_setup', 'gasMix_setup', 'energyresultunit_setup',
        'kind_list', 'loadlabels', 'loadratings', 'ratingunits', 'sourcetypes', 'load_etypes', 'presssure_percents', 'loadevent_zeropcts',
        'loadevent_hundpcts', 'preheatDuration', 'preheatenergies', 'betweenbatchDuration', 'betweenbatchenergies', 'coolingDuration', 'coolingenergies',
        'betweenbatch_after_preheat', 'electricEnergyMix', 'gasMix', 'baseX', 'baseY', 'base_horizontalcrossline', 'base_verticalcrossline',
        'base_messagevisible', 'colorDifferenceThreshold', 'handles', 'labels', 'legend_lines', 'eventmessage', 'backgroundeventmessage',
        'eventmessagetimer', 'resizeredrawing', 'logoimg', 'analysisresultsloc_default', 'analysisresultsloc', 'analysispickflag', 'analysisresultsstr',
        'analysisstartchoice', 'analysisoffset', 'curvefitstartchoice', 'curvefitoffset', 'segmentresultsloc_default', 'segmentresultsloc',
        'segmentpickflag', 'segmentdeltathreshold', 'segmentsamplesthreshold', 'stats_summary_rect', 'title_text', 'title_artist', 'title_width',
        'background_title_width', 'xlabel_text', 'xlabel_artist', 'xlabel_width', 'lazyredraw_on_resize_timer', 'mathdictionary_base',
        'ambient_pressure_sampled', 'ambient_humidity_sampled', 'ambientTemp_sampled', 'backgroundmovespeed', 'chargeTimerPeriod', 'flavors_default_value',
        'fmt_data_ON', 'l_subtitle', 'projectDeltaFlag', 'btbreak_params','bbpCache', 'glow',
        'custom_event_dlg_default_type', 'custom_event_dlg_default_type', 'foreground_event_ind', 'foreground_event_last_picked_ind',
        'foreground_event_last_picked_pos', 'background_event_ind', 'background_event_pos', 'background_event_pick_position',
        'background_event_last_picked_ind', 'background_event_last_picked_pos',
        'foreground_event_pos', 'plus_lockSchedule_sent_account', 'plus_lockSchedule_sent_date', 'specialeventplaybackramp',
        'CO2kg_per_BTU_default', 'CO2kg_per_BTU', 'Biogas_CO2_Reduction', 'Biogas_CO2_Reduction_default',
        'meterunitnames', 'meterreads_default', 'meterreads', 'meterlabels_setup', 'meterlabels', 'meterunits_setup', 'meterunits',
        'meterfuels_setup', 'meterfuels', 'metersources_setup', 'metersources'
        ]


    def __init__(self, parent:QWidget, dpi:int, locale:str, aw:'ApplicationWindow') -> None:

        self.aw = aw

        #default palette of colors
        self.locale_str:str = locale
        self.alpha:Dict[str,float] = {'analysismask':0.4,'statsanalysisbkgnd':1.0,'legendbg':0.4}
        self.palette:Dict[str,str] = {'background':'#ffffff','grid':'#e5e5e5','ylabel':'#808080','xlabel':'#808080','title':'#0c6aa6',
                        'title_focus':'#cc0f50', 'title_hidden':'#808080',
                        'rect1':'#e5e5e5','rect2':'#b2b2b2','rect3':'#e5e5e5','rect4':'#bde0ee','rect5':'#d3d3d3',
                        'et':'#cc0f50','bt':'#0a5c90','xt':'#404040','yt':'#404040','deltaet':'#cc0f50',
                        'deltabt':'#0a5c90','markers':'#000000','text':'#000000','watermarks':'#ffff00','timeguide':'#0a5c90',
                        'canvas':'#f8f8f8','legendbg':'#ffffff','legendborder':'#a9a9a9',
                        'specialeventbox':'#ff5871','specialeventtext':'#ffffff',
                        'bgeventmarker':'#7f7f7f','bgeventtext':'#000000',
                        'mettext':'#ffffff','metbox':'#cc0f50',
                        'aucguide':'#0c6aa6','messages':'#000000','aucarea':'#767676',
                        'analysismask':'#bababa','statsanalysisbkgnd':'#ffffff'}
        self.palette1 = self.palette.copy()
        self.EvalueColor_default:Final[List[str]] = ['#43a7cf','#49b160','#800080','#ad0427']
        self.EvalueTextColor_default:Final[List[str]] = ['#ffffff','#ffffff','#ffffff','#ffffff']


        # standard math functions allowed in symbolic formulas
        self.mathdictionary_base = {
            'min':min,'max':max,'sin':math.sin,'cos':math.cos,'tan':math.tan,
            'pow':math.pow,'exp':math.exp,'pi':math.pi,'e':math.e,
            'abs':abs,'acos':math.acos,'asin':math.asin,'atan':math.atan,
            'log':math.log,'radians':math.radians,
            'sqrt':math.sqrt,'degrees':math.degrees,'bit':lambda n,x:min(1,(int(x) & (1<<int(n))))}


        self.artisanflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Clean Cup'),
                                            QApplication.translate('Textbox', 'Head'),
                                            QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Body')]

        # custom labels are stored in the application settings and can be edited by the user
        self.customflavorlabels = self.artisanflavordefaultlabels

        self.SCAAflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Aftertaste'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Uniformity'),
                                        QApplication.translate('Textbox', 'Balance'),
                                        QApplication.translate('Textbox', 'Clean Cup'),
                                        QApplication.translate('Textbox', 'Sweetness'),
                                        QApplication.translate('Textbox', 'Overall')]

        self.SCAflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Aftertaste'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Intensity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Uniformity'),
                                        QApplication.translate('Textbox', 'Balance'),
                                        QApplication.translate('Textbox', 'Clean Cup'),
                                        QApplication.translate('Textbox', 'Sweetness'),
                                        QApplication.translate('Textbox', 'Overall')]

        self.CQIflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Fragance'),
                                        QApplication.translate('Textbox', 'Aroma'),
                                        QApplication.translate('Textbox', 'Flavor'),
                                        QApplication.translate('Textbox', 'Acidity'),
                                        QApplication.translate('Textbox', 'Body'),
                                        QApplication.translate('Textbox', 'Aftertaste')]

        self.SweetMariasflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Dry Fragrance'),
                                            QApplication.translate('Textbox', 'Uniformity'),
                                            QApplication.translate('Textbox', 'Complexity'),
                                            QApplication.translate('Textbox', 'Clean Cup'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Finish'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Flavor'),
                                            QApplication.translate('Textbox', 'Brightness'),
                                            QApplication.translate('Textbox', 'Wet Aroma')]

        self.Cflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Taste'),
                                            QApplication.translate('Textbox', 'Nose'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Acidity')]

        self.Eflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Fragrance-Aroma'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Flavor'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Balance')]


        self.coffeegeekflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Mouthfeel'),
                                            QApplication.translate('Textbox', 'Flavour'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Balance')]

        self.Intelligentsiaflavordefaultlabels: Final[List[str]] = [QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Finish')]

        self.IstitutoInternazionaleAssaggiatoriCaffe: Final[List[str]] = [QApplication.translate('Textbox', 'Roast Color'),
                                            QApplication.translate('Textbox', 'Crema Texture'),
                                            QApplication.translate('Textbox', 'Crema Volume'),
                                            QApplication.translate('Textbox', 'Fragrance'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Bitterness'),
                                            QApplication.translate('Textbox', 'Defects'),
                                            QApplication.translate('Textbox', 'Aroma Intensity'),
                                            QApplication.translate('Textbox', 'Aroma Persistence'),
                                            QApplication.translate('Textbox', 'Balance')]

        self.WorldCoffeeRoastingChampionship: Final[List[str]] = [QApplication.translate('Textbox', 'Aroma'),
                                            QApplication.translate('Textbox', 'Flavour'),
                                            QApplication.translate('Textbox', 'Aftertaste'),
                                            QApplication.translate('Textbox', 'Acidity'),
                                            QApplication.translate('Textbox', 'Body'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Sweetness'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Balance'),
                                            QApplication.translate('Textbox', 'Overall')]

        self.ax1:Optional[Axes] = None
        self.ax2:Optional[Axes] = None

        # Ambient Data Worker and Thread
        self.ambiWorker:Optional[AmbientWorker] = None
        self.ambiThread:Optional[QThread] = None

        # used by sample_processing
        self.afterTP:bool = False
        self.decay_weights:Optional[List[int]] = None
        self.temp_decay_weights:Optional[List[int]] = None

        # used by BTbreak
        self.btbreak_params:BTBreakParams = {
            'delay': [[40000,1000,500],               #autoChargeMode="Standard"
                      [40000,1000,500]],              #autoChargeMode="Sensitive"
            'd_charge': [[-0.67, -0.34, -0.20],       #autoChargeMode="Standard"  [delay>=1000, 500<=delay<1000, delay<500]
                         [ 0.00,  0.00,  0.00]],      #autoChargeMode="Sensitive" [delay>=1000, 500<=delay<1000, delay<500]
            'd_drop':   [[-0.34, -0.20,  0.00],       #autoDropMode="Standard"    [delay>=1000, 500<=delay<1000, delay<500]
                         [ 0.00,  0.00,  0.00]],      #autoDropMode="Sensitive"   [delay>=1000, 500<=delay<1000, delay<500]
            'offset_charge': [[0.5, 0.2, 0.0],        #autoChargeMode="Standard"  [delay>=1000, 500<=delay<1000, delay<500]
                              [0.5, 0.1, 0.0]],       #autoChargeMode="Sensitive" [delay>=1000, 500<=delay<1000, delay<500]
            'offset_drop':   [[0.2, 0.1, 0.0],        #autoDropMode="Standard"    [delay>=1000, 500<=delay<1000, delay<500]
                              [0.2, 0.05, 0.0]],      #autoDropMode="Sensitive"   [delay>=1000, 500<=delay<1000, delay<500]
            'dpre_dpost_diff': [[0.78, 0.78, 20.0],   #autoChargeMode="Standard"  [delay>=1000, 500<=delay<1000, delay<500]
                                [20.0, 20.0, 20.0]],  #autoChargeMode="Sensitive" [delay>=1000, 500<=delay<1000, delay<500]
            'tight': 3,
            'loose': 5,
            'f': 2.5,
            'maxdpre': 6.4,
            'f_dtwice': 1.5,
        }

        # invariants: len(self.flavorlabels) == len(self.flavors) > 0
        self.flavorlabels = list(self.artisanflavordefaultlabels)
        #Initial flavor parameters.
        self.flavors_default_value:float = 5.
        self.flavors:List[float] = [5.]*len(self.flavorlabels)
        self.flavors_total_correction:float = 0
        self.flavorstartangle:float = 90.
        self.flavoraspect:float = 1.0  #aspect ratio
        # flavor chart graph plots and annotations
        self.flavorchart_plotf:Optional[List[float]] = None
        self.flavorchart_angles:Optional[List[float]] = None
        self.flavorchart_plot:Optional[Line2D] = None
        self.flavorchart_fill:Optional[PolyCollection] = None
        self.flavorchart_labels:Optional[List[Annotation]] = None
        self.flavorchart_total:Optional[Text] = None

        #F = Fahrenheit; C = Celsius
        self.mode:str = 'F'

        # default mode on platforms we can detect it like macOS:
        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if QSettings().value('AppleTemperatureUnit') == 'Celsius':
                    self.mode = 'C'
            except Exception: # pylint: disable=broad-except
                pass
        else:
            # try to "guess" the users preferred temperature unit also on Windows and Linux
            try:
                if QLocale.system().countryToString(QLocale.system().country()) != 'United States':
                    self.mode = 'C'
            except Exception: # pylint: disable=broad-except
                pass

        self.mode_tempsliders = self.mode # the temperature mode of event slider to convert min/max limits

        self.errorlog:List[str] = []

        # default delay between readings in milliseconds
        self.default_delay: Final[int] = 2000 # default 2s
        self.delay:int = self.default_delay
        self.min_delay: Final[int] = 100 #250 # 1000 # Note that already a 0.25s min delay puts a lot of performance pressure on the app

        # extra event sampling interval in milliseconds. If 0, then extra sampling commands are sent "in sync" with the standard sampling commands
        self.extra_event_sampling_delay:int = 0 # sync, 0.5s, 1.0s, 1.5s,.., 5s => 0, 500, 1000, 1500, .. # 0, 500, 1000, 1500, ...

        #watermarks limits: dryphase1, dryphase2 (DRY), midphase (FCs), and finish phase Y limits
        self.phases_fahrenheit_defaults: Final[List[int]] = [300,300,390,450]
        self.phases_celsius_defaults: Final[List[int]] = [150,150,200,230]
        self.phases:List[int] = self.phases_fahrenheit_defaults # contains either the phases_filter or phases_espresso, depending on the mode
        #this flag makes the main push buttons DryEnd, and FCstart change the phases[1] and phases[2] respectively
        self.phasesbuttonflag:bool = True #False no change; True make the DRY and FC buttons change the phases during roast automatically
        self.phasesfromBackgroundflag:bool = False # False: no change; True: set phases from background profile on load
        self.watermarksflag:bool = True
        self.step100temp:Optional[int] = None # if set to a temperature value, the 100% event value in step modes is aligned with the given temperature, otherwise with the lowest phases limit

        #show phases LCDs during roasts
        self.phasesLCDflag:bool = True
        self.phasesLCDmode = 1 # one of 0: time, 1: percentage, 2: temp mode
        self.phasesLCDmode_l = [1,1,1]
        self.phasesLCDmode_all:List[bool] = [False,False,True]


        #statistics flags selects to display:
        #  0: stat. time, 1: stat. bar, 2: (stat. flavors), 3: characteristics line, 4: stat. deg/min, 5: (stat. ETBTarea), 6: stat. delta temp
        # NOTE: stat. flavors not used anymore. The code has been removed.
        #       statisticsflags[5] area is not used anymore
        self.statisticsflags:List[int] = [1,1,0,1,0,0,1]
        self.statisticsmode:int = 1 # one of 0: standard computed values, 1: roast properties, 2: total energy/CO2 data, 3: just roast energy/CO2 data

        # Area Under Curve (AUC)
        self.AUCbegin:int = 1 # counting begins after 0: CHARGE, 1: TP (default), 2: DE, 3: FCs
        self.AUCbase:float = 212 # base temperature above which the area is calculated (default 212F/110C)
        self.AUCbaseFlag:bool = False # if True, base AUC is taken from BT at AUCbegin event
        self.AUCtarget:int = 640 # target AUC for prediction
        self.AUCbackground:float = -1 # AUC of background profile or -1 if none loaded
        self.AUCtargetFlag:bool = False # if True, target is taken from the background else from self.AUCtarget
        self.AUCguideFlag:bool = False # if True a prediction line is drawn at the time the target area is reached considering current RoR
        self.AUClcdFlag:bool = False # if True a AUC LCD is displayed next to the phases LCDs to show current AUC or AUC difference to target
        self.AUCLCDmode:int = 0 # one of 0: abs value, 1: delta to target/background, 2: AUC since FCs
        self.AUCvalue:float = 0 # the running AUC value calculated during recording
        self.AUCsinceFCs:float = 0 # the running AUC since FCs calculated during recording
        self.AUCguideTime:float = 0 # the expected time in seconds the AUC target is reached (calculated by the AUC guide mechanism)
        self.AUCshowFlag:bool = False

        # timing statistics on loaded profile
        self.statisticstimes:List[float] = [0,0,0,0,0] # total, dry phase, mid phase, finish phase  and cooling phase times

        #DEVICES
        self.device:int = 18                                    # default device selected to None (18). Calls appropriate function

        self.device_logging:bool = False # turn on/off device debug logging (MODBUS, ..) # Note that MODBUS log messages are written to the main artisan log file
        # Phidget messages are logged to the artisan device log
        self.device_log_file_name = 'artisan_device'
        self.device_log_file = getDirectory(self.device_log_file_name,'.log')

        # Phidget variables

        self.phidget_dataRatesStrings : Final[List[str]] = ['32ms','64ms','128ms','256ms','512ms','768ms','1s'] # too fast: "8ms","16ms","32ms","64ms","0.12s",
        self.phidget_dataRatesValues : Final[List[int]] = [32,64,128,256,512,768,1024] # 8,16,32,64,128,

        # probe type values (along the Phidgets21 lib): k-type => 1, j-type => 2, e-type => 3, t-type => 4
        # Artisan will keep on using the Phidgets21 mapping
        self.phidget1048_types:List[int] = [1,1,1,1] # defaults all to k-type probes (values are 0-based)
        self.phidget1048_async:List[bool] = [False]*4
        self.phidget1048_changeTriggers:List[float] = [0]*4
        self.phidget1048_changeTriggersValues:List[float] = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1048_changeTriggersStrings:List[str] = [f'{x:.1f}C' for x in  self.phidget1048_changeTriggersValues]
        # add 0.02C and 0.05C change triggers
        self.phidget1048_changeTriggersValues.insert(1,0.05)
        self.phidget1048_changeTriggersValues.insert(1,0.02)
        self.phidget1048_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1048_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1048_dataRate = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active on v21 API, 256ms on v22 API)

        self.phidget1045_async:bool = False
        self.phidget1045_changeTrigger:float = 0.
        self.phidget1045_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1045_changeTriggersStrings = [f'{x}C' for x in self.phidget1045_changeTriggersValues]
        # add 0.02C and 0.05C change triggers
        self.phidget1045_changeTriggersValues.insert(1,0.05)
        self.phidget1045_changeTriggersValues.insert(1,0.02)
        self.phidget1045_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1045_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1045_emissivity:float = 1.0
        self.phidget1045_dataRate:int = 256

        self.phidget1200_async:bool = False
        self.phidget1200_formula:int = 0
        self.phidget1200_formulaValues: Final[List[str]] = ['PT100  3850', 'PT100  3920','PT1000 3850', 'PT1000 3920']
        self.phidget1200_wire:int = 0
        self.phidget1200_wireValues: Final[List[str]] = ['2-wire', '3-wire','4-wire']
        self.phidget1200_changeTrigger:float = 0
        self.phidget1200_changeTriggersValues: List[float] = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1200_changeTriggersStrings: List[str] = [f'{x}C' for x in self.phidget1200_changeTriggersValues]

        # add 0.02C and 0.05C change triggers
        self.phidget1200_changeTriggersValues.insert(1,0.05)
        self.phidget1200_changeTriggersValues.insert(1,0.02)
        self.phidget1200_changeTriggersValues.insert(1,0.01)
        self.phidget1200_changeTriggersValues.insert(1,0.005)
        self.phidget1200_changeTriggersStrings.insert(1,'0.05C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.02C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.01C')
        self.phidget1200_changeTriggersStrings.insert(1,'0.005C')
        self.phidget1200_dataRate:int = 250
        self.phidget1200_dataRatesStrings: Final[List[str]] = ['250ms','500ms','750ms','1s']
        self.phidget1200_dataRatesValues: Final[List[int]] = [250,500,700,1024]

        self.phidget1200_2_async:bool = False
        self.phidget1200_2_formula:int = 0
        self.phidget1200_2_wire:int = 0
        self.phidget1200_2_changeTrigger:float = 0
        self.phidget1200_2_dataRate:int = 250

        self.phidget1046_async: List[bool] = [False]*4
        self.phidget1046_gain: List[int] = [2]*4 # defaults to gain 8 (values are 1-based index into gainValues) # 0 is not value
        self.phidget1046_gainValues: Final[List[str]] = ['1', '8','16','32','64','128'] # 1 for no gain
        self.phidget1046_formula: List[int] = [1]*4 # 0: 1K Ohm Wheatstone Bridge, 1: 1K Ohm Voltage Divider, 2: raw
        self.phidget1046_formulaValues: Final[List[str]] = ['WS', 'Div','raw']
        self.phidget1046_dataRate:int = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active)

        self.phidgetRemoteFlag:bool = False # if True the specified remote server is harvestd to potentially attached Phidget devices
        self.phidgetRemoteOnlyFlag:bool = False # if True only Phidgets attached to remote servers are attached
        self.phidgetServerID:str = ''
        self.phidgetPassword:str = ''
        self.phidgetPort:int = 5661
        self.phidgetServerAdded:bool = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetServiceDiscoveryStarted:bool = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetManager:Optional[PhidgetManager] = None

        self.yoctoRemoteFlag:bool = False
        self.yoctoServerID = '127.0.0.1'
        self.YOCTOchanUnit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan1Unit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan2Unit = 'C' # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTO_emissivity = 1.0
        self.YOCTO_async = [False]*2
        self.YOCTO_dataRate = 256 # in ms
        self.YOCTO_dataRatesStrings: Final[List[str]] = ['32ms','64ms','128ms','256ms','512ms','768ms','1s','1s*']
        self.YOCTO_dataRatesValues: Final[List[int]] = [32,64,128,256,512,768,1000,1024] # the 1024 mode returns every sec an average over the period, while 1000 returns every second the last sample

        self.phidget1018valueFactor = 1000 # we map the 0-5V voltage returned by the Phidgets22 API to mV (0-5000)
        self.phidget1018_async = [False]*8
        self.phidget1018_ratio = [False]*8 # if True VoltageRatio instead of VoltageInput is returned
        self.phidget1018_dataRates = [256]*8 # in ms; (Phidgets default 256ms, min is 8ms, 16ms if wireless is active), max 1000ms
                # with the new PhidgetsAPI the 1011/1018 dataRate is from 1ms to 1.000ms
        self.phidget1018_changeTriggers = [10]*8
        self.phidget1018_changeTriggersValues: Final[List[int]] = list(range(0,51,1))
        self.phidget1018_changeTriggersStrings: Final[List[str]] = [f'{x*10}mV' for x in self.phidget1018_changeTriggersValues]

        self.phidgetVCP100x_voltageRanges: List[int] = [VoltageRange.VOLTAGE_RANGE_AUTO]*8
        self.phidgetVCP100x_voltageRangeValues: Final[List[int]] = [
            VoltageRange.VOLTAGE_RANGE_AUTO,
            VoltageRange.VOLTAGE_RANGE_10mV,
            VoltageRange.VOLTAGE_RANGE_40mV,
            VoltageRange.VOLTAGE_RANGE_200mV,
            VoltageRange.VOLTAGE_RANGE_312_5mV,
            VoltageRange.VOLTAGE_RANGE_400mV,
            VoltageRange.VOLTAGE_RANGE_1000mV,
            VoltageRange.VOLTAGE_RANGE_2V,
            VoltageRange.VOLTAGE_RANGE_5V,
            VoltageRange.VOLTAGE_RANGE_15V,
            VoltageRange.VOLTAGE_RANGE_40V
        ]
        self.phidgetVCP100x_voltageRangeStrings: Final[List[str]] = [
            'Auto',
            '±10mV',
            '±40mV',
            '±200mV',
            '±312.5mV',
            '±400mV',
            '±1000mV',
            '±2V',
            '±5V',
            '±15V',
            '±40V'
        ]

        self.phidgetDAQ1400_powerSupplyStrings: Final[List[str]] = ['--','12V','24V']
        self.phidgetDAQ1400_powerSupply:int = 1
        self.phidgetDAQ1400_inputModeStrings: Final[List[str]] = ['NPN','PNP']
        self.phidgetDAQ1400_inputMode:int = 0

        #menu of thermocouple devices
        #device with first letter + only shows in extra device tab
        #device with first letter - does not show in any tab (but its position in the list is important)
        # device labels (used in Dialog config).

        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:" in the code
        # (check also the tags in comm.py and devices.py!!)
        # - add to self.devices
        self.devices: Final[List[str]] = [
                        #Fuji PID               #0
                       'Omega HH806AU',         #1
                       'Omega HH506RA',         #2
                       'CENTER 309',            #3
                       'CENTER 306',            #4
                       'CENTER 305',            #5
                       'CENTER 304',            #6
                       'CENTER 303',            #7
                       'CENTER 302',            #8
                       'CENTER 301',            #9
                       'CENTER 300',            #10
                       'VOLTCRAFT K204',        #11
                       'VOLTCRAFT K202',        #12
                       'VOLTCRAFT 300K',        #13
                       'VOLTCRAFT 302KJ',       #14
                       'EXTECH 421509',         #15
                       'Omega HH802U',          #16
                       'Omega HH309',           #17
                       'NONE',                  #18
                       '-ARDUINOTC4',           #19
                       'TE VA18B',              #20
                       '+CENTER 309 34',        #21
                       '+PID SV/DUTY %',        #22
                       'Omega HHM28[6]',        #23
                       '+VOLTCRAFT K204 34',    #24
                       '+Virtual',              #25
                       '-DTAtemperature',       #26
                       'Program',               #27
                       '+ArduinoTC4 34',        #28
                       'MODBUS',                #29
                       'VOLTCRAFT K201',        #30
                       'Amprobe TMD-56',        #31
                       '+ArduinoTC4 56',        #32
                       '+MODBUS 34',            #33
                       'Phidget 1048 4xTC 01',  #34
                       '+Phidget 1048 4xTC 23', #35
                       '+Phidget 1048 4xTC AT', #36
                       'Phidget 1046 4xRTD 01', #37
                       '+Phidget 1046 4xRTD 23',#38
                       'Mastech MS6514',        #39
                       'Phidget IO 01',         #40
                       '+Phidget IO 23',        #41
                       '+Phidget IO 45',        #42
                       '+Phidget IO 67',        #43
                       '+ArduinoTC4 78',        #44
                       'Yocto Thermocouple',    #45
                       'Yocto PT100',           #46
                       'Phidget 1045 IR',       #47
                       '+Program 34',           #48
                       '+Program 56',           #49
                       'DUMMY',                 #50
                       '+CENTER 304 34',        #51
                       'Phidget 1051 1xTC 01',  #52
                       'Hottop BT/ET',          #53
                       '+Hottop Heater/Fan',    #54
                       '+MODBUS 56',            #55
                       'Apollo DT301',          #56
                       'EXTECH 755',            #57
                       'Phidget TMP1101 4xTC 01',  #58
                       '+Phidget TMP1101 4xTC 23', #59
                       '+Phidget TMP1101 4xTC AT', #60
                       'Phidget TMP1100 1xTC',     #61
                       'Phidget 1011 IO 01',       #62
                       'Phidget HUB IO 01',        #63
                       '+Phidget HUB IO 23',       #64
                       '+Phidget HUB IO 45',       #65
                       '-Omega HH806W',            #66 NOT WORKING
                       'VOLTCRAFT PL-125-T2',      #67
                       'Phidget TMP1200 1xRTD A',  #68
                       'Phidget IO Digital 01',    #69
                       '+Phidget IO Digital 23',   #70
                       '+Phidget IO Digital 45',   #71
                       '+Phidget IO Digital 67',   #72
                       'Phidget 1011 IO Digital 01', #73
                       'Phidget HUB IO Digital 01', #74
                       '+Phidget HUB IO Digital 23',#75
                       '+Phidget HUB IO Digital 45',#76
                       'VOLTCRAFT PL-125-T4',       #77
                       '+VOLTCRAFT PL-125-T4 34',   #78
                       'S7',                        #79
                       '+S7 34',                    #80
                       '+S7 56',                    #81
                       '+S7 78',                    #82
                       'Aillio Bullet R1 BT/DT',             #83
                       '+Aillio Bullet R1 Heater/Fan',       #84
                       '+Aillio Bullet R1 BT RoR/Drum',      #85
                       '+Aillio Bullet R1 Voltage/Exhaust',  #86
                       '+Aillio Bullet R1 State/Fan RPM',    #87
                       '+Program 78',               #88
                       '+Program 910',              #89
                       '+Slider 01',                #90
                       '+Slider 23',                #91
                       '-Probat Middleware',                 #92
                       '-Probat Middleware burner/drum',     #93
                       '-Probat Middleware fan/pressure',    #94
                       'Phidget DAQ1400 Current',   #95
                       'Phidget DAQ1400 Frequency', #96
                       'Phidget DAQ1400 Digital',   #97
                       'Phidget DAQ1400 Voltage',   #98
                       'Aillio Bullet R1 IBTS/BT',  #99
                       'Yocto IR',                  #100
                       'Behmor BT/CT',              #101
                       '+Behmor 34',                #102
                       'VICTOR 86B',                #103
                       '+Behmor 56',                #104
                       '+Behmor 78',                #105
                       'Phidget HUB IO 0',          #106
                       'Phidget HUB IO Digital 0',  #107
                       'Yocto 4-20mA Rx',           #108
                       '+MODBUS 78',                #109
                       '+S7 910',                   #110
                       'WebSocket',                 #111
                       '+WebSocket 34',             #112
                       '+WebSocket 56',             #113
                       '+Phidget TMP1200 1xRTD B',  #114
                       'HB BT/ET',                  #115
                       '+HB DT/IT',                 #116
                       '+HB AT',                    #117
                       '+WebSocket 78',             #118
                       '+WebSocket 910',            #119
                       'Yocto 0-10V Rx',            #120
                       'Yocto milliVolt Rx',        #121
                       'Yocto Serial',              #122
                       'Phidget VCP1000',           #123
                       'Phidget VCP1001',           #124
                       'Phidget VCP1002',           #125
                       'ARC BT/ET',                 #126
                       '+ARC MET/IT',               #127
                       '+ARC AT',                   #128
                       'Yocto Power',               #129
                       'Yocto Energy',              #130
                       'Yocto Voltage',             #131
                       'Yocto Current',             #132
                       'Yocto Sensor',              #133
                       'Santoker BT/ET',            #134
                       '+Santoker Power/Fan',       #135
                       '+Santoker Drum',            #136
                       'Phidget DAQ1500',           #137
                       'Kaleido BT/ET',             #138
                       '+Kaleido SV/AT',            #139
                       '+Kaleido Drum/AH',          #140
                       '+Kaleido Heater/Fan',       #141
                       'IKAWA',                     #142
                       '+IKAWA SET/RPM',            #143
                       '+IKAWA Heater/Fan',         #144
                       '+IKAWA State/Humidity',     #145
                       'Phidget DAQ1000 01',        #146
                       '+Phidget DAQ1000 23',       #147
                       '+Phidget DAQ1000 45',       #148
                       '+Phidget DAQ1000 67',       #149
                       '+MODBUS 910',               #150
                       '+S7 1112',                  #151
                       'Phidget DAQ1200 01',        #152
                       '+Phidget DAQ1200 23',       #153
                       'Phidget DAQ1300 01',        #154
                       '+Phidget DAQ1300 23',       #155
                       'Phidget DAQ1301 01',        #156
                       '+Phidget DAQ1301 23',       #157
                       '+Phidget DAQ1301 45',       #158
                       '+Phidget DAQ1301 67',       #159
                       f'+IKAWA {deltaLabelUTF8}Humidity/{deltaLabelUTF8}Humidity Dir.',    #160
                       '+Omega HH309 34',           #161
                       'Digi-Sense 20250-07',       #162
                       'Extech 42570',              #163
                       'Mugma BT/ET',               #164
                       '+Mugma Heater/Fan',         #165
                       '+Mugma Heater/Catalyzer',   #166
                       '+Mugma SV',                 #167
                       'Phidget TMP1202 1xRTD A',   #168
                       '+Phidget TMP1202 1xRTD B',  #169
                       'ColorTrack Serial',         #170
                       'Santoker R BT/ET',          #171
                       '+Santoker IR/Board',        #172
                       '+Santoker DelatBT/DeltaET', #173
                       'ColorTrack BT',             #174
                       'Thermoworks BlueDOT'        #175
                       ]

        # ADD DEVICE:
        # ids of (main) Phidget devices (without a + in front of their name string)
        self.phidgetDevices : Final[List[int]] = [
            34, # Phidget 1048
            37, # Phidget 1046
            40, # Phidget IO
            47, # Phidget 1045
            52, # Phidget 1051
            58, # Phidget TMP1101
            61, # Phidget TMP1100
            62, # Phidget 1011
            63, # Phidget HUB IO 01
            64, # Phidget HUB IO 23 # + device but need to be mounted directly
            65, # Phidget HUB IO 45 # + device but need to be mounted directly
            68, # Phidget TMP1200
            69, # Phidget IO Digital
            73, # Phidget 1011 IO Digital
            74, # Phidget HUB IO Digital 01
            75, # Phidget HUB IO Digital 23 # + device but need to be mounted directly
            76, # Phidget HUB IO Digital 45 # + device but need to be mounted directly
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            123, # Phidget VCP1000
            124, # Phidget VCP1001
            125, # Phidget VCP1002
            137, # Phidget DAQ1500
            146, # Phidget DAQ1000 01
            152, # Phidget DAQ1200 01
            154, # Phidget DAQ1300 01
            156, # Phidget DAQ1301 01
            168, # Phidget TMP1202
        ]

        # ADD DEVICE:
        # ids of (main) devices (without a + in front of their name string)
        # that do NOT communicate via any serial port thus do not need any serial port configuration
        self.nonSerialDevices : Final[List[int]] = self.phidgetDevices + [
            18, # NONE (manual)
            27, # Program
            45, # Yocto Thermocouple
            46, # Yocto PT100
            79, # S7
            83, # Aillio Bullet R1 BT/DT
            99, # Aillio Bullet R1 IBTS/BT
            100, # Yocto IR
            108, # Yocto 4-20mA Rx
            111, # WebSocket
            120, # Yocto-0-10V-Rx
            121, # Yocto-milliVolt-Rx
            122, # Yocto-Serial
            129, # Yocto Power
            130, # Yocto Energy
            131, # Yocto Voltage
            132, # Yocto Current
            133, # Yocto Sensor
            134, # Santoker BT/ET
            138, # Kaleido BT/ET
            142, # IKAWA,
            164, # Mugma BT/ET
            171, # Santoker R BT/ET
            174, # ColorTrack BT
            175  # Thermoworks BlueDOT
        ]

        # ADD DEVICE:
        # ids of devices temperature conversions should not be applied
        self.nonTempDevices : Final[List[int]] = [
            22, # +PID SV/DUTY %
            25, # +Virtual
            40, # Phidget IO 01
            41, # +Phidget IO 23
            42, # +Phidget IO 45
            43, # +Phidget IO 67
            50, # DUMMY
            54, # +Hottop Heater/Fan
            57, # EXTECH 755
            62, # Phidget 1011 IO 01
            63, # Phidget HUB IO 01
            64, # +Phidget HUB IO 23
            65, # +Phidget HUB IO 45
            69, # Phidget IO Digital 01
            70, # +Phidget IO Digital 23
            71, # +Phidget IO Digital 45
            72, # +Phidget IO Digital 67
            73, # Phidget 1011 IO Digital 01
            74, # Phidget HUB IO Digital 0
            75, # +Phidget HUB IO Digital 23
            76, # +Phidget HUB IO Digital 45
            84, # +Aillio Bullet R1 Heater/Fan
            87, # +Aillio Bullet R1 State
            90, # +Slider 01
            91, # +Slider 23
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            108, # Yocto 4-20mA Rx
            120, # Yocto-0-10V-Rx
            121, # Yocto-milliVolt-Rx
            122, # Yocto-Serial
            123, # Phidget VCP1000
            124, # Phidget VCP1001
            125, # Phidget VCP1002
            129, # Yocto Power
            130, # Yocto Energy
            131, # Yocto Voltage
            132, # Yocto Current
            133, # Yocto Sensor
            135, # Santoker Power/Fan
            136, # Santoker Drum
            137, # Phidget DAQ1500
            140, # Kaleido Drum/AH
            141, # Kaleido Heater/Fan
            143, # IKAWA Set/RPM
            144, # IKAWA Heater/Fan
            145, # IKAWA State/Humidity
            146, # Phidget DAQ1000 01
            147, # +Phidget DAQ1000 23
            148, # +Phidget DAQ1000 45
            149, # +Phidget DAQ1000 67
            152, # Phidget DAQ1200 01
            153, # +Phidget DAQ1200 23
            154, # Phidget DAQ1300 01
            155, # +Phidget DAQ1300 23
            156, # Phidget DAQ1301 01
            157, # +Phidget DAQ1301 23
            158, # +Phidget DAQ1301 45
            159, # +Phidget DAQ1301 67
            160, # IKAWA \Delta Humidity / \Delat Humidity direction
            165, # +Mugma Heater/Fan
            166, # +Mugma Heater/Catalyzer
            170, # ColorTrack Serial
            173, # +Santoker BT RoR / ET RoR
            174  # ColorTrack BT
        ]

        # ADD DEVICE:
        # ids of special devices certain input filters should not be applied
        self.specialDevices : Final[List[int]] = [
            18, # NONE (Manual)
            25, # Virtual
            50, # Dummy
            90, # Slider01
            91  # Slider23
        ]

        # ADD DEVICE:
        # ids of binary devices certain input filters should not be applied
        self.binaryDevices : Final[List[int]] = [
            69, # Phidget IO Digital 01
            70, # Phidget IO Digital 23
            71, # Phidget IO Digital 45
            72, # Phidget IO Digital 67
            73, # Phidget 1011 IO Digital 01
            74, # Phidget HUB IO Digital 01
            75, # Phidget HUB IO Digital 23
            76  # Phidget HUB IO Digital 45
        ]

        #extra devices
        self.extradevices:List[int] = []                            # list with indexes for extra devices
        self.extratimex:List[List[float]] = []                      # individual time for each extra device (more accurate). List of lists (2 dimension)
        #NOTE: extra device colors may contain alpha information thus to turn them into QColors, one needs to truncate the string by [:7] to remove the alpha or
        #  or first convert the color string using util.rgba_colorname2argb_colorname to preserve the alpha information
        self.extradevicecolor1:List[str] = []                       # extra line 1 color. list with colors.
        self.extradevicecolor2:List[str] = []                       # extra line 2 color. list with colors.
        self.extratemp1:List[List[float]] = []                      # extra temp1. List of lists
        self.extratemp2:List[List[float]] = []                      # extra temp2. List of lists
        self.extrastemp1:List[List[float]] = []                     # smoothed extra temp1. List of lists
        self.extrastemp2:List[List[float]] = []                     # smoothed extra temp2. List of lists
        # variants of extratimex/extratemp1/extratemp2 with -1 dropout values removed (or replaced by None)
        self.extractimex1:List[List[float]] = []
        self.extractimex2:List[List[float]] = []
        self.extractemp1:List[List[Optional[float]]] = []
        self.extractemp2:List[List[Optional[float]]] = []
        # NOTE: those extractimexN, extractempBN lists can be shorter than the regular extratimexN, extratempN lists,
        # however, the invariants len(extractimex1) = len(extractemp1) and len(extractimex2) = len(extractemp2) always hold
        self.extratemp1lines:List[Line2D] = []                      # lists with extra lines for speed drawing
        self.extratemp2lines:List[Line2D] = []
        self.extraname1:List[str] = []                              # name of labels for line (like ET or BT) - legend
        self.extraname2:List[str] = []
        self.extramathexpression1:List[str] = []                    # list with user defined math evaluating strings. Example "2*cos(x)"
        self.extramathexpression2:List[str] = []
        self.extralinestyles1:List[str] = []                        # list of extra curve line styles
        self.extralinestyles2:List[str] = []                        # list of extra curve line styles
        self.extradrawstyles1:List[str] = []                        # list of extra curve drawing styles
        self.extradrawstyles2:List[str] = []                        # list of extra curve drawing styles
        self.extralinewidths1:List[float] = []                      # list of extra curve 1 linewidth
        self.extralinewidths2:List[float] = []                      # list of extra curve 2 linewidth
        self.extramarkers1: List[str] = []                          # list of extra curve marker styles
        self.extramarkers2: List[str] = []                          # list of extra curve marker styles
        self.extramarkersizes1: List[float] = []                    # list of extra curve marker size
        self.extramarkersizes2: List[float] = []                    # list of extra curve marker size

        self.devicetablecolumnwidths:List[int] = []

        # the following two list are generated on ON from the extradevices types and might be longer or smaller than len(self.extradevices)
        # if no entry is available, a temperature curve that needs C<->F translation is assumed
        # note that ET/BT main curves are assumed to always hold temperatures
        self.extraNoneTempHint1:List[bool] = []                                # list of flags indicating which extra 1 curves are not holding temperature values
        self.extraNoneTempHint2:List[bool] = []                                # list of flags indicating which extra 2 curves are not holding temperature values

        #holds math expressions to plot
        self.plotcurves:List[str]=['']*9
        self.plotcurvecolor:List[str] = ['#000000']*9

        self.overlapList:List[Tuple[float,float,float,float]] = []

        self.tight_layout_params: Final[Dict[str,float]] = {'pad':.3,'h_pad':0.0,'w_pad':0.0} # slightly less space for axis labels
        self.fig:Figure = Figure(tight_layout=self.tight_layout_params,frameon=True,dpi=dpi)
        # with tight_layout=True, the matplotlib canvas expands to the maximum using figure.autolayout

        self.fig.patch.set_facecolor(str(self.palette['canvas']))

        self.ax:Optional[Axes]
        self.ax = self.fig.add_subplot(111,facecolor=self.palette['background'])
        self.delta_ax:Optional[_AxesBase] = self.ax.twinx()

        #legend location
        self.legendloc:int = 7
        self.legendloc_pos:Optional[Tuple[float,float]] = None # holds the custom position of the legend set on profile load and reset after first redraw

        self.fig.subplots_adjust(
            # all values in percent
            top=0.93, # the top of the subplots of the figure (default: 0.9)
            bottom=0.1, # the bottom of the subplots of the figure (default: 0.1)
            left=0.067, # the left side of the subplots of the figure (default: 0.125)
            right=.925) # the right side of the subplots of the figure (default: 0.9
        FigureCanvas.__init__(self, self.fig) # type: ignore

        self.fig.canvas.set_cursor = lambda _: None # type: ignore # deactivate the busy cursor on slow full redraws

        # important to make the Qt canvas transparent (note that this changes stylesheets of children like popups too!):
        if isinstance(self.fig.canvas, QWidget):
            cast(QWidget, self.fig.canvas).setStyleSheet('background-color:transparent;') # default is white

        self.onclick_cid = self.fig.canvas.mpl_connect('button_press_event', cast('Callable[[Event],None]',self.onclick))
        self.oncpick_cid = self.fig.canvas.mpl_connect('pick_event', cast('Callable[[Event],None]', self.onpick)) # incompatible type "Callable[[PickEvent], None]"; expected "Callable[[Event], Any] # type: ignore[arg-type]
        self.ondraw_cid = self.fig.canvas.mpl_connect('draw_event', self._draw_event)

        self.custom_event_dlg_default_type:int = 4 # the default type remembered by the customEventDlg on adding events via a right click on the graph
        self.foreground_event_ind:Optional[int] = None # index of the currently moved event marker in self.specialevents
        self.foreground_event_pos:Optional[int] = None # position of the currently moved event marker in its 2DLine.xdata() value array
        self.foreground_event_pick_position:Optional[Tuple[float,float]] = None # pick position, as (x-time,y-value) tuple, of the currently moved event
        self.foreground_event_last_picked_ind:Optional[int] = None # index of the last picked event marker in self.specialevents to be deleted via backspace or moved by cursor keys
        self.foreground_event_last_picked_pos:Optional[int] = None # position of the last picked event marker in its 2DLine.xdata() value array to be deleted via backspace or moved by cursor keys
        #
        self.background_event_ind:Optional[int] = None
        self.background_event_pos:Optional[int] = None
        self.background_event_pick_position:Optional[Tuple[float,float]] = None
        self.background_event_last_picked_ind:Optional[int] = None # index of the last picked event marker in self.specialevents to be deleted via backspace or moved by cursor keys
        self.background_event_last_picked_pos:Optional[int] = None # position of the last picked event marker in its 2DLine.xdata() value array to be deleted via backspace or moved by cursor keys

        self.onmove_cid = self.fig.canvas.mpl_connect('motion_notify_event', cast('Callable[[Event],None]', self.onmove))

        self.fig.canvas.mpl_connect('button_release_event', self.onrelease_after_pick)

        # set the parent widget
        self.setParent(parent)
        # we define the widget as
        FigureCanvas.setSizePolicy(self,QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)  #@UndefinedVariable
        # notify the system of updated policy
        FigureCanvas.updateGeometry(self)  #@UndefinedVariable

        # the rate of change of temperature
        self.rateofchange1:float = 0.0
        self.rateofchange2:float = 0.0

        #read and plot on/off flag
        self.flagon:bool = False  # Artisan turned on (sampling)
        self.flagstart:bool = False # Artisan logging/recording
        self.flagKeepON:bool = False # turn Artisan ON again after pressing OFF during recording
        self.flagOpenCompleted:bool = False # after completing a recording with OFF, send the saved profile to be opened in the ArtisanViewer
        self.flagsampling:bool = False # if True, Artisan is still in the sampling phase and one has to wait for its end to turn OFF
        self.flagsamplingthreadrunning:bool = False
        #log flag that tells to log ET when using device 18 (manual mode)
        self.manuallogETflag = 0

        self.zoom_follow:bool = False # if True, Artisan "follows" BT in the center by panning during recording. Activated via a click on the HOME icon

        self.alignEvent = 0 # 0:CHARGE, 1:DRY, 2:FCs, 3:FCe, 4:SCs, 5:SCe, 6:DROP, 7:ALL
        self.alignnames = [
            QApplication.translate('Label','CHARGE'),
            QApplication.translate('Label','DRY'),
            QApplication.translate('Label','FCs'),
            QApplication.translate('Label','FCe'),
            QApplication.translate('Label','SCs'),
            QApplication.translate('Label','SCe'),
            QApplication.translate('Label','DROP'),
            QApplication.translate('Label','ALL'),
            ]
        self.compareAlignEvent = 0 # 0:CHARGE, 1:DRY, 2:FCs, 3:FCe, 4:SCs, 5:SCe, 6:DROP
        self.compareEvents = 0 # 0: no events, 1: event type 1, 2: event type 2, 3: event type 3, 4: event type 4
        self.compareET:bool = False
        self.compareBT:bool = True
        self.compareDeltaET:bool = False
        self.compareDeltaBT:bool = True
        self.compareMainEvents:bool = True
        self.compareExtraCurves1:List[bool] = [False]*self.aw.nLCDS
        self.compareExtraCurves2:List[bool] = [False]*self.aw.nLCDS
        # Comparator: Roast (compareBBP=False & compareRoast=True); BBP+Roast (compareBBP=True & compareRoast=True); BBP (compareBBP=True & compareRoast=False)
        #   the state compareBBP=False and compareRoast=False should never occur
        self.compareBBP:bool = False # if True incl. BBP
        self.compareRoast:bool = True # if False roast should not be compared (self.compareBBP should be True in this case!)

        self.replayType:int = 0 # 0: by time, 1: by BT, 2: by ET
        self.replayedBackgroundEvents:Set[int] = set()  # set of BackgroundEvent indices that have already been replayed (cleared in ClearMeasurements)
        self.beepedBackgroundEvents:Set[int] = set()   # set of BackgroundEvent indices that have already been beeped for (cleared in ClearMeasurements)

        self.roastpropertiesflag:int = 1  #resets roast properties if not zero
        self.roastpropertiesAutoOpenFlag:int = 0  #open roast properties dialog on CHARGE if not zero
        self.roastpropertiesAutoOpenDropFlag:int = 0  #open roast properties dialog on DROP if not zero
        self.title:str = QApplication.translate('Scope Title', 'Roaster Scope')
        self.title_show_always:bool = False
        self.ambientTemp:float = 0.
        self.ambientTemp_sampled:float = 0. # keeps the measured ambientTemp over a restart
        self.ambientTempSource:int = 0 # indicates the temperature curve that is used to automatically fill the ambient temperature on DROP
#                                  # 0 : None; 1 : ET, 2 : BT, 3 : 0xT1, 4 : 0xT2,
        self.ambient_temperature_device:int = 0
        self.ambient_pressure:float = 0.
        self.ambient_pressure_sampled:float = 0. # keeps the measured ambient_pressure over a restart/reset
        self.ambient_pressure_device:int = 0
        self.ambient_humidity:float = 0.
        self.ambient_humidity_sampled:float = 0. # keeps the measured ambient_humidity over a restart/reset
        self.ambient_humidity_device:int = 0
        self.elevation:int = 0

        self.temperaturedevicefunctionlist: Final[List[str]] = [
            '',                #0
            'Phidget HUM100x', #1
            'Yocto Meteo',     #2
            'Phidget TMP1000', #3
        ]
        self.humiditydevicefunctionlist: Final[List[str]] = [
            '',                #0
            'Phidget HUM100x', #1
            'Yocto Meteo',     #2
        ]
        self.pressuredevicefunctionlist: Final[List[str]] = [
            '',                #0
            'Phidget PRE1000', #1
            'Yocto Meteo',     #2
        ]

        self.moisture_greens:float = 0.
        self.moisture_roasted:float = 0.
        self.greens_temp:float = 0.

        self.beansize:float = 0.0 # legacy; now mapped to beansize_max on load
        self.beansize_min:int = 0
        self.beansize_max:int = 0

        self.whole_color:int = 0
        self.ground_color:int = 0
        self.color_systems: Final[List[str]] = ['','Tonino','ColorTest','Colorette','ColorTrack','Agtron']
        self.color_system_idx:int = 0

        # roast property flags
        self.heavyFC_flag:bool = False
        self.lowFC_flag:bool = False
        self.lightCut_flag:bool = False
        self.darkCut_flag:bool = False
        self.drops_flag:bool = False
        self.oily_flag:bool = False
        self.uneven_flag:bool = False
        self.tipping_flag:bool = False
        self.scorching_flag:bool = False
        self.divots_flag:bool = False

        #list to store the time in seconds of each reading. Most IMPORTANT variable.
        self.timex:List[float] = []

        #lists to store temps and rates of change. Second most IMPORTANT variables. All need same dimension.
        #self.temp1 = ET ; self.temp2 = BT; self.delta1 = deltaMET; self.delta2 = deltaBT
        self.temp1:List[float] = []
        self.temp2:List[float] = []
        self.delta1:List[Optional[float]] = []
        self.delta2:List[Optional[float]] = []
        self.stemp1:List[float] = [] # smoothed versions of temp1/temp2 used in redraw()
        self.stemp2:List[float] = []
        self.tstemp1:List[float] = [] # (temporarily) smoothed version of temp1/temp2 used in sample() to compute the RoR
        self.tstemp2:List[float] = []
        self.ctimex1:List[float] = [] # (potential shorter) variants of timex/temp1/temp2 with -1 dropout values removed (or replaced by None)
        self.ctimex2:List[float] = []
        self.ctemp1:List[Optional[float]] = []
        self.ctemp2:List[Optional[float]] = []
        # NOTE: those ctimexN, ctempN lists can be shorter than the original timex/tempN lists as some dropout values may have been removed,
        # however, the invariants len(ctimex1) = len(ctemp1) and len(timex2) = len(ctemp2) always hold
        self.unfiltereddelta1:List[float] = [] # Delta mathexpressions applied; used in sample()
        self.unfiltereddelta2:List[float] = []
        self.unfiltereddelta1_pure:List[float] = [] # Delta mathexpressions not applied; used in sample() and by projections
        self.unfiltereddelta2_pure:List[float] = []

        # arrays to use while monitoring but not recording
        self.on_timex:List[float] = []
        self.on_temp1:List[float] = []
        self.on_temp2:List[float] = []
        self.on_ctimex1:List[float] = []
        self.on_ctemp1:List[Optional[float]] = []
        self.on_ctimex2:List[float] = []
        self.on_ctemp2:List[Optional[float]] = []
        self.on_tstemp1:List[float] = []
        self.on_tstemp2:List[float] = []
        self.on_unfiltereddelta1:List[float] = []
        self.on_unfiltereddelta2:List[float] = []
        self.on_delta1:List[Optional[float]] = []
        self.on_delta2:List[Optional[float]] = []
        # list of lists:
        self.on_extratemp1:List[List[float]] = []
        self.on_extratemp2:List[List[float]] = []
        self.on_extratimex:List[List[float]] = []
        self.on_extractimex1:List[List[float]] = []
        self.on_extractemp1:List[List[Optional[float]]] = []
        self.on_extractimex2:List[List[float]] = []
        self.on_extractemp2:List[List[Optional[float]]] = []

        # data for projection lines
        self.BTprojection_tx:List[float] = []
        self.BTprojection_temp:List[float] = []
        self.ETprojection_tx:List[float] = []
        self.ETprojection_temp:List[float] = []
        self.DeltaBTprojection_tx:List[float] = []
        self.DeltaBTprojection_temp:List[float] = []
        self.DeltaETprojection_tx:List[float] = []
        self.DeltaETprojection_temp:List[float] = []

        #indexes for CHARGE[0],DRYe[1],FCs[2],FCe[3],SCs[4],SCe[5],DROP[6] and COOLe[7]
        #Example: Use as self.timex[self.timeindex[1]] to get the time of DryEnd
        #Example: Use self.temp2[self.timeindex[4]] to get the BT temperature of SCs

        self.timeindex:List[int] = [-1,0,0,0,0,0,0,0] #CHARGE index init set to -1 as 0 could be an actual index used

        #applies a Y(x) function to ET or BT
        self.ETfunction:str = ''
        self.BTfunction:str = ''

        #applies a Y(x) function to DeltaET or DeltaBT
        self.DeltaETfunction = ''
        self.DeltaBTfunction = ''

        #put a "self.safesaveflag = True" whenever there is a change of a profile like at [DROP], edit properties Dialog, etc
        #prevents accidentally deleting a modified profile. ("dirty file")
        #ATTENTION: never change this flag directly. Use the methods self.fileDirty() and self.fileClean() instead!!
        self.safesaveflag:bool = False

        self.pid = pid.PID()

        #background profile
        self.background:bool = False # set to True if loaded background profile is shown and False if hidden
        self.backgroundprofile:Optional[ProfileData] = None # if not None, a background profile is loaded
        self.backgroundprofile_moved_x:int = 0 # background profile moved in horizontal direction
        self.backgroundprofile_moved_y:int = 0 # background profile moved in vertical direction
        self.backgroundDetails:bool = True
        self.backgroundeventsflag:bool = True
        self.backgroundpath:str = ''
        self.backgroundUUID:Optional[str] = None
        self.backgroundmovespeed = 30
        self.backgroundShowFullflag:bool = False
        self.backgroundKeyboardControlFlag:bool = True
        self.titleB:str = ''
        self.roastbatchnrB:int = 0
        self.roastbatchprefixB:str = ''
        self.roastbatchposB:int = 1
        self.temp1B:List[float] = []
        self.temp2B:List[float] = []
        self.temp1BX:List[npt.NDArray[numpy.double]] = []
        self.temp2BX:List[npt.NDArray[numpy.double]] = []
        self.timeB:List[float] = []
        self.abs_timeB:List[float] = []
        self.temp1Bdelta:List[float] = []
        self.temp2Bdelta:List[float] = []
        # smoothed versions of the background curves
        self.stemp1B:npt.NDArray[numpy.double] = numpy.empty(0)
        self.stemp2B:npt.NDArray[numpy.double] = numpy.empty(0)
        self.stemp1BX:List[npt.NDArray[numpy.double]] = []
        self.stemp2BX:List[npt.NDArray[numpy.double]] = []
        self.extraname1B:List[str] = []
        self.extraname2B:List[str] = []
        self.extratimexB:List[List[float]] = []
        self.xtcurveidx:int = 0 # the selected first extra background courve to be displayed
        self.ytcurveidx:int = 0 # the selected second extra background courve to be displayed
        self.delta1B:List[Optional[float]] = []
        self.delta2B:List[Optional[float]] = []
        self.timeindexB:List[int] = [-1,0,0,0,0,0,0,0]
        self.TP_time_B_loaded:Optional[float] = None # the time in seconds the background TP happens. TP_time_B_loaded does not change and should be used for display
        self.backgroundEvents:List[int] = [] #indexes of background events
        self.backgroundEtypes:List[int] = []
        self.backgroundEvalues:List[float] = []
        self.backgroundEStrings:List[str] = []
        self.backgroundalpha:float = 0.2
        self.backgroundmetcolor:str = self.palette['et']
        self.backgroundbtcolor:str = self.palette['bt']
        self.backgroundxtcolor:str = self.palette['xt']
        self.backgroundytcolor:str = self.palette['yt']
        self.backgrounddeltaetcolor:str = self.palette['deltaet']
        self.backgrounddeltabtcolor:str = self.palette['deltabt']
        self.detectBackgroundEventTime:int = 20 #seconds
        self.backgroundReproduce:bool = False
        self.backgroundReproduceBeep:bool = False
        self.backgroundPlaybackEvents:bool = False
        self.backgroundPlaybackDROP:bool = False
        self.Betypes:List[str] = [QApplication.translate('ComboBox', 'Air'),
                        QApplication.translate('ComboBox', 'Drum'),
                        QApplication.translate('ComboBox', 'Damper'),
                        QApplication.translate('ComboBox', 'Burner'),
                        '--']
        self.backgroundFlavors:List[float] = []
        self.flavorbackgroundflag:bool = False
        #background by value
        self.E1backgroundtimex:List[float] = []
        self.E2backgroundtimex:List[float] = []
        self.E3backgroundtimex:List[float] = []
        self.E4backgroundtimex:List[float] = []
        self.E1backgroundvalues:List[float] = []
        self.E2backgroundvalues:List[float] = []
        self.E3backgroundvalues:List[float] = []
        self.E4backgroundvalues:List[float] = []
        self.l_backgroundeventtype1dots:Optional[Line2D] = None
        self.l_backgroundeventtype2dots:Optional[Line2D] = None
        self.l_backgroundeventtype3dots:Optional[Line2D] = None
        self.l_backgroundeventtype4dots:Optional[Line2D] = None

        # background Deltas
        self.DeltaETBflag:bool = False
        self.DeltaBTBflag:bool = True
        self.clearBgbeforeprofileload:bool = False
        self.setBatchSizeFromBackground:bool = False
        self.hideBgafterprofileload:bool = False

        self.heating_types: Final[List[str]] = [
            '',
            QApplication.translate('ComboBox', 'Propane Gas (LPG)'),
            QApplication.translate('ComboBox', 'Natural Gas (NG)'),
            QApplication.translate('ComboBox', 'Electric')
        ]

        #General notes. Accessible through "edit graph properties" of graph menu. WYSIWYG viewer/editor.
        # setup of the current profile
        self.operator: str = ''
        self.organization: str = ''
        self.roastertype: str = ''
        self.roastersize: float = 0 # in kg
        self.roasterheating:int = 0 # 0: ??, 1: LPG, 2: NG, 3: Elec
        self.drumspeed: str = ''
        # kept in app settings
        self.organization_setup:str = ''
        self.operator_setup:str = ''
        self.roastertype_setup:str = ''
        self.roastersize_setup_default:float = 0 # in kg # the default to present on setup as loaded from the machine setup
        self.roastersize_setup:float = 0 # in kg
        self.roasterheating_setup:int = 0
        self.roasterheating_setup_default:int = 0 # the default to present on setup as loaded from the machine setup
        self.drumspeed_setup:str = ''
        #
        self.last_batchsize:float = 0 # in unit of self.weight[2]; remember the last batchsize used to be applied as default for the next batch
        #
        self.machinesetup_energy_ratings:Optional[Dict[int,Dict[float, Dict[str,List[Any]]]]] = None # read from predefined machine setups and used if available to set energy defaults
        #
        self.machinesetup:str = ''
        self.roastingnotes:str = ''
        self.cuppingnotes:str = ''
        self.roastdate:QDateTime = QDateTime.currentDateTime()
        # system batch nr system
        self.roastepoch:int = self.roastdate.toSecsSinceEpoch() # in seconds
        self.roastepoch_timeout:Final[int] = 90*60  # in seconds; period after last roast which starts a new roasting session
        self.lastroastepoch:int = self.roastepoch - self.roastepoch_timeout - 1 # the epoch of the last roast in seconds, initialized such that a new roast session can start
        self.batchcounter:int = -1 # global batch counter; if batchcounter is -1, batchcounter system is inactive
        self.batchsequence:int = 1 # global counter of position in sequence of batches of one session
        self.batchprefix:str = ''
        self.neverUpdateBatchCounter:bool = False
        # profile batch nr
        self.roastbatchnr:int = 0 # batch number of the roast; if roastbatchnr=0, prefix/counter is hidden/inactiv (initialized to 0 on roast START)
        self.roastbatchprefix:str = self.batchprefix # batch prefix of the roast
        self.roastbatchpos:int = 1 # position of the roast in the roast session (first batch, second batch,..)
        self.roasttzoffset:int = libtime.timezone # timezone offset to be added to roastepoch to get time in local timezone; NOTE: this is not set/updated on loading a .alog profile!
        # profile UUID
        self.roastUUID:Optional[str] = None
        self.scheduleID:Optional[str] = None
        self.scheduleDate:Optional[str] = None # not stored on server and thus might be None while scheduleID is not None (in case scheduleID got set on server side)

#PLUS
        # the default store selected by the user (save in the  app settings)
        self.plus_default_store:Optional[str] = None
        # the current profiles coffee or blend and associated store ids (saved in the *.alog profile)
        self.plus_store:Optional[str] = None # holds the plus hr_id of the selected store of the current profile or None
        self.plus_store_label:Optional[str] = None # holds the plus label of the selected store of the current profile or None
        self.plus_coffee:Optional[str] = None # holds the plus hr_id of the selected coffee of the current profile or None
        self.plus_coffee_label:Optional[str] = None # holds the plus label of the selected coffee of the current profile or None
        self.plus_blend_spec:Optional[Blend] = None # the plus blend structure [<blend_label>,[[<coffee_label>,<hr_id>,<ratio>],...,[<coffee_label>,<hr_id>,<ratio>]]] # label + ingredients
        self.plus_blend_spec_labels:Optional[List[str]] = None # a list of labels as long as the list of ingredients in self.plus_blend_spec or None
        self.plus_blend_label:Optional[str] = None # holds the plus selected label of the selected blend of the current profile or None
        self.plus_custom_blend:Optional[CustomBlend] = None # holds the one custom blend, an instance of plus.blend.Blend, or None
        self.plus_sync_record_hash:Optional[str] = None
        self.plus_file_last_modified:Optional[float] = None # holds the last_modified timestamp of the loaded profile as EPOCH (float incl. milliseconds as returned by time.time())
        # plus_file_last_modified is set on load, reset on RESET, and updated on save. It is also update, if not None and new data is received from the server (sync:applyServerUpdates)
        # this timestamp is used in sync:fetchServerUpdate to ask server for updated data

        # remember the lockSchedule date/account sent to the server to prevent re-sending
        self.plus_lockSchedule_sent_account:Optional[str] = None
        self.plus_lockSchedule_sent_date:Optional[str] = None

        self.beans:str = ''

        self.curveVisibilityCache:Optional[Tuple[bool,bool,bool,bool,List[bool],List[bool]]] = None # caches the users curve visibility settings to be reset after recording

        #flags to show projections, draw Delta ET, and draw Delta BT
        self.ETprojectFlag:bool = True
        self.BTprojectFlag:bool = True
        self.projectDeltaFlag:bool = False
        self.ETcurve:bool = True
        self.BTcurve:bool = True
        self.ETlcd:bool = True
        self.BTlcd:bool = True
        self.swaplcds:bool = False # if set draw ET curver on top of BT curve and show ET LCD above BT LCD by default
        self.LCDdecimalplaces = 1
        self.foregroundShowFullflag:bool = True
        self.interpolateDropsflag:bool = True
        self.DeltaETflag:bool = False
        self.DeltaBTflag:bool = True
        self.DeltaETlcdflag:bool = False
        self.DeltaBTlcdflag:bool = True
        self.swapdeltalcds:bool = False
        self.PIDbuttonflag:bool = True # TC4 PID firmware available?
        self.Controlbuttonflag:bool = False # PID Control active (either internal/external or Fuji)
        # user filter values x are translated as follows to internal filter values: y = x*2 + 1 (to go the other direction: x = y/2)
        # this is to ensure, that only uneven window values are used and no wrong shift is happening through smoothing
        self.deltaETfilter:int = 7 # => corresponds to 3 on the user interface
        self.deltaBTfilter:int = 7 # => corresponds to 3 on the user interface
        self.curvefilter:int = 3 # => corresponds to 1 on the user interface
        # a deltaET span of 0 indicates that the delta RoR is computed by two succeeding readings
        self.deltaETspan:int = 20 # the time period taken to compute one deltaET value (1-30sec) # deltaETspan >= 0
        self.deltaBTspan:int = 20 # the time period taken to compute one deltaBT value (1-30sec) # deltaBTspan >= 0
        # deltaETsamples == 1 (sample) implies that the delta RoR is computed from only two readings:
        self.deltaETsamples:int = 6 # the number of samples that make up the delta span, to be used in the delta computations (>= 1!)
        self.deltaBTsamples:int = 6 # the number of samples that make up the delta span, to be used in the delta computations (>= 1!)
        self.profile_sampling_interval:Optional[float] = None # will be updated on loading a profile
        self.background_profile_sampling_interval:Optional[float] = None # will be updated on loading a profile into the background
        self.profile_meter:str = 'Unknown' # will be updated on loading a profile

        self.optimalSmoothing:bool = False
        self.polyfitRoRcalc:bool = False

        self.patheffects:int = 1
        self.glow:int = 0
        self.graphstyle:int = 0
        self.graphfont:int = 0

        #variables to configure the 8 default buttons
        # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END;
        self.buttonvisibility = [True,True,True,True,True,False,True,False]
        self.buttonactions = [0]*8
        self.buttonactionstrings = ['']*8
        #variables to configure the 0: ON, 1: OFF, 2: SAMPLE, 3:RESET, 4:START
        self.extrabuttonactions = [0]*3
        self.extrabuttonactionstrings = ['']*3
        #variables to configure the 0:RESET, 1:START
        self.xextrabuttonactions = [0]*2
        self.xextrabuttonactionstrings = ['']*2

        #flag to activate the automatic marking of the CHARGE and DROP events
        self.chargeTimerFlag: bool = False
        self.chargeTimerPeriod: int = 0 # period until CHARGE since START if CHARGE timer is active
        self.autoChargeFlag: bool = True
        self.autoDropFlag: bool = True
        # auto mark modes for autoCHARGE and autoDROP (0: Standard, 1: Sensitive)
        self.autoChargeMode: int = 0
        self.autoDropMode: int = 0
        #autodetected CHARGE and DROP index
        self.autoChargeIdx = 0 # if positive it holds the autoCHARGE index, if negative, autoCHARGE is disabled
        self.autoDropIdx = 0 # if positive it holds the autoDROP index, if negative, autoDROP is disabled

        self.markTPflag:bool = True # user setting if TP should be marked or not

        # flags to control automatic DRY and FCs events based on phases limits
        self.autoDRYflag:bool = False
        self.autoFCsFlag:bool = False

        self.autoCHARGEenabled:bool = True # gets disabled on undo of the CHARGE event and prevents further autoCHARGE marks
        self.autoDRYenabled:bool = True # gets disabled on undo of the DRY event and prevents further autoDRY marks
        self.autoFCsenabled:bool = True # gets disabled on undo of the FCs event and prevents further autoFCs marks
        self.autoDROPenabled:bool = True # gets disabled on undo of the DROP event and prevents further autoDROP marks


        # projection variables of change of rate
        self.projectionconstant = 1
        self.projectionmode = 0     # 0 = linear; 1 = quadratic;   # 2 = newton#disabled

        # profile transformator mapping mode
        self.transMappingMode = 0 # 0: discrete, 1: linear, 2: quadratic

        #[0]weight in, [1]weight out, [2]units (string)
        self.weight:Tuple[float,float,str] = (0, 0, weight_units[1])

        #[0]volume in, [1]volume out, [2]units (string)
        self.volume:Tuple[float,float,str] = (0, 0, volume_units[0])

        #[0]probe weight, [1]weight unit, [2]probe volume, [3]volume unit
        self.density:Tuple[float,str,float,str] = (0,'g',1.,'l')
        # density weight and volume units are not to be used any longer and assumed to be fixed to g/l
        # thus also probe volume is not used anymore, and only self.density[0] holds the green been density in g/l

        self.density_roasted:Tuple[float,str,float,str] = (0,'g',1.,'l') # this holds the roasted beans density in g/l


        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if not QSettings().value('AppleMetricUnits'):
                    self.weight = (0, 0, weight_units[2])
                    self.volume = (0, 0, volume_units[1])
            except Exception: # pylint: disable=broad-except
                pass

        self.volumeCalcUnit:float = 0
        self.volumeCalcWeightInStr:str = ''
        self.volumeCalcWeightOutStr:str = ''

        # container scale tare
        self.container_names:List[str] = []
        self.container_weights:List[int] = [] # all weights in g and as int
        self.container_idx:int = -1 # the empty field (as -1 + 2 = 1)

        #stores _indexes_ of self.timex to record events.
        # Use as self.timex[self.specialevents[x]] to get the time of an event
        # use self.temp2[self.specialevents[x]] to get the BT temperature of an event.
        self.specialevents:List[int] = []
        #ComboBox text event types. They can be modified in eventsDlg()
        self.etypes:List[str] = [QApplication.translate('ComboBox', 'Air'),
                       QApplication.translate('ComboBox', 'Drum'),
                       QApplication.translate('ComboBox', 'Damper'),
                       QApplication.translate('ComboBox', 'Burner'),
                       '--']
        #default etype settings to restore
        self.etypesdefault: Final[List[str]] = [
                                QApplication.translate('ComboBox', 'Air'),
                                QApplication.translate('ComboBox', 'Drum'),
                                QApplication.translate('ComboBox', 'Damper'),
                                QApplication.translate('ComboBox', 'Burner'),
                                '--']
        #alternative default etype settings to restore
        self.alt_etypesdefault: Final[List[str]] = [
                                QApplication.translate('ComboBox', 'Fan'),
                                QApplication.translate('ComboBox', 'Drum'), # still free to choose another name (currently unused)
                                QApplication.translate('ComboBox', 'Cooling'),
                                QApplication.translate('ComboBox', 'Heater'),
                                '--']
        self.default_etypes_set: List[int] = [0,0,0,0,0] # if 1 the default is taken from alt_etypesdefault if 0 from etypesdefault
        #stores the type of each event as index of self.etypes. None = 0, Power = 1, etc.
        self.specialeventstype:List[int] = []
        #stores text string descriptions for each event.
        self.specialeventsStrings:List[str] = []
        #event values are from 0-10
        #stores the value for each event
        self.specialeventsvalue:List[float] = []
        #flag that makes the events location type bars (horizontal bars) appear on the plot. flag read on redraw()
        # 0 = no event bars (flags); 1 = type bars (4 bars); 2 = step lines; 3 = step+ (combination of 0 and 2); 4 = combo (as 2, but values rendered on lines instead of flags)
        self.eventsGraphflag:int = 2
        self.clampEvents:bool = False # if True, custom events are drawn w.r.t. the temperature scale
        self.renderEventsDescr:bool = False # if True, descriptions are rendered instead of type/value tags
        self.eventslabelschars:int = 6 # maximal number of chars to render as events label
        #flag that shows events in the graph
        self.eventsshowflag:int = 1
        #flag that shows major event annotations in the graph
        self.annotationsflag:int = 1
        #shows events anchored to the BT curve if true, events anchored to greater of ET or BT curve if false
        self.showeventsonbt:bool = False
        #selectively show/hide event types
        self.showEtypes:List[bool] = [True]*5
        #plot events by value
        self.E1timex:List[float] = []
        self.E2timex:List[float] = []
        self.E3timex:List[float] = []
        self.E4timex:List[float] = []
        self.E1values:List[float] = []
        self.E2values:List[float] = []
        self.E3values:List[float] = []
        self.E4values:List[float] = []
        self.EvalueColor:List[str] = self.EvalueColor_default.copy()
        self.EvalueTextColor:List[str] = self.EvalueTextColor_default.copy()
        self.EvalueMarker:List[str] = ['o','s','h','D']
        self.EvalueMarkerSize:List[float] = [4,4,4,4]
        self.Evaluelinethickness:List[float] = [1,1,1,1]
        self.Evaluealpha:List[float] = [.8,.8,.8,.8]
        #the event value position bars are calculated at redraw()
        self.eventpositionbars:List[float] = [0.]*120
        self.specialeventannotations:List[str] = ['','','','']
        self.specialeventannovisibilities:List[int] = [0,0,0,0]
        self.specialeventplaybackaid:List[bool] = [True, True, True, True]          # per event type decides if playback aid is active (note that eventtype 4 "--" is not replayed)
        self.specialeventplayback:List[bool] = [True, True, True, True]             # per event type decides if background events are play-backed or not
        self.specialeventplaybackramp:List[bool] = [False, False, False, False]     # per event type decides if playback ramping is applied or not
        self.overlappct:int = 100

        #curve styles
        self.linewidth_min: Final[float] = 0.1 # minimum linewidth. NOTE: MPL raises an (unhandled) exception if linewidth is 0 with dotted styles in plot()
        self.markersize_min: Final[float] = 0.1

        self.linestyle_default: Final[str] = '-'
        self.drawstyle_default: Final[str] = 'default'
        self.linewidth_default: Final[float] = 1.5
        self.back_linewidth_default: Final[float] = 2
        self.delta_linewidth_default: Final[float] = 1
        self.back_delta_linewidth_default: Final[float] = 1.5
        self.extra_linewidth_default: Final[float] = 1
        self.marker_default: Final[str] = 'None'
        self.markersize_default: Final[float] = 6

        self.BTlinestyle:str = self.linestyle_default
        self.BTdrawstyle:str = self.drawstyle_default
        self.BTlinewidth:float = self.linewidth_default
        self.BTmarker:str = self.marker_default
        self.BTmarkersize:float = self.markersize_default
        self.ETlinestyle:str = self.linestyle_default
        self.ETdrawstyle:str = self.drawstyle_default
        self.ETlinewidth:float = self.linewidth_default
        self.ETmarker:str = self.marker_default
        self.ETmarkersize:float = self.markersize_default
        self.BTdeltalinestyle:str = self.linestyle_default
        self.BTdeltadrawstyle:str = self.drawstyle_default
        self.BTdeltalinewidth:float = self.delta_linewidth_default
        self.BTdeltamarker:str = self.marker_default
        self.BTdeltamarkersize:float = self.markersize_default
        self.ETdeltalinestyle:str = self.linestyle_default
        self.ETdeltadrawstyle:str = self.drawstyle_default
        self.ETdeltalinewidth:float = self.delta_linewidth_default
        self.ETdeltamarker:str = self.marker_default
        self.ETdeltamarkersize:float = self.markersize_default
        self.BTbacklinestyle:str = self.linestyle_default
        self.BTbackdrawstyle:str = self.drawstyle_default
        self.BTbacklinewidth:float = self.back_linewidth_default
        self.BTbackmarker:str = self.marker_default
        self.BTbackmarkersize:float = self.markersize_default
        self.ETbacklinestyle:str = self.linestyle_default
        self.ETbackdrawstyle:str = self.drawstyle_default
        self.ETbacklinewidth:float = self.back_linewidth_default
        self.ETbackmarker:str = self.marker_default
        self.ETbackmarkersize:float = self.markersize_default
        self.XTbacklinestyle:str = self.linestyle_default
        self.XTbackdrawstyle:str = self.drawstyle_default
        self.XTbacklinewidth:float = self.extra_linewidth_default
        self.XTbackmarker:str = self.marker_default
        self.XTbackmarkersize:float = self.markersize_default
        self.YTbacklinestyle:str = self.linestyle_default
        self.YTbackdrawstyle:str = self.drawstyle_default
        self.YTbacklinewidth:float = self.extra_linewidth_default
        self.YTbackmarker:str = self.marker_default
        self.YTbackmarkersize:float = self.markersize_default
        self.BTBdeltalinestyle:str = self.linestyle_default
        self.BTBdeltadrawstyle:str = self.drawstyle_default
        self.BTBdeltalinewidth:float = self.back_delta_linewidth_default
        self.BTBdeltamarker:str = self.marker_default
        self.BTBdeltamarkersize:float = self.markersize_default
        self.ETBdeltalinestyle:str = self.linestyle_default
        self.ETBdeltadrawstyle:str = self.drawstyle_default
        self.ETBdeltalinewidth:float = self.back_delta_linewidth_default
        self.ETBdeltamarker:str = self.marker_default
        self.ETBdeltamarkersize:float = self.markersize_default

        #Temperature Alarms lists. Data is written in  alarmDlg
        self.alarmsetlabel:str = ''
        self.alarmflag: List[int] = []      # 0 = OFF; 1 = ON flags
        self.alarmguard: List[int] = []      # points to another alarm by index that has to be triggered before; -1 indicates no guard
        self.alarmnegguard: List[int] = []   # points to another alarm by index that should not has been triggered before; -1 indicates no guard
        self.alarmtime: List[int] = []      # time event after which each alarm becomes effective. Usage: self.timeindex[self.alarmtime[i]]
#                               # -1 : START.
#                               # 0: CHARGE, 1: DRY END; 2: FCs, 3: FCe, 4: SCs, 5: SCe, 6: DROP, 7: COOL (corresponding to those timeindex positions)
#                               # 8: TP
#                               # 9: ON
#                               # 10: If Alarm
        self.alarmoffset: List[int] = []    # for timed alarms, the seconds after alarmtime the alarm is triggered
        self.alarmtime2menuidx: Final[List[int]] = [2,4,5,6,7,8,9,10,3,0,11,1] # maps self.alarmtime index to menu idx (to move TP in menu from index 9 to 3)
        self.menuidx2alarmtime: Final[List[int]] = [9,-1,0,8,1,2,3,4,5,6,7,10] # inverse of above (note that those two are only inverse in one direction!)
        self.alarmcond: List[int] = []      # 0 = falls below; 1 = rises above; 2 = equal; 3 not equal
        # alarmstate is set to 'not triggered' on reset(). This is needed so that the user does not have to turn the alarms ON next roast after alarm being used once.
        self.alarmstate:List[int] = []   # <idx>=triggered, -1=not triggered.
        self.alarmsource: List[int] = []    # -3=None, -2=DeltaET, -1=DeltaBT, 0=ET , 1=BT, 2=extratemp1[0], 3=extratemp2[0], 4=extratemp2[1],....
        self.alarmtemperature: List[float] = []  # set temperature number (example 500; can be negative)
        self.alarmaction: List[int] = []         # -1 = no action; 0 = open a window;
                                    # 1 = call program with a filepath equal to alarmstring;
                                    # 2 = activate button with number given in description;
                                    # 3,4,5,6 = move slider with value given in description
                                    # 7 (START), 8 (DRY), 9 (FCs), 10 (FCe), 11 (SCs), 12 (SCe), 13 (DROP), 14 (COOL), 15 (OFF)
                                    # 16 (CHARGE),
                                    # 17 (RampSoak_ON), 18 (RampSoak_OFF), 19 (PID_ON), 20 (PID_OFF)
        self.alarmbeep: List[int] = []           # 0 = OFF; 1 = ON flags
        self.alarmstrings: List[str] = []         # text descriptions, action to take, or filepath to call another program (comments after # are ignored)
        self.alarmtablecolumnwidths:List[int] = []
        self.silent_alarms:bool = False # if this is true (can be set via a + button action "alarm(1)", alarms are triggered, but actions are not fired

        # alarm sets
        self.alarmsets:List[AlarmSet] = []
        for _ in range(self.ALARMSET_COUNT):
            self.alarmsets.append(tgraphcanvas.emptyAlarmSet())

        self.loadalarmsfromprofile:bool = False # if set, alarms are loaded from profile
        self.loadalarmsfrombackground:bool = False # if set, alarms are loaded from background profiles
        self.alarmsfile:str = '' # filename alarms were loaded from
        self.TPalarmtimeindex:Optional[int] = None # is set to the current  self.time index by sample(), if alarms are defined and once the TP is detected

        self.rsfile:str = '' # filename Ramp/Soak patterns were loaded from

        self.loadaxisfromprofile:bool = False # if set, axis are loaded from profile

        # set initial limits for X and Y axes. But they change after reading the previous settings at self.aw.settingsload()
        self.startofx_default: Final[float] = -30
        self.endofx_default: Final[float] = 600 # 10min*60

        self.xgrid_default: Final[int] = 120

        self.ylimit_F_default: Final[int] = 527# 500
        self.ylimit_min_F_default: Final[int] = 100
        self.ygrid_F_default: Final[int] = 100
        self.zlimit_F_default: Final[int] = 45
        self.zlimit_min_F_default: Final[int] = 0
        self.zgrid_F_default: Final[int] = 10

        self.ylimit_C_default: Final[int] = 275 #250
        self.ylimit_min_C_default: Final[int] = 0
        self.ygrid_C_default: Final[int] = 50
        self.zlimit_C_default: Final[int] = 25
        self.zlimit_min_C_default: Final[int] = 0
        self.zgrid_C_default: Final[int] = 5

        self.temp_grid:bool = False
        self.time_grid:bool = False

        # maximum accepted min/max settings for y and z axis
        self.zlimit_max:int = 500
        self.zlimit_min_max:int = -500
        self.ylimit_max:int = 9999
        self.ylimit_min_max:int = -9999

        #----
        # set limits to F defaults

        self.ylimit:int = self.ylimit_F_default
        self.ylimit_min:int = self.ylimit_min_F_default
        self.zlimit:int = self.zlimit_F_default
        self.zlimit_min:int = self.zlimit_min_F_default


        # RoR display limits
        # user configurable RoR limits (only applied if flag is True; applied before TP during recording as well as full redraw)
        self.RoRlimitFlag:bool = True
        self.RoRlimit:int = 95
        self.RoRlimitm:int = -95
        # system fixed RoR limits (only applied if flag is True; usually higher than the user configurable once and always applied)
        self.maxRoRlimit: Final[int] = 170
        # axis limits
        self.endofx:float = self.endofx_default     # endofx is the display time in seconds of the right x-axis limit (excluding any shift of CHARGE time)
        self.startofx:float = self.startofx_default # startofx is the time in seconds of the left x-axis limit in data time (display time in seconds of the left x-axis limit plus the CHARGE time in seconds); NOTE: as startofx depends CHARGE it has to be adjusted whenever CHARGE is adjusted
        self.resetmaxtime:int = 600  #time when pressing RESET: 10min*60
        self.chargemintime:float = self.startofx_default  #time when pressing CHARGE: -30sec
        self.fixmaxtime:bool = False # if true, do not automatically extend the endofx by 3min if needed because the measurements get out of the x-axis
        self.locktimex:bool = False # if true, do not set time axis min and max from profile on load
        self.autotimex:bool = True # automatically set time axis min and max from profile CHARGE/DROP on load
        self.autotimexMode = 0 # mode for autotimex with 0: profile (CHARGE/DROP), 1: BBP+profile (START/DROP), 2: BBP (START/CHARGE)
        self.autodeltaxET:bool = False # automatically set the delta axis max to the max(DeltaET)
        self.autodeltaxBT:bool = False # automatically set the delta axis max to the max(DeltaBT)
        self.locktimex_start:float = self.startofx_default # seconds of x-axis min as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.locktimex_end:float = self.endofx_default # seconds of x-axis max as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.xgrid:int = self.xgrid_default   #initial time separation; 60 = 1 minute
        self.ygrid:int = self.ygrid_F_default  #initial temperature separation
        self.zgrid:int = self.zgrid_F_default   #initial RoR separation
        self.gridstyles:List[str] =    ['-','--','-.',':',' ']  #solid,dashed,dash-dot,dotted,None
        self.gridlinestyle:int = 0
        self.gridthickness:float = 1
        self.gridalpha:float = .2
#        self.xrotation:float = 0

        #height of statistics bar
        self.statisticsheight:int = 650
        self.statisticsupper:int = 655
        self.statisticslower:int = 617

        # autosave
        self.autosaveflag:int = 0
        self.autosaveprefix:str = ''
        self.autosavepath:str = ''
        self.autosavealsopath:str = ''
        self.autosaveaddtorecentfilesflag:bool = False

        self.autosaveimage:bool = False # if true save an image along alog files

        self.autoasaveimageformat_types:List[str] = ['PDF', 'PDF Report', 'SVG', 'PNG', 'JPEG', 'CSV', 'JSON']
        self.autosaveimageformat:str = 'PDF' # one of the supported image file formats PDF, PDF Report, SVG, PNG, JPEG, CSV, JSON

        #used to place correct height of text to avoid placing text over text (annotations)
        self.ystep_down:int = 0
        self.ystep_up:int = 0

        self.ax.set_xlim(self.startofx, self.endofx)
        self.ax.set_ylim(self.ylimit_min,self.ylimit)

        if self.delta_ax is not None:
            self.delta_ax.set_xlim(self.startofx, self.endofx)
            self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
            self.delta_ax.set_autoscale_on(False)

        # disable figure autoscale
        self.ax.set_autoscale_on(False)

        #set grid + axis labels + title
        grid_axis:Optional[str] = None
        if self.temp_grid and self.time_grid:
            grid_axis = 'both'
        elif self.temp_grid:
            grid_axis = 'y'
        elif self.time_grid:
            grid_axis = 'x'
        if grid_axis is not None:
            self.ax.grid(True,
                axis=grid_axis, # type: ignore # "grid" of "_AxesBase" has incompatible type "str"; expected "Literal['both', 'x', 'y']
                color=self.palette['grid'],
                linestyle = self.gridstyles[self.gridlinestyle],
                linewidth = self.gridthickness,
                alpha = self.gridalpha)

        #change label colors
        for label in self.ax.yaxis.get_ticklabels():
            label.set_color(self.palette['ylabel'])

        for label in self.ax.xaxis.get_ticklabels():
            label.set_color(self.palette['xlabel'])

        self.backgroundETcurve:bool = True
        self.backgroundBTcurve:bool = True

        # generates first "empty" plot (lists are empty) of temperature and deltaT
        self.l_temp1:Optional[Line2D] = None
        self.l_temp2:Optional[Line2D] = None
        self.l_delta1:Optional[Line2D] = None
        self.l_delta2:Optional[Line2D] = None
        self.l_back1:Optional[Line2D] = None
        self.l_back2:Optional[Line2D] = None
        self.l_back3:Optional[Line2D] = None # first extra background curve
        self.l_back4:Optional[Line2D] = None # second extra background curve
        self.l_delta1B:Optional[Line2D] = None
        self.l_delta2B:Optional[Line2D] = None

        self.l_subtitle:Optional[Text] = None # the subtitle artist if any as used to render the background title

        self.l_BTprojection:Optional[Line2D] = None
        self.l_ETprojection:Optional[Line2D] = None
        self.l_DeltaBTprojection:Optional[Line2D] = None
        self.l_DeltaETprojection:Optional[Line2D] = None

        self.l_AUCguide:Optional[Line2D] = None

        self.l_horizontalcrossline:Optional[Line2D] = None
        self.l_verticalcrossline:Optional[Line2D] = None

        self.l_timeline:Optional[Line2D] = None

        self.legend:Optional[Legend] = None

        self.l_eventtype1dots:Optional[Line2D] = None
        self.l_eventtype2dots:Optional[Line2D] = None
        self.l_eventtype3dots:Optional[Line2D] = None
        self.l_eventtype4dots:Optional[Line2D] = None

        self.l_eventtype1annos:List[Annotation] = []
        self.l_eventtype2annos:List[Annotation] = []
        self.l_eventtype3annos:List[Annotation] = []
        self.l_eventtype4annos:List[Annotation] = []

        self.l_eventflagannos:List[Annotation] = [] # collects all the foreground profile flag annotations in Step+ mode (self.eventsGraphflag == 3)

        self.l_eteventannos:List[Annotation] = []
        self.l_bteventannos:List[Annotation] = []

        self.l_eventtype1backannos:List[Annotation] = []
        self.l_eventtype2backannos:List[Annotation] = []
        self.l_eventtype3backannos:List[Annotation] = []
        self.l_eventtype4backannos:List[Annotation] = []

        self.l_eventflagbackannos:List[Annotation] = [] # collects all the background profile flag annotations in Step+ mode (self.eventsGraphflag == 3)

        self.l_annotations:List[Annotation] = []
        self.l_background_annotations:List[Annotation] = []

        # NOTE: the l_annotations_pos_dict is set on profile load and its positions are preferred over those in l_annotations_dict, but deleted at the end of the first redraw()
        self.l_annotations_dict:Dict[int,List[Annotation]] = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time annotations
        self.l_annotations_pos_dict:Dict[int,Tuple[Tuple[float,float],Tuple[float,float]]] = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time xyann coordinate pairs
        self.l_event_flags_dict:Dict[int,Annotation] = {} # associating event flag annotations id (event number) to its draggable text annotation
        self.l_event_flags_pos_dict:Dict[int,Tuple[float,float]] = {} # associating event flag annotations id (event number) to its draggable text xyann coordinates

        self.ai:Optional[AxesImage] = None # holds background logo image

        ###########################  TIME  CLOCK     ##########################
        # create an object time to measure and record time (in milliseconds)

        self.timeclock:ArtisanTime = ArtisanTime()

        ############################  Thread Server #################################################
        #server that spawns a thread dynamically to sample temperature (press button ON to make a thread press OFF button to kill it)
        self.threadserver:Athreadserver = Athreadserver(self.aw)


        ##########################     Designer variables       #################################
        self.designerflag:bool = False
        self.designerconnections:List[Optional[int]] = [None,None,None,None]   #mouse event ids
        self.mousepress:bool = False
        self.indexpoint:int = 0
        self.workingline:int = 2  #selects 1:ET or 2:BT
        self.eventtimecopy:List[float] = []
        self.etypescopy:List[str] = []
        self.specialeventsStringscopy:List[str] = []
        self.specialeventsvaluecopy:List[float]   = []
        self.specialeventstypecopy:List[int]    = []
        self.currentx:float = 0               #used to add point when right click
        self.currenty:float = 0               #used to add point when right click
        self.designertimeinit:List[float] = [50,300,540,560,660,700,800,900]
        self.BTsplinedegree:int = 3
        self.ETsplinedegree:int = 3
        self.reproducedesigner:int = 0      #flag to add events to help reproduce (replay) the profile: 0 = none; 1 = sv; 2 = ramp
        self.designertemp1init:List[float] = []
        self.designertemp2init:List[float] = []
        self.ax_background_designer:Optional[Any] = None # canvas background in designer mode for bitblitting # pylint: disable=c-extension-no-member
        self.designer_timez:Optional[List[float]] = None
        self.time_step_size:Final[int] = 2 # only every 2sec a point to increase speed of redrawing
        # designer artist line caches
        self._designer_orange_mark:Optional[Line2D] = None
        self._designer_orange_mark_shown:bool = False
        self._designer_blue_mark:Optional[Line2D] = None
        self._designer_blue_mark_shown:bool = False
        self.l_temp1_markers:Optional[Line2D] = None
        self.l_temp2_markers:Optional[Line2D] = None
        self.l_stat1:Optional[Line2D] = None
        self.l_stat2:Optional[Line2D] = None
        self.l_stat3:Optional[Line2D] = None
        self.l_div1:Optional[Line2D] = None
        self.l_div2:Optional[Line2D] = None
        self.l_div3:Optional[Line2D] = None
        self.l_div4:Optional[Line2D] = None

        ###########################         filterDropOut variables     ################################

        # constants

        self.filterDropOut_replaceRoR_period:Final[int] = 3
        self.filterDropOut_spikeRoR_period:Final[int] = 3


        # defaults

        self.filterDropOut_tmin_C_default:Final[float] = 0
        self.filterDropOut_tmax_C_default:Final[float] = 700
        self.filterDropOut_tmin_F_default:Final[float] = 0
        self.filterDropOut_tmax_F_default:Final[float] = 1292
        self.filterDropOut_spikeRoR_dRoR_limit_C_default:Final[float] = 4.2
        self.filterDropOut_spikeRoR_dRoR_limit_F_default:Final[float] = 7

        # variables

        self.filterDropOuts:bool = True # Smooth Spikes
        self.filterDropOut_tmin:float = self.filterDropOut_tmin_F_default
        self.filterDropOut_tmax:float = self.filterDropOut_tmax_F_default
        self.filterDropOut_spikeRoR_dRoR_limit:float = self.filterDropOut_spikeRoR_dRoR_limit_F_default # the limit of additional RoR in temp/sec compared to previous readings
        self.minmaxLimits:bool = False
        self.dropSpikes:bool = False
        self.dropDuplicates:bool = False
        self.dropDuplicatesLimit:float = 0.54

        # self.median_filter_factor: factor used for MedianFilter on both, temperature and RoR curves
        self.median_filter_factor:Final[int] = 5 # k=3 is conservative seems not to catch all spikes in all cases; k=5 and k=7 seems to be ok; 13 might be the maximum; k must be odd!
        self.median_filter_factor_RoR:Final[int] = 3
        self.liveMedianETfilter:LiveMedian = LiveMedian(self.median_filter_factor)
        self.liveMedianBTfilter:LiveMedian = LiveMedian(self.median_filter_factor)
        self.liveMedianETRoRfilter:LiveMedian = LiveMedian(self.median_filter_factor_RoR)
        self.liveMedianBTRoRfilter:LiveMedian = LiveMedian(self.median_filter_factor_RoR)

        self.interpolatemax:Final[int] = 3 # maximal number of dropped readings (-1) that will be interpolated

        self.swapETBT:bool = False

        ###########################         wheel graph variables     ################################
        self.wheelflag:bool = False

        # set data for a nice demo flavor wheel

        #data containers for wheel
        self.wheelnames: List[List[str]] = [[''], ['Fruity', 'Sour', 'Green', 'Other', 'Roasted', 'Spices', 'Nutty', 'Sweet', 'Floral'], ['Floral', 'Berry', 'Dried fruit', 'Other fruit', 'Citrus fruit', 'Sour', 'Alcohol', 'Olive oil', 'Raw', 'Green', 'Beany', 'Musty', 'Chemical', 'Pipe tobaco', 'Tobaco', 'Burnt', 'Cereal', 'Pungent', 'Pepper', 'Brown spice', 'Nutty', 'Cocoa', 'Brown sugar', 'Vanilla', 'Vanillin', 'Overall sweet', 'Sweet Aromatics', 'Black Tea']]

        self.segmentlengths: List[List[float]] = [[100.0], [11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 5.109999999999999], [2.5549999999999997, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 3.95375, 3.95375, 3.95375, 5.930625, 5.930625, 2.37225, 2.37225, 2.37225, 2.37225, 2.37225, 2.5549999999999997]]

        self.segmentsalpha: List[List[float]] = [[0.09], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]]

        self.wheellabelparent:List[List[int]] = [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 8, 8, 9]]

        self.wheelcolor:List[List[str]] = [['#fdfffb'], ['#cd001b', '#dea20e', '#186923', '#1693a6', '#bb3424', '#9b0f2f', '#976751', '#de4126', '#cf0055'], ['#d6588a', '#d33440', '#bb3435', '#ed513b', '#d47e1d', '#d9b913', '#a08727', '#91a41f', '#5e7927', '#309543', '#4d8a6d', '#8ca3a9', '#65b4c0', '#be9452', '#d7b06b', '#b07351', '#d4a04f', '#653540', '#bf2732', '#9f3845', '#ba7456', '#ac623b', '#c84347', '#f4866d', '#ee5e61', '#df4255', '#c33d4d', '#844a5a']]

        #properties
        #store radius of each circle as percentage(sum of all must at all times add up to 100.0%)
        self.wradii = [7.83, 30.9006201171875, 61.2693798828125]
        #starting angle for each circle (0-360).
        self.startangle:List[float] = [0, 42, 33]
        #text projection: 0 = Flat, 1 = perpendicular to center, 2 = radial from center
        self.projection:List[int] = [1, 2, 2]
        self.wheeltextsize:List[int] = [10,10,10,10]
        self.wheelcolorpattern:int = 0              #pattern
        self.wheeledge:float = 0.01                 #overlapping decorative edge
        self.wheellinewidth:float = 2.
        self.wheellinecolor:str = '#ffffff'         #initial color of lines
        self.wheeltextcolor:str = '#ffffff'         #initial color of text
        self.wheelconnections:List[int] = [0,0,0]   #ids of connected signals
        #temp variables to pass index values
        self.wheelx:int = 0
        self.wheelz:int = 0
        #temp vars to pass mouse location (angleX+radiusZ)
        self.wheellocationx:float = 0.
        self.wheellocationz:float = 0.
        self.wheelaspect:float = 1.0

        # a nicer demo flavor wheel


        self.samplingSemaphore = QSemaphore(1)
        self.updateGraphicsSemaphore = QSemaphore(1)
        self.profileDataSemaphore = QSemaphore(1)
        self.messagesemaphore = QSemaphore(1)
        self.errorsemaphore = QSemaphore(1)
        self.serialsemaphore = QSemaphore(1)
        self.seriallogsemaphore = QSemaphore(1)
        self.eventactionsemaphore = QSemaphore(1)
        self.updateBackgroundSemaphore = QSemaphore(1)
        self.alarmSemaphore = QSemaphore(1)
        self.rampSoakSemaphore = QSemaphore(1)

        #flag to plot cross lines from mouse
        self.crossmarker:bool = False
        self.crossmouseid:Optional[int] = None # connect mouse signal id
        self.onreleaseid:Optional[int] = None # connect release signal id

        #
        self.analyzer_connect_id: Optional[int] = None # analyzer connect signal id


        #########  temporary serial variables
        #temporary storage to pass values. Holds extra T3 and T4 values for center 309
        self.extra309T3:float = -1
        self.extra309T4:float = -1
        self.extra309TX:float = 0.

        #temporary storage to pass values. Holds all values retrieved from a Hottop roaster
        self.hottop_ET:float = -1
        self.hottop_BT:float = -1
        self.hottop_HEATER = 0 # 0-100
        self.hottop_MAIN_FAN = 0 # 0-10 (!)
        self.hottop_TX = 0.

        #temporary storage to pass values. Holds all values retrieved from an R1 roaster
        self.R1_DT:float = -1
        self.R1_BT:float = -1
        self.R1_BT_ROR:float = -1
        self.R1_EXIT_TEMP:float = -1
        self.R1_HEATER:float = 0 # 0-9
        self.R1_FAN:float = 0 # 0-12
        self.R1_DRUM:float = 0 # 1-9
        self.R1_VOLTAGE:float = 0 # 0-300
        self.R1_TX:float = 0.
        self.R1_STATE:int = 0
        self.R1_FAN_RPM:float = 0
        self.R1_STATE_STR:str = ''

        #used by extra device +ArduinoTC4_XX to pass values
        self.extraArduinoTX:float = 0.  # timestamp of retrieval
        self.extraArduinoT1:float = 0.  # Arduino T3: chan 3
        self.extraArduinoT2:float = 0.  # Arduino T4: chan 4
        self.extraArduinoT3:float = 0.  # Arduino T5: heater duty %
        self.extraArduinoT4:float = 0.  # Arduino T6: fan duty %
        self.extraArduinoT5:float = 0.  # Arduino T7: SV
        self.extraArduinoT6:float = 0.  # Arduino T8: TC4 internal ambient temperature

        #used by extra device +Program_34, +Program_56, +Program_78 and +Program_910 to pass values
        self.program_tx:float = 0
        self.program_t3:float = -1
        self.program_t4:float = -1
        self.program_t5:float = -1
        self.program_t6:float = -1
        self.program_t7:float = -1
        self.program_t8:float = -1
        self.program_t9:float = -1
        self.program_t10:float = -1

        #temporary storage to pass values. Holds the power % ducty cycle of Fuji PIDs and ET-BT
        self.dutycycle:float = -1
        self.dutycycleTX:float = 0.
        self.currentpidsv:float = 0.

        self.linecount:Optional[int] = None # linecount cache for resetlines(); has to be reset if visibility of ET/BT or extra lines or background ET/BT changes
        self.deltalinecount:Optional[int] = None # deltalinecount cache for resetdeltalines(); has to be reset if visibility of deltaET/deltaBT or background deltaET/deltaBT

        #variables to organize the delayed update of the backgrounds for bitblitting
        self.ax_background:Optional[Any] = None # pylint: disable=c-extension-no-member
        self.block_update:bool = False

        # flag to toggle between Temp and RoR scale of xy-display
        self.fmt_data_RoR:bool = False
        self.fmt_data_ON:bool = True #; if False, the xy-display is deactivated
        # toggle between using the 0: y-cursor pos, 1: BT@x, 2: ET@x, 3: BTB@x, 4: ETB@x (thus BT, ET or the corresponding background curve data at cursor position x)
        # to display the y of the cursor coordinates
        self.fmt_data_curve = 0
        self.running_LCDs = 0 # if not 0 and not sampling visible LCDs show the readings at the cursor position of 1: foreground profile, 2: background profile

        #holds last values calculated from plotter
        self.plotterstack:List[float] = [0]*10
        #holds results for each equation (9 total)
        self.plotterequationresults:List[List[float]] = [[],[],[],[],[],[],[],[],[]]
        #message string for plotter
        self.plottermessage:str = ''

        self.alarm_popup_timout:int = 10


        #buffers for real time symbolic evaluation
        self.RTtemp1:float = 0.
        self.RTtemp2:float = 0.
        self.RTextratemp1:List[float] = []
        self.RTextratemp2:List[float] = []
        self.RTextratx:List[float] = []

        #Extras more info
        self.idx_met:Optional[int] = None
        self.showmet:bool = False
        self.met_annotate:Optional[Annotation] = None
        self.met_timex_temp1_delta:Optional[Tuple[float,float,Optional[float]]] = None # (time, temp, time delta) tuple
        self.extendevents:bool = True
        self.statssummary:bool = False
        self.showtimeguide:bool = True
        self.statsmaxchrperline = 30

        # Cache for BBP calculations
        self.bbpCache: BbpCache = {}

        #EnergyUse
        # Energy conversion canstants
        #reference: https://www.eia.gov/environment/emissions/co2_vol_mass.php (dated Nov-18-2021, accessed Jan-02-2022)
        #           https://www.eia.gov/tools/faqs/faq.php?id=74&t=11 (referencing data from 2020, accessed Jan-02-2022)
        # entries in this list correlate with those in self.sourcenames
        self.CO2kg_per_BTU_default: Final[List[float]] = [6.288e-05,  # LPG
                                                          5.291e-05,  # NG
                                                          2.964e-04]  # Elec
        #reference: https://www.bafa.de/SharedDocs/Downloads/DE/Energie/eew_infoblatt_co2_faktoren_2024.pdf?__blob=publicationFile&v=2 (dated Aug-08-2024, accessed Jan-28-2025)
        self.Biogas_CO2_Reduction_default: Final[float] = 0.7562

        self.CO2kg_per_BTU:List[float] = self.CO2kg_per_BTU_default.copy()
        self.Biogas_CO2_Reduction:float = self.Biogas_CO2_Reduction_default

        self.energyunits: Final[List[str]] = ['BTU', 'kJ', 'kCal', 'kWh', 'hph']
        self.powerunits: Final[List[str]] = ['BTU/h', 'kJ/h', 'kCal/h', 'kW', 'hp']
        self.sourcenames: Final[List[str]] = ['LPG', 'NG', QApplication.translate('ComboBox','Elec')]
        self.meterunitnames: Final[List[str]] = ['BTU', 'kJ', 'kCal', 'kWh', 'thm']
        self.meterreads_default: List[List[float]] = [[0.]*9,[0.]*9] # scaled to btu, [0]:ON to OFF, [1:8] ON to extratemp[timeindex[0:7]]
        self.meterreads = self.meterreads_default.copy()
        ## setup defaults (stored in app):
        # Burners
        self.loadlabels_setup:List[str] = ['']*4                   # burner labels
        self.loadratings_setup:List[float] = [0]*4                 # in ratingunits
        self.ratingunits_setup:List[int] = [0]*4                   # index in list self.powerunits
        self.sourcetypes_setup:List[int] = [0]*4                   # index in list self.sourcenames
        self.load_etypes_setup:List[int] = [0]*4                   # index of the etype that is the gas/burner setting
        self.presssure_percents_setup:List[bool] = [False]*4       # event value in pressure percent
        self.loadevent_zeropcts_setup:List[int] = [0]*4            # event value corresponding to 0 percent
        self.loadevent_hundpcts_setup:List[int] = [100]*4          # event value corresponding to 100 percent
        # Meters
        self.meterlabels_setup:List[str] = ['']*2                  # meter labels
        self.meterunits_setup:List[int] = [3]*2                    # index in list meterunitnames, default to Elec
        self.meterfuels_setup:List[int] = [2]*2                    # index in list sourcetypes, default to kWh
        self.metersources_setup:List[int] = [0]*2                  # index in locally generated list curvenames
        # Protocol
        self.preheatDuration_setup:int = 0                         # length of preheat in seconds
        self.preheatenergies_setup:List[float] = [0]*4             # rating of the preheat burner
        self.betweenbatchDuration_setup:int = 0                    # length of bbp in seconds
        self.betweenbatchenergies_setup:List[float] = [0]*4        # rating of the between batch burner
        self.coolingDuration_setup:int = 0                         # length of cooling in seconds
        self.coolingenergies_setup:List[float] = [0]*4             # rating of the cooling burner
        self.betweenbatch_after_preheat_setup:bool = True          # True adds BBP to pre-heating (and cooling) for the first batch.
        self.electricEnergyMix_setup:int = 0                       # the amount of renewable electric energy in the energy mix in %
        self.gasMix_setup:int = 0                                  # the amount of renewable gas in the energy mix in %

        # Others
        self.energyresultunit_setup:int = 0                        # index in list self.powerunits
        self.kind_list: Final[List[str]] = [QApplication.translate('Label','Preheat Measured'),
                          QApplication.translate('Label','Preheat %'),
                          QApplication.translate('Label','BBP Measured'),
                          QApplication.translate('Label','BBP %'),
                          QApplication.translate('Label','Cooling Measured'),
                          QApplication.translate('Label','Cooling %'),
                          QApplication.translate('Label','Continuous'),
                          QApplication.translate('Label','Roast Event'),
                          QApplication.translate('Label','Meter')]
        self.perKgRoastMode:bool = False # if true only the amount during the roast and not the full batch (incl. preheat and BBP) are displayed), toggled by click on the result widget

        ## working variables (stored in .alog profiles):
        # Burners
        self.loadlabels = self.loadlabels_setup[:]               # burner labels
        self.loadratings = self.loadratings_setup[:]             # in ratingunits
        self.ratingunits = self.ratingunits_setup[:]             # index in list self.heatunits
        self.sourcetypes = self.sourcetypes_setup[:]             # index in list self.sourcetypes
        self.load_etypes = self.load_etypes_setup[:]             # index of the etype that is the gas/burner setting
        self.presssure_percents = self.presssure_percents_setup[:]  # event value in pressure percent
        self.loadevent_zeropcts = self.loadevent_zeropcts_setup[:]  # event value corresponding to 0 percent
        self.loadevent_hundpcts = self.loadevent_hundpcts_setup[:]  # event value corresponding to 100 percent
        # Meters
        self.meterlabels = self.meterlabels_setup[:]            # meter labels
        self.meterunits = self.meterunits_setup[:]              # index in list meterunitnames
        self.meterfuels = self.meterfuels_setup[:]              # index in list sourcetypes
        self.metersources = self.metersources_setup[:]          # index in locally generated list curvenames
        # Protocol
        self.preheatDuration = self.preheatDuration_setup               # length of preheat in seconds
        self.preheatenergies = self.preheatenergies_setup[:]            # rating of the preheat burner
        self.betweenbatchDuration = self.betweenbatchDuration_setup     # length of bbp in seconds
        self.betweenbatchenergies = self.betweenbatchenergies_setup[:]  # rating of the between batch burner
        self.coolingDuration = self.coolingDuration_setup               # length of cooling in seconds
        self.coolingenergies = self.coolingenergies_setup[:]            # rating of the cooling burner
        self.betweenbatch_after_preheat = self.betweenbatch_after_preheat_setup # True if after preheat a BBP is done
        self.electricEnergyMix = self.electricEnergyMix_setup           # the amount of renewable electric energy in the energy mix in %
        self.gasMix = self.gasMix_setup                                 # the amount of renewable gas in the energy mix in %

        #mouse cross lines measurement
        self.baseX:Optional[float] = None
        self.baseY:Optional[float] = None
        self.base_horizontalcrossline:Optional[Line2D] = None
        self.base_verticalcrossline:Optional[Line2D] = None
        self.base_messagevisible:bool = False

        #threshold for deltaE color difference comparisons
        self.colorDifferenceThreshold = 20

        #references to legend objects
        self.handles:List[Line2D] = []
        self.labels:List[str] = []
        self.legend_lines:List[Line2D] = []

        #used for picked event messages
        self.eventmessage = ''
        self.backgroundeventmessage = ''
        self.eventmessagetimer:Optional[QTimer] = None

        self.resizeredrawing = 0 # holds timestamp of last resize triggered redraw

        self.logoimg:Optional[npt.NDArray[numpy.double]] = None # holds the background logo image
        self.analysisresultsloc_default: Final[Tuple[float, float]] = (.49, .5)
        self.analysisresultsloc:Tuple[float, float] = self.analysisresultsloc_default
        self.analysispickflag:bool = False
        self.analysisresultsstr:str = ''
        self.analysisstartchoice:int = 1
        self.analysisoffset:int = 180
        self.curvefitstartchoice:int = 0
        self.curvefitoffset:int = 180
        self.segmentresultsloc_default: Final[Tuple[float, float]] = (.5, .5)
        self.segmentresultsloc:Tuple[float, float] = self.segmentresultsloc_default
        self.segmentpickflag:bool = False
        self.segmentdeltathreshold:float = 0.6
        self.segmentsamplesthreshold:int = 3

        self.stats_summary_rect:Optional[patches.Rectangle] = None

        # temp vars used to truncate title and statistic line (x_label) to width of MPL canvas
        self.title_text:Optional[str] = None
        self.title_artist:Optional[Text] = None
        self.title_width:Optional[float] = None
        self.background_title_width:float = 0
        self.xlabel_text:Optional[str] = None
        self.xlabel_artist:Optional[Text] = None
        self.xlabel_width:Optional[float] = None

        self.lazyredraw_on_resize_timer:QTimer =  QTimer()
        self.lazyredraw_on_resize_timer.timeout.connect(self.lazyredraw_on_resize)
        self.lazyredraw_on_resize_timer.setSingleShot(True)

        self.updategraphicsSignal.connect(self.updategraphics)
        self.updateLargeLCDsSignal.connect(self.updateLargeLCDs)
        self.updateLargeLCDsReadingsSignal.connect(self.updateLargeLCDsReadings)
        self.setTimerLargeLCDcolorSignal.connect(self.setTimerLargeLCDcolor)
        self.showAlarmPopupSignal.connect(self.showAlarmPopup)
        self.updateLargeLCDsTimeSignal.connect(self.updateLargeLCDsTime)
        self.fileDirtySignal.connect(self.fileDirty)
        self.fileCleanSignal.connect(self.fileClean)
        self.markChargeDelaySignal.connect(self.markChargeDelay)
        self.markChargeSignal.connect(self.markCharge, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markTPSignal.connect(self.markTPTrigger, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markDRYSignal.connect(self.markDryEnd, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markFCsSignal.connect(self.mark1Cstart, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markFCeSignal.connect(self.mark1Cend, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markSCsSignal.connect(self.mark2Cstart, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markSCeSignal.connect(self.mark2Cend, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markDropSignal.connect(self.markDrop, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.markCoolSignal.connect(self.markCoolEnd, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.onMonitorSignal.connect(self.OnMonitor, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.toggleMonitorSignal.connect(self.toggleMonitorTigger)
        self.toggleRecorderSignal.connect(self.toggleRecorderTigger)
        self.processAlarmSignal.connect(self.processAlarm, type=Qt.ConnectionType.QueuedConnection) # type: ignore # queued to avoid deadlock between RampSoak processing and EventRecordAction, both accessing the same critical section protected by profileDataSemaphore
        self.alarmsetSignal.connect(self.selectAlarmSet)
        self.moveBackgroundSignal.connect(self.moveBackgroundAndRedraw)
        self.eventRecordSignal.connect(self.EventRecordSlot)
        self.eventRecordActionSignal.connect(self.EventRecordActionSlot, type=Qt.ConnectionType.QueuedConnection) # type: ignore # queued to avoid deadlock between PID processing and EventRecordAction, both accessing the same critical section protected by profileDataSemaphore
        self.showCurveSignal.connect(self.showCurve)
        self.showExtraCurveSignal.connect(self.showExtraCurve)
        self.showEventsSignal.connect(self.showEvents)
        self.showBackgroundEventsSignal.connect(self.showBackgroundEvents)
        self.redrawSignal.connect(self.redraw, type=Qt.ConnectionType.QueuedConnection) # type: ignore
        self.redrawKeepViewSignal.connect(self.redraw_keep_view, type=Qt.ConnectionType.QueuedConnection) # type: ignore

    #NOTE: empty Figure is initially drawn at the end of self.awsettingsload()
    #################################    FUNCTIONS    ###################################
    #####################################################################################

    # ADD DEVICE:
    # returns True if the given device_id and channel_offset indicating if the devices first or second channel is addressed,
    # is a binary or special device channel
    # which should for example be excluded from filtering
    def dummy_or_special_device(self, device_id:int, channel_offset:int) -> bool:
        return (
              # any S7 binary channel
             (device_id == 79 and 2 < self.aw.s7.type[0+channel_offset] < 11) or # S7
             (device_id == 80 and 2 < self.aw.s7.type[2+channel_offset] < 11) or # S7 34
             (device_id == 81 and 2 < self.aw.s7.type[4+channel_offset] < 11) or # S7 56
             (device_id == 82 and 2 < self.aw.s7.type[6+channel_offset] < 11) or # S7 78
             (device_id == 83 and 2 < self.aw.s7.type[8+channel_offset] < 11) or # S7 910
             (device_id == 151 and 2 < self.aw.s7.type[8+channel_offset] < 11) or # S7 1112
              # any other binary device
             device_id in self.binaryDevices or
              # special device
             device_id in self.specialDevices
             )

    def get_container_weight(self, container_idx:int) -> Optional[int]:
        if len(self.container_weights) > container_idx >= 0:
            return self.container_weights[container_idx]
        return None

    # toggles the y cursor coordinate see self.fmt_data_curve
    def nextFmtDataCurve(self) -> None:
        self.fmt_data_curve = (self.fmt_data_curve+1) % 5
        if self.backgroundprofile is None and self.fmt_data_curve in {3, 4}:
            self.fmt_data_curve = 0
        if len(self.timex)<3 and self.fmt_data_curve in {1, 2}:
            if self.backgroundprofile is None:
                self.fmt_data_curve = 0
            else:
                self.fmt_data_curve = 3
        s = 'cursor position'
        if self.fmt_data_curve == 1:
            s = self.aw.BTname
        elif self.fmt_data_curve == 2:
            s = self.aw.ETname
        elif self.fmt_data_curve == 3:
            s = f"{QApplication.translate('Label','Background')} {self.aw.BTname}"
        elif self.fmt_data_curve == 4:
            s = f"{QApplication.translate('Label','Background')} {self.aw.ETname}"
        self.aw.ntb.update_message()
        self.aw.sendmessage(QApplication.translate('Message', 'set y-coordinate to {}').format(s))

    @pyqtSlot(str, bool)
    def showCurve(self, name: str, state: bool) -> None:
        changed:bool = False
        if name == 'ET' and self.ETcurve != state:
            self.ETcurve = state
            changed = True
        elif name == 'BT' and self.BTcurve != state:
            self.BTcurve = state
            changed = True
        elif name == 'DeltaET' and self.DeltaETflag != state:
            self.DeltaETflag = state
            changed = True
        elif name == 'DeltaBT' and self.DeltaBTflag != state:
            self.DeltaBTflag = state
            changed = True
        elif name == 'BackgroundET' and self.backgroundETcurve != state:
            self.backgroundETcurve = state
            changed = True
        elif name == 'BackgroundBT' and self.backgroundBTcurve != state:
            self.backgroundBTcurve = state
            changed = True
        if changed:
            self.redraw(recomputeAllDeltas=False,re_smooth_foreground=False)

    @pyqtSlot(int, str, bool)
    def showExtraCurve(self, extra_device: int, curve: str, state: bool) -> None:
        assert self.aw is not None
        if curve.strip() == 'T1' and len(self.aw.extraCurveVisibility1) > extra_device and self.aw.extraCurveVisibility1[extra_device] != state:
            self.aw.extraCurveVisibility1[extra_device] = state
            self.redraw(recomputeAllDeltas=False,re_smooth_foreground=False)
        elif curve.strip() == 'T2' and len(self.aw.extraCurveVisibility2) > extra_device and self.aw.extraCurveVisibility2[extra_device] != state:
            self.aw.extraCurveVisibility2[extra_device] = state
            self.redraw(recomputeAllDeltas=False,re_smooth_foreground=False)

    @pyqtSlot(int, bool)
    def showEvents(self, event_type: int, state: bool) -> None:
        event_type -= 1
        if len(self.showEtypes) > event_type >= 0 and self.showEtypes[event_type] != state:
            self.showEtypes[event_type] = state
            self.redraw(recomputeAllDeltas=False,re_smooth_foreground=False)

    @pyqtSlot(bool)
    def showBackgroundEvents(self, state: bool) -> None:
        if state != self.backgroundeventsflag:
            self.backgroundeventsflag = state
            self.redraw(recomputeAllDeltas=False,re_smooth_foreground=False)

    def ax_lines_clear(self) -> None:
        if self.ax is not None:
            while len(self.ax.lines) > 0:
                self.ax.lines[0].remove()

    def ax_combo_text_annotations_clear(self) -> None:
        if self.ax is not None:
            for child in self.ax.get_children():
                if isinstance(child, Annotation):
                    try:
                        child.remove()
                    except Exception: # pylint: disable=broad-except
                        pass

    def ax_annotations_clear(self) -> None:
        for la in self.l_annotations + self.l_background_annotations:
            if la:
                try:
                    la.remove()
                except Exception: # pylint: disable=broad-except
                    pass

    # set current burner settings as defaults
    def setEnergyLoadDefaults(self) -> None:
        self.loadlabels_setup = self.loadlabels[:]
        self.loadratings_setup = self.loadratings[:]
        self.ratingunits_setup = self.ratingunits[:]
        self.sourcetypes_setup = self.sourcetypes[:]
        self.load_etypes_setup = self.load_etypes[:]
        self.presssure_percents_setup = self.presssure_percents[:]
        self.loadevent_zeropcts_setup = self.loadevent_zeropcts[:]
        self.loadevent_hundpcts_setup = self.loadevent_hundpcts[:]
        self.meterlabels_setup = self.meterlabels[:]
        self.meterunits_setup = self.meterunits[:]
        self.meterfuels_setup = self.meterfuels[:]
        self.metersources_setup = self.metersources[:]
        self.electricEnergyMix_setup = self.electricEnergyMix
        self.gasMix_setup = self.gasMix

    # restore burner settings to their defaults
    def restoreEnergyLoadDefaults(self) -> None:
        self.loadlabels = self.loadlabels_setup[:]
        self.loadratings = self.loadratings_setup[:]
        self.ratingunits = self.ratingunits_setup[:]
        self.sourcetypes = self.sourcetypes_setup[:]
        self.load_etypes = self.load_etypes_setup[:]
        self.presssure_percents = self.presssure_percents_setup[:]
        self.loadevent_zeropcts = self.loadevent_zeropcts_setup[:]
        self.loadevent_hundpcts = self.loadevent_hundpcts_setup[:]
        self.meterlabels = self.meterlabels_setup[:]
        self.meterunits = self.meterunits_setup[:]
        self.meterfuels = self.meterfuels_setup[:]
        self.metersources = self.metersources_setup[:]
        self.electricEnergyMix = self.electricEnergyMix_setup
        self.gasMix = self.gasMix_setup

    # set current protocol settings as defaults
    def setEnergyProtocolDefaults(self) -> None:
        self.preheatDuration_setup = self.preheatDuration
        self.preheatenergies_setup = self.preheatenergies[:]
        self.betweenbatchDuration_setup = self.betweenbatchDuration
        self.betweenbatchenergies_setup = self.betweenbatchenergies[:]
        self.coolingDuration_setup = self.coolingDuration
        self.coolingenergies_setup = self.coolingenergies[:]
        self.betweenbatch_after_preheat_setup = self.betweenbatch_after_preheat

    # restore protocol settings to their defaults
    def restoreEnergyProtocolDefaults(self) -> None:
        self.preheatDuration = self.preheatDuration_setup
        self.preheatenergies = self.preheatenergies_setup[:]
        self.betweenbatchDuration = self.betweenbatchDuration_setup
        self.betweenbatchenergies = self.betweenbatchenergies_setup[:]
        self.coolingDuration = self.coolingDuration_setup
        self.coolingenergies = self.coolingenergies_setup[:]
        self.betweenbatch_after_preheat = self.betweenbatch_after_preheat_setup

    @pyqtSlot()
    def fileDirty(self) -> None:
        self.safesaveflag = True
        self.aw.updateWindowTitle()

    @pyqtSlot()
    def fileClean(self) -> None:
        self.safesaveflag = False
        self.aw.updateWindowTitle()

    @pyqtSlot()
    def lazyredraw_on_resize(self) -> None:
        self.lazyredraw(recomputeAllDeltas=False)

    def resizeEvent(self, event:'QResizeEvent') -> None:
        super().resizeEvent(event) # type:ignore
        # we only trigger a redraw on resize if a watermark is displayed to fix its aspect ratio
        if self.aw.redrawOnResize and self.aw.logofilename != '':
            dw = event.size().width() - event.oldSize().width()   # width change
            dh = event.size().height() - event.oldSize().height() # height change
#            t = libtime.time()
#            # ensure that we redraw during resize only once per second
#            if self.resizeredrawing + 0.5 < t and ((dw != 0) or (dh != 0)):
#                self.resizeredrawing = t
#                QTimer.singleShot(1, lazyredraw_on_resize)
            if ((dw != 0) or (dh != 0)):
                self.lazyredraw_on_resize_timer.start(10)


    # update the self.deltaBTspan and deltaETspan from the given sampling interval, self.deltaETsamples and self.deltaBTsamples
    # interval is expected in seconds (either from the profile on load or from the sampling interval set for recording)
    # both deltaBTsamples and deltaETsamples are at least one
    def updateDeltaSamples(self) -> None:
        if self.flagstart or self.profile_sampling_interval is None:
            speed = self.timeclock.getBase()/1000
            interval = speed * (self.delay / 1000)
        else:
            interval = self.profile_sampling_interval
        self.deltaBTsamples = max(1,int(round(self.deltaBTspan / interval)))
        self.deltaETsamples = max(1,int(round(self.deltaETspan / interval)))

    @pyqtSlot()
    def updateBackground(self) -> None:
        if not self.block_update and self.ax is not None:
            try:
                self.updateBackgroundSemaphore.acquire(1)
                self.block_update = True
                self.doUpdate()
            finally:
                if self.updateBackgroundSemaphore.available() < 1:
                    self.updateBackgroundSemaphore.release(1)

    def doUpdate(self) -> None:
        if not self.designerflag:
            self.resetlinecountcaches() # ensure that the line counts are up to date
            self.resetlines() # get rid of projection, cross lines and AUC line

            try:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw() # this triggers _draw_event(self,evt)
                #self.fig.canvas.draw_idle() # ask the canvas to kindly draw it self some time in the future when Qt thinks it is convenient
                # make sure that the GUI framework has a chance to run its event loop
                # and clear any GUI events.  This needs to be in a try/except block
                # because the default implementation of this method is to raise
                # NotImplementedError
                #self.fig.canvas.flush_events() # don't FLUSH event as this can lead to a second redraw started from within the same GUI thread and
                # causen a hang by the blocked semaphore
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            if self.ax is not None:
                axfig = self.ax.get_figure()
                if axfig is not None and hasattr(self.fig.canvas,'copy_from_bbox'):
                    self.ax_background = self.fig.canvas.copy_from_bbox(axfig.bbox) # pyright: ignore[reportAttributeAccessIssue]
                    # we redraw the additional artists like the projection lines, the timeline and the AUC guide line
                    self.update_additional_artists()
                    self.fig.canvas.blit(axfig.bbox)

        self.block_update = False

    def device_name_subst(self, device_name:str) -> str:
        try:
            return device_name.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3],self.mode)
        except Exception: # pylint: disable=broad-except
            # substitution might fail if the label contains brackets like in "t{FCS}"
            return device_name

    def get_etype_default(self, i:int, default_etypes_set:Optional[List[int]] = None) -> str:
        etypes_set = (self.default_etypes_set if default_etypes_set is None else default_etypes_set)
        return (self.alt_etypesdefault[i] if etypes_set[i] else self.etypesdefault[i])

    def get_etypes_defaults(self) -> List[str]:
        return [self.get_etype_default(i) for i,_ in enumerate(self.etypesdefault)]

    def getetypes(self) -> List[str]:
        if len(self.etypes) == 4:
            self.etypes.append('--')
        return self.etypes

    def etypesf(self, i:int) -> str:
        if len(self.etypes) == 4:
            self.etypes.append('--')
        if i > 4:
            return self.etypes[i-5]
        return self.etypes[i]

    def Betypesf(self, i:int, prefix:bool = False) -> str:
        if len(self.Betypes) == 4:
            self.Betypes.append('--')
        if prefix and i < 4:
            return 'Background'+self.Betypes[i]
        return self.Betypes[i]

    # returns the first letter as abbrev of the etype name if any
    # NOTE: that event type names should never be the empty string, but older Artisan versions allowed for this!
    @staticmethod
    def etypeAbbrev(etype_name:str) -> str:
        return etype_name[:1]

    def ambientTempSourceAvg(self) -> Optional[float]:
        res:Optional[float] = None
        if self.ambientTempSource:
            try:
                start = 0
                end = len(self.temp1) - 1
                if self.timeindex[0] > -1: # CHARGE
                    start = self.timeindex[0]
                if self.timeindex[6] > 0: # DROP
                    end = self.timeindex[6]
                if self.ambientTempSource == 1: # from ET
                    res = float(numpy.mean([e for e in self.temp1[start:end] if e is not None and e != -1]))
                elif self.ambientTempSource == 2: # from BT
                    res = float(numpy.mean([e for e in self.temp2[start:end] if e is not None and e != -1]))
                elif self.ambientTempSource > 2 and ((self.ambientTempSource - 3) < (2*len(self.extradevices))):
                    # from an extra device
                    if (self.ambientTempSource)%2==0:
                        res = float(numpy.mean([e for e in self.extratemp2[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1]))
                    else:
                        res = float(numpy.mean([e for e in self.extratemp1[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1]))
            except Exception as ex: # pylint: disable=broad-except # the array to average over might get empty and mean thus invoking an exception
                _log.exception(ex)
        if res is not None:
            res = float2float(res)
        return res

    def updateAmbientTempFromPhidgetModulesOrCurve(self) -> None:
        if not self.ambientTempSource:
            AT_device = None
            try:
                AT_device = self.extradevices.index(36)
            except Exception: # pylint: disable=broad-except
                try:
                    AT_device = self.extradevices.index(60)
                except Exception: # pylint: disable=broad-except
                    pass
            if AT_device is not None:
                # 1048_AT channel #36, TMP1101_AT channel #60
                # we try to access that devices first channel to retrieve the temperature data
                try:
                    ser = self.aw.extraser[AT_device]
                    if ser.PhidgetTemperatureSensor is not None:
                        at = ser.PhidgetTemperatureSensor[0].getTemperature()
                        if self.mode == 'F':
                            at = float2float(fromCtoFstrict(at))
                        self.ambientTemp = float2float(at)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            # in case the AT channel of the 1048 or the TMP1101 is not used as extra device, we try to attach to it anyhow and read the temp off
            elif self.ambientTemp == 0.0 and self.device in {34, 58}: # Phidget 1048 or TMP1101 channel 4 (use internal temp)
                try:
                    if self.aw.ser.PhidgetTemperatureSensor is not None and self.aw.ser.PhidgetTemperatureSensor[0].getAttached():
                        from Phidget22.Devices.TemperatureSensor import TemperatureSensor as PhidgetTemperatureSensor # type: ignore
                        ambient = PhidgetTemperatureSensor()
                        ambient.setDeviceSerialNumber(self.aw.ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber())
                        if self.device == 58:
                            ambient.setHubPort(self.aw.ser.PhidgetTemperatureSensor[0].getHubPort())
                        ambient.setChannel(4)
                        ambient.openWaitForAttachment(1000) # timeout in ms
                        if self.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                        t = ambient.getTemperature()
                        if self.mode == 'F':
                            self.ambientTemp = float2float(fromCtoFstrict(t))
                        else:
                            self.ambientTemp = float2float(t)
                        if ambient.getAttached():
                            ambient.close()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        res = self.ambientTempSourceAvg()
        if res is not None and (isinstance(res, (float,int))) and not math.isnan(res):
            self.ambientTemp = float2float(float(res))

    def updateAmbientTemp(self) -> None:
        self.updateAmbientTempFromPhidgetModulesOrCurve()
        try:
            self.startPhidgetManager()
            self.getAmbientData()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # eventsvalues maps the given internal event value v to an external event int value as displayed to the user as special event value
    # historicaly internal event values ranged from [1-11] and external event values from [0-10]
    #   that range was extended to 0-100 in later Artisan versions
    # v is expected to be float value of range [-11.0,11.0] or None (interpreted as 0)
    # negative values are not used as event values, but as step arguments in extra button definitions
    #   11.0 => 100
    #   10.1 => 91
    #   10.0 => 90
    #   1.1 => 1
    #   1.0 => 0
    #   0.5 => 0
    #     0 => 0
    #  -1.0 => 0
    #  -1.1 => -1
    # -10.0 => -90
    # -10.1 => -91
    # -11.0 => -100
    @staticmethod
    def eventsInternal2ExternalValue(v:Optional[float]) -> int:
        if v is None:
            return 0
        if -1.0 <= v <= 1.0:
            return 0
        if v < -1.0:
            return -(int(round(abs(v)*10)) - 10)
        return int(round(v*10)) - 10

    # the inverse of eventsInternal2ExternalValue, converting an external to an internal event value
    # v from [-100,100]
    @staticmethod
    def eventsExternal2InternalValue(v:int) -> float:
        if v == 0:
            return 0.
        if v >= 1:
            return v/10. + 1.
        return v/10. - 1.

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0-10]
    # negative values are mapped to ""
    # 0.1 to "1"
    # ..
    # 1.0 to "10"
    # ..
    # 10.0 to "100"
    def eventsvalues(self, v:float) -> str:
        return str(self.eventsInternal2ExternalValue(v))

    # 100.0 to "10" and 10.1 to "1"
    @staticmethod
    def eventsvaluesShort(v:float) -> str:
        value = v*10. - 10.
        if value == -10:
            return '0'
        if value < 0:
            return ''
        return str(int(round(value)))

    # the inverse to eventsvalues above (string -> value)
    def str2eventsvalue(self, s:str) -> float:
        st = s.strip()
        if st is None or len(st) == 0:
            return -1
        return self.eventsExternal2InternalValue(int(st))

    def fit_titles(self) -> None:
        #truncate title and statistic line to width of axis system to avoid that the MPL canvas goes into miser mode
        try:
            if self.ax is not None:
                r = None
                try:
                    r = self.fig.canvas.get_renderer() # type: ignore # MPL fails on savePDF with 'FigureCanvasPdf' object has no attribute 'get_renderer'
                except Exception: # pylint: disable=broad-except
                    pass
                if r is None:
                    ax_width = self.ax.get_window_extent().width
                else:
                    ax_width = self.ax.get_window_extent(renderer=r).width
                ax_width_for_title = ax_width - self.background_title_width
                redraw = False
                if self.title_text is not None and self.title_artist is not None and self.title_width is not None:
                    try:
                        prev_title_text = self.title_artist.get_text()
                        render = None
                        try:
                            render = self.fig.canvas.get_renderer() # type: ignore
                        except Exception: # pylint: disable=broad-except
                            # FigureCanvasPdf does not feature a renderer and thus the abbreviation mechanism does not work for PDF export
                            pass
                        if render is not None and ax_width_for_title <= self.title_width:
                            chars = max(3,int(ax_width_for_title / (self.title_width / len(self.title_text))) - 2)
                            self.title_artist.set_text(f'{self.title_text[:chars].strip()}...')
                        else:
                            self.title_artist.set_text(self.title_text)
                        if prev_title_text != self.title_artist.get_text():
                            redraw = True
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                if self.xlabel_text is not None and self.xlabel_artist is not None and self.xlabel_width is not None:
                    try:
                        prev_xlabel_text = self.xlabel_artist.get_text()
                        if ax_width <= self.xlabel_width:
                            chars = max(3,int(ax_width / (self.xlabel_width / len(self.xlabel_text))) - 2)
                            self.xlabel_artist.set_text(f'{self.xlabel_text[:chars].strip()}...')
                        else:
                            self.xlabel_artist.set_text(self.xlabel_text)
                        if prev_xlabel_text != self.xlabel_artist.get_text():
                            redraw = True
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                try:
                    if redraw:
                        # Temporarily disconnect any callbacks to the draw event...
                        # (To avoid recursion)
                        func_handles = self.fig.canvas.callbacks.callbacks['draw_event']
                        self.fig.canvas.callbacks.callbacks['draw_event'] = {}
                        # Re-draw the figure..
                        with warnings.catch_warnings():
                            warnings.simplefilter('ignore')
                            self.fig.canvas.draw()
                        # Reset the draw event callbacks
                        self.fig.canvas.callbacks.callbacks['draw_event'] = func_handles
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # hook up to mpls event handling framework for draw events
    # this is emitted after the canvas has finished a full redraw
    def _draw_event(self, _event:'Event') -> None:
        #self.fig.canvas.flush_events() # THIS prevents the black border on >Qt5.5, but slows down things (especially resizings) on redraw otherwise!!!
        self.ax_background = None
        # we trigger a re-fit of the titles to fit to the resized MPL canvas
        self.fit_titles()

    @pyqtSlot()
    def sendeventmessage(self) -> None:
        self.eventmessagetimer = None
        if len(self.backgroundeventmessage) != 0:
            self.aw.sendmessage(self.backgroundeventmessage,append=True)
            self.backgroundeventmessage = ''
            self.starteventmessagetimer(2)  #hack to ensure that the background event message is written first
            return
        if len(self.eventmessage) != 0:
            self.aw.sendmessage(self.eventmessage,append=True)
            self.eventmessage = ''

    def starteventmessagetimer(self,time:int = 120) -> None:
        if self.eventmessagetimer is not None:
            self.eventmessagetimer.stop()
            self.eventmessagetimer.deleteLater()
        self.eventmessagetimer = QTimer()
        self.eventmessagetimer.timeout.connect(self.sendeventmessage)
        self.eventmessagetimer.setSingleShot(True)
        self.eventmessagetimer.start(time)

    def onpick(self, event:'PickEvent') -> None:
        try:
            # reset picked foreground event
            self.foreground_event_ind = None
            self.foreground_event_pos = None
            self.foreground_event_pick_position = None
            self.clear_last_picked_event_selection()
            # reset picked background event
            self.background_event_ind = None
            self.background_event_pos = None
            self.background_event_pick_position = None
            self.clear_last_background_picked_event_selection()
            # display MET information by clicking on the MET marker
            if (isinstance(event.artist, Annotation) and self.showmet and event.artist in [self.met_annotate] and
                    self.met_timex_temp1_delta is not None and self.met_timex_temp1_delta[2] is not None):
                if  self.met_timex_temp1_delta[2] >= 0:
                    met_time_str = str(self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate('Message','seconds before FCs')
                else:
                    met_time_str = str(-1*self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate('Message','seconds after FCs')

                self.aw.sendmessage(f'MET {float2float(self.met_timex_temp1_delta[1],1)}{self.mode} @ {stringfromseconds(self.met_timex_temp1_delta[0])}, {met_time_str} {met_time_msg}')

            # the analysis results were clicked
            elif self.aw.analysisresultsanno is not None and isinstance(event.artist, Annotation) and event.artist in [self.aw.analysisresultsanno]:
                self.analysispickflag = True

            # the segment results were clicked
            elif self.aw.segmentresultsanno is not None and isinstance(event.artist, Annotation) and event.artist in [self.aw.segmentresultsanno]:
                self.segmentpickflag = True

            # toggle visibility of graph lines by clicking on the legend
            elif self.legend is not None and event.artist != self.legend and isinstance(event.artist, (Line2D, Text)) \
                and event.artist not in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots] \
                and event.artist not in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                idx = None
                # deltaLabelMathPrefix (legend label)
                # deltaLabelUTF8 (artist)
                if isinstance(event.artist, Text):
                    artist = None
                    label = None
                    try:
                        label = event.artist.get_text() # pyright: ignore[reportGeneralTypeIssues]
                        idx = self.labels.index(label)
                    except Exception: # pylint: disable=broad-except
                        pass
                    if label is not None and idx is not None:
                        if label == self.aw.ETname:
                            label = 'ET'  #allows for a match below to the label in legend_lines
                            try:
                                for a in self.l_eteventannos:
                                    a.set_visible(not a.get_visible())
                                if self.met_annotate is not None:
                                    self.met_annotate.set_visible(not self.met_annotate.get_visible())
                            except Exception: # pylint: disable=broad-except
                                pass
                        elif label == self.aw.BTname:
                            label = 'BT'  #allows for a match below to the label in legend_lines
                            try:
                                for a in self.l_bteventannos:
                                    a.set_visible(not a.get_visible())
                            except Exception: # pylint: disable=broad-except
                                pass
                        try:
                            # toggle also the visibility of the legend handle
                            clean_label = label.replace(deltaLabelMathPrefix,deltaLabelUTF8)
                            artist = next((x for x in self.legend_lines if x.get_label() == clean_label), None)
                            if artist:
                                artist.set_visible(not artist.get_visible())
                        except Exception: # pylint: disable=broad-except
                            pass
                    # toggle the visibility of the corresponding line
                    if idx is not None and artist:
                        artist = self.handles[idx]
                        artist.set_visible(not artist.get_visible())
                        if self.eventsGraphflag in {2, 3, 4} and label is not None:
                            # if events are rendered in Combo style we need to hide also the corresponding annotations:
                            try:
                                i = [self.aw.arabicReshape(et) for et in self.etypes[:4]].index(label)
                                if i == 0:
                                    for a in self.l_eventtype1annos:
                                        a.set_visible(not a.get_visible())
                                elif i == 1:
                                    for a in self.l_eventtype2annos:
                                        a.set_visible(not a.get_visible())
                                elif i == 2:
                                    for a in self.l_eventtype3annos:
                                        a.set_visible(not a.get_visible())
                                elif i == 3:
                                    for a in self.l_eventtype4annos:
                                        a.set_visible(not a.get_visible())
                            except Exception: # pylint: disable=broad-except
                                pass

            # show event information by clicking on event lines in step, step+ and combo modes
            elif isinstance(event.artist, Line2D):
                event_type:Optional[int] = None
                if isinstance(event.ind, int): # type: ignore[attr-defined] # "PickEvent" has no attribute "ind"
                    ind = event.ind # type: ignore[attr-defined] # "PickEvent" has no attribute "ind"
                else:
                    if event.ind is None or len(event.ind) < 1 or not isinstance(event.ind[0], (int, numpy.integer)): # type: ignore[attr-defined] # "PickEvent" has no attribute "ind"
                        return
                    ind = event.ind[-1] # type: ignore[attr-defined] # "PickEvent" has no attribute "ind"
                digits = (1 if self.LCDdecimalplaces else 0)
                if event.artist in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]:
                    tx = event.artist.get_xdata()[ind]
                    timex = self.backgroundtime2index(tx)
                    if event.artist is not None and abs(tx - event.mouseevent.xdata)<3: # allow a slightly different mouse position, but close enough to the point on the line
                        if event.artist == self.l_backgroundeventtype1dots:
                            event_type = 0
                        elif event.artist == self.l_backgroundeventtype2dots:
                            event_type = 1
                        elif event.artist == self.l_backgroundeventtype3dots:
                            event_type = 2
                        elif event.artist == self.l_backgroundeventtype4dots:
                            event_type = 3
                        if event_type is not None:
                            event_ydata = event.artist.get_ydata()[ind]
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            if self.clampEvents:
                                evalue = max(0,int(round(event_ydata)))
                            else:
                                evalue = max(0,int(round((event_ydata - event_pos_offset) / event_pos_factor)))
                            evalue_internal = self.eventsExternal2InternalValue(evalue)
                            for i, bge in enumerate(self.backgroundEvents):
                                if (event_type == self.backgroundEtypes[i] and
                                        evalue_internal == self.backgroundEvalues[i] and # same event value
                                        abs(timex-bge) <= 1):
                                    if self.timeindex[0] != -1:
                                        start = self.timex[self.timeindex[0]]
                                    else:
                                        start = 0
                                    if len(self.backgroundeventmessage) != 0:
                                        self.backgroundeventmessage += ' | '
                                    else:
                                        self.backgroundeventmessage += 'Background: '
                                    self.backgroundeventmessage = f'{self.backgroundeventmessage}{self.Betypesf(self.backgroundEtypes[i])} = {self.eventsvalues(self.backgroundEvalues[i])}'
                                    if self.renderEventsDescr and self.backgroundEStrings[i] and self.backgroundEStrings[i]!='':
                                        self.backgroundeventmessage = f'{self.backgroundeventmessage} ({self.backgroundEStrings[i].strip()[:self.eventslabelschars]})'
                                    self.backgroundeventmessage = f'{self.backgroundeventmessage} @ {(stringfromseconds(self.timeB[bge] - start))} {float2float(self.temp2B[bge],digits)}{self.mode}'
                                    self.starteventmessagetimer()
                                    if self.eventsGraphflag in {2,3,4}:
                                        # we support custom event pick-and-drag only for events rendered as step lines, step+ and as combo.
                                        self.background_event_ind = i
                                        self.background_event_pos = ind
                                        self.background_event_pick_position = (event.artist.get_xdata()[ind],event.artist.get_ydata()[ind])
                                        self.background_event_last_picked_ind = i
                                        self.background_event_last_picked_pos = ind
                                    break
                elif event.artist in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                    tx = event.artist.get_xdata()[ind]
                    timex = self.time2index(tx)
                    if event.artist is not None and abs(tx - event.mouseevent.xdata)<3: # allow a slightly different mouse position, but close enough to the point on the line
                        if event.artist == self.l_eventtype1dots:
                            event_type = 0
                        elif event.artist == self.l_eventtype2dots:
                            event_type = 1
                        elif event.artist == self.l_eventtype3dots:
                            event_type = 2
                        elif event.artist == self.l_eventtype4dots:
                            event_type = 3
                        if event_type is not None:
                            event_ydata = event.artist.get_ydata()[ind]
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            if self.clampEvents:
                                evalue = max(0,int(round(event_ydata)))
                            else:
                                evalue = max(0,int(round((event_ydata - event_pos_offset) / event_pos_factor)))
                            evalue_internal = self.eventsExternal2InternalValue(evalue)
                            for i, spe in enumerate(self.specialevents):
                                # search for the corresponding custom event
                                if (event_type == self.specialeventstype[i] and # same event type
                                        evalue_internal == self.specialeventsvalue[i] and # same event value
                                        abs(timex -spe) <= 1): # same event time
                                    if self.timeindex[0] != -1:
                                        start = self.timex[self.timeindex[0]]
                                    else:
                                        start = 0
                                    if len(self.eventmessage) != 0:
                                        self.eventmessage = f'{self.eventmessage} | '
                                    self.eventmessage = f'{self.eventmessage}{self.etypesf(self.specialeventstype[i])} = {self.eventsvalues(self.specialeventsvalue[i])}'
                                    if self.renderEventsDescr and self.specialeventsStrings[i] and self.specialeventsStrings[i]!='':
                                        self.eventmessage = f'{self.eventmessage} ({self.specialeventsStrings[i].strip()[:self.eventslabelschars]})'
                                    self.eventmessage = f'{self.eventmessage} @ {stringfromseconds(self.timex[spe] - start)} {float2float(self.temp2[spe],digits)}{self.mode}'
                                    self.starteventmessagetimer()
                                    if self.eventsGraphflag in {2,3,4}:
                                        # we support custom event pick-and-drag only for events rendered as step lines, step+ and as combo.
                                        self.foreground_event_ind = i
                                        self.foreground_event_pos = ind
                                        self.foreground_event_pick_position = (event.artist.get_xdata()[ind],event.artist.get_ydata()[ind])
                                        self.foreground_event_last_picked_ind = i
                                        self.foreground_event_last_picked_pos = ind
                                    break
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' onpick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    # returns event line artist, if any, and, if events are displayed as Combo also the list event annotations or in Step+ mode also the flag annos
    def event_type_to_artist(self, event_type:int) -> Tuple[Optional[Line2D],Optional[List[Annotation]]]:
        ldots:Optional[Line2D] = None
        event_annos:Optional[List[Annotation]] = None
        if event_type == 0:
            ldots = self.l_eventtype1dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype1annos
        elif event_type == 1:
            ldots = self.l_eventtype2dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype2annos
        elif event_type == 2:
            ldots = self.l_eventtype3dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype3annos
        elif event_type == 3:
            ldots = self.l_eventtype4dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype4annos
        if self.eventsGraphflag == 3:
            event_annos = self.l_eventflagannos
        return ldots, event_annos

    # returns background event line artist, if any, and, if events are displayed as Combo also the list event annotations or in Step+ mode also the flag annos
    def event_type_to_background_artist(self, event_type:int) -> Tuple[Optional[Line2D],Optional[List[Annotation]]]:
        ldots:Optional[Line2D] = None
        event_annos:Optional[List[Annotation]] = None
        if event_type == 0:
            ldots = self.l_backgroundeventtype1dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype1backannos
        elif event_type == 1:
            ldots = self.l_backgroundeventtype2dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype2backannos
        elif event_type == 2:
            ldots = self.l_backgroundeventtype3dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype3backannos
        elif event_type == 3:
            ldots = self.l_backgroundeventtype4dots
            if self.eventsGraphflag == 4:
                event_annos = self.l_eventtype4backannos
        if self.eventsGraphflag == 3:
            event_annos = self.l_eventflagbackannos
        return ldots, event_annos

    # ind: the event index in self.specialevents; pos: the index in the corresponding 2DLine artist
    # if foreground, we ind and pos are interpreted against the foreground profile otherwise against the background profile
    def move_custom_event(self, foreground:bool, ind:int, pos:int, xstep:int = 0, ystep:int = 0) -> None:
        specialevents = (self.specialevents if foreground else self.backgroundEvents)
        specialeventstype = (self.specialeventstype if foreground else self.backgroundEtypes)
        specialeventsvalue = (self.specialeventsvalue if foreground else self.backgroundEvalues)
        if len(specialeventstype)>ind:
            # update event value
            new_value:int = self.eventsInternal2ExternalValue(specialeventsvalue[ind]) + ystep
            specialeventsvalue[ind] = self.eventsExternal2InternalValue(new_value)
            # establish new artist value
            event_type = specialeventstype[ind]
            ldots:Optional[Line2D] = None
            event_annos = None
            ldots, event_annos = (self.event_type_to_artist(event_type) if foreground else self.event_type_to_background_artist(event_type))
            if ldots is not None:
                xdata = ldots.get_xdata()
                ydata = ldots.get_ydata()
                if self.clampEvents:
                    event_ydata = new_value
                else:
                    event_pos_offset = self.eventpositionbars[0]
                    event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                    event_ydata = int(round(new_value * event_pos_factor + event_pos_offset))
                ydata[pos] = event_ydata
                if (not self.flagon and len(ydata) == pos + 2 and (
                    self.timeindex[6]!=0 and self.timex[self.timeindex[6]] >= xdata[-1] if foreground
                        else self.timeindexB[6]!=0 and self.timeB[self.timeindexB[6]] >= xdata[-1])):
                    # we also move the last dot up and down with the butlast
                    ydata[-1] = ydata[-2]
                ldots.set_ydata(ydata)
                # update the xdata
                time_idx = (max(0,min(len(self.timex)-1,self.time2index(xdata[pos]))) if foreground else
                        max(0,min(len(self.timeB)-1,self.backgroundtime2index(xdata[pos]))))
                if xstep:
                    time_idx += xstep
                    if not foreground:
                        # don't move events beyond previous and next events positions
                        if pos != 0:
                            # there is a point left to ours
                            time_idx = max(self.backgroundtime2index(xdata[pos-1])+1,time_idx)
                        if pos != len(xdata)-1:
                            # there is a point right to ours
                            time_idx = min(time_idx,self.backgroundtime2index(xdata[pos+1])-1)
                    # limit to length of timex/timeB
                    time_idx = (max(0,min(len(self.timex)-1,time_idx)) if foreground else max(0,min(len(self.timeB)-1,time_idx)))
                    specialevents[ind] = time_idx
                    # update also the Artist to the final time
                    xdata[pos] = (self.timex[time_idx] if foreground else self.timeB[time_idx])
                    ldots.set_xdata(xdata)
                if foreground and xstep != 0:
                    # we redraw the selection mark only for foreground selections
                    self.resetlines()
                    self.aw.plotEventSelection(ind)
                if event_annos is not None:
                    if (foreground and self.foregroundShowFullflag) or (not foreground and self.backgroundShowFullflag):
                        corrected_event_pos = pos
                    else: # extra one is added to line at the end, but without anno
                        corrected_event_pos = pos - max(0, len(xdata) - len(event_annos) - 1) # before first anno there can be others line elements
                    if self.eventsGraphflag == 4 and len(event_annos)>corrected_event_pos:
                        event_anno = event_annos[corrected_event_pos]
                        self.updateEventAnno(
                            event_type,
                            event_anno,
                            (self.timex[time_idx] if foreground else self.timeB[time_idx]),
                            event_ydata,
                            background = not foreground)
                    elif self.eventsGraphflag == 3 and ((foreground and (self.ETcurve or self.BTcurve)) or (not foreground and (self.backgroundETcurve or self.backgroundBTcurve))):
                        event_ind = ind
                        if foreground and not self.foregroundShowFullflag:
                            event_ind -= self.foreground_evens_before_CAHRGE()
                        if not foreground and not self.backgroundShowFullflag:
                            event_ind -= self.background_evens_before_CAHRGE()
                        if len(event_annos)>event_ind:
                            event_anno = event_annos[event_ind]
                            tempo:Optional[float] = None
                            if foreground:
                                if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[ind] > self.temp2[ind]):
                                    if self.flagon:
                                        tempo = self.temp1[time_idx]
                                    else:
                                        tempo = self.stemp1[time_idx]
                                elif self.BTcurve:
                                    if self.flagon:
                                        tempo = self.temp2[time_idx]
                                    else:
                                        tempo = self.stemp2[time_idx]
                            elif self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1B[ind] > self.temp2B[ind]):
                                tempo = self.temp1B[time_idx]
                            elif self.BTcurve:
                                tempo = self.temp2B[time_idx]
                            if tempo is not None:
                                self.updateFlagAnno(
                                    event_type,
                                    event_anno,
                                    (self.timex[time_idx] if foreground else self.timeB[time_idx]),
                                    event_ydata,
                                    tempo)
                # redraw
                if self.flagon:
                    self.redraw_keep_view(recomputeAllDeltas=False)
                else:
                    self.fileDirtySignal.emit()
                    self.fig.canvas.draw_idle()

    def onrelease_after_pick(self, _event:'Optional[Event]') -> None:
        try:
            ldots:Optional[Line2D]
            event_annos:Optional[List[Annotation]]
            tempo:Optional[float] = None
            if (self.foreground_event_ind is not None and self.foreground_event_pos is not None and self.foreground_event_pick_position is not None and
                    len(self.specialeventstype)>self.foreground_event_ind):
                event_type = self.specialeventstype[self.foreground_event_ind]
                ldots = None
                event_annos = None
                ldots, event_annos = self.event_type_to_artist(event_type)
                if ldots is not None:
                    # update the xdata
                    xdata = ldots.get_xdata()
                    time_idx = max(0,min(len(self.timex)-1,self.time2index(xdata[self.foreground_event_pos])))
                    self.specialevents[self.foreground_event_ind] = time_idx
                    # update also the Artist to the final time
                    xdata[self.foreground_event_pos] = self.timex[time_idx]
                    ldots.set_xdata(xdata)
                    # update the ydata
                    ydata = ldots.get_ydata()
                    event_ydata = ydata[self.foreground_event_pos]
                    event_pos_offset = self.eventpositionbars[0]
                    event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                    if self.clampEvents:
                        evalue = max(0,int(round(event_ydata)))
                    else:
                        evalue = max(0,int(round((event_ydata - event_pos_offset) / event_pos_factor)))
                    evalue_internal = self.eventsExternal2InternalValue(evalue)
                    self.specialeventsvalue[self.foreground_event_ind] = evalue_internal
                    # put back after rounding and converting back to position
                    ydata[self.foreground_event_pos] = (evalue if self.clampEvents else (evalue*event_pos_factor)+event_pos_offset)
                    if event_annos is not None:
                        if self.foregroundShowFullflag:
                            corrected_foreground_event_pos = self.foreground_event_pos
                        else: # extra one is added to line at the end, but without anno
                            corrected_foreground_event_pos = self.foreground_event_pos - max(0, len(xdata) - len(event_annos) - 1) # before first anno there can be others line elements
                        if self.eventsGraphflag == 4 and len(event_annos)>corrected_foreground_event_pos:
                            event_anno = event_annos[corrected_foreground_event_pos]
                            self.updateEventAnno(
                                event_type,
                                event_anno,
                                self.timex[time_idx],
                                event_ydata)
                        elif self.eventsGraphflag == 3 and (self.ETcurve or self.BTcurve):
                            event_ind = self.foreground_event_ind
                            if not self.foregroundShowFullflag:
                                event_ind -= self.foreground_evens_before_CAHRGE()
                            if len(event_annos)>event_ind:
                                event_anno = event_annos[event_ind]
                                if self.ETcurve and (not self.BTcurve or
                                            not self.showeventsonbt or self.temp1[time_idx] > self.temp2[time_idx]):
                                    if self.flagon:
                                        tempo = self.temp1[time_idx]
                                    else:
                                        tempo = self.stemp1[time_idx]
                                elif self.BTcurve:
                                    if self.flagon:
                                        tempo = self.temp2[time_idx]
                                    else:
                                        tempo = self.stemp2[time_idx]
                                if tempo is not None:
                                    self.updateFlagAnno(
                                        event_type,
                                        event_anno,
                                        self.timex[time_idx],
                                        event_ydata,
                                        tempo)
                    # redraw
                    if self.flagon:
                        self.redraw_keep_view(recomputeAllDeltas=False)
                    else:
                        if self.foreground_event_last_picked_ind is not None:
                            self.resetlines()
                            if self.aw.eNumberSpinBox.value() == self.foreground_event_last_picked_ind+1:
                                self.aw.changeEventNumber(self.foreground_event_last_picked_ind+1)
                            else:
                                self.aw.eNumberSpinBox.setValue(self.foreground_event_last_picked_ind+1) # updates Event minieditor and draws selection
                        self.fileDirtySignal.emit()
                        self.fig.canvas.draw_idle()
                elif self.legend is not None:
                    QTimer.singleShot(1,self.updateBackground)


            elif (self.background_event_ind is not None and self.background_event_pos is not None and self.background_event_pick_position is not None and
                    len(self.backgroundEtypes)>self.background_event_ind):
                event_type = self.backgroundEtypes[self.background_event_ind]
                ldots = None
                event_annos = None
                ldots, event_annos = self.event_type_to_background_artist(event_type)
                if ldots is not None:
                    # update the xdata
                    xdata = ldots.get_xdata()
                    time_idx = max(0,min(len(self.timeB)-1,self.backgroundtime2index(xdata[self.background_event_pos])))
                    self.backgroundEvents[self.background_event_ind] = time_idx
                    # update also the Artist to the final time
                    xdata[self.background_event_pos] = self.timeB[time_idx]
                    ldots.set_xdata(xdata)
                    # update the ydata
                    ydata = ldots.get_ydata()
                    event_ydata = ydata[self.background_event_pos]
                    event_pos_offset = self.eventpositionbars[0]
                    event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                    if self.clampEvents:
                        evalue = max(0,int(round(event_ydata)))
                    else:
                        evalue = max(0,int(round((event_ydata - event_pos_offset) / event_pos_factor)))
                    evalue_internal = self.eventsExternal2InternalValue(evalue)
                    self.backgroundEvalues[self.background_event_ind] = evalue_internal
                    # put back after rounding and converting back to position
                    ydata[self.background_event_pos] = (evalue if self.clampEvents else (evalue*event_pos_factor)+event_pos_offset)
                    if event_annos is not None:
                        if self.backgroundShowFullflag: # extra one is added to line at the end, but without anno
                            corrected_backround_event_pos = self.background_event_pos #- max(0, len(xdata) - len(event_annos)) # before first anno there can be others line elements
                        else:
                            corrected_backround_event_pos = self.background_event_pos - max(0, len(xdata) - len(event_annos) - 1) # before first anno there can be others line elements
                        if self.eventsGraphflag == 4 and len(event_annos)>corrected_backround_event_pos:
                            event_anno = event_annos[corrected_backround_event_pos]
                            self.updateEventAnno(
                                event_type,
                                event_anno,
                                self.timeB[time_idx],
                                event_ydata,
                                background=True)
                        elif self.eventsGraphflag == 3 and (self.backgroundETcurve or self.backgroundBTcurve):
                            event_ind = self.background_event_ind
                            if not self.backgroundShowFullflag:
                                event_ind -= self.background_evens_before_CAHRGE()
                            if len(event_annos)>event_ind:
                                event_anno = event_annos[event_ind]
                                if self.backgroundETcurve and (not self.backgroundBTcurve or
                                            not self.showeventsonbt or self.temp1B[time_idx] > self.temp2B[time_idx]):
                                    tempo = self.temp1B[time_idx]
                                elif self.BTcurve:
                                    tempo = self.temp2B[time_idx]
                                if tempo is not None:
                                    self.updateFlagAnno(
                                        event_type,
                                        event_anno,
                                        self.timeB[time_idx],
                                        event_ydata,
                                        tempo)
                    # redraw
                    if self.flagon:
                        self.redraw_keep_view(recomputeAllDeltas=False)
                    else:
                        self.fig.canvas.draw_idle()
                elif self.legend is not None:
                    QTimer.singleShot(1,self.updateBackground)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        self.release_picked_event()

    def release_picked_event(self) -> None:
        self.foreground_event_ind = None
        self.foreground_event_pos = None
        self.foreground_event_pick_position = None
        self.background_event_ind = None
        self.background_event_pos = None
        self.background_event_pick_position = None

    def onrelease(self, event:'Event') -> None:     # NOTE: onrelease() is connected/disconnected in togglecrosslines()
        event = cast('MouseEvent', event)
        try:
            if self.ax is None:
                return
            if event.button == 1:
                i:int
                self.baseX,self.baseY = None, None
                try:
                    i = self.ax.lines.index(self.base_horizontalcrossline)
                    self.ax.lines[i].remove()
#                    self.ax.lines.remove(self.base_horizontalcrossline)
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    i = self.ax.lines.index(self.base_verticalcrossline)
                    self.ax.lines[i].remove()
#                    self.ax.lines.remove(self.base_verticalcrossline)
                except Exception: # pylint: disable=broad-except
                    pass
                self.base_horizontalcrossline, self.base_verticalcrossline = None, None
            # save the location of analysis results after dragging
            if self.analysispickflag and self.aw.analysisresultsanno is not None:
                self.analysispickflag = False
                bboxpatch = self.aw.analysisresultsanno.get_bbox_patch()
                if bboxpatch is not None:
                    corners = self.ax.transAxes.inverted().transform(bboxpatch.get_extents())
                    self.analysisresultsloc = (toFloat(corners[0][0]), toFloat(corners[0][1] + (corners[1][1] - corners[0][1])/2))
                    #reset the annotation location if the origin is out of the screen
                    for dim in self.analysisresultsloc:
                        if dim >= 1 or dim <=0:
                            self.analysisresultsloc = self.analysisresultsloc_default
            # save the location of segment results after dragging
            if self.segmentpickflag and self.aw.segmentresultsanno is not None:
                self.segmentpickflag = False
                bbox_patch = self.aw.segmentresultsanno.get_bbox_patch()
                if bbox_patch is not None:
                    corners = self.ax.transAxes.inverted().transform(bbox_patch.get_extents())
                    self.segmentresultsloc = (toFloat(corners[0][0]), toFloat(corners[0][1] + (corners[1][1] - corners[0][1])/2))
                    #reset the annotation location if the origin is out of the screen
                    for dim in self.segmentresultsloc:
                        if dim >= 1 or dim <=0:
                            self.segmentresultsloc = self.segmentresultsloc_default
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' onclick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))


    def disconnect_draggableannotations_motion_notifiers(self) -> None:
        cids = []
        try:
            if 'motion_notify_event' in self.fig.canvas.callbacks.callbacks:
                motion_notify_event_handlers = self.fig.canvas.callbacks.callbacks['motion_notify_event']
                for cid, func_ref in motion_notify_event_handlers.items():
                    func = func_ref()
                    if func.__self__ is not None: # a bound method
                        c = func.__self__.__class__
                        if c == DraggableAnnotation:
                            cids.append(cid)
            # disconnecting all established motion_notify_event_handlers of DraggableAnnotations
            for cid in cids:
                self.fig.canvas.mpl_disconnect(cid)
        except Exception: # pylint: disable=broad-except
            pass

    # update event annotation value and position in combo mode
    # if background is True, we use the backgrounds event name/letters
    def updateEventAnno(self, event_type:int, event_anno:Annotation, x:float, y:float, background:bool = False) -> None:
        # update marker position
        event_anno.set_position((x,y))
        # update marker text
        event_pos_offset = self.eventpositionbars[0]
        event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
        if self.clampEvents:
            evalue = max(0,int(round(y)))
        else:
            evalue = max(0,int(round((y - event_pos_offset) / event_pos_factor)))
        evalue_internal = self.eventsExternal2InternalValue(evalue)
        # set anno text
        if background:
            Betype = self.Betypesf(event_type)
            firstletter = self.etypeAbbrev(Betype)
        else:
            etype = self.etypesf(event_type)
            firstletter = self.etypeAbbrev(etype)
        secondletter = self.eventsvaluesShort(evalue_internal)
        if self.aw.eventslidertemp[event_type]:
            thirdletter = self.mode # postfix
        else:
            thirdletter = self.aw.eventsliderunits[event_type] # postfix
        if thirdletter != '':
            firstletter = ''
        event_anno.set_text(f'{firstletter}{secondletter}{thirdletter}')

    def updateFlagAnno(self, event_type:int, flag_anno:Annotation, x:float, y:float, yy:float) -> None:
        # update marker position
        height = 50 if self.mode == 'F' else 20
        flag_anno.set_position((x,yy+height))
        flag_anno.xy = (x,yy)

        # update marker text
        event_pos_offset = self.eventpositionbars[0]
        event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
        if self.clampEvents:
            evalue = max(0,int(round(y)))
        else:
            evalue = max(0,int(round((y - event_pos_offset) / event_pos_factor)))
        evalue_internal = self.eventsExternal2InternalValue(evalue)
        # set anno text
        etype = self.etypesf(event_type)
        firstletter = self.etypeAbbrev(etype)
        secondletter = self.eventsvaluesShort(evalue_internal)
        flag_anno.set_text(f'{firstletter}{secondletter}')

    def foreground_evens_before_CAHRGE(self) -> int:
        if self.timeindex[0] < 0:
            return 0
        # assuming self.specialevents are ordered by time
        count = 0
        for se in self.specialevents:
            if se >= self.timeindex[0]:
                return count
            count += 1
        return count

    def background_evens_before_CAHRGE(self) -> int:
        if self.timeindexB[0] < 0:
            return 0
        # assuming self.backgroundEvents are ordered by time
        count = 0
        for se in self.backgroundEvents:
            if se >= self.timeindexB[0]:
                return count
            count += 1
        return count

    def onmove(self, event:'MouseEvent') -> None:
        if all(x is None for x in [self.foreground_event_ind, self.foreground_event_pos, self.foreground_event_pick_position,
            self.background_event_ind, self.background_event_pos, self.background_event_pick_position]):
            return
        if self.foreground_event_ind is not None:
            self.clear_last_picked_event_selection() # clear the last picked event index, if any, remembered for the delete event by backspace action
        if event.inaxes is None:
            return
        if event.button != 1:
            return
        if event.xdata is None:
            return
        if event.ydata is None:
            return
        tempo:Optional[float] = None
        if  (self.foreground_event_ind is not None and self.foreground_event_pos is not None and self.foreground_event_pick_position is not None and
                    len(self.specialeventstype)>self.foreground_event_ind):
            event_type = self.specialeventstype[self.foreground_event_ind]
            ldots = None
            event_annos = None
            ldots, event_annos = self.event_type_to_artist(event_type)
            set_x = True
            set_y = True
            if ldots is not None:
                if QApplication.keyboardModifiers() == Qt.KeyboardModifier.ShiftModifier:
                    if abs(event.xdata - self.foreground_event_pick_position[0]) < abs(event.ydata - self.foreground_event_pick_position[1]):
                        set_x = False
                    else:
                        set_y = False
                xdata = ldots.get_xdata()
                if set_x:
                    xdata[self.foreground_event_pos] = int(round(event.xdata))
                    ldots.set_xdata(xdata)
                ydata = ldots.get_ydata()
                if set_y:
                    ydata[self.foreground_event_pos] = max(0,event.ydata)
                    if not self.flagon and len(ydata) == self.foreground_event_pos + 2 and (self.timeindex[6]!=0 and self.timex[self.timeindex[6]] >= xdata[-1]):
                        # we also move the last dot up and down with the butlast if automatically added, but only if that last one is not after DROP
                        ydata[-1] = ydata[-2]
                    ldots.set_ydata(ydata)
                if event_annos is not None:
                    if self.foregroundShowFullflag:
                        corrected_foreground_event_pos = self.foreground_event_pos
                    else: # extra one is added to line at the end, but without anno
                        corrected_foreground_event_pos = self.foreground_event_pos - max(0, len(xdata) - len(event_annos) - 1) # before first anno there can be others line elements
                    if self.eventsGraphflag == 4 and len(event_annos)>corrected_foreground_event_pos:
                        event_anno = event_annos[corrected_foreground_event_pos]
                        self.updateEventAnno(
                            event_type,
                            event_anno,
                            xdata[self.foreground_event_pos],
                            ydata[self.foreground_event_pos])
                    elif self.eventsGraphflag == 3 and (self.ETcurve or self.BTcurve):
                        event_ind = self.foreground_event_ind
                        if not self.foregroundShowFullflag:
                            event_ind -= self.foreground_evens_before_CAHRGE()
                        if len(event_annos)>event_ind:
                            event_anno = event_annos[event_ind]
                            idx = max(0,min(len(self.timex)-1,self.time2index(xdata[self.foreground_event_pos])))
                            if self.ETcurve and (not self.BTcurve or
                                            not self.showeventsonbt or self.temp1[idx] > self.temp2[idx]):
                                if self.flagon:
                                    tempo = self.temp1[idx]
                                else:
                                    tempo = self.stemp1[idx]
                            elif self.BTcurve:
                                if self.flagon:
                                    tempo = self.temp2[idx]
                                else:
                                    tempo = self.stemp2[idx]
                            if tempo is not None:
                                self.updateFlagAnno(
                                    event_type,
                                    event_anno,
                                    xdata[self.foreground_event_pos],
                                    ydata[self.foreground_event_pos],
                                    tempo)
                self.fig.canvas.draw_idle()
        elif (self.background_event_ind is not None and self.background_event_pos is not None and self.background_event_pick_position is not None and
                    len(self.backgroundEtypes)>self.background_event_ind):
            event_type = self.backgroundEtypes[self.background_event_ind]
            ldots = None
            event_annos = None
            ldots, event_annos = self.event_type_to_background_artist(event_type)
            set_x = True
            set_y = True
            if ldots is not None:
                if QApplication.keyboardModifiers() == Qt.KeyboardModifier.ShiftModifier:
                    if abs(event.xdata - self.background_event_pick_position[0]) < abs(event.ydata - self.background_event_pick_position[1]):
                        set_x = False
                    else:
                        set_y = False
                xdata = ldots.get_xdata()
                if set_x:
                    # allow to move events only between the previous and the next of that type on the time axis to keep the temporal order
                    new_x = event.xdata
                    if self.background_event_pos != 0:
                        # there is a point left to ours
                        new_x = max(xdata[self.background_event_pos-1]+1,new_x)
                    if self.background_event_pos != len(xdata)-1:
                        # there is a point right to ours
                        new_x = min(xdata[self.background_event_pos+1]-1,new_x)
                    xdata[self.background_event_pos] = int(round(new_x))
                    ldots.set_xdata(xdata)
                ydata = ldots.get_ydata()
                if set_y:
                    ydata[self.background_event_pos] = max(0,event.ydata)
                    if not self.flagon and len(ydata) == self.background_event_pos + 2 and (self.timeindex[6]!=0 and self.timex[self.timeindex[6]] >= xdata[-1]):
                        # we also move the last dot up and down with the butlast if automatically added, but only if that last one is not after DROP
                        ydata[-1] = ydata[-2]
                    ldots.set_ydata(ydata)
                if event_annos is not None:
                    if self.backgroundShowFullflag:
                        corrected_background_event_pos = self.background_event_pos
                    else: # extra one is added to line at the end, but without anno
                        corrected_background_event_pos = self.background_event_pos - max(0, len(xdata) - len(event_annos) - 1) # before first anno there can be others line elements
                    if self.eventsGraphflag == 4 and len(event_annos)>corrected_background_event_pos:
                        event_anno = event_annos[corrected_background_event_pos]
                        self.updateEventAnno(
                            event_type,
                            event_anno,
                            xdata[self.background_event_pos],
                            ydata[self.background_event_pos],
                            background=True)
                    elif self.eventsGraphflag == 3 and (self.backgroundETcurve or self.backgroundBTcurve):
                        event_ind = self.background_event_ind
                        if not self.backgroundShowFullflag:
                            event_ind -= self.background_evens_before_CAHRGE()
                        if len(event_annos)>event_ind:
                            event_anno = event_annos[event_ind]
                            idx = max(0,min(len(self.timeB)-1,self.backgroundtime2index(xdata[self.background_event_pos])))
                            if self.backgroundETcurve and (not self.backgroundBTcurve or
                                            not self.showeventsonbt or self.temp1B[idx] > self.temp2B[idx]):
                                tempo = self.temp1B[idx]
                            elif self.backgroundBTcurve:
                                tempo = self.temp2B[idx]
                            if tempo is not None:
                                self.updateFlagAnno(
                                    event_type,
                                    event_anno,
                                    xdata[self.background_event_pos],
                                    ydata[self.background_event_pos],
                                    tempo)
                self.fig.canvas.draw_idle()

    def clear_last_picked_event_selection(self) -> None:
        if self.foreground_event_last_picked_ind is not None or self.foreground_event_last_picked_pos is not None:
            self.foreground_event_last_picked_ind = None # clear the last picked event index remembered for the delete event by backspace action
            self.foreground_event_last_picked_pos = None
            self.aw.eNumberSpinBox.setValue(0)

    def clear_last_background_picked_event_selection(self) -> None:
        if self.background_event_last_picked_ind is not None or self.background_event_last_picked_pos is not None:
            self.background_event_last_picked_ind = None # clear the last picked event index remembered for the delete event by backspace action
            self.background_event_last_picked_pos = None

    def onclick(self, event:'MouseEvent') -> None:
        if self.foreground_event_last_picked_ind is not None and self.foreground_event_last_picked_ind != self.foreground_event_ind:
            self.clear_last_picked_event_selection()
        if self.background_event_last_picked_ind is not None and self.background_event_last_picked_ind != self.background_event_ind:
            self.clear_last_background_picked_event_selection()
        self.aw.setFocus() # we set the focus to the ApplicationWindow on clicking the MPL canvas to (re-)gain focus while the event minieditor is open
        try:
            if self.ax is None:
                return
            if not self.designerflag and not self.wheelflag and event.inaxes is None and not self.flagstart and not self.flagon and event.button == 3:
                self.statisticsmode = (self.statisticsmode + 1)%4
                self.writecharacteristics()
                self.fig.canvas.draw_idle()
                return

#PLUS
            if not self.designerflag and not self.wheelflag and event.inaxes is None and not self.flagstart and not self.flagon and event.button == 1 and event.dblclick and \
                    event.x < event.y and self.roastUUID is not None:
                QDesktopServices.openUrl(QUrl(roastLink(self.roastUUID), QUrl.ParsingMode.TolerantMode))
                return

            if event.dblclick and event.button == 1 and not self.designerflag and not self.wheelflag and event.inaxes:
                if self.ax.get_autoscaley_on():
                    self.ax.autoscale(enable=False, axis='y', tight=False)
                    self.redraw(recomputeAllDeltas=False)
                else:
                    self.ax.autoscale(enable=True, axis='y', tight=False)
                    self.fig.canvas.draw_idle()

            if not self.wheelflag and event.inaxes is None and event.button == 1 and event.dblclick and event.x > event.y:
                fig = self.ax.get_figure()
                if fig is None:
                    return
                s = fig.get_size_inches()*fig.dpi # type:ignore[union-attr] # MPL 3.10.0 reports `Item "SubFigure" of "Union[Figure, SubFigure]" has no attribute "get_size_inches"`
                if event.x > s[0]*2/3 and event.y > s[1]*2/3:
                    if not self.flagstart and not self.flagon and self.backgroundprofile is None and __release_sponsor_domain__ and __release_sponsor_url__:
                        QDesktopServices.openUrl(QUrl(__release_sponsor_url__, QUrl.ParsingMode.TolerantMode))
                        return
                    if self.backgroundprofile is not None:
                        # toggle background if right top corner above canvas where the subtitle is clicked
                        self.background = not self.background
                        self.aw.autoAdjustAxis(background=self.background and (not len(self.timex) > 3))
                        if self.statssummary and self.autotimex:
                            self.redraw(recomputeAllDeltas=True)
                        else:
                            self.redraw_keep_view(recomputeAllDeltas=True)
                        return

            if event.button == 1 and event.inaxes and self.crossmarker and not self.designerflag and not self.wheelflag and not self.flagon:
                self.baseX,self.baseY = event.xdata, event.ydata
                if self.base_horizontalcrossline is None and self.base_verticalcrossline is None:
                    # Mark starting point of click-and-drag with a marker
                    self.base_horizontalcrossline, = self.ax.plot(numpy.array(self.baseX), numpy.array(self.baseY), 'r+', markersize=20)
                    self.base_verticalcrossline, = self.ax.plot(numpy.array(self.baseX), numpy.array(self.baseY), 'wo', markersize = 2)
            elif event.button == 3 and event.inaxes and not self.designerflag and not self.wheelflag and self.aw.ntb.mode not in ['pan/zoom', 'zoom rect']:# and not self.flagon:
                # popup not available if pan/zoom or zoom rect is active as it interacts
                event_xdata = event.xdata
                event_ydata = event.ydata
                if event_xdata is not None and event_ydata is not None:
                    timex = self.time2index(event_xdata)
                    if timex > 0:
                        # reset the zoom rectangles
                        menu = QMenu(self.aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
    #                    menu.setStyleSheet("QMenu::item {background-color: palette(window); selection-color: palette(window); selection-background-color: darkBlue;}")
                        # populate menu
                        ac = QAction(menu)
                        bt = self.temp2[timex]
                        if not self.BTcurve and self.ETcurve:
                            # we allow click to ET if BT is hidden and ET is shown
                            bt = self.temp1[timex]
                        #btdelta = 50 if self.mode == 'C' else 70
                        if bt != -1: # and abs(bt-event_ydata) < btdelta:
                            # we suppress the popup if not clicked close enough to the BT curve
                            if self.timeindex[0] > -1:
                                ac.setText(f"{QApplication.translate('Label', 'at')} {stringfromseconds(event_xdata - self.timex[self.timeindex[0]])}")
                            else:
                                ac.setText(f"{QApplication.translate('Label', 'at')} {stringfromseconds(event_xdata)}")
                            ac.setEnabled(False)
                            menu.addAction(ac)
                            for k in [(QApplication.translate('Label','CHARGE'),0),
                                      (QApplication.translate('Label','DRY END'),1),
                                      (QApplication.translate('Label','FC START'),2),
                                      (QApplication.translate('Label','FC END'),3),
                                      (QApplication.translate('Label','SC START'),4),
                                      (QApplication.translate('Label','SC END'),5),
                                      (QApplication.translate('Label','DROP'),6),
                                      (QApplication.translate('Label','COOL'),7)]:
                                idx_before = idx_after = 0
                                for i in range(k[1]):
                                    if self.timeindex[i] and self.timeindex[i] != -1:
                                        idx_before = self.timeindex[i]
                                for i in range(6,k[1],-1) :
                                    if self.timeindex[i] and self.timeindex[i] != -1:
                                        idx_after = self.timeindex[i]
                                if (((not idx_before) or timex > idx_before) and ((not idx_after) or timex < idx_after) and
                                    (not self.flagstart or (k[1] == 0) or (k[1] != 0 and self.timeindex[k[1]] != 0))): # only add menu item during recording if already a value is set (via a button); but for CHARGE
                                    ac = QAction(menu)
                                    ac.key = (k[1],timex) # type: ignore # key a custom attribute of QAction which should be defined in a custom subclass
                                    ac.setText(' ' + k[0])
                                    menu.addAction(ac)
                            # add user EVENT entry
                            ac = QAction(menu)
                            ac.setText(' ' + QApplication.translate('Label', 'EVENT'))
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            if self.clampEvents:
                                evalue = int(round(event_ydata))
                            else:
                                evalue = int(round((event_ydata - event_pos_offset) / event_pos_factor))
                            ac.key = (-1,timex,self.eventsExternal2InternalValue(evalue))  # type: ignore # key a custom attribute of QAction which should be defined in a custom subclass
                            menu.addAction(ac)

                            # we deactivate all active motion_notify_event_handlers of draggable annotations that might have been connected by this click to
                            # avoid redraw conflicts between Artisan canvas bitblit caching and the matplotlib internal bitblit caches.
                            self.disconnect_draggableannotations_motion_notifiers()

                            # show menu
                            menu.triggered.connect(self.event_popup_action)
                            menu.popup(QCursor.pos())
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' onclick() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot('QAction*')
    def event_popup_action(self, action:QAction) -> None:
        if action.key[0] >= 0:  # type: ignore[attr-defined] # "QAction" has no attribute "key"
            # we check if this is the first DROP mark on this roast
            firstDROP = (action.key[0] == 6 and self.timeindex[6] == 0)  # type: ignore[attr-defined] # "QAction" has no attribute "key"
            timeindex_before = self.timeindex[action.key[0]]  # type: ignore[attr-defined] # "QAction" has no attribute "key"
            self.timeindex[action.key[0]] = action.key[1]  # type: ignore[attr-defined] # "QAction" has no attribute "key"
            # clear custom label positions cache entry
            if action.key[0] in self.l_annotations_dict:  # type: ignore[attr-defined] # "QAction" has no attribute "key"
                del self.l_annotations_dict[action.key[0]]  # type: ignore[attr-defined]# "QAction" has no attribute "key"
            try:
                # clear the event mark position cache
                self.l_annotations_dict.pop(action.key[0])  # type: ignore[attr-defined] # "QAction" has no attribute "key"
            except Exception: # pylint: disable=broad-except
                pass
            if action.key[0] == 0: # type: ignore[attr-defined] # "QAction" has no attribute "key" # CHARGE
                try:
                    # clear the TP mark position cache (TP depends on CHARGE!)
                    self.l_annotations_dict.pop(-1)
                except Exception: # pylint: disable=broad-except
                    pass
                # realign to background
                if self.flagstart:
                    try:
                        if self.locktimex:
                            self.startofx = self.locktimex_start + self.timex[self.timeindex[0]]
                        else:
                            self.startofx = self.chargemintime + self.timex[self.timeindex[0]] # we set the min x-axis limit to the CHARGE Min time
                    except Exception: # pylint: disable=broad-except
                        pass
                    if not self.aw.buttonCHARGE.isFlat():
                        self.aw.buttonCHARGE.setFlat(True)
                        self.aw.buttonCHARGE.stopAnimation()
                        self.aw.onMarkMoveToNext(self.aw.buttonCHARGE)

                    self.xaxistosm(redraw=False) # need to fix uneven x-axis labels like -0:13
                    self.updateProjection() # we update the data here to have the projections drawn by the redraw() triggered by the call to timealign below
                else:
                    # we keep xaxis limit the same but adjust to updated timeindex[0] mark
                    if timeindex_before > -1:
                        self.startofx += (self.timex[self.timeindex[0]] - self.timex[timeindex_before])
                    else:
                        self.startofx += self.timex[self.timeindex[0]]
                    self.aw.autoAdjustAxis(deltas=False)
                self.timealign(redraw=True,recompute=False,force=True) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            elif action.key[0] == 6: # type: ignore[attr-defined] # "QAction" has no attribute "key" # DROP
                try:
                    # clear the TP mark position cache (TP depends on DROP!)
                    self.l_annotations_dict.pop(-1)
                except Exception: # pylint: disable=broad-except
                    pass
                try:
                    # update ambient temperature if a ambient temperature source is configured and no value yet established
                    self.updateAmbientTempFromPhidgetModulesOrCurve()
                except Exception: # pylint: disable=broad-except
                    pass
#PLUS
                # only on first setting the DROP event (not set yet and no previous DROP undone), we upload to PLUS
                if firstDROP and self.autoDROPenabled and self.aw.plus_account is not None:
                    # NOTE: scheduler is only active if connected to artisan.plus
                    if self.aw.schedule_window is not None:
                        self.aw.schedule_window.register_completed_roast.emit()
                    try:
                        self.aw.updatePlusStatus()
                    except Exception: # pylint: disable=broad-except
                        pass
                        # add to out-queue
                    try:
                        addRoast()
                    except Exception: # pylint: disable=broad-except
                        pass
                if not self.flagstart:
                    self.aw.autoAdjustAxis(deltas=False)


            # update phases
            elif action.key[0] == 1 and self.phasesbuttonflag:  # type: ignore[attr-defined] # "QAction" has no attribute "key" # DRY
                self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
            elif action.key[0] == 2 and self.phasesbuttonflag:  # type: ignore[attr-defined] # "QAction" has no attribute "key" # FCs
                self.phases[2] = int(round(self.temp2[self.timeindex[2]]))

            self.fileDirtySignal.emit()
            self.redraw_keep_view(recomputeAllDeltas=(action.key[0] in {0, 6}))  # type: ignore[attr-defined] # "QAction" has no attribute "key" # on moving CHARGE or DROP, we have to recompute the Deltas
        else:
            # add a special event at the current timepoint
            from artisanlib.events import customEventDlg
            dlg = customEventDlg(self.aw, self.aw, action.key[1], value=action.key[2], event_type=self.custom_event_dlg_default_type) # type: ignore[attr-defined] # "QAction" has no attribute "key"
            if dlg.exec():
                self.addEvent(action.key[1], # type: ignore[attr-defined] # "QAction" has no attribute "key" # absolute time index
                    dlg.type, # default: "--"
                    dlg.description,
                    dlg.value)
                self.custom_event_dlg_default_type = dlg.type
                self.aw.orderEvents()
                self.fileDirtySignal.emit()
                self.redraw_keep_view(recomputeAllDeltas=(action.key[0] in {0, 6}))  # type: ignore[attr-defined] # "QAction" has no attribute "key" # on moving CHARGE or DROP, we have to recompute the Deltas
                # redraw minieditor event selection line
                currentevent = self.aw.eNumberSpinBox.value()
                if currentevent:
                    self.aw.plotEventSelection(currentevent-1)
                    if not self.flagstart:
                        self.fig.canvas.draw()

            try:
                dlg.dialogbuttons.accepted.disconnect()
                dlg.dialogbuttons.rejected.disconnect()
#                QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
#                try: # sip not supported on older PyQt versions (RPi!)
#                    sip.delete(dlg)
#                    #print(sip.isdeleted(dlg))
#                except Exception: # pylint: disable=broad-except
#                    pass
            except Exception: # pylint: disable=broad-except
                pass

    def updateWebLCDs(self, bt:Optional[str] = None, et:Optional[str] = None, time:Optional[str] = None, alertTitle:Optional[str] = None, alertText:Optional[str] = None, alertTimeout:Optional[int] = None) -> None:
        if self.aw.weblcds_server is not None:
            try:
                payload:Dict[str,Dict[str,Union[str,int]]] = {'data': {}}
                if not (bt is None and et is None) and self.flagon and not self.flagstart:
                    # in monitoring only mode, timer might be set by PID RS
                    time = None
                if bt is not None:
                    payload['data']['bt'] = bt
                if et is not None:
                    payload['data']['et'] = et
                if time is not None:
                    payload['data']['time'] = time
                if alertText is not None:
                    payload['alert'] = {}
                    payload['alert']['text'] = alertText
                    if alertTitle:
                        payload['alert']['title'] = alertTitle
                    if alertTimeout:
                        payload['alert']['timeout'] = alertTimeout
                from json import dumps as json_dumps
                self.aw.weblcds_server.send_msg(json_dumps(payload, indent=None, separators=(',', ':')))
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

    # note that partial values might be given here (time might update, but not the values)
    @pyqtSlot(str,str,str)
    def updateLargeLCDs(self, bt:str, et:str, time:str) -> None: # pylint: disable=no-self-use # used as slot
        try:
            if self.aw.largeLCDs_dialog is not None:
                # in monitoring only mode, timer might be set by PID RS
                self.aw.largeLCDs_dialog.updateValues([et],[bt],time=(None if self.flagon and not self.flagstart else time))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str,str)
    # pylint: disable=no-self-use # used as slot
    def setTimerLargeLCDcolor(self, fc:str, bc:str) -> None:
        try:
            if self.aw.largeLCDs_dialog is not None:
                self.aw.largeLCDs_dialog.setTimerLCDcolor(fc,bc)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str,int)
    def showAlarmPopup(self, message:str, timeout:int) -> None: # pylint: disable=no-self-use # used as slot
        # alarm popup message with <self.alarm_popup_timout>sec timeout
        amb = ArtisanMessageBox(self.aw, QApplication.translate('Message', 'Alarm notice'),message,timeout=timeout,modal=True) # modal=False prevent rendering as native message box on macOS
        amb.show()
        #send alarm also to connected WebLCDs clients
        if self.aw.WebLCDs and self.aw.WebLCDsAlerts:
            self.updateWebLCDs(alertText=message,alertTimeout=timeout)

    @pyqtSlot(str,str)
    def updateLargeLCDsReadings(self, bt:str, et:str) -> None: # pylint: disable=no-self-use # used as slot
        try:
            if self.aw.largeLCDs_dialog is not None:
                self.aw.largeLCDs_dialog.updateValues([et],[bt])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    def updateLargeLCDsTime(self, time:str) -> None: # pylint: disable=no-self-use # used as slot
        try:
            if self.aw.largeLCDs_dialog is not None:
                self.aw.largeLCDs_dialog.updateValues([],[],time=time)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    def updateLargeDeltaLCDs(self, deltabt:Optional[str] = None, deltaet:Optional[str] = None) -> None:
        try:
            if self.aw.largeDeltaLCDs_dialog is not None:
                self.aw.largeDeltaLCDs_dialog.updateValues([deltaet],[deltabt])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    def updateLargePIDLCDs(self, sv:Optional[str] = None, duty:Optional[str] = None) -> None:
        try:
            if self.aw.largePIDLCDs_dialog is not None:
                self.aw.largePIDLCDs_dialog.updateValues([sv],[duty])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # note that partial values might be given here
    def updateLargeScaleLCDs(self, weight:Optional[str] = None, total:Optional[str] = None) -> None:
        try:
            if self.aw.largeScaleLCDs_dialog is not None:
                self.aw.largeScaleLCDs_dialog.updateValues([weight],[total])
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def updateLargeExtraLCDs(self, extra1:Optional[List[Optional[str]]] = None, extra2:Optional[List[Optional[str]]] = None) -> None:
        if extra1 is None:
            extra1 = []
        if extra2 is None:
            extra2 = []
        try:
            if self.aw.largeExtraLCDs_dialog is not None:
                self.aw.largeExtraLCDs_dialog.updateValues(extra1,extra2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)


    # ADD DEVICE:

    # returns True if the extra device n, channel c, is of type MODBUS or S7, has no factor defined, nor any math formula, and is of type int
    # channel c is either 0 or 1
    @functools.lru_cache(maxsize=None) # noqa: B019 # pylint: disable=W1518 #for Python >= 3.9 can use @functools.cache; Not relevant here, as qmc is only created once: [B019] Use of `functools.lru_cache` or `functools.cache` on methods can lead to memory leaks
    def intChannel(self, n:int, c:int) -> bool:
        if self.aw is not None and len(self.extradevices) > n:
            no_math_formula_defined:bool = False
            if c == 0:
                no_math_formula_defined = bool(self.extramathexpression1[n] == '')
            if c == 1:
                no_math_formula_defined = bool(self.extramathexpression2[n] == '')
            # MODBUS channels
            for idx, dev_type in enumerate([29,33,55,109,150]): # MODBUS, MODBUS_34, MODBUS_56, MODBUS_78, MODBUS_910
                if self.extradevices[n] == dev_type:
                    return ((self.aw.modbus.inputFloatsAsInt[idx*2 + c] or self.aw.modbus.inputBCDsAsInt[idx*2 + c] or not self.aw.modbus.inputFloats[idx*2 + c]) and
                        self.aw.modbus.inputDivs[idx*2 + c] == 0 and
                        (self.aw.modbus.inputModes[idx*2 + c] == '' or self.aw.modbus.inputModes[idx*2 + c] == self.aw.qmc.mode) and
                        no_math_formula_defined)
            # S7 channels
            for idx, dev_type in enumerate([70,80,81,82,110,151]): # S7, S7_34, S7_56, S7_78, S7_910, S7_1112
                if self.extradevices[n] == dev_type:
                    return (self.aw.s7.type[idx*2 + c] != 1 and
                            (self.aw.s7.mode[idx*2 + c] == 0 or (self.aw.s7.mode[idx*2 + c] == 1 and
                                self.aw.qmc.mode == 'C') or (self.aw.s7.mode[idx*2 + c] == 2 and self.aw.qmc.mode == 'F')) and
                            (self.aw.s7.div[idx*2 + c] == 0 or self.aw.s7.type[idx*2 + c] == 2) and
                            no_math_formula_defined)
            # others
            if self.extradevices[n] in {54, 90, 91, 135, 136, 140, 141, 165}: # Hottop Heater/Fan, Slider 12, Slider 34, Santoker Power / Fan, Kaleido Fan/Drum, Kaleido Heater/AH, Mugma Heater/Fan
                return True
            if self.extradevices[n] == 136 and c == 0: # Santoker Drum
                return True
            if self.extradevices[n] in {140, 141}: # Kaleido drum/AH, heater/fan
                return True
            if self.extradevices[n] == 144 or (self.extradevices[n] == 145 and c==0): # IKAWA heater/fan, state
                return True
            if self.extradevices[n] == 165: # noqa: SIM103 # MUGMA heater/fan
                return True
            return False
        return False

    # draw additional "dynamic" artists during recording
    def update_additional_artists(self) -> None:
        if self.ax is not None and self.flagstart:
            if self.l_timeline is not None and self.flagstart and ((self.device == 18 and self.aw.simulator is None) or self.showtimeguide): # not NONE device
                self.l_timeline.set_xdata([self.timeclock.elapsedMilli()] if self.aw.sample_loop_running else [self.aw.time_stopped])
                self.l_timeline.set_visible(self.flagstart)
                self.ax.draw_artist(self.l_timeline)
            if self.ETprojectFlag:
                if self.l_ETprojection is not None and self.ETcurve:
                    # show only if either the DeltaBT curve or LCD is shown (allows to suppress projects for cases where ET channel is used for other signals)
                    self.ax.draw_artist(self.l_ETprojection)
                if self.projectDeltaFlag and self.l_DeltaETprojection is not None and self.DeltaETflag:
                    self.ax.draw_artist(self.l_DeltaETprojection)
            if self.BTprojectFlag:
                if self.l_BTprojection is not None and self.BTcurve:
                    # show only if either the DeltaBT curve or LCD is shown (allows to suppress projects for cases where ET channel is used for other signals)
                    self.ax.draw_artist(self.l_BTprojection)
                if self.projectDeltaFlag and self.l_DeltaBTprojection is not None and self.DeltaBTflag:
                    self.ax.draw_artist(self.l_DeltaBTprojection)
            if self.l_AUCguide is not None and self.AUCguideFlag and self.AUCguideTime > 0 and self.AUCguideTime < self.endofx:
                self.ax.draw_artist(self.l_AUCguide)

    # input filter
    # if temp (the actual reading) is outside of the interval [tmin,tmax] or
    # a spike is detected, the previous value is repeated or if that happened already before, -1 is returned
    # note that here we assume that the actual measured temperature time/temp was not already added to the list of previous measurements timex/tempx
    def inputFilter(self, timex:List[float], tempx:List[float], time:float, temp:float, BT:bool = False) -> float:
        try:
            wrong_reading = 0
            #########################
            # a) detect duplicates: remove a reading if it is equal to the previous or if that is -1 to the one before that
            if self.dropDuplicates and ((len(tempx)>1 and tempx[-1] == -1 and abs(temp - tempx[-2]) <= self.dropDuplicatesLimit) or (len(tempx)>0 and abs(temp - tempx[-1]) <= self.dropDuplicatesLimit)):
                wrong_reading = 2 # replace by previous reading not by -1
            #########################
            # b) detect overflows
            if self.minmaxLimits and (temp < self.filterDropOut_tmin or temp > self.filterDropOut_tmax):
                wrong_reading = 1
            #########################
            # c) detect spikes (on BT only after CHARGE if autoChargeFlag=True not to have a conflict here)
            n = self.filterDropOut_spikeRoR_period
            dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit # the limit of additional RoR in temp/sec (4C for C / 7F for F) compared to previous readings
            if self.dropSpikes and ((not self.autoChargeFlag) or (not BT) or (self.timeindex[0] != -1 and (self.timeindex[0] + n) < len(timex))) and not wrong_reading and len(tempx) >= n:
                # no min/max overflow detected
                # check if RoR caused by actual measurement is way higher then the previous one
                # calc previous RoR (pRoR) taking the last n samples into account
                pdtemp = tempx[-1] - tempx[-n]
                pdtime = timex[-1] - timex[-n]
                if pdtime > 0:
                    pRoR = abs(pdtemp/pdtime)
                    dtemp = tempx[-1] - temp
                    dtime = timex[-1] - time
                    if dtime > 0:
                        RoR = abs(dtemp/dtime)
                        if RoR > (pRoR + dRoR_limit):
                            wrong_reading = 2
            #########################
            # c) handle outliers if it could be detected
            if wrong_reading:
                if len(tempx) > 0 and tempx[-1] != -1:
                    # repeate last correct reading if not done before in the last two fixes (min/max violation are always filtered)
                    if len(tempx) == 1 or (len(tempx) > 3 and (tempx[-1] != tempx[-2] or tempx[-2] != tempx[-3])):
                        return tempx[-1]
                    if wrong_reading == 1:
                        return -1
                    # no way to correct this
                    return temp
                if wrong_reading == 1:
                    return -1
                # no way to correct this
                return temp
            # try to improve a previously corrected reading timex/temp[-1] based on the current reading time/temp (just in this case the actual reading is not a drop)
            if (self.minmaxLimits or self.dropSpikes or self.dropDuplicates):
                if len(tempx) > 2 and tempx[-1] == tempx[-2] == tempx[-3] and tempx[-1] != -1 and tempx[-1] != temp and temp!=-1: # previous reading was a drop and replaced by reading[-2] and same for the one before
                    delta = (tempx[-3] - temp) / 3.0
                    tempx[-1] = tempx[-3] - 2*delta
                    tempx[-2] = tempx[-3] - delta
                elif len(tempx) > 1 and tempx[-1] == tempx[-2] and tempx[-1] != -1 and tempx[-1] != temp and temp!=-1: # previous reading was a drop and replaced by reading[-2]
                    tempx[-1] = (tempx[-2] + temp) / 2.0
            return temp
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' filterDropOuts() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return temp

    # the temp gets averaged using the given decay weights after resampling
    # to linear time based on tx and the current sampling interval
    # -1 and None values are skipped/ignored
    def decay_average(self, tx_in:List[float], temp_in:Sequence[Optional[float]], decay_weights:Optional[List[int]]) -> float:
        if decay_weights is None or len(decay_weights)<2 or len(tx_in) != len(temp_in):
            if len(temp_in)>0 and temp_in[-1] is not None:
                return temp_in[-1]
            return -1
        l = min(len(decay_weights),len(temp_in))
        # take trail of length l and remove items where temp[i]=None to fulfil precond. of numpy.interp
        tx_org:List[float] = []
        temp_trail:List[float] = []
        for x, tp in zip(tx_in[-l:],temp_in[-l:]): # we only iterate over l-elements
            if tp is not None and tp != -1:
                tx_org.append(x)
                temp_trail.append(tp)
        if len(temp_trail) == 0:
            # no valid values
            return -1
        l = len(temp_trail) # might be shorter than before
        # len(tx)=len(temp) here and it is guaranteed that len(tx_org)=len(temp_trail) = l
        d = self.delay / 1000.
        # we create a linearly spaced time array starting from the newest timestamp in sampling interval distance
        tx_lin = numpy.flip(numpy.arange(tx_org[-1],tx_org[-1]-l*d,-d), axis=0) # by construction, len(tx_lin)=len(tx_org)=l
        temp_trail_re = numpy.interp(tx_lin, tx_org, temp_trail) # resample data into that linear spaced time
        try:
            return float(numpy.average(temp_trail_re[-len(decay_weights):],axis=0,weights=decay_weights[-l:]))  # len(decay_weights)>len(temp_trail_re)=l is possible
        except Exception: # pylint: disable=broad-except
            # in case something goes very wrong we at least return the standard average over temp, this should always work as len(tx)=len(temp)
            return float(numpy.average(tx_org, numpy.array(temp_trail)))

    # returns true after BT passed the TP
    def checkTPalarmtime(self) -> bool:
        seconds_since_CHARGE = int(self.timex[-1]-self.timex[self.timeindex[0]])
        # if v[-1] is the current temperature then check if
        #   we are 20sec after CHARGE
        #   len(BT) > 4
        # BT[-5] <= BT[-4] and BT[-5] <= BT[-3] and BT[-5] <= BT[-2] and BT[-5] <= BT[-1] and BT[-5] < BT[-1]
        if seconds_since_CHARGE > 20 and not self.afterTP and len(self.temp2) > 3 and (self.temp2[-5] <= self.temp2[-4]) and (self.temp2[-5] <= self.temp2[-3]) and (self.temp2[-5] <= self.temp2[-2]) and (self.temp2[-5] <= self.temp2[-1]) and (self.temp2[-5] < self.temp2[-1]):
            self.afterTP = True
        return self.afterTP

    # sample devices at interval self.delay milliseconds.
    # we can assume within the processing of sample_processing() that flagon=True
    # NOTE: sample_processing is processed in the GUI thread NOT the sample thread!
    def sample_processing(self, local_flagstart:bool, temp1_readings:List[float], temp2_readings:List[float], timex_readings:List[float]) -> None: # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths
        ##### (try to) lock resources  #########
        wait_period = 200  # we try to catch a lock within the next 200ms
        if self.delay < 500:
            wait_period = 10 # on tight sampling rate we only wait 10ms
        gotlock = self.profileDataSemaphore.tryAcquire(1, wait_period) # we try to catch the lock, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        if not gotlock:
            _log.debug('sample_processing(): failed to get profileDataSemaphore lock')
        else:
            try:
                # duplicate system state flag flagstart locally and only refer to this copy within this function to make it behaving uniquely (either append or overwrite mode)

                # initialize the arrays modified depending on the recording state
                if local_flagstart:
                    sample_timex = self.timex
                    sample_temp1 = self.temp1
                    sample_temp2 = self.temp2
                    sample_ctimex1 = self.ctimex1
                    sample_ctemp1 = self.ctemp1
                    sample_ctimex2 = self.ctimex2
                    sample_ctemp2 = self.ctemp2
                    sample_tstemp1 = self.tstemp1
                    sample_tstemp2 = self.tstemp2
                    sample_unfiltereddelta1 = self.unfiltereddelta1 # no sample_unfiltereddelta1_pure as used only during recording for projections
                    sample_unfiltereddelta2 = self.unfiltereddelta2 # no sample_unfiltereddelta2_pure as used only during recording for projections
                    sample_delta1 = self.delta1
                    sample_delta2 = self.delta2
                    # list of lists:
                    sample_extratimex = self.extratimex
                    sample_extratemp1 = self.extratemp1
                    sample_extratemp2 = self.extratemp2
                    sample_extractimex1 = self.extractimex1
                    sample_extractemp1 = self.extractemp1
                    sample_extractimex2 = self.extractimex2
                    sample_extractemp2 = self.extractemp2
                else:
                    m_len = self.curvefilter
                    sample_timex = self.on_timex = self.on_timex[-m_len:]
                    sample_temp1 = self.on_temp1 = self.on_temp1[-m_len:]
                    sample_temp2 = self.on_temp2 = self.on_temp2[-m_len:]
                    sample_ctimex1 = self.on_ctimex1 = self.on_ctimex1[-m_len:]
                    sample_ctemp1 = self.on_ctemp1 = self.on_ctemp1[-m_len:]
                    sample_ctimex2 = self.on_ctimex2 = self.on_ctimex2[-m_len:]
                    sample_ctemp2 = self.on_ctemp2 = self.on_ctemp2[-m_len:]
                    sample_tstemp1 = self.on_tstemp1 = self.on_tstemp1[-m_len:]
                    sample_tstemp2 = self.on_tstemp2 = self.on_tstemp2[-m_len:]
                    sample_unfiltereddelta1 = self.on_unfiltereddelta1 = self.on_unfiltereddelta1[-m_len:] # no sample_unfiltereddelta1_pure as used only during recording for projections
                    sample_unfiltereddelta2 = self.on_unfiltereddelta2 = self.on_unfiltereddelta2[-m_len:] # no sample_unfiltereddelta2_pure as used only during recording for projections
                    sample_delta1 = self.on_delta1 = self.on_delta1[-m_len:]
                    sample_delta2 = self.on_delta2 = self.on_delta2[-m_len:]
                    # list of lists:
                    for i in range(len(self.extradevices)):
                        self.on_extratimex[i] = self.on_extratimex[i][-m_len:]
                        self.on_extratemp1[i] = self.on_extratemp1[i][-m_len:]
                        self.on_extratemp2[i] = self.on_extratemp2[i][-m_len:]
                        self.on_extractimex1[i] = self.on_extractimex1[i][-m_len:]
                        self.on_extractemp1[i] = self.on_extractemp1[i][-m_len:]
                        self.on_extractimex2[i] = self.on_extractimex2[i][-m_len:]
                        self.on_extractemp2[i] = self.on_extractemp2[i][-m_len:]
                    sample_extratimex = self.on_extratimex
                    sample_extratemp1 = self.on_extratemp1
                    sample_extratemp2 = self.on_extratemp2
                    sample_extractimex1 = self.on_extractimex1
                    sample_extractemp1 = self.on_extractemp1
                    sample_extractimex2 = self.on_extractimex2
                    sample_extractemp2 = self.on_extractemp2

                #if using a meter (thermocouple device)
                if self.device != 18 or self.aw.simulator is not None: # not NONE device

                    t1 = temp1_readings[0]
                    t2 = temp2_readings[0]
                    tx = timex_readings[0]

                    self.RTtemp1 = t1 # store readings for real-time symbolic evaluation
                    self.RTtemp2 = t2
                    ##############  if using Extra devices
                    nxdevices = len(self.extradevices)
                    if nxdevices:
                        les,led,let =  len(self.aw.extraser),nxdevices,len(sample_extratimex)
                        if les == led == let:
                            xtra_dev_lines1 = 0
                            xtra_dev_lines2 = 0
                            #1 clear extra device buffers
                            self.RTextratemp1,self.RTextratemp2,self.RTextratx = [],[],[]
                            #2 load RT buffers
                            self.RTextratemp1 = temp1_readings[1:]
                            self.RTextratemp2 = temp2_readings[1:]
                            self.RTextratx = timex_readings[1:]
                            #3 evaluate symbolic expressions
                            for i in range(nxdevices):
                                extratx = self.RTextratx[i]
                                extrat1 = self.RTextratemp1[i]
                                extrat2 = self.RTextratemp2[i]
                                if len(self.extramathexpression1) > i and self.extramathexpression1[i] is not None and len(self.extramathexpression1[i].strip()):
                                    try:
                                        extrat1 = self.eval_math_expression(self.extramathexpression1[i],self.RTextratx[i],RTsname='Y'+str(2*i+3),RTsval=self.RTextratemp1[i])
                                        self.RTextratemp1[i] = extrat1
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)
                                if len(self.extramathexpression2) > i and self.extramathexpression2[i] is not None and len(self.extramathexpression2[i].strip()):
                                    try:
                                        extrat2 = self.eval_math_expression(self.extramathexpression2[i],self.RTextratx[i],RTsname='Y'+str(2*i+4),RTsval=self.RTextratemp2[i])
                                        self.RTextratemp2[i] = extrat2
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)

                                et1_prev = et2_prev = None
                                et1_prevprev = et2_prevprev = None
                                if self.extradevices[i] != 25: # don't apply input filters to virtual devices

                                    ## Apply InputFilters. As those might modify destructively up to two older readings in temp1/2 via interpolation for drop outs we try to detect this and copy those
                                    # changes back to the ctemp lines that are rendered.
                                    if (self.minmaxLimits or self.dropSpikes or self.dropDuplicates):
                                        if len(sample_extratemp1[i])>0:
                                            et1_prev = sample_extratemp1[i][-1]
                                            if len(sample_extratemp1[i])>1:
                                                et1_prevprev = sample_extratemp1[i][-2]
                                        if len(sample_extratemp2[i])>0:
                                            et2_prev = sample_extratemp2[i][-1]
                                            if len(sample_extratemp2[i])>1:
                                                et2_prevprev = sample_extratemp2[i][-2]
                                    if not self.dummy_or_special_device(self.extradevices[i], 0):
                                        extrat1 = self.inputFilter(sample_extratimex[i],sample_extratemp1[i],extratx,extrat1)
                                    if not self.dummy_or_special_device(self.extradevices[i], 1):
                                        extrat2 = self.inputFilter(sample_extratimex[i],sample_extratemp2[i],extratx,extrat2)

                                    # now copy the destructively modified values from temp1/2 to ctemp1/2 if any (to ensure to pick the right elements we compare the timestamps at those indices)
                                    if (self.minmaxLimits or self.dropSpikes or self.dropDuplicates):
                                        if len(sample_extractimex1[i])>0:
                                            if et1_prev is not None and sample_extractimex1[i][-1] == sample_extratimex[i][-1] and et1_prev != sample_extratemp1[i][-1]:
                                                sample_extractemp1[i][-1] = sample_extratemp1[i][-1]
                                            if len(sample_extractimex1[i])>1 and et1_prevprev is not None and sample_extractimex1[i][-2] == sample_extratimex[i][-2] and et1_prevprev != sample_extratemp1[i][-2]:
                                                sample_extractemp1[i][-2] = sample_extratemp1[i][-2]
                                        if len(sample_extractimex2[i])>0:
                                            if et2_prev is not None and sample_extractimex2[i][-1] == sample_extratimex[i][-1] and et2_prev != sample_extratemp2[i][-1]:
                                                sample_extractemp2[i][-1] = sample_extratemp2[i][-1]
                                            if len(sample_extractimex2[i])>1 and et2_prevprev is not None and sample_extractimex2[i][-2] == sample_extratimex[i][-2] and et2_prevprev != sample_extratemp2[i][-2]:
                                                sample_extractemp2[i][-2] = sample_extratemp2[i][-2]

                                sample_extratimex[i].append(extratx)
                                sample_extratemp1[i].append(float(extrat1))
                                sample_extratemp2[i].append(float(extrat2))

                                # gaps larger than self.interpolatemax readings are not connected in the graph (as util.py:fill_gaps() is not interpolating them)
                                if extrat1 != -1:
                                    sample_extractimex1[i].append(float(extratx))
                                    sample_extractemp1[i].append(float(extrat1))
                                elif len(sample_extratemp1[i])>(self.interpolatemax+1) and all(v == -1 for v in sample_extratemp1[i][-(self.interpolatemax+1):]):
                                    sample_extractimex1[i].append(float(extratx))
                                    sample_extractemp1[i].append(None)
                                if extrat2 != -1:
                                    sample_extractimex2[i].append(float(extratx))
                                    sample_extractemp2[i].append(float(extrat2))
                                elif len(sample_extratemp2[i])>(self.interpolatemax+1) and all(v == -1 for v in sample_extratemp2[i][-(self.interpolatemax+1):]):
                                    sample_extractimex2[i].append(float(extratx))
                                    sample_extractemp2[i].append(None)

                                # update extra lines
                                if local_flagstart:
                                    if self.aw.extraCurveVisibility1[i] and len(self.extratemp1lines) > xtra_dev_lines1 and self.extratemp1lines[xtra_dev_lines1] is not None:
                                        self.extratemp1lines[xtra_dev_lines1].set_data(sample_extractimex1[i], numpy.array(sample_extractemp1[i]))
                                        xtra_dev_lines1 = xtra_dev_lines1 + 1
                                    if self.aw.extraCurveVisibility2[i] and len(self.extratemp2lines) > xtra_dev_lines2 and self.extratemp2lines[xtra_dev_lines2] is not None:
                                        self.extratemp2lines[xtra_dev_lines2].set_data(sample_extractimex2[i], numpy.array(sample_extractemp2[i]))
                                        xtra_dev_lines2 = xtra_dev_lines2 + 1
                        #ERROR FOUND
                        else:
                            lengths = [les,led,let]
                            location = ['Extra-Serial','Extra-Devices','Extra-Temp']
                            #find error
                            if nxdevices-1 in lengths:
                                indexerror =  lengths.index(nxdevices-1)
                            elif nxdevices+1 in lengths:
                                indexerror =  lengths.index(nxdevices+1)
                            else:
                                indexerror = 1000
                            if indexerror != 1000:
                                errormessage = f'ERROR: length of {location[indexerror]} (={lengths[indexerror]}) does not have the necessary length (={nxdevices})'
                                errormessage += '\nPlease Reset: Extra devices'
                            else:
                                errormessage = f"ERROR: extra devices lengths don't match: {location[0]}= {lengths[0]} {location[1]}= {lengths[1]} {location[2]}= {lengths[2]}"
                                errormessage += '\nPlease Reset: Extra devices'
                            raise Exception(errormessage) # pylint: disable=broad-exception-raised

                    ####### all values retrieved

                    if self.ETfunction is not None and self.ETfunction.strip():
                        try:
                            t1 = self.eval_math_expression(self.ETfunction,tx,RTsname='Y1',RTsval=t1)
                            self.RTtemp1 = t1
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    if self.BTfunction is not None and self.BTfunction.strip():
                        try:
                            t2 = self.eval_math_expression(self.BTfunction,tx,RTsname='Y2',RTsval=t2)
                            self.RTtemp2 = t2
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                    # if modbus device do the C/F conversion if needed (done after mathexpression, not to mess up with x/10 formulas)
                    # modbus channel 1+2, respect input temperature scale setting

                    ## Apply InputFilters. As those might modify destructively up to two older readings in temp1/2 via interpolation for drop outs we try to detect this and copy those
                    # changes back to the ctemp lines that are rendered.
                    t1_prev = t2_prev = None
                    t1_prevprev = t2_prevprev = None
                    if (self.minmaxLimits or self.dropSpikes or self.dropDuplicates):
                        if len(sample_temp1)>0:
                            t1_prev = sample_temp1[-1]
                            if len(sample_temp1)>1:
                                t1_prevprev = sample_temp1[-2]
                        if len(sample_temp2)>0:
                            t2_prev = sample_temp2[-1]
                            if len(sample_temp2)>1:
                                t2_prevprev = sample_temp2[-2]
                    if not self.dummy_or_special_device(self.device, 0):
                        t1 = self.inputFilter(sample_timex,sample_temp1,tx,t1)
                    if not self.dummy_or_special_device(self.device, 0):
                        t2 = self.inputFilter(sample_timex,sample_temp2,tx,t2,True)

                    length_of_qmc_timex = len(sample_timex)

                    # now copy the destructively modified values from temp1/2 to ctemp1/2 if any (to ensure to pick the right elements we compare the timestamps at those indices)
                    if (self.minmaxLimits or self.dropSpikes or self.dropDuplicates):
                        if len(sample_ctimex1)>0:
                            if t1_prev is not None and sample_ctimex1[-1] == sample_timex[-1] and t1_prev != sample_temp1[-1]:
                                sample_ctemp1[-1] = sample_temp1[-1]
                            if len(sample_ctimex1)>1 and t1_prevprev is not None and sample_ctimex1[-2] == sample_timex[-2] and t1_prevprev != sample_temp1[-2]:
                                sample_ctemp1[-2] = sample_temp1[-2]
                        if len(sample_ctimex2)>0:
                            if t2_prev is not None and sample_ctimex2[-1] == sample_timex[-1] and t2_prev != sample_temp2[-1]:
                                sample_ctemp2[-1] = sample_temp2[-1]
                            if len(sample_ctimex2)>1 and t2_prevprev is not None and sample_ctimex2[-2] == sample_timex[-2] and t2_prevprev != sample_temp2[-2]:
                                sample_ctemp2[-2] = sample_temp2[-2]
                    t1_final = t1
                    t2_final = t2

                    sample_temp1.append(t1_final)
                    sample_temp2.append(t2_final)
                    sample_timex.append(tx)
                    length_of_qmc_timex += 1

                    if t1_final != -1:
                        sample_ctimex1.append(tx)
                        sample_ctemp1.append(t1_final)
                    elif len(sample_temp1)>(self.interpolatemax+1) and all(v == -1 for v in sample_temp1[-(self.interpolatemax+1):]):
                        sample_ctimex1.append(tx)
                        sample_ctemp1.append(None)
                    if t2_final != -1:
                        sample_ctimex2.append(tx)
                        sample_ctemp2.append(t2_final)
                    elif len(sample_temp2)>(self.interpolatemax+1) and all(v == -1 for v in sample_temp2[-(self.interpolatemax+1):]):
                        sample_ctimex2.append(tx)
                        sample_ctemp2.append(None)


                    #we populate the temporary smoothed ET/BT data arrays (with readings cleansed from -1 dropouts)
                    cf = self.curvefilter
                    if self.temp_decay_weights is None or len(self.temp_decay_weights) != cf: # recompute only on changes
                        self.temp_decay_weights = list(numpy.arange(1,cf+1))
                    # we don't smooth st'x if last, or butlast temperature value were a drop-out not to confuse the RoR calculation
                    if -1 in sample_temp1[-(cf+1):]:
                        dw1 = [1]
                    else:
                        dw1 = self.temp_decay_weights
                    if -1 in sample_temp2[-(cf+1):]:
                        dw2 = [1]
                    else:
                        dw2 = self.temp_decay_weights
                    # average smoothing
                    if len(sample_ctemp1) > 0:
                        st1 = self.decay_average(sample_ctimex1,sample_ctemp1,dw1)
                    else:
                        st1 = -1
                    if len(sample_ctemp2) > 0:
                        st2 = self.decay_average(sample_ctimex2,sample_ctemp2,dw2)
                    else:
                        st2 = -1

#                    # we apply a minimal live median spike filter
#                    if self.filterDropOuts:
#                        if st1 is not None and st1 != -1:
#                            st1 = self.liveMedianETfilter(st1)
#                        if st1 is not None and st2 != -1:
#                            st2 = self.liveMedianBTfilter(st2)

                    # register smoothed values
                    sample_tstemp1.append(st1)
                    sample_tstemp2.append(st2)

                    if local_flagstart:
                        if self.ETcurve and self.l_temp1 is not None:
                            self.l_temp1.set_data(sample_ctimex1, numpy.array(sample_ctemp1))
                        if self.BTcurve and self.l_temp2 is not None:
                            self.l_temp2.set_data(sample_ctimex2, numpy.array(sample_ctemp2))

                    #NOTE: the following is no longer restricted to self.aw.pidcontrol.pidActive==True
                    # as now the software PID is also update while the PID is off (if configured).
                    if (self.Controlbuttonflag and \
                            not self.aw.pidcontrol.externalPIDControl()): # any device and + Artisan Software PID lib
                        if self.aw.pidcontrol.pidSource in {0, 1}:
                            self.pid.update(st2) # smoothed BT
                        elif self.aw.pidcontrol.pidSource == 2:
                            self.pid.update(st1) # smoothed ET
                        else:
                            # pidsource = 3 => extra device 1, channel 1 => sample_extratemp1[0]
                            # pidsource = 4 => extra device 1, channel 2 => sample_extratemp2[0]
                            # pidsource = 5 => extra device 2, channel 3 => sample_extratemp1[1]
                            #...
                            ps = self.aw.pidcontrol.pidSource - 3
                            if ps % 2 == 0 and len(sample_extratemp1)>(ps // 2) and len(sample_extratemp1[ps // 2])>0:
                                self.pid.update(sample_extratemp1[ps // 2][-1])
                            elif len(sample_extratemp1)>(ps // 2) and len(sample_extratemp2[ps // 2])>0:
                                self.pid.update(sample_extratemp2[ps // 2][-1])

                    rateofchange1plot:Optional[float]
                    rateofchange2plot:Optional[float]

                    #we need a minimum of two readings to calculate rate of change
                    if length_of_qmc_timex > 1:
                        # compute T1 RoR
                        try:
                            if t1_final == -1 or len(sample_ctimex1)<2:  # we repeat the last RoR if underlying temperature dropped
                                if sample_unfiltereddelta1:
                                    self.rateofchange1 = sample_unfiltereddelta1[-1]
                                else:
                                    self.rateofchange1 = 0.
                            else: # normal data received
                                #   Delta T = (changeTemp/ChangeTime)*60. =  degrees per minute;
                                left_index = min(len(sample_ctimex1),len(sample_tstemp1),max(2, self.deltaETsamples + 1))
                                # ****** Instead of basing the estimate on the window extremal points,
                                #        grab the full set of points and do a formal LS solution to a straight line and use the slope estimate for RoR
                                if self.polyfitRoRcalc:
                                    try:
                                        time_vec = sample_ctimex1[-left_index:]
                                        temp_samples = sample_tstemp1[-left_index:]
                                        with warnings.catch_warnings():
                                            warnings.simplefilter('ignore')
                                            # using stable polyfit from numpy polyfit module
                                            LS_fit = numpy.polynomial.polynomial.polyfit(time_vec, temp_samples, 1)
                                            self.rateofchange1 = LS_fit[1]*60.
                                    except Exception: # pylint: disable=broad-except
                                        # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                                        # https://github.com/numpy/numpy/issues/16744
                                        # we fall back to the two point algo
                                        timed = sample_ctimex1[-1] - sample_ctimex1[-left_index]   #time difference between last self.deltaETsamples readings
                                        self.rateofchange1 = ((sample_tstemp1[-1] - sample_tstemp1[-left_index])/timed)*60.  #delta ET (degrees/minute)
                                else:
                                    timed = sample_ctimex1[-1] - sample_ctimex1[-left_index]   #time difference between last self.deltaETsamples readings
                                    self.rateofchange1 = ((sample_tstemp1[-1] - sample_tstemp1[-left_index])/timed)*60.  #delta ET (degrees/minute)
                        except Exception as e: # pylint: disable=broad-except
                            _log.error(e)
                            self.rateofchange1 = 0.

                        # compute T2 RoR
                        try:
                            if t2_final == -1 or len(sample_ctimex2)<2:  # we repeat the last RoR if underlying temperature dropped
                                if sample_unfiltereddelta2:
                                    self.rateofchange2 = sample_unfiltereddelta2[-1]
                                else:
                                    self.rateofchange2 = 0.
                            else: # normal data received
                                #   Delta T = (changeTemp/ChangeTime)*60. =  degrees per minute;
                                left_index = min(len(sample_ctimex2),len(sample_tstemp2),max(2, self.deltaBTsamples + 1))
                                # ****** Instead of basing the estimate on the window extremal points,
                                #        grab the full set of points and do a formal LS solution to a straight line and use the slope estimate for RoR
                                if self.polyfitRoRcalc:
                                    try:
                                        time_vec = sample_ctimex2[-left_index:]
                                        temp_samples = sample_tstemp2[-left_index:]
                                        with warnings.catch_warnings():
                                            warnings.simplefilter('ignore')
                                            LS_fit = numpy.polynomial.polynomial.polyfit(time_vec, temp_samples, 1)
                                            self.rateofchange2 = LS_fit[1]*60.
                                    except Exception: # pylint: disable=broad-except
                                        # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                                        # https://github.com/numpy/numpy/issues/16744
                                        # we fall back to the two point algo
                                        timed = sample_ctimex2[-1] - sample_ctimex2[-left_index]   #time difference between last self.deltaBTsamples readings
                                        self.rateofchange2 = ((sample_tstemp2[-1] - sample_tstemp2[-left_index])/timed)*60.  #delta BT (degrees/minute)
                                else:
                                    timed = sample_ctimex2[-1] - sample_ctimex2[-left_index]   #time difference between last self.deltaBTsamples readings
                                    self.rateofchange2 = ((sample_tstemp2[-1] - sample_tstemp2[-left_index])/timed)*60.  #delta BT (degrees/minute)
                        except Exception as e: # pylint: disable=broad-except
                            _log.error(e)
                            self.rateofchange1 = 0.


                        # self.unfiltereddelta{1,2}_pure contain the RoR values respecting the delta_span, but without any delta smoothing NOR delta mathformulas applied
                        self.unfiltereddelta1_pure.append(self.rateofchange1)
                        self.unfiltereddelta2_pure.append(self.rateofchange2)

                        # apply the math formula before the delta smoothing
                        if self.DeltaETfunction is not None and self.DeltaETfunction.strip():
                            try:
                                self.rateofchange1 = self.eval_math_expression(self.DeltaETfunction,tx,RTsname='R1',RTsval=self.rateofchange1)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        if self.DeltaBTfunction is not None and self.DeltaBTfunction.strip():
                            try:
                                self.rateofchange2 = self.eval_math_expression(self.DeltaBTfunction,tx,RTsname='R2',RTsval=self.rateofchange2)
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)

# RoR Smooth Spikes (Drop Filter, Median Filter) is only applied offline
#                        # unfiltereddelta1/2 contains the RoRs respecting the delta_span, but without any delta smoothing AND delta mathformulas applied
#                        # we apply a minimal live median spike filter minimizing the delay by choosing a window smaller than in the offline medfilt
#                        if self.filterDropOuts:
#                            if self.rateofchange1 is not None and self.rateofchange1 != -1:
#                                self.rateofchange1 = self.liveMedianETRoRfilter(self.rateofchange1)
#                            if self.rateofchange2 is not None and self.rateofchange2 != -1:
#                                self.rateofchange2 = self.liveMedianBTRoRfilter(self.rateofchange2)

                        sample_unfiltereddelta1.append(self.rateofchange1)
                        sample_unfiltereddelta2.append(self.rateofchange2)

                        #######   filter deltaBT deltaET
                        # decay smoothing
                        if self.deltaETfilter:
                            user_filter = int(round(self.deltaETfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(sample_unfiltereddelta1) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = list(numpy.arange(1,user_filter+1))
                                self.rateofchange1 = self.decay_average(sample_timex,sample_unfiltereddelta1,self.decay_weights)
                        if self.deltaBTfilter:
                            user_filter = int(round(self.deltaBTfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(sample_unfiltereddelta2) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = list(numpy.arange(1,user_filter+1))
                                self.rateofchange2 = self.decay_average(sample_timex,sample_unfiltereddelta2,self.decay_weights)
                        rateofchange1plot = self.rateofchange1
                        rateofchange2plot = self.rateofchange2
                    else:
                        sample_unfiltereddelta1.append(0.)
                        sample_unfiltereddelta2.append(0.)
                        self.rateofchange1,self.rateofchange2,rateofchange1plot,rateofchange2plot = 0.,0.,0.,0.

                    # limit displayed RoR #(only before TP is recognized) # WHY?
                    if self.RoRlimitFlag: # not self.TPalarmtimeindex and self.RoRlimitFlag:
                        if not max(-self.maxRoRlimit,self.RoRlimitm) < rateofchange1plot < min(self.maxRoRlimit,self.RoRlimit):
                            rateofchange1plot = None
                        if not max(-self.maxRoRlimit,self.RoRlimitm) < rateofchange2plot < min(self.maxRoRlimit,self.RoRlimit):
                            rateofchange2plot = None

                    # append new data to the rateofchange arrays
                    sample_delta1.append(rateofchange1plot)
                    sample_delta2.append(rateofchange2plot)

                    if local_flagstart:
                        ror_start = 0
                        ror_end = length_of_qmc_timex
                        if self.timeindex[6] > 0:
                            ror_end = self.timeindex[6]+1
                        if self.DeltaETflag and self.l_delta1 is not None:
                            if self.timeindex[0] > -1:
                                ror_start = max(self.timeindex[0],self.timeindex[0]+int(round(self.deltaETfilter/2.)) + max(2,(self.deltaETsamples + 1)))
                                self.l_delta1.set_data(sample_timex[ror_start:ror_end], numpy.array(sample_delta1[ror_start:ror_end]))
                            else:
                                self.l_delta1.set_data([], [])
                        if self.DeltaBTflag and self.l_delta2 is not None:
                            if self.timeindex[0] > -1:
                                ror_start = max(self.timeindex[0],self.timeindex[0]+int(round(self.deltaBTfilter/2.)) + max(2,(self.deltaBTsamples + 1)))
                                self.l_delta2.set_data(sample_timex[ror_start:ror_end], numpy.array(sample_delta2[ror_start:ror_end]))
                            else:
                                self.l_delta2.set_data([], [])

                        #readjust xlimit of plot if needed
                        if  not self.fixmaxtime and not self.locktimex:
                            now = (sample_timex[-1] if self.timeindex[0] == -1 else sample_timex[-1] - sample_timex[self.timeindex[0]])
                            if now > (self.endofx - 45):            # if difference is smaller than 45 seconds
                                self.endofx = int(now + 180.)       # increase x limit by 3 minutes
                                self.xaxistosm()
                        if self.ETprojectFlag or self.BTprojectFlag:
                            self.updateProjection()

                        # autodetect CHARGE event
                        # only if BT > 77C/170F
                        if self.autoChargeIdx == 0 and self.autoChargeFlag and self.autoCHARGEenabled and self.timeindex[0] < 0 and length_of_qmc_timex >= 5 and \
                            ((self.mode == 'C' and sample_temp2[-1] > 77) or (self.mode == 'F' and sample_temp2[-1] > 170)):
                            b = self.aw.BTbreak(length_of_qmc_timex - 1,event='CHARGE') # call BTbreak with last index
                            if b > 0:
                                # we found a BT break at the current index minus b
                                self.autoChargeIdx = length_of_qmc_timex - b
                                self.markChargeSignal.emit(False) # this queues an event which forces a realignment/redraw by resetting the cache ax_background and fires the CHARGE action

                        # check for TP event if already CHARGEed and not yet recognized (earliest in the next call to sample())
                        elif self.TPalarmtimeindex is None and self.timeindex[0] > -1 and not self.timeindex[1] and self.timeindex[0]+8 < len(sample_temp2) and self.checkTPalarmtime():
                            try:
                                tp = self.aw.findTP()

                                if ((self.mode == 'C' and sample_temp2[tp] > 50 and sample_temp2[tp] < 150) or \
                                    (self.mode == 'F' and sample_temp2[tp] > 100 and sample_temp2[tp] < 300)): # only mark TP if not an error value!
                                    self.TPalarmtimeindex = tp
                                    self.markTPSignal.emit() # queued
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                            try:
                                # if 2:30min into the roast and TPalarmtimeindex alarmindex not yet set,
                                # we place the TPalarmtimeindex at the current index to enable in airoasters without TP the autoDRY and autoFCs functions and activate the TP Phases LCDs
                                if self.TPalarmtimeindex is None and ((sample_timex[-1] - sample_timex[self.timeindex[0]]) > 150):
                                    self.TPalarmtimeindex = length_of_qmc_timex - 1
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        # autodetect DROP event
                        # only if 7min into roast and BT>160C/320F
                        if self.autoDropIdx == 0 and self.autoDropFlag and self.autoDROPenabled and self.timeindex[0] > -1 and self.timeindex[6] == 0 and \
                            length_of_qmc_timex >= 5 and ((self.mode == 'C' and sample_temp2[-1] > 160) or (self.mode == 'F' and sample_temp2[-1] > 320)) and\
                            ((sample_timex[-1] - sample_timex[self.timeindex[0]]) > 7*60):
                            b = self.aw.BTbreak(length_of_qmc_timex - 1,event='DROP') # call BTbreak with last index
                            if b > 0:
                                # we found a BT break at the current index minus b
                                self.autoDropIdx = length_of_qmc_timex - b
                                self.markDropSignal.emit(False)
                        #check for autoDRY: # only after CHARGE and TP and before FCs if not yet set
                        if self.autoDRYflag and self.autoDRYenabled and self.TPalarmtimeindex and self.timeindex[0] > -1 and not self.timeindex[1] and not self.timeindex[2] and sample_temp2[-1] >= self.phases[1]:
                            # if DRY event not yet set check for BT exceeding Dry-max as specified in the phases dialog
                            self.markDRYSignal.emit(False) # queued
                        #check for autoFCs: # only after CHARGE and TP and before FCe if not yet set
                        if self.autoFCsFlag and self.autoFCsenabled and self.TPalarmtimeindex and self.timeindex[0] > -1 and not self.timeindex[2] and not self.timeindex[3] and sample_temp2[-1] >= self.phases[2]:
                            # after DRY (if FCs event not yet set) check for BT exceeding FC-min as specified in the phases dialog
                            self.markFCsSignal.emit(False) # queued

                    #process active quantifiers
                    try:
                        self.aw.process_active_quantifiers()
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    #update SV on Arduino/TC4, Hottop, or MODBUS if in Ramp/Soak or Background Follow mode and PID is active
                    if self.flagon: # only during sampling
                        #update SV on FujiPIDs
                        if self.device == 0 and self.aw.fujipid.followBackground and self.flagstart: # no SV updates while not yet recording for Fuji PIDs
                            # calculate actual SV
                            sv = self.aw.fujipid.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != self.aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                self.aw.fujipid.setsv(sv,silent=True) # this is called in updategraphics() within the GUI thread to move the sliders
                        elif (self.aw.pidcontrol.pidActive and self.aw.pidcontrol.svMode == 1) or self.aw.pidcontrol.svMode == 2:
                            # in BackgroundFollow mode we update the SV even if not active, just we do not move the SV slider
                            # calculate actual SV
                            sv = self.aw.pidcontrol.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != self.aw.pidcontrol.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                self.aw.pidcontrol.setSV(sv,init=False)

                    # update AUC running value
                    if local_flagstart: # only during recording
                        try:
                            self.aw.updateAUC()
                            if self.AUCguideFlag:
                                self.aw.updateAUCguide()
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)

                    # update BBP values
                    if local_flagstart: # only during recording
                        try:
                            if self.timeindex[0] > -1 and len(sample_timex) == self.timeindex[0] + 5:
                                self.aw.calcBBPMetrics(checkCache=True)
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)


                    #output ET, BT, ETB, BTB to output program
                    if self.aw.ser.externaloutprogramFlag:
                        try:
                            if self.background:
                                if self.timeindex[0] != -1:
                                    j = self.backgroundtime2index(tx - sample_timex[self.timeindex[0]])
                                else:
                                    j = self.backgroundtime2index(tx)
                                ETB = self.temp1B[j]
                                BTB = self.temp2B[j]
                            else:
                                ETB = -1
                                BTB = -1
#                            from subprocess import call as subprocesscall# @Reimport
#                            subprocesscall([self.aw.ser.externaloutprogram,
#                                f'{sample_temp1[-1]:.1f}',
#                                f'{sample_temp2[-1]:.1f}',
#                                f'{ETB:.1f}',
#                                f'{BTB:.1f}'])
                            self.aw.call_prog_with_args(f'{self.aw.ser.externaloutprogram} {sample_temp1[-1]:.1f} {sample_temp2[-1]:.1f} {ETB:.1f} {BTB:.1f}')
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)

                    #check for each alarm that was not yet triggered
                    try:
                        self.alarmSemaphore.acquire(1)
                        for i, aflag in enumerate(self.alarmflag):
                            alarm_ready:bool = False # set to true if alarm i is ready to be fired by either criteria, time or temp
                            #if alarm on, and not triggered, and time is after set time:
                            # menu: 0:ON, 1:START, 2:CHARGE, 3:TP, 4:DRY, 5:FCs, 6:FCe, 7:SCs, 8:SCe, 9:DROP, 10:COOL
                            # qmc.alarmtime = -1 (None == START)
                            # qmc.alarmtime = 0 (CHARGE)
                            # qmc.alarmtime = 1 (DRY)
                            # qmc.alarmtime = 2 (FCs)
                            # qmc.alarmtime = 3 (FCe)
                            # qmc.alarmtime = 4 (SCs)
                            # qmc.alarmtime = 5 (SCe)
                            # qmc.alarmtime = 6 (DROP)
                            # qmc.alarmtime = 7 (COOL)
                            # qmc.alarmtime = 8 (TP)
                            # qmc.alarmtime = 9 (ON)
                            # qmc.alamrtime = 10 (If Alarm)
                            # Cases: (only between CHARGE and DRY we check for TP if alarmtime[i]=8)
                            # 1) the alarm From is START
                            # 2) the alarm was not triggered yet
                            # 3) the alarm From is ON
                            # 4) the alarm From is CHARGE
                            # 5) the alarm From is any other event but TP
                            # 6) the alarm From is TP, it is CHARGED and the TP pattern is recognized
                            if aflag \
                              and self.alarmstate[i] == -1 \
                              and (self.alarmguard[i] < 0 or (0 <= self.alarmguard[i] < len(self.alarmstate) and self.alarmstate[self.alarmguard[i]] != -1)) \
                              and (self.alarmnegguard[i] < 0 or (0 <= self.alarmnegguard[i] < len(self.alarmstate) and self.alarmstate[self.alarmnegguard[i]] == -1)) \
                              and ((self.alarmtime[i] == 9) or (self.alarmtime[i] < 0 and local_flagstart) \
                                or (local_flagstart and self.alarmtime[i] == 0 and self.timeindex[0] > -1) \
                                or (local_flagstart and self.alarmtime[i] > 0 and self.alarmtime[i] < 8 and self.timeindex[self.alarmtime[i]] > 0) \
                                or (self.alarmtime[i] == 10 and self.alarmguard[i] != -1)  \
                                or (local_flagstart and self.alarmtime[i] == 8 and self.timeindex[0] > -1 \
                                    and self.TPalarmtimeindex)):
                                #########
                                # check alarmoffset (time after From event):
                                if self.alarmoffset[i] > 0:
                                    alarm_time = self.timeclock.elapsed()/1000.
                                    if self.alarmtime[i] < 0: # time after START
                                        pass # the alarm_time is the clock time
                                    elif local_flagstart and self.alarmtime[i] == 0 and self.timeindex[0] > -1: # time after CHARGE
                                        alarm_time = alarm_time - sample_timex[self.timeindex[0]]
                                    elif local_flagstart and self.alarmtime[i] == 8 and self.TPalarmtimeindex: # time after TP
                                        alarm_time = alarm_time - sample_timex[self.TPalarmtimeindex]
                                    elif local_flagstart and self.alarmtime[i] < 8 and self.timeindex[self.alarmtime[i]] > 0: # time after any other event
                                        alarm_time = alarm_time - sample_timex[self.timeindex[self.alarmtime[i]]]
                                    elif local_flagstart and self.alarmtime[i] == 10: # time or temp after the trigger of the alarmguard (if one is set)
                                        # we know here that the alarmstate of the guard is valid as it has triggered
                                        alarm_time = alarm_time - sample_timex[self.alarmstate[self.alarmguard[i]]]

                                    if alarm_time >= self.alarmoffset[i]:
                                        alarm_ready = True
                                #########
                                # check alarmtemp:
                                alarm_temp = None
                                alarm_idx = None
                                if self.alarmtime[i] == 10: # IF ALARM and only during recording as otherwise no data to refer to is available
                                    # and this is a conditional alarm with alarm_time set to IF ALARM
                                    if_alarm_state = self.alarmstate[self.alarmguard[i]] # reading when the IF ALARM triggered
                                    if if_alarm_state != -1:
                                        if if_alarm_state < len(sample_timex):
                                            alarm_idx = if_alarm_state
                                        else:
                                            alarm_idx = -1
                                    # we subtract the reading at alarm_idx from the current reading of the channel determined by alarmsource
                                else:
                                    alarm_idx = None
                                if self.alarmsource[i] == -2 and sample_delta1[-1] is not None:  #check DeltaET (might be None)
                                    alarm_temp = sample_delta1[-1]
                                    if alarm_idx is not None:
                                        sd1 = sample_delta1[alarm_idx]
                                        if sd1 is not None:
                                            alarm_temp -= sd1 # subtract the reading at alarm_idx for IF ALARMs
                                elif self.alarmsource[i] == -1 and sample_delta2[-1] is not None: #check DeltaBT (might be None
                                    alarm_temp = sample_delta2[-1]
                                    if alarm_idx is not None:
                                        sd2 = sample_delta2[alarm_idx]
                                        if sd2 is not None:
                                            alarm_temp -= sd2 # subtract the reading at alarm_idx for IF ALARMs
                                elif self.alarmsource[i] == 0:                      #check ET
                                    alarm_temp = sample_temp1[-1]
                                    if alarm_idx is not None:
                                        alarm_temp -= sample_temp1[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif self.alarmsource[i] == 1:                      #check BT
                                    alarm_temp = sample_temp2[-1]
                                    if alarm_idx is not None:
                                        alarm_temp -= sample_temp2[alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                elif self.alarmsource[i] > 1 and ((self.alarmsource[i] - 2) < (2*len(self.extradevices))):
                                    if (self.alarmsource[i])%2==0:
                                        alarm_temp = sample_extratemp1[(self.alarmsource[i] - 2)//2][-1]
                                        if alarm_idx is not None:
                                            alarm_temp -= sample_extratemp1[(self.alarmsource[i] - 2)//2][alarm_idx] # subtract the reading at alarm_idx for IF ALARMs
                                    else:
                                        alarm_temp = sample_extratemp2[(self.alarmsource[i] - 2)//2][-1]
                                        if alarm_idx is not None:
                                            alarm_temp -= sample_extratemp2[(self.alarmsource[i] - 2)//2][alarm_idx] # subtract the reading at alarm_idx for IF ALARMs

                                alarm_limit = self.alarmtemperature[i]

                                if alarm_temp is not None and alarm_temp != -1 and (
                                        (self.alarmcond[i] == 1 and alarm_temp > alarm_limit) or
                                        (self.alarmcond[i] == 0 and alarm_temp < alarm_limit) or
                                        (self.alarmcond[i] == 2 and alarm_temp == alarm_limit) or
                                        (self.alarmcond[i] == 3 and alarm_temp != alarm_limit) or
                                        (alarm_idx is not None and alarm_temp == alarm_limit)): # for relative IF_ALARMS we include the equality
                                    alarm_ready = True
                            if alarm_ready:
                                # fire alarm i
                                self.alarmstate[i] = max(0,len(self.timex) - 1) # we have to ensure that alarmstate of triggered alarms is never negative
                                alarm_beep = len(self.alarmbeep) > i and self.alarmbeep[i] # beep?
                                alarm_action = self.alarmaction[i]
                                alarm_string = self.alarmstrings[i]
                                self.processAlarmSignal.emit(i+1,alarm_beep,alarm_action,alarm_string)
                                _log.debug('alarm %s fired',i+1)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    finally:
                        if self.alarmSemaphore.available() < 1:
                            self.alarmSemaphore.release(1)

                #############    if using DEVICE 18 (no device). Manual mode
                # temperatures are entered when pressing push buttons like for example at self.markDryEnd()
                else:
                    tx = int(self.timeclock.elapsed()/1000.)
                    #readjust xlimit of plot if needed
                    if  not self.fixmaxtime and not self.locktimex:
                        now = (tx if self.timeindex[0] == -1 else tx - sample_timex[self.timeindex[0]])
                        if now > (self.endofx - 45):            # if difference is smaller than 45 seconds
                            self.endofx = now + 180              # increase x limit by 3 minutes (180)
                            if self.ax is not None:
                                self.ax.set_xlim(self.startofx,self.endofx)
                            self.xaxistosm()
                    # also in the manual case we check for TP
                    # check for TP event if already CHARGEed and not yet recognized
                    if local_flagstart and self.TPalarmtimeindex is None and self.timeindex[0] > -1 and self.timeindex[0]+5 < len(sample_temp2) and self.checkTPalarmtime():
                        self.TPalarmtimeindex = self.aw.findTP()
                        self.markTPSignal.emit()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message','Exception:') + ' sample() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                try:
                    if local_flagstart and self.backgroundprofile is not None and (self.timeindex[0] > -1 or self.timeindexB[0] < 0):
                        if self.backgroundReproduce or self.backgroundPlaybackEvents:
                            self.playbackevent()
                        if self.backgroundPlaybackDROP:
                            self.playbackdrop()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    _, _, exc_tb = sys.exc_info()
                    self.adderror((QApplication.translate('Error Message','Exception:') + ' sample_processing() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                #update screen in main GUI thread
                self.updategraphicsSignal.emit()


    # idx is the index to be displayed, by default -1 (the last item of each given array)
    # if idx is None, the default error values are displayed
    # all other parameters are expected to be lists of values, but for PID_SV and PID_DUTY
    # time is the time at in second to be displayed (might be negative, but negative times are rendered as 00:00)
    # if time is None, the timer LCD is not updated
    # time is only updated if not sampling (self.flagon=False)
    # values of -1 are suppressed to their default "off" representation
    # XTs1 and XTs2 are lists of lists of values for the corresponding extra LCDs
    def updateLCDs(self, time:Optional[float], temp1:List[float], temp2:List[float], delta1:List[Optional[float]], delta2:List[Optional[float]], XTs1:Union[List[List[float]], List['npt.NDArray[numpy.double]']], XTs2:Union[List[List[float]], List['npt.NDArray[numpy.double]']], PID_SV:float=-1., PID_DUTY:float=-1, idx:Optional[int]=-1) -> None:
        try:
            if self.LCDdecimalplaces:
                lcdformat = '%.1f'
                resLCD = '-.-' if idx is None else 'u.u'
            else:
                lcdformat = '%.0f'
                resLCD = '--' if idx is None else 'uu'
            timestr = None
            ## TIMER LCDS:
            if not self.flagon and time is not None:
                timestr = '00:00'
                if time > 0:
                    try:
                        timestr = stringfromseconds(time)
                    except Exception: # pylint: disable=broad-except
                        pass
                self.aw.lcd1.display(timestr)
                if self.aw.largeLCDs_dialog is not None:
                    self.updateLargeLCDsTimeSignal.emit(timestr)

            ## ET LCD:
            etstr = resLCD
            try: # if temp1 is None, which should never be the case, this fails
                if temp1 and idx is not None and idx < len(temp1) and temp1[idx] not in [None, -1] and not numpy.isnan(temp1[idx]):
                    if -100 < temp1[idx] < 1000:
                        etstr = lcdformat%temp1[idx]
                    elif self.LCDdecimalplaces and -10000 < temp1[idx] < 100000:
                        etstr = f'{temp1[idx]:.0f}'
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.aw.lcd2.display(etstr)

            ## BT LCD:
            btstr = resLCD
            try:
                if temp2 and idx is not None and idx < len(temp2) and temp2[idx] not in [None, -1] and not numpy.isnan(temp2[idx]):
                    if -100 < temp2[idx] < 1000:
                        btstr = lcdformat%temp2[idx]            # BT
                    elif self.LCDdecimalplaces and -10000 < temp2[idx] < 100000:
                        btstr = f'{temp2[idx]:.0f}'
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.aw.lcd3.display(btstr)

            ## Delta LCDs:
            deltaetstr = resLCD
            deltabtstr = resLCD
            try:
                if delta1 and idx is not None and idx < len(delta1):
                    d1:Optional[float] = delta1[idx]
                    if d1 is not None and d1 != -1 and -100 < d1 < 1000:
                        deltaetstr = lcdformat%d1        # rate of change ET (degrees per minute)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            try:
                if delta2 and idx is not None and idx < len(delta2):
                    d2:Optional[float] = delta2[idx]
                    if d2 is not None and d2 != -1 and  -100 < d2 < 1000:
                        deltabtstr = lcdformat%d2        # rate of change BT (degrees per minute)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.aw.lcd4.display(deltaetstr)
            self.aw.lcd5.display(deltabtstr)
            try:
                self.updateLargeDeltaLCDs(deltabt=deltabtstr,deltaet=deltaetstr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # Fuji/Delta LCDs
            try:
                if self.aw.ser.showFujiLCDs and self.device in {0, 26}:
                    pidsvstr = resLCD
                    piddutystr = resLCD
                    if PID_SV not in [None, -1] and not numpy.isnan(PID_SV) and PID_DUTY not in [None, -1] and not numpy.isnan(PID_DUTY):
                        pidsvstr = lcdformat%PID_SV
                        piddutystr = lcdformat%PID_DUTY
                    self.aw.lcd6.display(pidsvstr)
                    self.aw.lcd7.display(piddutystr)
                    self.updateLargePIDLCDs(sv=pidsvstr,duty=piddutystr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # LargeLCDs and WebLCDs
            if self.aw.WebLCDs:
                self.updateWebLCDs(bt=btstr,et=etstr,time=timestr)
            try:
                if timestr is None:
                    self.updateLargeLCDsReadingsSignal.emit(btstr,etstr)
                else:
                    self.updateLargeLCDsSignal.emit(btstr,etstr,timestr)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # Extra LCDs
            ndev = min(len(XTs1),len(XTs2))
            extra1_values:List[Optional[str]] = []
            extra2_values:List[Optional[str]] = []

            for i in range(ndev):
                if i < self.aw.nLCDS:
                    try:
                        extra1_value = resLCD
                        if idx is not None and XTs1[i] and idx < len(XTs1[i]):
                            fmt = lcdformat
                            v = float(XTs1[i][idx])
                            if v is not None and v != -1:
                                if self.intChannel(i,0):
                                    fmt = '%.0f'
                                if -100 < v < 1000:
                                    extra1_value = fmt%v # everything fits
                                elif self.LCDdecimalplaces and -10000 < v < 100000:
                                    fmt = '%.0f'
                                    extra1_value = fmt%v
                            elif self.intChannel(i,0):
                                extra1_value = 'uu'
                        self.aw.extraLCD1[i].display(extra1_value)
                        extra1_values.append(extra1_value)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        extra1_value = '--'
                        extra1_values.append(extra1_value)
                        self.aw.extraLCD1[i].display(extra1_value)
                    try:
                        extra2_value = resLCD
                        if idx is not None and XTs2[i] and idx < len(XTs2[i]):
                            fmt = lcdformat
                            v = float(XTs2[i][idx])
                            if v is not None and v != -1:
                                if self.intChannel(i,1):
                                    fmt = '%.0f'
                                if -100 < v < 1000:
                                    extra2_value = fmt%v # everything fits
                                elif self.LCDdecimalplaces and -10000 < v < 100000:
                                    fmt = '%.0f'
                                    extra2_value = fmt%v
                            elif self.intChannel(i,1):
                                extra2_value = 'uu'
                        self.aw.extraLCD2[i].display(extra2_value)
                        extra2_values.append(extra2_value)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        extra2_value = '--'
                        extra2_values.append(extra2_value)
                        self.aw.extraLCD2[i].display(extra2_value)

            self.updateLargeExtraLCDs(extra1=extra1_values,extra2=extra2_values)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    # runs from GUI thread.
    # this function is called by a signal at the end of the thread sample() from sample_processing()
    # during sample, updates to GUI widgets or anything GUI must be done here (never from thread)
    @pyqtSlot()
    def updategraphics(self) -> None:
#        QApplication.processEvents() # without this we see some flickers (canvas redraws) on using multiple button event actions on macOS!?
        gotlock = self.updateGraphicsSemaphore.tryAcquire(1,300) # we try to catch a lock if available but we do not wait, if we fail we just skip this redraw round (prevents stacking of waiting calls); we maximally wait 300ms which should be enough on modern machines
        if not gotlock:
            _log.info('updategraphics(): failed to get updateGraphicsSemaphore lock')
        else:
            try:
                if self.flagon and self.ax is not None:
                    #### lock shared resources #####
                    self.profileDataSemaphore.acquire(1)
                    try:
                        # initialize the arrays depending on the recording state
                        if (self.flagstart and len(self.timex) > 0) or not self.flagon: # on recording or off we use the standard data structures
                            sample_timex = self.timex
                            sample_temp1 = self.temp1
                            sample_temp2 = self.temp2
                            sample_extratimex = self.extratimex
                            sample_extratemp1 = self.extratemp1
                            sample_extratemp2 = self.extratemp2

                            sample_delta1 = self.delta1
                            sample_delta2 = self.delta2

                        else: # only on ON we use the temporary sampling datastructures
                            sample_timex = self.on_timex
                            sample_temp1 = self.on_temp1
                            sample_temp2 = self.on_temp2
                            sample_extratimex = self.extratimex
                            sample_extratemp1 = self.on_extratemp1
                            sample_extratemp2 = self.on_extratemp2

                            sample_delta1 = self.on_delta1
                            sample_delta2 = self.on_delta2

                        if sample_timex:
                            # update all LCDs (small, large, Web,..)
                            self.updateLCDs(
                                None,
                                sample_temp1,
                                sample_temp2,
                                sample_delta1,
                                sample_delta2,
                                sample_extratemp1,
                                sample_extratemp2,
                                self.currentpidsv,
                                self.dutycycle)
                    finally:
                        if self.profileDataSemaphore.available() < 1:
                            self.profileDataSemaphore.release(1)

                    if self.flagstart:
                        if  self.zoom_follow: # self.aw.ntb._active == 'ZOOM'
                            if not self.fmt_data_RoR:
                                # center current temp reading on canvas
                                temp = None
                                if self.temp2 and len(self.temp2)>0:
                                    temp = self.temp2[-1]
                                    if temp is not None:
                                        tx = self.timex[-1]
                                        # get current limits
                                        xlim = self.ax.get_xlim()
                                        xlim_offset = (xlim[1] - xlim[0]) / 2.
                                        xlim_new = (tx - xlim_offset, tx + xlim_offset)
                                        ylim = self.ax.get_ylim()
                                        ylim_offset = (ylim[1] - ylim[0]) / 2.
                                        ylim_new = (temp - ylim_offset, temp + ylim_offset)
                                        if ylim != ylim_new or xlim != xlim_new:
                                            # set new limits to center current temp on canvas
                                            self.ax.set_xlim(xlim_new)
                                            self.ax.set_ylim(ylim_new)
                                            if self.twoAxisMode() and self.delta_ax is not None:
                                                # keep the RoR axis constant
                                                zlim = self.delta_ax.get_ylim()
                                                zlim_offset = (zlim[1] - zlim[0]) / 2.
                                                tempd = float(self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,temp))[1]))[1])
                                                zlim_new = (tempd - zlim_offset, tempd + zlim_offset)
                                                self.delta_ax.set_ylim(zlim_new)
                                            self.ax_background = None
                            else:
                                # center current RoR reading on canvas
                                ror = None
                                two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or (self.background and (self.DeltaETBflag or self.DeltaBTBflag)))
                                if two_ax_mode and self.delta_ax is not None:
                                    if self.delta2 and len(self.delta2)>0:
                                        ror = self.delta2[-1]
                                    if ror is not None:
                                        tx = self.timex[-1]
                                        # get current limits
                                        xlim = self.ax.get_xlim()
                                        xlim_offset = (xlim[1] - xlim[0]) / 2.
                                        xlim_new = (tx - xlim_offset, tx + xlim_offset)
                                        ylim = self.ax.get_ylim()
                                        ylim_offset = (ylim[1] - ylim[0]) / 2.
                                        rord = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,ror))[1]))[1])
                                        ylim_new = (rord - ylim_offset, rord + ylim_offset)
                                        if ylim != ylim_new or xlim != xlim_new:
                                            # set new limits to center current temp on canvas
                                            self.ax.set_xlim(xlim_new)
                                            self.ax.set_ylim(ylim_new)
                                            # keep the RoR axis constant
                                            zlim = self.delta_ax.get_ylim()
                                            zlim_offset = (zlim[1] - zlim[0]) / 2.
                                            zlim_new = (ror - zlim_offset, ror + zlim_offset)
                                            self.ax_background = None

                        ##### updated canvas
                        try:
                            if not self.block_update:
                            #-- start update display
                                #### lock shared resources to ensure that no other redraw is interfering with this one here #####
                                self.profileDataSemaphore.acquire(1)
                                try:
                                    if self.ax_background is not None:
                                        self.fig.canvas.restore_region(self.ax_background) # type: ignore

                                        # draw delta lines

                                        if self.swapdeltalcds:
                                            if self.DeltaETflag and self.l_delta1 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_delta1)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                            if self.DeltaBTflag and self.l_delta2 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_delta2)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                        else:
                                            if self.DeltaBTflag and self.l_delta2 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_delta2)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                            if self.DeltaETflag and self.l_delta1 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_delta1)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)

                                        # draw extra curves
                                        xtra_dev_lines1 = 0
                                        xtra_dev_lines2 = 0

                                        try:
                                            for i in range(min(len(self.aw.extraCurveVisibility1),len(self.aw.extraCurveVisibility1),len(sample_extratimex),len(sample_extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(sample_extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                                                if self.aw.extraCurveVisibility1[i] and len(self.extratemp1lines) > xtra_dev_lines1:
                                                    try:
                                                        self.ax.draw_artist(self.extratemp1lines[xtra_dev_lines1])
                                                    except Exception as e: # pylint: disable=broad-except
                                                        _log.exception(e)
                                                    xtra_dev_lines1 = xtra_dev_lines1 + 1
                                                if self.aw.extraCurveVisibility2[i] and len(self.extratemp2lines) > xtra_dev_lines2:
                                                    try:
                                                        self.ax.draw_artist(self.extratemp2lines[xtra_dev_lines2])
                                                    except Exception as e: # pylint: disable=broad-except
                                                        _log.exception(e)
                                                    xtra_dev_lines2 = xtra_dev_lines2 + 1
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                        if self.swaplcds:
                                            # draw ET
                                            if self.ETcurve and self.l_temp1 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_temp1)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                            # draw BT
                                            if self.BTcurve and self.l_temp2 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_temp2)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                        else:
                                            # draw BT
                                            if self.BTcurve and self.l_temp2 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_temp2)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)
                                            # draw ET
                                            if self.ETcurve and self.l_temp1 is not None:
                                                try:
                                                    self.ax.draw_artist(self.l_temp1)
                                                except Exception as e: # pylint: disable=broad-except
                                                    _log.exception(e)

                                        try:
                                            if self.BTcurve:
                                                for a in self.l_annotations:
                                                    self.ax.draw_artist(a)
                                        except Exception as e : # pylint: disable=broad-except
                                            _log.exception(e)

                                        try:
                                            self.update_additional_artists()
                                        except Exception as e: # pylint: disable=broad-except
                                            _log.exception(e)
                                        axfig = self.ax.get_figure()
                                        if axfig is not None:
                                            self.fig.canvas.blit(axfig.bbox)

                                    else:
                                        # we do not have a background to bitblit, so do a full redraw
                                        self.updateBackground() # does the canvas draw, but also fills the ax_background cache
                                        self.update_additional_artists()
                                finally:
                                    if self.profileDataSemaphore.available() < 1:
                                        self.profileDataSemaphore.release(1)
                            #-- end update display
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            self.adderror((QApplication.translate('Error Message','Exception:') + ' updategraphics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

                        #####

                        #update phase lcds
                        self.aw.updatePhasesLCDs()

                        #update AUC lcd
                        if self.AUClcdFlag:
                            self.aw.updateAUCLCD()

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message','Exception:') + ' updategraphics() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.updateGraphicsSemaphore.available() < 1:
                    self.updateGraphicsSemaphore.release(1)

    def setLCDtimestr(self, timestr:str) -> None:
        self.aw.lcd1.display(timestr)
        # update connected WebLCDs
        if self.aw.WebLCDs is not None:
            self.updateWebLCDs(time=timestr)
        if self.aw.largeLCDs_dialog is not None:
            self.updateLargeLCDsTimeSignal.emit(timestr)

    def setLCDtime(self, ts:float) -> None:
        timestr = stringfromseconds(ts)
        self.setLCDtimestr(timestr)

    @pyqtSlot()
    def updateLCDtime(self) -> None:
        if self.flagstart and self.flagon:
            tx = self.timeclock.elapsedMilli()
            if self.aw.simulator is not None:
                speed = self.timeclock.getBase()/1000
                nextreading = (1000. - 1000.*(tx%1.) ) / speed
            else:
                nextreading = 1000. - 1000.*(tx%1.)

            try:
                if self.aw.sample_loop_running and isinstance(self.timeindex, list) and len(self.timeindex) == 8: # ensure we have a valid self.timeindex array

                    if self.timeindex[0] != -1 and isinstance(self.timex, list) and len(self.timex) > self.timeindex[0]:
                        ts = tx - self.timex[self.timeindex[0]]
                    else:
                        ts = tx

                    # if more than max cool (from statistics) past DROP and not yet COOLend turn the time LCD red:
                    if self.timeindex[0]!=-1 and self.timeindex[6] and not self.timeindex[7] and ((len(self.timex) == 1+self.timeindex[6]) or (4*60+2 > (tx - self.timex[self.timeindex[6]]) > 4*60)):
                        # switch LCD color to "cooling" color (only after 4min cooling we switch to slowcoolingtimer color)
                        if (tx - self.timex[self.timeindex[6]]) > 4*60:
                            timer_color = 'slowcoolingtimer'
                        else:
                            timer_color = 'rstimer'
                        self.aw.setTimerColor(timer_color)

                    if self.chargeTimerFlag and self.timeindex[0] == -1 and self.chargeTimerPeriod != 0:
                        if self.chargeTimerPeriod > ts:
                            ts = self.chargeTimerPeriod - ts
                        elif self.chargeTimerPeriod <= ts < self.chargeTimerPeriod + 1:
                            ts = 0

                    self.setLCDtime(ts)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                QTimer.singleShot(int(round(nextreading)),self.updateLCDtime)

    # redraws at least the canvas if redraw=True and force=True
    def timealign(self, redraw:bool = True, recompute:bool = False, force:bool = False) -> None:
        try:
            ptime = None
            btime = None
            if self.alignEvent in {6, 7} and self.timeindexB[6] and self.timeindex[6]: # DROP
                ptime = self.timex[self.timeindex[6]]
                btime = self.timeB[self.timeindexB[6]]
            elif self.alignEvent in {5, 7} and self.timeindexB[5] and self.timeindex[5]: # SCe
                ptime = self.timex[self.timeindex[5]]
                btime = self.timeB[self.timeindexB[5]]
            elif self.alignEvent in {4, 7} and self.timeindexB[4] and self.timeindex[4]: # SCs
                ptime = self.timex[self.timeindex[4]]
                btime = self.timeB[self.timeindexB[4]]
            elif self.alignEvent in {3, 7} and self.timeindexB[3] and self.timeindex[3]: # FCe
                ptime = self.timex[self.timeindex[3]]
                btime = self.timeB[self.timeindexB[3]]
            elif self.alignEvent in {2, 7} and self.timeindexB[2] and self.timeindex[2]: # FCs
                ptime = self.timex[self.timeindex[2]]
                btime = self.timeB[self.timeindexB[2]]
            elif self.alignEvent in {1, 7} and self.timeindexB[1] and self.timeindex[1]: # DRY
                ptime = self.timex[self.timeindex[1]]
                btime = self.timeB[self.timeindexB[1]]
            elif self.timeindexB[0] != -1 and self.timeindex[0] != -1: # CHARGE
                ptime = self.timex[self.timeindex[0]]
                btime = self.timeB[self.timeindexB[0]]
            elif self.timeindexB[0] != -1: # if no foreground profile, align 0:00 to the CHARGE event of the background profile
                ptime = 0
                if self.flagstart:
                    btime = self.timeB[0] if len(self.timeB) > 0 else 0
                elif len(self.timeB)>self.timeindexB[0]:
                    btime = self.timeB[self.timeindexB[0]]
                else:
                    btime = 0
            if ptime is not None and btime is not None:
                difference = ptime - btime
                if difference > 0:
                    self.movebackground('right',int(round(abs(difference))))
                    if redraw:
                        self.redraw_keep_view(recomputeAllDeltas=recompute)
                elif difference < 0:
                    self.movebackground('left',int(round(abs(difference))))
                    if redraw:
                        self.redraw_keep_view(recomputeAllDeltas=recompute)
                elif redraw and force: # ensure that we at least redraw the canvas
                    self.updateBackground()
            elif redraw and force: # only on aligning with CHARGE we redraw even if nothing is moved to redraw the time axis
                self.updateBackground()
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' timealign() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # we count
    # - foreground curves
    # . ET/BT, even if not visible
    # . all visible extra curves
    # . all foreground event curves
    # - background curves
    # . background ET/BT, even if not visible
    # . 3rd background curve only if visible
    # . background event curves if not empty
    def lenaxlines(self) -> int:
        active_curves = len(self.extratimex)
        curves = self.aw.extraCurveVisibility1[0:active_curves] + self.aw.extraCurveVisibility2[0:active_curves] + [self.ETcurve,self.BTcurve]
        c = curves.count(True)
        if self.background:
            c += 2 # those are alwyays populated
            if self.xtcurveidx > 0: # 3rd background curve set?
                idx3 = self.xtcurveidx - 1
                n3 = idx3 // 2
                if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                    c += 1
            if self.ytcurveidx > 0: # 4th background curve set?
                idx4 = self.xtcurveidx - 1
                n4 = idx4 // 2
                if len(self.stemp1BX) > n4 and len(self.stemp2BX) > n4 and len(self.extratimexB) > n4:
                    c += 1
            if self.backgroundeventsflag and self.eventsGraphflag in {2, 3, 4}:
                unique_etypes = set(self.backgroundEtypes)
                # only those background event lines exists that are active and hold events
#                active_background_events = [e < 4 and self.showEtypes[e] for e in unique_etypes] # we remove the "untyped" event as this is only drawn as annotation
#  the above is not reliable as background event lines might be missing if there are no events within the CHARGE/DROP period with backgroundShowFullflag=False
#  the active_background_events below just checks which lines are None and which are populated by line objects
                background_lines = [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]
                active_background_events = [l is not None and e < 4 and self.showEtypes[e] and e in unique_etypes for e, l in enumerate(background_lines)]
                c += sum(active_background_events)
        if self.eventsshowflag and self.eventsGraphflag in {2, 3, 4}:
            c += 4 # the foreground event lines (in contrast to the background ones) are always all present in those modes
        return c

    # we count
    # - deltaET if visible
    # - deltaBT if visible
    # - background deltaET if visible
    # - background deltaBT if visible
    def lendeltaaxlines(self) -> int:
        linecount = 0
        if self.DeltaETflag:
            linecount += 1
        if  self.DeltaBTflag:
            linecount += 1
        if self.background:
            if self.DeltaETBflag:
                linecount += 1
            if self.DeltaBTBflag:
                linecount += 1
        return linecount

    def resetlinecountcaches(self) -> None:
        self.linecount = None
        self.deltalinecount = None

    # NOTE: delta lines are also drawn on the main ax
    # ATTENTION: all lines that should be populated need to established in self.ax.lines thus for example delta lines should be established (with empty point lists)
    #   even if they are not drawn before CHARGE to ensure that the linecount corresponds to the fixes lines in self.ax.lines!!
    def resetlines(self) -> None:
        if self.ax is not None and not bool(self.aw.comparator):
            #note: delta curves are now in self.delta_ax and have been removed from the count of resetlines()
            if self.linecount is None:
                self.linecount = self.lenaxlines()
            if self.deltalinecount is None:
                self.deltalinecount = self.lendeltaaxlines()
            total_linecount = self.linecount+self.deltalinecount
            # remove lines beyond the max limit of self.linecount)
            for i in range(len(self.ax.lines)-1,-1,-1):
                if i >= total_linecount:
                    self.ax.lines[i].remove()
                else:
                    break

    @pyqtSlot(int)
    def getAlarmSet(self, n:int) -> 'Optional[AlarmSet]':
        try:
            self.alarmSemaphore.acquire(1)
            if 0<= n < len(self.alarmsets):
                return self.alarmsets[n]
            return None
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    def setAlarmSet(self, n:int, alarmset:'AlarmSet') -> None:
        try:
            self.alarmSemaphore.acquire(1)
            self.alarmsets[n] = alarmset
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    @pyqtSlot(int)
    def selectAlarmSet(self, n:int) -> None:
        alarmset:Optional[AlarmSet] = self.getAlarmSet(n)
        if alarmset is not None:
            try:
                self.alarmSemaphore.acquire(1)
                #
                self.alarmsetlabel = alarmset['label']
                self.alarmflag = alarmset['flags'][:]
                self.alarmguard = alarmset['guards'][:]
                self.alarmnegguard = alarmset['negguards'][:]
                self.alarmtime = alarmset['times'][:]
                self.alarmoffset = alarmset['offsets'][:]
                self.alarmsource = alarmset['sources'][:]
                self.alarmcond = alarmset['conditions'][:]
                self.alarmtemperature = alarmset['temperatures'][:]
                self.alarmaction = alarmset['actions'][:]
                self.alarmbeep = alarmset['beeps'][:]
                self.alarmstrings = alarmset['alarmstrings'][:]
                # update the alarmstate array to the new size:
                self.alarmstate = [-1]*len(self.alarmflag)
            finally:
                if self.alarmSemaphore.available() < 1:
                    self.alarmSemaphore.release(1)

    @pyqtSlot(str,int)
    def moveBackgroundAndRedraw(self, direction:str, step:int) -> None:
        self.movebackground(direction, step) # direction in {'left', 'right'}
        self.redraw_keep_view(recomputeAllDeltas=False,
            re_smooth_foreground=False,
            re_smooth_background=False)

    def findAlarmSet(self, label:str) -> Optional[int]:
        try:
            self.alarmSemaphore.acquire(1)
            for i, alrmset in enumerate(self.alarmsets):
                if alrmset['label'] == label:
                    return i
            return None
        finally:
            if self.alarmSemaphore.available() < 1:
                self.alarmSemaphore.release(1)

    @staticmethod
    def makeAlarmSet(label:str, flags:List[int], guards:List[int], negguards:List[int], times:List[int], offsets:List[int],
            sources:List[int], conditions:List[int], temperatures:List[float], actions:List[int], beeps:List[int], alarmstrings:List[str]) -> 'AlarmSet':
        return {
            'label': label,
            'flags': flags,
            'guards': guards,
            'negguards': negguards,
            'times': times,
            'offsets': offsets,
            'sources': sources,
            'conditions': conditions,
            'temperatures': temperatures,
            'actions': actions,
            'beeps': beeps,
            'alarmstrings': alarmstrings
        }

    @staticmethod
    def lists2AlarmSet(l:List[Any]) -> 'AlarmSet':
        if len(l) == tgraphcanvas.ALARMSET_ITEMS:
            return tgraphcanvas.makeAlarmSet(*l)
        return tgraphcanvas.emptyAlarmSet()

    @staticmethod
    def emptyAlarmSet() -> 'AlarmSet':
        return tgraphcanvas.makeAlarmSet('',[],[],[],[],[],[],[],[],[],[],[])

    @staticmethod
    def alarmSet2Lists(aset:'AlarmSet') -> List[Any]:
        return [aset['label'], aset['flags'], aset['guards'], aset['negguards'], aset['times'], aset['offsets'],
            aset['sources'], aset['conditions'], aset['temperatures'], aset['actions'], aset['beeps'], aset['alarmstrings']]

    # number is alarmnumber+1 (the 1-based alarm number the user sees), for alarms triggered from outside the alarmtable (like PID RS alarms) number is 0
    @pyqtSlot(int,bool,int,str)
    def processAlarm(self,number:int, beep:bool, action:int, string:str) -> None:
        if not self.silent_alarms:
            try:
                if beep:
                    QApplication.beep()
                if action == 0:
                    self.showAlarmPopupSignal.emit(string,self.alarm_popup_timout)
                elif action == 1:
                    # alarm call program
                    fname = string.split('#')[0]
        # take c the QDir().current() directory changes with loads and saves
        #            QDesktopServices.openUrl(QUrl("file:///" + str(QDir().current().absolutePath()) + "/" + fname, QUrl.ParsingMode.TolerantMode))
#                    if False: # and platform.system() == 'Windows': # this Windows version fails on commands with arguments # pylint: disable=condition-evals-to-constant,using-constant-test
#                        f = f'file:///{QApplication.applicationDirPath()}/{fname}'
#                        res = QDesktopServices.openUrl(QUrl(f, QUrl.ParsingMode.TolerantMode))
                    # MacOS X: script is expected to sit next to the Artisan.app or being specified with its full path
                    # Linux: script is expected to sit next to the artisan binary or being specified with its full path
                    #
                    # to get the effect of speaking alarms a text containing the following two lines called "say.sh" could do
                    #                #!/bin/sh
                    #                say "Hello" &
                    # don't forget to do
                    #                # cd
                    #                # chmod +x say.sh
                    #
                    # alternatively use "say $@ &" as command and send text strings along
                    # Voices:
                    #  -v Alex (male english)
                    #  -v Viki (female english)
                    #  -v Victoria (female english)
                    #  -v Yannick (male german)
                    #  -v Anna (female german)
                    #  -v Paolo (male italian)
                    #  -v Silvia (female italian)
                    self.aw.call_prog_with_args(fname)
                    res = True
                    if res:
                        self.aw.sendmessage(QApplication.translate('Message','Alarm is calling: {0}').format(fname))
                    else:
                        self.adderror(QApplication.translate('Message','Calling alarm failed on {0}').format(fname))
                elif action == 2:
                    # alarm event button
                    button_number = None
                    text = string.split('#')[0]
                    bnrs = text.split(',')
                    for bnr in bnrs:
                        try:
                            button_number = int(str(bnr.strip())) - 1 # the event buttons presented to the user are numbered from 1 on
                        except Exception: # pylint: disable=broad-except
                            self.aw.sendmessage(QApplication.translate('Message',"Alarm trigger button error, description '{0}' not a number").format(string))
                        if button_number is not None and -1 < button_number < len(self.aw.buttonlist):
                            self.aw.recordextraevent(button_number)
                elif action in {3, 4, 5, 6}:
                    # alarm slider 1-4
                    slidernr = None
                    try:
                        text = string.split('#')[0].strip()
                        if action == 3:
                            slidernr = 0
                        elif action == 4:
                            slidernr = 1
                        elif action == 5:
                            slidernr = 2
                        elif action == 6:
                            slidernr = 3
                        if slidernr is not None:
                            slidervalue = max(self.aw.eventslidermin[slidernr],min(self.aw.eventslidermax[slidernr],toInt(str(text))))
                            self.aw.moveslider(slidernr,slidervalue)
                            # we set the last value to be used for relative +- button action as base
                            self.aw.extraeventsactionslastvalue[slidernr] = int(round(slidervalue))
                            if self.flagstart:
                                value = float2float((slidervalue + 10.0) / 10.0)
                                self.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,eventdescription=f'A{number:d} (S{slidernr:d})')
                            self.aw.fireslideraction(slidernr)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.aw.sendmessage(QApplication.translate('Message',"Alarm trigger slider error, description '{0}' not a valid number [0-100]").format(string))

                elif action == 7:
                    # START
                    if self.aw.buttonSTARTSTOP.isEnabled():
                        self.ToggleRecorder()
                elif action == 8:
                    # DRY
                    self.markDRYSignal.emit(False) # queued
                elif action == 9:
                    # FCs
                    self.markFCsSignal.emit(False) # queued
                elif action == 10:
                    # FCe
                    if self.aw.buttonFCe.isEnabled():
                        self.markFCeSignal.emit(False) # queued
                elif action == 11:
                    # SCs
                    if self.aw.buttonSCs.isEnabled():
                        self.markSCsSignal.emit(False) # queued
                elif action == 12:
                    # SCe
                    if self.aw.buttonSCe.isEnabled():
                        self.markSCeSignal.emit(False) # queued
                elif action == 13 and self.timex:
                    # DROP
                    self.autoDropIdx = max(0, len(self.timex) - 1)
                    self.markDropSignal.emit(False) # this queues an event which forces a realignment/redraw by resetting the cache ax_background and fires the CHARGE action
                elif action == 14:
                    # COOL
                    if self.aw.buttonCOOL.isEnabled():
                        self.markCoolSignal.emit(False) # queued
                elif action == 15:
                    # OFF
                    if self.aw.buttonONOFF.isEnabled():
                        self.ToggleMonitor()
                elif action == 16:
                    # CHARGE
                    self.autoChargeIdx = len(self.timex)
                    self.markChargeSignal.emit(False) # this queues an event which forces a realignment/redraw by resetting the cache ax_background and fires the CHARGE action
                elif action == 17 and self.Controlbuttonflag:
                    # RampSoak ON
                    if self.device == 0 and self.aw.fujipid: # FUJI PID
                        self.aw.fujipid.setrampsoak(1)
                    elif self.aw.pidcontrol: # internal or external MODBUS PID control
                        self.aw.pidcontrol.svMode = 1
                        self.aw.pidcontrol.pidOn()
                elif action == 18 and self.Controlbuttonflag:
                    # RampSoak OFF
                    if self.device == 0 and self.aw.fujipid: # FUJI PID
                        self.aw.fujipid.setrampsoak(0)
                    elif self.aw.pidcontrol:  # internal or external MODBUS PID control
                        self.aw.pidcontrol.svMode = 0
                        self.aw.pidcontrol.pidOff()
                elif action == 19 and self.Controlbuttonflag:
                    # PID ON
                    if self.device == 0 and self.aw.fujipid: # FUJI PID
                        self.aw.fujipid.setONOFFstandby(0)
                    elif self.aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        self.aw.pidcontrol.pidOn()
                elif action == 20 and self.Controlbuttonflag:
                    # PID OFF
                    if self.device == 0 and self.aw.fujipid: # FUJI PID
                        self.aw.fujipid.setONOFFstandby(1)
                    elif self.aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        self.aw.pidcontrol.pidOff()
                elif action == 21:
                    # SV slider alarm
                    try:
                        text = string.split('#')[0]
                        sv = float(str(text))
                        if self.device == 0:
                            if sv is not None and sv != self.aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                self.aw.fujipid.setsv(sv,silent=True)
                        #elif self.aw.pidcontrol.pidActive:
                        elif sv is not None and sv != self.aw.pidcontrol.sv:
                            sv = max(0,sv) # we don't send SV < 0
                            self.aw.pidcontrol.setSV(sv,init=False)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.adderror((QApplication.translate('Error Message','Exception:') + ' processAlarm() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
                        self.aw.sendmessage(QApplication.translate('Message',"Alarm trigger SV slider error, description '{0}' not a valid number").format(string))
                elif action == 22:
                    # Playback ON
                    self.turn_playback_event_ON()
                elif action == 23:
                    # Playback OFF
                    self.turn_playback_event_OFF()
                elif action == 24:
                    # grab only the color definition
                    m = re.match('#[0-9,a-f,A-F]{6}',string.strip())
                    if m is not None:
                        c = m.group()
                        # Set Canvas Color
                        self.aw.setCanvasColorSignal.emit(c)
                elif action == 25:
                    # Reset Canvas Color
                    self.aw.resetCanvasColorSignal.emit()

                self.aw.sendmessageSignal.emit(QApplication.translate('Message','Alarm {0} triggered').format(number), True, None)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message','Exception:') + ' processAlarm() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # called only after CHARGE with at least 7min into the roast
    def playbackdrop(self) -> None:
        try:
            #needed when using device NONE
            if (self.timeindex[0] > -1 and self.autoDropIdx == 0 and self.timex and self.timeindexB[6]>0 and self.timeindex[6] == 0 and
                (self.timex[-1] - self.timex[self.timeindex[0]]) > 7*60 and
                ((self.replayType == 0 and self.timeB[self.timeindexB[6]] - self.timeclock.elapsed()/1000. <= 0) or # by time
                    (self.replayType == 1 and len(self.ctemp2)>0 and len(self.stemp2B)>self.timeindexB[6] and  # pylint: disable=chained-comparison
                        self.TPalarmtimeindex and self.ctemp2[-1] is not None and self.stemp2B[self.timeindexB[6]] - self.ctemp2[-1] <= 0) or # by BT
                    (self.replayType == 2 and len(self.ctemp1)>0 and len(self.stemp1B)>self.timeindexB[6] and  # pylint: disable=chained-comparison
                        self.TPalarmtimeindex and self.ctemp1[-1] is not None and self.stemp1B[self.timeindexB[6]] - self.ctemp1[-1] <= 0))): # by ET
                self.autoDropIdx = len(self.timex) - 2
                self.markDropSignal.emit(False)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' playbackdrop() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))


    # update the cache (self.replayedBackgroundEvents) which holds the background events considered to have been already triggered to prevent
    # to have them triggered again. All events before NOW are considered to have been triggered already.
    def updateReplayedBackgroundEvents(self) -> None:
        self.replayedBackgroundEvents = set()
        if self.flagstart:
            sample_interval = self.delay/1000. # in sec
            if self.timeindex[0] != -1:
                start = self.timex[self.timeindex[0]]
            else:
                start = 0
            now = self.timeclock.elapsedMilli() # time since ON
            additional_samples = (3 if self.autoChargeFlag else 2)
            # to catch also background events scheduled for around 00:00 we relax the condition to mark
            # events before now where time has already passed by 2 (or 3 with autoCHARGE) samples
            short_after_CHARGE:bool = False
            if self.timeindex[0] != -1 and now - start <  additional_samples*sample_interval:
                now -= additional_samples*sample_interval
                short_after_CHARGE = True
            for i, bge in enumerate(self.backgroundEvents):
                if (self.timeB[bge] - now) <= 0 and not (short_after_CHARGE and self.timeB[bge] < 0):
                    # switching on short after CHARGE, does not disable background events before CHARGE
                    self.replayedBackgroundEvents.add(i)

    # turns playback event on and fills self.replayedBackgroundEvents with already passed events (w.r.t. time) if any
    def turn_playback_event_ON(self) -> None:
        if not self.backgroundPlaybackEvents:
            # mark all events before NOW as already replayed to prevent them to replay again
            self.updateReplayedBackgroundEvents()
            self.backgroundPlaybackEvents = True

    def turn_playback_event_OFF(self) -> None:
        self.backgroundPlaybackEvents = False
        self.replayedBackgroundEvents = set()

    # called only after CHARGE
    def playbackevent(self) -> None:
        try:
            #needed when using device NONE
            if self.timex:
                #find time or temp distances


                reproducing:Optional[int] = None # index of the event that is currently replaying as text (suppress other replays in this round)

                # if all event types reached their end, we can stop checking further events (optimization)

                # register per event type that we do not have to check further events of that type, if all are checked we can stop the processing
                end_reached:List[bool] = [not flag for flag in self.specialeventplayback] # those event types not activated for event replay are considered done already

                # the next variables is used to realize ramping event replay
                ramps:List[Optional[int]] = [None,None,None,None]  # holds the time or temp ramp value to be applied per event type, calculated from last_replayed_events and the succeeding event

                slider_events = {} # keep event type value pairs to move sliders (but only once per slider and per interval!)
                next_byTemp_checked:List[bool] = [False,False,False,False] # we take care to reply events by temperature in order

                # after an replay by-temp event is checked we set the flag corresponding to its event type in next_byTemp_checked to prevent further checking of this type for by-temp
                # preventing later events to trigger by-temp to keep events triggered in-order (we assume temps increase and without this all further event will trigger immediately!)

                for i, bge in enumerate(self.backgroundEvents):
                    if all(end_reached):
                        # for each type an event was found that did not fire, we can stop looking further for monotonicity
                        break

                    event_type = self.backgroundEtypes[i]

                    if 0 <= event_type < 4: # only the 4 custom events can be replayed

                        now = self.timeclock.elapsedMilli()

                        if (i not in self.replayedBackgroundEvents and # never replay one event twice
                            not end_reached[event_type] and # we already reached the next event of this type after the first enabled one
                            event_type < 4 and len(self.timeB)>bge):

                            timed = self.timeB[bge] - now
                            delta:float = 1 # by default don't trigger this one
                            increasing:bool = True

                            if (self.timeindexB[6]==0 or bge <= self.timeindexB[6]):
                                # don't replay events that happened after DROP in the backgroundprofile (but still apply the last ramp!)
                                if self.replayType == 0: # replay by time
                                    delta = timed
                                elif not next_byTemp_checked[event_type] and self.replayType == 1: # replay by BT (after TP)
                                    if self.TPalarmtimeindex is not None:
                                        if len(self.ctemp2)>0 and self.ctemp2[-1] is not None and len(self.stemp2B)>bge:
                                            delta = self.stemp2B[bge] - self.ctemp2[-1]
# disable "decreasing" support for now (might lead to issues)
#                                            try:
#                                                # if last registered event of event_type has higher BT as next to be replayed one, we
#                                                # expect a temperature decrease instead of an increase
#                                                last_registered_event_index = len(self.specialeventstype) - 1 - self.specialeventstype[::-1].index(event_type)
#                                                if self.ctemp2[self.specialevents[last_registered_event_index]] > self.stemp2B[bge]:
#                                                    delta = self.ctemp2[-1] - self.stemp2B[bge]
#                                                    increasing = False
#                                            except Exception: # pylint: disable=broad-except
#                                                # a previous event of that type might not yet exist
#                                                pass
                                    else: # before TP we switch back to time-based
                                        delta = timed
                                    next_byTemp_checked[event_type] = True
                                elif not next_byTemp_checked[event_type] and self.replayType == 2: # replay by ET (after TP)
                                    if self.TPalarmtimeindex is not None:
                                        if len(self.ctemp1)> 0 and self.ctemp1[-1] is not None and len(self.stemp1B)>bge:
                                            delta = self.stemp1B[bge] - self.ctemp1[-1]
#                                            try:
#                                                # if last registered event of event_type has higher BT as next to be replayed one, we
#                                                # expect a temperature decrease instead of an increase
#                                                last_registered_event_index = len(self.specialeventstype) - 1 - self.specialeventstype[::-1].index(event_type)
#                                                if self.ctemp1[self.specialevents[last_registered_event_index]] > self.stemp1B[bge]:
#                                                    delta = self.ctemp1[-1] - self.stemp1B[bge]
#                                                    increasing = False
#                                            except Exception: # pylint: disable=broad-except
#                                                # a previous event of that type might not yet exist
#                                                pass
                                    else: # before TP we switch back to time-based
                                        delta = timed
                                    next_byTemp_checked[event_type] = True
                                else:
                                    delta = 99999 # don't trigger this one

                            if (reproducing is None and self.specialeventplaybackaid[event_type] and  # only show playback aid for event types with activated playback aid
                                    self.backgroundReproduce and 0 < timed < self.detectBackgroundEventTime):
                                if i not in self.beepedBackgroundEvents and self.backgroundReproduceBeep:
                                    self.beepedBackgroundEvents.add(i)
                                    QApplication.beep()
                                #write text message
                                message = f'> [{self.Betypesf(event_type)}] [{self.eventsvalues(self.backgroundEvalues[i])}] : <b>{stringfromseconds(timed)}</b> : {self.backgroundEStrings[i]}'
                                #rotate colors to get attention
                                if int(round(timed))%2:
                                    style = "background-color:'transparent';"
                                else:
                                    style = "background-color:'yellow';"

                                self.aw.sendmessage(message,style=style)
                                reproducing = i


                            if delta <= 0:
                                #for devices that support automatic roaster control
                                #if Fuji PID
                                if self.device == 0 and '::' in self.backgroundEStrings[i]:

                                    # COMMAND SET STRINGS
                                    #  (adjust the SV PID to the float VALUE1)
                                    # SETRS::VALUE1::VALUE2::VALUE3  (VALUE1 = target SV. float VALUE2 = time to reach int VALUE 1 (ramp) in minutes. int VALUE3 = hold (soak) time in minutes)

                                    # IMPORTANT: VALUES are for controlling ET only (not BT). The PID should control ET not BT. The PID should be connected to ET only.
                                    # Therefore, these values don't reflect a BT defined profile. They define an ET profile.
                                    # They reflect the changes in ET, which indirectly define BT after some time lag

                                    # There are two ways to record a roast. One is by changing Set Values (SV) during the roast,
                                    # the other is by using ramp/soaks segments (RS).
                                    # Examples:

                                    # SETSV::560.3           sets an SV value of 560.3F in the PID at the time of the recorded background event

                                    # SETRS::440.2::2::0     starts Ramp Soak mode so that it reaches 440.2F in 2 minutes and holds (soaks) 440.2F for zero minutes

                                    # SETRS::300.0::2::3::SETRS::540.0::6::0::SETRS::560.0::4::0::SETRS::560::0::0
                                    #       this command has 4 comsecutive commands inside (4 segments)
                                    #       1 SETRS::300.0::2::3 reach 300.0F in 2 minutes and hold it for 3 minutes (ie. total dry phase time = 5 minutes)
                                    #       2 SETRS::540.0::6::0 then reach 540.0F in 6 minutes and hold it there 0 minutes (ie. total mid phase time = 6 minutes )
                                    #       3 SETRS::560.0::4::0 then reach 560.0F in 4 minutes and hold it there 0 minutes (ie. total finish phase time = 4 minutes)
                                    #       4 SETRS::560::0::0 then do nothing (because ramp time and soak time are both 0)
                                    #       END ramp soak mode

                                    self.aw.fujipid.replay(self.backgroundEStrings[i])
                                    libtime.sleep(.5)  #avoid possible close times (rounding off)


                                # if playbackevents is active, we fire the event by moving the slider, but only if
                                # an event type is given (type<4), the background event type is named exactly as the one of the foreground
                                # (NOTE: the event slider does not need to be visible any longer)
                                if (self.backgroundPlaybackEvents and event_type < 4 and
                                        self.specialeventplayback[event_type] and # only replay event types activated for replay
                                        (str(self.etypesf(event_type) == str(self.Betypesf(event_type)))) and
                                        #self.aw.eventslidervisibilities[event_type] and
                                        len(self.backgroundEvalues)>i):
                                    slider_events[event_type] = self.eventsInternal2ExternalValue(self.backgroundEvalues[i]) # add to dict (later overwrite earlier slider moves!)

                                self.replayedBackgroundEvents.add(i) # in any case we mark this event as processed

                            elif self.backgroundPlaybackEvents and event_type < 4:

                                # we reached a background event (in order) which is not yet ready for (direct) replay
                                # as we assume all further events of this type will as well not fire as they are ordered by time and
                                # temperatures which are assumed to increase
                                end_reached[event_type] = True

                                if (event_type not in slider_events and # only if there is no slider event of the corresponding type
                                        self.specialeventplayback[event_type] and # only replay event types activated for replay
                                        (str(self.etypesf(event_type) == str(self.Betypesf(event_type)))) and
                                        #self.aw.eventslidervisibilities[event_type] and # we ramp also events of invisible sliders
                                        self.specialeventplaybackramp[event_type]):   # only calculate ramp for ramping events

                                    ## calculate ramping

                                    # we pick the left event of the ramp the last event of type event_type either of the foreground or the background, whichever ever is closer
                                    # NOTE: this last event was not necessarily replayed before and might have been manually entered instead

                                    last_registered_background_event_idx:Optional[int] = None
                                    last_registered_background_event_time:Optional[float] = None
                                    last_registered_foreground_event_idx:Optional[int] = None
                                    last_registered_foreground_event_time:Optional[float] = None
                                    TP_time:Optional[float] = None
                                    try:
                                        previous_background_event_types = self.backgroundEtypes[:i] # check only events before NOW (events before the current checked index bge)
                                        last_registered_background_event_idx = len(previous_background_event_types) - 1 - previous_background_event_types[::-1].index(event_type) # index of last background event if any; except otherwise
                                        if last_registered_background_event_idx is not None:
                                            last_registered_background_event_time = self.timeB[self.backgroundEvents[last_registered_background_event_idx]]
                                    except ValueError: # index access fails if there is no such event/index
                                        pass
                                    try:
                                        last_registered_foreground_event_idx = len(self.specialeventstype) - 1 - self.specialeventstype[::-1].index(event_type) # index of last foreground event if any; except otherwise
                                        if last_registered_foreground_event_idx is not None:
                                            last_registered_foreground_event_time = self.timex[self.specialevents[last_registered_foreground_event_idx]]
                                    except ValueError:
                                        pass
                                    try:
                                        if self.TPalarmtimeindex is not None:
                                            TP_time = self.timex[self.TPalarmtimeindex]
                                    except ValueError: # index access fails if there is no such event/index
                                        pass

                                    last_event_idx:Optional[int] = last_registered_background_event_idx
                                    last_event_time:Optional[float] = last_registered_background_event_time
                                    last_event_value:Optional[float] = None
                                    last_event_temp1:Optional[float] = None
                                    last_event_temp2:Optional[float] = None
                                    last_event_temp:Optional[float] = None

                                    if (last_registered_foreground_event_idx is not None and last_registered_background_event_time is not None and last_registered_foreground_event_time is not None and
                                        last_registered_foreground_event_time > last_registered_background_event_time):
                                        # last foreground event is newer then last background event thus we use that foreground one
                                        last_event_idx = last_registered_foreground_event_idx
                                        last_event_time = last_registered_foreground_event_time
                                        last_event_value = self.eventsInternal2ExternalValue(self.specialeventsvalue[last_registered_foreground_event_idx])
                                        # only if there is a last_event after TP we do ramping by temperature
                                        if TP_time is not None and TP_time < last_event_time and len(self.specialevents)>last_event_idx:
                                            last_event_temp1 = self.temp1[self.specialevents[last_event_idx]]
                                            last_event_temp2 = self.temp2[self.specialevents[last_event_idx]]
                                    elif last_registered_background_event_idx is not None and last_event_time is not None and last_event_idx is not None:
                                        # use last background event as assigned above is the last we just passed, we add its value
                                        last_event_value = self.eventsInternal2ExternalValue(self.backgroundEvalues[last_registered_background_event_idx])
                                        # only if there is a last_event after TP we do ramping by temperature
                                        if TP_time is not None and TP_time < last_event_time and len(self.backgroundEvents)>last_event_idx:
                                            last_event_temp1 = self.temp1B[self.backgroundEvents[last_event_idx]]
                                            last_event_temp2 = self.temp2B[self.backgroundEvents[last_event_idx]]

                                    if last_event_idx is not None:
                                        next_event_value = self.eventsInternal2ExternalValue(self.backgroundEvalues[i])                          # next always from background
                                        next_event_temp:Optional[float] = None
                                        current_temp:Optional[float] = None

                                        # for ramp by BT only after TP
                                        if (last_event_temp2 is not None and self.replayType == 1 and len(self.temp2)>1 and self.temp2[-1] != -1 and
                                                self.temp2[-2] != -1 and ((increasing and self.temp2[-1] >= self.temp2[-2]) or (not increasing and self.temp2[-1] <= self.temp2[-2])) and
                                                len(self.temp2B) > bge):
                                            last_event_temp = last_event_temp2
                                            next_event_temp = self.temp2B[bge]
                                            current_temp = self.temp2[-1]
                                        elif (last_event_temp1 is not None and self.replayType == 2 and len(self.temp1)>1 and self.temp1[-1] != -1 and
                                                self.temp1[-2] != -1 and ((increasing and self.temp1[-1] >= self.temp1[-2]) or (not increasing and self.temp1[-1] <= self.temp1[-2])) and
                                                len(self.temp1B) > bge):
                                            last_event_temp = last_event_temp1
                                            next_event_temp = self.temp1B[bge]
                                            current_temp = self.temp1[-1]

                                        # compute ramp value if possible
                                        if (self.replayType in {1,2} and last_event_temp is not None and next_event_temp is not None and
                                                last_event_temp is not None and next_event_temp is not None and
                                                current_temp is not None):
                                            # if background event target temperature did increase (or decrease) as the foreground, we ramp by temperature
                                            if min(last_event_temp, next_event_temp) <= current_temp <= max(last_event_temp, next_event_temp):
                                                # we ramp only within the limits
                                                coefficients = numpy.polyfit([last_event_temp, next_event_temp] , [last_event_value, next_event_value], 1)
                                                ramps[event_type] = numpy.poly1d(coefficients)(current_temp)
                                        elif (last_event_temp is None and next_event_temp is None and
                                                (self.replayType == 0 or self.TPalarmtimeindex is None) and # replay by time active
                                                last_event_time is not None and len(self.timeB)>bge):
                                                  # if replay by temp (as one or both of those event_temps is not None), but current temp did not increase we don't
                                                  # ramp by time instead as this would confuse everything.
                                            # we ramp by (absolute) time (ignoring relative shift by CHARGE)
                                            last_time = last_event_time
                                            next_time = self.timeB[bge]
                                            if last_time <= now <= next_time:
                                                # we ramp only within the limits
                                                coefficients = numpy.polyfit([last_time, next_time], [last_event_value, next_event_value], 1)
                                                ramps[event_type] = numpy.poly1d(coefficients)(now)

                # now move the sliders to the new values (if any)
                for k,v in slider_events.items():
                    self.aw.moveslider(k,v)
                    self.aw.sliderReleased(k,force=True)

                for k,ramp_value in enumerate(ramps):
                    if ramp_value is not None:
                        self.aw.moveslider(k, ramp_value)
                        self.aw.fireslideraction_internal(k, ramp_value) # higher precision ramp value send in extern slider actions

                #delete existing message
                if reproducing is None:
                    text = self.aw.messagelabel.text()
                    if len(text) and text[0] == '>':
                        self.aw.clearMessageLine(style="background-color:'transparent';")
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' playbackevent() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    #make a projection of change of rate of BT and ET on the graph
    def updateProjection(self) -> None:
        try:
            # projections are only drawn after CHARGE and before DROP
            if self.ax is not None and self.timeindex[0] != -1 and self.timeindex[6] == 0 and len(self.timex)>0:
                charge = self.timex[self.timeindex[0]] # in data time (corresponds to display time 00:00)
                now = self.timex[-1]                   # in data time (incl. time to charge)
                _,xlim_right = self.ax.get_xlim()      # in data time like timex (incl. time to charge)
                if self.projectionmode == 0 or (self.projectionmode == 1 and (self.timex[-1]-charge)<=60*5): # linear temperature projection mode based on current RoR
                    #calculate the temperature endpoint at endofx according to the latest rate of change
                    if self.l_BTprojection is not None:
                        if self.BTcurve and len(self.unfiltereddelta2_pure) > 0 and self.unfiltereddelta2_pure[-1] is not None and len(self.ctemp2) > 0 and self.ctemp2[-1] is not None and self.ctemp2[-1] != -1 and not numpy.isnan(self.ctemp2[-1]):
                            # projection extended to the plots current endofx
                            left = now
                            right = max(left, xlim_right + charge) # never have the right point be left of left;)
                            BTprojection = self.ctemp2[-1] + self.unfiltereddelta2_pure[-1]*(right - left)/60.
                            #plot projection
                            self.BTprojection_tx = [left,right]
                            self.BTprojection_temp = [self.ctemp2[-1], BTprojection]
                        else:
                            self.BTprojection_tx = []
                            self.BTprojection_temp = []
                        self.l_BTprojection.set_data(self.BTprojection_tx, self.BTprojection_temp)
                    if self.l_ETprojection is not None:
                        if self.ETcurve and len(self.unfiltereddelta1_pure) > 0 and self.unfiltereddelta1_pure[-1] is not None and len(self.ctemp1) > 0 and self.ctemp1[-1] is not None and self.ctemp1[-1] != -1 and not numpy.isnan(self.ctemp1[-1]):
                            # projection extended to the plots current endofx
                            left = now
                            right = max(left,xlim_right + charge) # never have the right point be left of left;)
                            ETprojection = self.ctemp1[-1] + self.unfiltereddelta1_pure[-1]*(right - left)/60.
                            #plot projection
                            self.ETprojection_tx = [left,right]
                            self.ETprojection_temp = [self.ctemp1[-1], ETprojection]
                        else:
                            self.ETprojection_tx = []
                            self.ETprojection_temp = []
                        self.l_ETprojection.set_data(self.ETprojection_tx, self.ETprojection_temp)

                # quadratic temperature projection based on linear RoR approximation
                # only active 5min after CHARGE
                elif self.projectionmode == 1 and (self.timex[-1]-charge)>60*5:
                    delta_interval_BT = max(10, self.deltaBTsamples) # at least a span of 10 readings
                    delta_interval_ET = max(10, self.deltaETsamples) # at least a span of 10 readings
                    deltadeltalimit = 0.002
                    delay = self.delay/1000.

                    # NOTE: we use the unfiltered deltas here to make this work also with a delta symbolic formula like x/2 to render RoR in C/30sec
                    if self.l_BTprojection is not None:
                        if (len(self.ctemp2) > 0 and self.ctemp2[-1] is not None and self.ctemp2[-1] != -1 and not numpy.isnan(self.ctemp2[-1]) and
                                len(self.unfiltereddelta2_pure)>delta_interval_BT and
                                self.unfiltereddelta2_pure[-1] and
                                self.unfiltereddelta2_pure[-1]>0 and
                                self.unfiltereddelta2_pure[-delta_interval_BT] and
                                self.unfiltereddelta2_pure[-delta_interval_BT]>0):

                            deltadelta_secsec = (((self.unfiltereddelta2_pure[-1] - self.unfiltereddelta2_pure[-delta_interval_BT])/60) /
                                    (now - self.timex[-delta_interval_BT])) # linear BT RoRoR   C/sec/sec
                            # limit deltadelta
                            deltadelta_secsec = max(-deltadeltalimit,min(deltadeltalimit,deltadelta_secsec))
                            xpoints = numpy.arange(now, xlim_right, delay)
                            ypoints = [self.ctemp2[-1]]
                            delta_sec = self.unfiltereddelta2_pure[-1]/60
                            for _ in range(len(xpoints)-1):
                                ypoints.append(ypoints[-1] + delta_sec*delay)
                                delta_sec = delta_sec + deltadelta_secsec*delay
                            #plot BT curve
                            self.BTprojection_tx = xpoints.tolist()
                            self.BTprojection_temp = ypoints
                        else:
                            self.BTprojection_tx = []
                            self.BTprojection_temp = []
                        self.l_BTprojection.set_data(self.BTprojection_tx, self.BTprojection_temp)

                    if self.l_ETprojection is not None:
                        if (len(self.ctemp1) > 0 and self.ctemp1[-1] is not None and self.ctemp1[-1] != -1 and not numpy.isnan(self.ctemp1[-1]) and
                                len(self.unfiltereddelta1_pure)>delta_interval_BT and
                                self.unfiltereddelta1_pure[-1] and
                                self.unfiltereddelta1_pure[-1]>0 and
                                self.unfiltereddelta1_pure[-delta_interval_BT] and
                                self.unfiltereddelta1_pure[-delta_interval_BT]>0):

                            deltadelta_secsec = (((self.unfiltereddelta1_pure[-1] - self.unfiltereddelta1_pure[-delta_interval_ET])/60) /
                                    (self.timex[-1] - self.timex[-delta_interval_ET])) # linear ET RoRoR   C/sec/sec
                            # limit deltadelta
                            deltadelta_secsec = max(-deltadeltalimit,min(deltadeltalimit,deltadelta_secsec))
                            xpoints = numpy.arange(now, xlim_right, delay)
                            ypoints = [self.ctemp1[-1]]
                            delta_sec = self.unfiltereddelta1_pure[-1]/60
                            for _ in range(len(xpoints)-1):
                                ypoints.append(ypoints[-1] + delta_sec*delay)
                                delta_sec = delta_sec + deltadelta_secsec*delay
                            #plot ET curve
                            self.ETprojection_tx = xpoints.tolist()
                            self.ETprojection_temp = ypoints
                        else:
                            self.ETprojection_tx = []
                            self.ETprojection_temp = []
                        self.l_ETprojection.set_data(self.ETprojection_tx, self.ETprojection_temp)

                # RoR projections
                if self.projectDeltaFlag and (self.timex[-1]-charge)>60*5:
                    delay = self.delay/1000.

                    if self.l_DeltaBTprojection is not None:
                        delta_interval_BT = max(10, self.deltaBTsamples*2) # at least a span of 10 readings
                        if (self.DeltaBTflag and len(self.delta2)>0 and len(self.delta2)>delta_interval_BT):
                            d2_last = self.delta2[-1]
                            d2_left = self.delta2[-delta_interval_BT]
                            if d2_last is not None and d2_left is not None and d2_last>0 and d2_left>0:
                                # compute deltadelta_secsec from delta2 adjusted to delta math formulas
                                deltadelta_secsec = (((d2_last - d2_left)/60) /
                                    (now - self.timex[-delta_interval_BT])) # linear BT RoRoR   C/sec/sec
                                left = now
                                right = max(left, xlim_right) # never have the right point be left of left;)
                                DeltaBTprojection = d2_last + deltadelta_secsec * (right - left) * 60
                                # projection extended to the plots current endofx
                                self.DeltaBTprojection_tx = [left,right]
                                self.DeltaBTprojection_temp = [d2_last, DeltaBTprojection]
                            else:
                                self.DeltaBTprojection_tx = []
                                self.DeltaBTprojection_temp = []
                        else:
                            self.DeltaBTprojection_tx = []
                            self.DeltaBTprojection_temp = []
                        self.l_DeltaBTprojection.set_data(self.DeltaBTprojection_tx, self.DeltaBTprojection_temp)

                    if self.l_DeltaETprojection is not None:
                        delta_interval_ET = max(10, self.deltaETsamples*2) # at least a span of 10 readings
                        if (self.DeltaETflag and len(self.delta1)>0 and len(self.delta1)>delta_interval_ET):
                            d1_last = self.delta1[-1]
                            d1_left = self.delta1[-delta_interval_ET]
                            if d1_last is not None and d1_left is not None and d1_last>0 and d1_left>0:
                                # compute deltadelta_secsec from delta1 adjusted to delta math formulas
                                deltadelta_secsec = (((d1_last - d1_left)/60) /
                                    (now - self.timex[-delta_interval_ET])) # linear ET RoRoR   C/sec/sec
                                left = now
                                right = max(left, xlim_right) # never have the right point be left of left;)
                                DeltaETprojection = d1_last + deltadelta_secsec * (right - left) * 60
                                # projection extended to the plots current endofx
                                self.DeltaETprojection_tx = [left,right]
                                self.DeltaETprojection_temp = [d1_last, DeltaETprojection]
                            else:
                                self.DeltaETprojection_tx = []
                                self.DeltaETprojection_temp = []
                        else:
                            self.DeltaETprojection_tx = []
                            self.DeltaETprojection_temp = []
                        self.l_DeltaETprojection.set_data(self.DeltaETprojection_tx, self.DeltaETprojection_temp)
            else:
                self.BTprojection_tx = []
                self.BTprojection_temp = []
                self.ETprojection_tx = []
                self.ETprojection_temp = []
                self.DeltaBTprojection_tx = []
                self.DeltaBTprojection_temp = []
                self.DeltaETprojection_tx = []
                self.DeltaETprojection_temp = []
                if self.l_BTprojection is not None:
                    self.l_BTprojection.set_data([],[])
                if self.l_ETprojection is not None:
                    self.l_ETprojection.set_data([],[])
                if self.l_DeltaBTprojection is not None:
                    self.l_DeltaBTprojection.set_data([],[])
                if self.l_DeltaETprojection is not None:
                    self.l_DeltaETprojection.set_data([],[])

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' updateProjection() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            if self.l_BTprojection is not None:
                self.l_BTprojection.set_data([],[])
            if self.l_ETprojection is not None:
                self.l_ETprojection.set_data([],[])
            if self.l_DeltaBTprojection is not None:
                self.l_DeltaBTprojection.set_data([],[])
            if self.l_DeltaETprojection is not None:
                self.l_DeltaETprojection.set_data([],[])

    # takes array with readings, the current index, the sign of the shift as character and the shift value
    # returns val, evalsign
    @staticmethod
    def shiftValueEvalsign(readings:Sequence[Optional[float]],index:int, sign:str, shiftval:int) -> Tuple[float, str]:
        if sign == '-': #  ie. original [1,2,3,4,5,6]; shift right 2 = [1,1,1,2,3,4]
            evalsign = '0'      # "-" becomes digit "0" for python eval compatibility
            shiftedindex = index - shiftval
        else: # sign == '+': #"+" original [1,2,3,4,5,6]; shift left 2  = [3,4,5,6,6,6]
            evalsign = '1'      #digit 1 = "+"
            shiftedindex = index + shiftval
        if len(readings) > 0:
            if shiftedindex >= len(readings):
                shiftedindex = len(readings)- 1
            if shiftedindex < 0:
                return -1, evalsign
            r = readings[shiftedindex]
            return (-1 if r is None else r), evalsign
        return -1, evalsign

    # Computes the shifted value and and sign of the background data (readings), based on the index interpreted w.r.t. foreground time
    # takes array with readings, the current index, the sign of the shift as character and the shift value
    # timex is the time array of the foreground and timeb is that of the background
    # the index is computed w.r.t. the foreground and then mapped to the corresponding index in the given background readings w.r.t. its time array timeb
    # result is clipped w.r.t. foreground data thus data beyond foreground cannot be accessed in the background
    # returns val, evalsign
    def shiftValueEvalsignBackground(self, timex:List[float], timeb:List[float], readings:Sequence[Optional[float]], index:int, sign:str, shiftval:int) -> Tuple[float, str]:
        if sign == '-': #  ie. original [1,2,3,4,5,6]; shift right 2 = [1,1,1,2,3,4]
            evalsign = '0'      # "-" becomes digit "0" for python eval compatibility
            shiftedindex = index - shiftval
        else: # sign == '+': #"+" original [1,2,3,4,5,6]; shift left 2  = [3,4,5,6,6,6]
            evalsign = '1'      #digit 1 = "+"
            shiftedindex = index + shiftval
        if len(timex) > 0 and len(timeb)>0:
            if shiftedindex < 0:
                return -1, evalsign
            if shiftedindex >= len(timex):
                if len(timex)>2:
                    # we extend the time beyond the foreground
                    tx = timex[-1] + (1+shiftedindex-len(timex))*(timex[-1] - timex[-2])
                else:
                    tx = timex[-1]
            else:
                tx = timex[shiftedindex]
            if timeb[0] <= tx <= timeb[-1]:
                idx = self.timearray2index(timeb, tx)
                if -1 < idx < len(readings):
                    r = readings[idx]
                    return (-1 if r is None else r), evalsign
        return -1, evalsign

    # mathexpression = formula; t = a number to evaluate(usually time);
    # equeditnumber option = plotter edit window number; RTsname = option RealTime var name; RTsval = RealTime var val
    # The given mathexpression has to be a non-empty string!
    def eval_math_expression(self,mathexpression:str, t:float, equeditnumber:Optional[int] = None,
                RTsname:Optional[str] = None, RTsval:Optional[float] = None, t_offset:float = 0.) -> float:
        if len(mathexpression):
            mathdictionary = {}
            mathdictionary.update(self.mathdictionary_base) # extend by the standard math symbolic formulas

            if self.flagstart or not self.flagon:
                sample_timex = self.timex
                sample_temp1 = self.temp1
                sample_temp2 = self.temp2
                sample_delta1 = self.delta1
                sample_delta2 = self.delta2
                sample_extratimex = self.extratimex
                sample_extratemp1 = self.extratemp1
                sample_extratemp2 = self.extratemp2
            else:
                sample_timex = self.on_timex
                sample_temp1 = self.on_temp1
                sample_temp2 = self.on_temp2
                sample_delta1 = self.on_delta1
                sample_delta2 = self.on_delta2
                sample_extratimex = self.on_extratimex
                sample_extratemp1 = self.on_extratemp1
                sample_extratemp2 = self.on_extratemp2

            #if sampling
            if RTsname is not None and RTsname != '':
                index = len(sample_timex) - 1 if sample_timex else 0
                #load real time buffers acquired at sample() to the dictionary
                mathdictionary['Y1'] = self.RTtemp1 # ET
                mathdictionary['Y2'] = self.RTtemp2 # BT

                mathdictionary['R1'] = self.rateofchange1 # ET RoR
                mathdictionary['R2'] = self.rateofchange2 # BT RoR

                for d,_ in enumerate(self.RTextratemp1):
                    mathdictionary[f'Y{(d*2+3):.0f}'] = self.RTextratemp1[d]
                    mathdictionary[f'Y{(d*2+4):.0f}'] = self.RTextratemp2[d]
                if RTsname not in mathdictionary and RTsval is not None:
                    mathdictionary[RTsname] = RTsval

            # get index from the time.
            elif sample_timex:
                index = self.time2index(t)  # If using the plotter with loaded profile. Background index done below at "B"
            else:
                index = 0      #if plotting but nothing loaded.
            #if background
            if self.backgroundprofile is not None and 'B' in mathexpression:
                bindex = self.backgroundtime2index(t)         #use background time
            else:
                bindex = None

            replacements = {'+':'p','-':'m','*':'m','/':'d','(':'o',')':'c'} # characters to be replaced from symb variable for substitution

            #symbolic variables holding the index of main events from self.timeindex to be used to retrieve time and temp data from the corresponding t and Y variables
            #using the absolute access symbolic variables t{<i>} and Y{<i>} defined below
            #those variable are set to the error item -1 if no index is yet available

            main_events = ['CHARGE','DRY','FCs','FCe','SCs','SCe','DROP', 'COOL']
            for i,v in enumerate(main_events):
                if (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0):
                    mathdictionary[v] = self.timeindex[i]
                else:
                    mathdictionary[v] = -1

            if self.background:
                background_main_events = ['bCHARGE','bDRY','bFCs','bFCe','bSCs','bSCe','bDROP', 'bCOOL']
                for i,v in enumerate(background_main_events):
                    if (i == 0 and self.timeindexB[i] > -1) or (self.timeindexB[i] > 0):
                        mathdictionary[v] = self.timeindexB[i]
                    else:
                        mathdictionary[v] = -1

            # time in seconds after those events. If an event was not issued yet this evaluates to 0
            delta_main_events = ['dCHARGE','dDRY','dFCs','dFCe','dSCs','dSCe','dDROP', 'dCOOL']
            try:
                for i,v in enumerate(delta_main_events):
                    if len(sample_timex)>0 and (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0) and len(sample_timex)>self.timeindex[i]:
                        # we return the time after the event in seconds
                        mathdictionary[v] = sample_timex[-1] - sample_timex[self.timeindex[i]]
                    else:
                        # before the event we return 0
                        mathdictionary[v] = 0
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            try:
                mathdictionary['aTMP'] = self.ambientTemp
                mathdictionary['aHUM'] = self.ambient_humidity
                mathdictionary['aPRE'] = self.ambient_pressure
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # prediction of the time to DRY and FCs before the event
            # this evaluates to None before TP and 0 after the event
            try:
                for v in ['pDRY','pFCs']:
                    if len(sample_delta2) > 0 and sample_delta2[-1] and sample_delta2[-1] > 0:
                        mathdictionary[v] = 0
                        if v == 'pDRY':
                            if self.backgroundprofile is not None and self.timeindexB[1] and not self.autoDRYflag: # with AutoDRY, we always use the set DRY phase temperature as target
                                drytarget = self.temp2B[self.timeindexB[1]] # Background DRY BT temperature
                            else:
                                drytarget = self.phases[1] # Drying max phases definition
                            if drytarget > sample_temp2[-1]:
                                mathdictionary[v] = (drytarget - sample_temp2[-1])/(sample_delta2[-1]/60.)
                        elif v == 'pFCs':
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.backgroundprofile is not None and self.timeindexB[2]:
                                fcstarget = self.temp2B[self.timeindexB[2]] # Background FCs BT temperature
                            else:
                                fcstarget = self.phases[2] # FCs min phases definition
                            if fcstarget > sample_temp2[-1]:
                                mathdictionary[v] = (fcstarget - sample_temp2[-1])/(sample_delta2[-1]/60.)
                    else:
                        # if a prediction is not possible (before TP), we return the error value -1
                        mathdictionary[v] = -1
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # add AUC variables (AUCbase, AUCtarget, AUCvalue)
            try:
                mathdictionary['AUCvalue'] = self.AUCvalue
                if self.AUCbaseFlag:
                    if self.AUCbegin == 0 and self.timeindex[0] > -1: # start after CHARGE
                        idx = self.timeindex[0]
                    elif self.AUCbegin == 1 and self.TPalarmtimeindex: # start ater TP
                        idx = self.TPalarmtimeindex
                    elif self.AUCbegin == 2 and self.timeindex[1] > 0: # DRY END
                        idx = self.timeindex[1]
                    elif self.AUCbegin == 3 and self.timeindex[2] > 0: # FC START
                        idx = self.timeindex[2]
                    else:
                        idx = -1
                    if idx > -1: # we passed the AUCbegin event
                        mathdictionary['AUCbase'] = sample_temp2[idx]
                    else:
                        mathdictionary['AUCbase'] = None # Event not set yet, no AUCbase
                else:
                    mathdictionary['AUCbase'] = self.AUCbase
                if self.AUCtargetFlag and self.backgroundprofile is not None and self.AUCbackground > 0:
                    mathdictionary['AUCtarget'] = self.AUCbackground
                else:
                    mathdictionary['AUCtarget'] = self.AUCtarget
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # add Roast Properties
            try:
                # weight-in in g
                mathdictionary['WEIGHTin'] = int(round(convertWeight(self.weight[0], weight_units.index(self.weight[2]),0)))
                mathdictionary['MOISTUREin'] = self.moisture_greens
                mathdictionary['TEMPunit'] = (0 if self.mode == 'C' else 1) # 0:C and 1:F
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            #timeshift working vars
            timeshiftexpressions = []           #holds strings like "Y10040" as explained below
            timeshiftexpressionsvalues = []     #holds the evaluated values (float) for the above

            try:
                t = float(t)
                #extract Ys
                Yval = []                   #stores value number example Y9 = 9 => Yval = ['9']
                mlen = len(mathexpression)
                for i in range(mlen):
                    #Start symbolic assignment
                    #Y + one digit
                    if mathexpression[i] == 'Y' and i+1 < mlen and mathexpression[i+1].isdigit():
                        #find Y number for ET,BT,Extras (up to 9)
                        #check for out of range
                        seconddigitstr = ''
                        if i+2 < mlen and mathexpression[i+2].isdigit():
                            offset = 1
                            nint = int(f'{mathexpression[i+1]}{mathexpression[i+2]}')  # two digits Ynumber int
                        else:
                            offset = 0
                            nint = int(mathexpression[i+1])                      # one digit Ynumber int
                        #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]"
                        if i+5+offset < mlen and mathexpression[i+2+offset] == '[':
                            Yshiftval = int(mathexpression[i+offset+4])
                            sign = mathexpression[i+offset+3]

                            #timeshift with two digits
                            if mathexpression[i+offset+5].isdigit():
                                seconddigitstr = mathexpression[i+offset+5]
                                mathexpression = f'{mathexpression[:i+offset+5]}{mathexpression[i+offset+6:]}'
                                Yshiftval = 10*Yshiftval + int(seconddigitstr)

                            if nint == 1: #ET
                                readings = sample_temp1
                            elif nint == 2: #BT
                                readings = sample_temp2
                            else: # nint > 2:
                                #map the extra device
                                edindex = (nint-1)//2 - 1
                                if nint%2:
                                    readings = sample_extratemp1[edindex]
                                else:
                                    readings = sample_extratemp2[edindex]
                            val:float
                            val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)

                            #add expression and values found
                            evaltimeexpression = f'Y{mathexpression[i+1:i+2+offset]}{evalsign*2}{mathexpression[i+offset+4]}{seconddigitstr}{evalsign}'
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            #convert "Y2[+9]" to Ynumber compatible for python eval() to add to dictionary
                            #METHOD USED: replace all non digits chars with sign value.
                            #Example1 "Y2[-7]" = "Y20070"   Example2 "Y2[+9]" = "Y21191"
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+offset+6:]))
                        #direct index access: e.g. "Y2{CHARGE}" or "Y2{12}"
                        elif i+4+offset < mlen and mathexpression[i+offset+2] == '{' and mathexpression.find('}',i+offset+3) > -1:
                            end_idx = mathexpression.index('}',i+offset+3)
                            body = mathexpression[i+3:end_idx]
                            val = -1
                            try:
                                absolute_index = eval(body,{'__builtins__':None},mathdictionary) # pylint: disable=eval-used
                                if absolute_index > -1:
                                    if nint == 1: #ET
                                        val = sample_temp1[absolute_index]
                                    elif nint == 2: #BT
                                        val = sample_temp2[absolute_index]
                                    elif nint > 2:
                                        #map the extra device
                                        edindex = (nint-1)//2 - 1
                                        if nint%2:
                                            val = sample_extratemp1[edindex][absolute_index]
                                        else:
                                            val = sample_extratemp2[edindex][absolute_index]
                            except Exception: # pylint: disable=broad-except
                                pass
                            #add expression and values found
                            literal_body = body
                            for kk, v in replacements.items():
                                literal_body = literal_body.replace(kk,v)
                            evaltimeexpression = f'Y{mathexpression[i+1]}u{literal_body}u' # curle brackets replaced by "u"
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                        # Y + TWO digits. Y10-Y99 . 4+ extra devices. No timeshift
                        elif i+2 < mlen and mathexpression[i+2].isdigit():
                            Yval.append(f'{mathexpression[i+1]}{mathexpression[i+2]}')
                        # No timeshift Y1,Y2,Y3,etc.
                        else:
                            Yval.append(mathexpression[i+1])

                    #the actual value
                    elif mathexpression[i] == 'x':
                        if 'x' not in mathdictionary:
                            if RTsval is not None:                   # zero could be a valid value
                                mathdictionary['x'] = RTsval         # add x to the math dictionary
                            else:
                                mathdictionary['x'] = -1

                    #the factor to plot C/min delta_ax values on the standard temperature axis
                    elif mathexpression[i] == 'k':
                        if 'k' not in mathdictionary:
                            try:
                                mathdictionary['k'] = (self.ylimit - self.ylimit_min) / float(self.zlimit - self.zlimit_min)
                            except Exception: # pylint: disable=broad-except
                                mathdictionary['k'] = 1

                    #the offset to plot C/min delta_ax values on the standard temperature axis
                    elif mathexpression[i] == 'o':
                        if 'o' not in mathdictionary:
                            try:
                                mathdictionary['o'] = self.ylimit_min - (self.zlimit_min * (self.ylimit - self.ylimit_min) / float(self.zlimit - self.zlimit_min))
                            except Exception: # pylint: disable=broad-except
                                mathdictionary['o'] = 0

                    elif mathexpression[i] == 'R':
                        try:
                            if i+1 < mlen:
                                k:int
                                if mathexpression[i+1] == 'B': # RBnn : RoR of Background Profile
                                    k = 1
                                    c = 'RB'
                                else:
                                    k = 0
                                    c = 'R'
                                delta_readings: List[Optional[float]]
                                seconddigitstr = ''
                                if mathexpression[i+k+1].isdigit():
                                    nint = int(mathexpression[i+k+1])              #Rnumber int
                                    #check for TIMESHIFT 0-9 (one digit). Example: "R1[-2]" or RB1[-2]
                                    if i+k+5 < mlen and mathexpression[i+k+2] == '[':
                                        Yshiftval = int(mathexpression[i+k+4])
                                        sign = mathexpression[i+k+3]

                                        # TWO digits shifting
                                        if mathexpression[i+k+5].isdigit():
                                            seconddigit = int(mathexpression[i+k+5])
                                            seconddigitstr = mathexpression[i+k+5]
                                            mathexpression = f'{mathexpression[:i+k+5]}{mathexpression[i+k+6:]}'
                                            Yshiftval = 10*Yshiftval + seconddigit
                                        if nint == 1: #DeltaET
                                            if k == 0:
                                                delta_readings = sample_delta1
                                            else:
                                                delta_readings = self.delta1B
                                        #nint == 2: #DeltaBT
                                        elif k == 0:
                                            delta_readings = sample_delta2
                                        else:
                                            delta_readings = self.delta2B
                                        if k == 0:
                                            val, evalsign = self.shiftValueEvalsign(delta_readings,index,sign,Yshiftval)
                                        else:
                                            #if sampling
                                            if RTsname is not None and RTsname != '':
                                                idx = index + 1
                                            else:
                                                idx = index
                                            val, evalsign = self.shiftValueEvalsignBackground(sample_timex, self.timeB,delta_readings,idx,sign,Yshiftval)

                                        #add expression and values found
                                        evaltimeexpression = ''.join((c,mathexpression[i+k+1],evalsign*2,mathexpression[i+k+4],seconddigitstr,evalsign))
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        #convert "R2[+9]" to Rnumber compatible for python eval() to add to dictionary
                                        #METHOD USED: replace all non digits chars with numbers value.
                                        #Example1 "R2[-7]" = "R20070"   Example2 "R2[+9]" = "R21191" Example3 "RB2[-1]" = "RB23313
                                        mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+k+6:]))

                                    #direct index access: e.g. "R2{CHARGE}" or "R2{12}"
                                    elif i+k+5 < mlen and mathexpression[i+k+2] == '{' and mathexpression.find('}',i+k+3) > -1:
                                        end_idx = mathexpression.index('}',i+k+3)
                                        body = mathexpression[i+k+3:end_idx]
                                        val = -1
                                        try:
                                            absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                            if absolute_index > -1:
                                                if nint == 1: #DeltaET
                                                    if k == 0:
                                                        val = sample_delta1[absolute_index]
                                                    else:
                                                        val = self.delta1B[absolute_index]
                                                # nint == 2: #DeltaBT
                                                elif k == 0:
                                                    val = sample_delta2[absolute_index]
                                                else:
                                                    val = self.delta2B[absolute_index]
                                        except Exception: # pylint: disable=broad-except
                                            pass
                                        #add expression and values found
                                        literal_body = body
                                        for j, v in replacements.items():
                                            literal_body = literal_body.replace(j,v)
                                        evaltimeexpression = ''.join((c,mathexpression[i+1],'z',literal_body,'z')) # curle brackets replaced by "z"
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))

                                    #no shift
                                    elif mathexpression[i+k+1] == '1':
                                        if k == 0:
                                            mathdictionary['R1'] = sample_delta1[index]
                                        else:
                                            #if sampling
                                            if RTsname is not None and RTsname != '':
                                                idx = index + 1
                                            else:
                                                idx = index
                                            # the index is resolved relative to the time of the foreground profile if available
                                            if not sample_timex:
                                                mathdictionary['RB1'] = self.delta1B[idx]
                                            else:
                                                if RTsname is not None and RTsname != '':
                                                    if len(sample_timex)>2:
                                                        sample_interval = sample_timex[-1] - sample_timex[-2]
                                                        tx = sample_timex[index] + sample_interval
                                                    else:
                                                        tx = sample_timex[index]
                                                else:
                                                    tx = sample_timex[index]
                                                idx = self.timearray2index(self.timeB, tx)
                                                if -1 < idx < len(self.delta1B):
                                                    res = self.delta1B[idx]
                                                else:
                                                    res = -1
                                                mathdictionary['RB1'] = res
                                    elif mathexpression[i+k+1] == '2':
                                        if k == 0:
                                            mathdictionary['R2'] = sample_delta2[index]
                                        else:
                                            if RTsname is not None and RTsname != '':
                                                idx = index + 1
                                            else:
                                                idx = index
                                            # the index is resolved relative to the time of the foreground profile if available
                                            if not sample_timex:
                                                mathdictionary['RB2'] = self.delta2B[idx]
                                            else:
                                                if RTsname is not None and RTsname != '':
                                                    if len(sample_timex)>2:
                                                        sample_interval = sample_timex[-1] - sample_timex[-2]
                                                        tx = sample_timex[index] + sample_interval
                                                    else:
                                                        tx = sample_timex[index]
                                                else:
                                                    tx = sample_timex[index]
                                                idx = self.timearray2index(self.timeB, tx)
                                                if -1 < idx < len(self.delta2B):
                                                    res = self.delta2B[idx]
                                                else:
                                                    res = -1
                                                mathdictionary['RB2'] = res
                        except Exception: # pylint: disable=broad-except
                            # if deltas of backgrounds are not visible the data is not calculated and thus this fails with an exception
                            pass

                    #Add to dict Event1-4 external value
                    elif mathexpression[i] == 'E' and i+1 < mlen and mathexpression[i+1].isdigit():                          #check for out of range
                        nint = int(mathexpression[i+1])-1              #Enumber int
                        #find right most occurrence before index of given event type
                        if nint in self.specialeventstype and nint < 4:
                            spevtylen = len(self.specialeventstype)-1
                            iii = None
                            for iii in range(spevtylen,-1,-1):
                                if self.specialeventstype[iii] == nint and index >= self.specialevents[iii]:
                                    break  #index found
                            if iii is None:
                                val = 0 # type: ignore # mypy: Statement is unreachable  [unreachable]
                            else:
                                val = self.eventsInternal2ExternalValue(self.specialeventsvalue[iii])
                        else:
                            val = 0
                        e_string = f'E{mathexpression[i+1]}'
                        if e_string not in mathdictionary:
                            mathdictionary[e_string] = val

                    # time timeshift of absolute time (not relative to CHARGE)
                    # t : to access the foreground profiles time (sample_timex)
                    # b : to access the background profiles time (self.timeB)
                    elif mathexpression[i] in {'t', 'b'}:
                        if mathexpression[i] == 't':
                            timex = sample_timex
                        else:
                            timex = self.abs_timeB
                        seconddigitstr = ''
                        if i+4 < mlen and mathexpression[i+1] == '[':
                            Yshiftval = int(mathexpression[i+3])
                            sign = mathexpression[i+2]

                            if mathexpression[i+4].isdigit():
                                seconddigit = int(mathexpression[i+4])
                                seconddigitstr = mathexpression[i+4]
                                mathexpression = f'{mathexpression[:i+4]}{mathexpression[i+5:]}'
                                Yshiftval = 10*Yshiftval + seconddigit

                            val, evalsign = self.shiftValueEvalsign(timex,index,sign,Yshiftval)

                            val = val - t_offset
                            evaltimeexpression = ''.join((mathexpression[i],evalsign*2,mathexpression[i+3],seconddigitstr,evalsign))
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+5:]))
                        #direct index access: e.g. "t{CHARGE}" or "t{12}"
                        elif i+3 < mlen and mathexpression[i+1] == '{' and mathexpression.find('}',i+2) > -1:
                            end_idx = mathexpression.index('}',i+2)
                            body = mathexpression[i+2:end_idx]
                            if mathexpression[i]=='b':
                                body = 'b' + body
                            val = -1
                            try:
                                absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                if absolute_index > -1:
                                    val = timex[absolute_index]
                            except Exception: # pylint: disable=broad-except
                                pass
                            literal_body = body
                            for kv, v in replacements.items():
                                literal_body = literal_body.replace(kv,v)
                            evaltimeexpression = ''.join((mathexpression[i],'q',literal_body,'q')) # curle brackets replaced by "q"
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                        #no timeshift
                        elif mathexpression[i] == 't' and 't' not in mathdictionary:
                            mathdictionary['t'] = t - t_offset         #add t to the math dictionary
                        # b is only valid with index

                    #Add to dict plotter Previous results (cascading) from plotter field windows (1-9)
                    elif mathexpression[i] == 'P' and i+1 < mlen and mathexpression[i+1].isdigit():                          #check for out of range
                        nint = int(mathexpression[i+1])              #Ynumber int
                        #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]"
                        if i+5 < mlen and mathexpression[i+2] == '[' and mathexpression[i+5] == ']':
                            Yshiftval = int(mathexpression[i+4])
                            sign = mathexpression[i+3]
                            evaltimeexpression = ''.join(('P',mathexpression[i+1],'1'*2,mathexpression[i+4],'1'))
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(-1000)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                        #no shift
                        else:
                            if index < len(self.plotterequationresults[nint-1]):
                                val = self.plotterequationresults[nint-1][index]
                            else:
                                val = -1000
                            p_string = f'P{mathexpression[i+1]}'
                            if p_string not in mathdictionary:
                                mathdictionary[p_string] = val

                    #Background B1 = ETbackground; B2 = BTbackground
                    elif mathexpression[i] == 'B':
                        if i+1 < mlen:
                            seconddigitstr = ''
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])              #Bnumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "B1[-2]"
                                if i+5 < mlen and mathexpression[i+2] == '[':
                                    Yshiftval = int(mathexpression[i+4])
                                    sign = mathexpression[i+3]

                                    # TWO digits shifting
                                    if mathexpression[i+5].isdigit():
                                        seconddigit = int(mathexpression[i+5])
                                        seconddigitstr = mathexpression[i+5]
                                        mathexpression = f'{mathexpression[:i+5]}{mathexpression[i+6:]}'
                                        Yshiftval = 10*Yshiftval + seconddigit

                                    if not self.timeB:
                                        # no background, set to 0
                                        val = 0
                                        evalsign = '0'
                                    else:
                                        readings = None
                                        readings_time = None
                                        if nint == 1: #ETbackground
                                            readings = self.temp1B
                                            readings_time = self.timeB
                                        elif nint == 2: #BTbackground
                                            readings = self.temp2B
                                            readings_time = self.timeB
                                        #B3, B4, B5, ...
                                        elif nint > 2:
                                            idx3 = self.xtcurveidx - 1
                                            n3 = idx3//2
                                            if self.xtcurveidx%2:
                                                readings = list(self.temp1BX[n3])
                                            else:
                                                readings = list(self.temp2BX[n3])
                                            readings_time = self.extratimexB[n3]
#                                        # variant operating directly on the background curve via the given index
#                                        val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)
                                        # variant operating on the background curve with the given index interpreted as time relative to the foreground curve:
                                        if RTsname is not None and RTsname != '':
                                            idx = index + 1
                                        else:
                                            idx = index
                                        if readings is None or readings_time is None:
                                            val = 0
                                            evalsign = '0'
                                        else:
                                            val, evalsign = self.shiftValueEvalsignBackground(sample_timex, readings_time, readings, idx, sign, Yshiftval)
                                    evaltimeexpression = ''.join(('B',mathexpression[i+1],evalsign*2,mathexpression[i+4],seconddigitstr,evalsign))
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                #direct index access: e.g. "B2{CHARGE}" or "B2{12}"
                                elif i+5 < mlen and mathexpression[i+2] == '{' and mathexpression.find('}',i+3) > -1:
                                    end_idx = mathexpression.index('}',i+3)
                                    body = mathexpression[i+3:end_idx]
                                    val = -1
                                    try:
                                        absolute_index = eval(body,{'__builtins__':None},mathdictionary)  # pylint: disable=eval-used
                                        if absolute_index > -1:
                                            if nint == 1: #ET
                                                val = self.temp1B[absolute_index]
                                            elif nint == 2: #BT
                                                val = self.temp2B[absolute_index]
                                            else:
                                                idx3 = self.xtcurveidx - 1
                                                n3 = idx3//2
                                                #map the extra device
                                                b = [0,0,1,1,2,2,3]
                                                edindex = b[nint-3]
                                                if self.xtcurveidx%2:
                                                    val = float(self.temp1BX[n3][absolute_index])
                                                else:
                                                    val = float(self.temp2BX[n3][absolute_index])
                                    except Exception: # pylint: disable=broad-except
                                        pass
                                    #add expression and values found
                                    literal_body = body
                                    for vk, v in replacements.items():
                                        literal_body = literal_body.replace(vk,v)
                                    evaltimeexpression = ''.join(('B',mathexpression[i+1],'z',literal_body,'z')) # curle brackets replaced by "z"
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                #no shift
                                elif not self.timeB:
                                    # no background, set to 0
                                    mathdictionary[f'B{mathexpression[i+1]}'] = 0
                                else:
                                    if nint == 1:
                                        readings = self.temp1B
                                    elif nint == 2:
                                        readings = self.temp2B
                                    else:
                                        idx3 = self.xtcurveidx - 1
                                        n3 = idx3//2
                                        if self.xtcurveidx%2:
                                            readings = list(self.temp1BX[n3])
                                        else:
                                            readings = list(self.temp2BX[n3])
                                    if sample_timex:
                                        if RTsname is not None and RTsname != '':
                                            if len(sample_timex)>2:
                                                sample_interval = sample_timex[-1] - sample_timex[-2]
                                                tx = sample_timex[index] + sample_interval
                                            else:
                                                tx = sample_timex[index]
                                        else:
                                            tx = sample_timex[index]
                                        # the index is resolved relative to the time of the foreground profile if available
                                        idx = self.timearray2index(self.timeB, tx)
                                        if -1 < idx < len(readings):
                                            val = readings[idx]
                                        else:
                                            val = -1
                                    elif bindex is not None:
                                        val = readings[bindex]
                                    else:
                                        val = -1

                                    mathdictionary[f'B{mathexpression[i+1]}'] = val

                    # Feedback from previous result. Stack = [10,9,8,7,6,5,4,3,2,1]
                    # holds the ten previous formula results (same window) in order.
                    # F1 is the last result. F5 is the past 5th result
                    elif mathexpression[i] == 'F' and i+1 < mlen and mathexpression[i+1].isdigit():
                        nint = int(mathexpression[i+1])
                        val = self.plotterstack[-1*nint]
                        f_string = f'F{mathexpression[i+1]}'
                        if f_string not in mathdictionary:
                            mathdictionary[f_string] = val

                    # add channel tare values (T1 => ET, T2 => BT, T3 => E1c1, T4 => E1c2, T5 => E2c1,
                    # set by clicking on the corresponding LCD
                    elif mathexpression[i] == 'T' and i+1 < mlen:                          #check for out of range
                        nint = -1 #Enumber int
                        if i+2 < mlen and mathexpression[i+2].isdigit():
                            nint = int(f'{mathexpression[i+1]}{mathexpression[i+2]}')-1
                            mexpr = f'T{mathexpression[i+1]}{mathexpression[i+2]}'
                        elif mathexpression[i+1].isdigit():
                            nint = int(mathexpression[i+1])-1
                            mexpr = f'T{mathexpression[i+1]}'
                        else:
                            mexpr = None
                        if nint != -1 and mexpr is not None:
                            if len(self.aw.channel_tare_values) > nint:
                                mathdictionary[mexpr] = self.aw.channel_tare_values[nint]
                            else:
                                mathdictionary[mexpr] = 0.0

                    #############   end of mathexpression loop ##########################

                #created Ys values
                try:
                    if len(sample_timex)>0:
                        if RTsname:
                            Y = [sample_temp1[-1], sample_temp2[-1]] # in realtime mode we take the last value
                        else:
                            Y = [sample_temp1[index], sample_temp2[index]]
                        if sample_extratimex:
                            for i in range(len(self.extradevices)):
                                if len(sample_extratimex[i]):
                                    if RTsname:
                                        Y.append(sample_extratemp1[i][-1])
                                        Y.append(sample_extratemp2[i][-1])
                                    else:
                                        Y.append(sample_extratemp1[i][index])
                                        Y.append(sample_extratemp2[i][index])

                        #add Ys and their value to math dictionary
                        for yv in Yval:
                            y_string = f'Y{yv}'
                            if y_string not in mathdictionary:
                                idx = int(yv)-1
                                if len(Y) > idx > -1:
                                    mathdictionary[y_string] = Y[idx]

                        #add other timeshifted expressions to the math dictionary: shifted t and P
                        for i,tsexpr in enumerate(timeshiftexpressions):
                            if tsexpr not in mathdictionary:
                                mathdictionary[tsexpr] = timeshiftexpressionsvalues[i]
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

                reslt:float = -1
                #background symbols just in case there was no profile loaded but a background loaded.
                if len(self.timeB) > 0:
                    for i,tsexpr in enumerate(timeshiftexpressions):
                        if tsexpr not in mathdictionary:
                            mathdictionary[tsexpr] = timeshiftexpressionsvalues[i]
                try:
                    # we exclude the main_events as they occur as substrings in others like CHARGE in dCHARGE
                    # the special case of a variable Y1 overlapping with a variable Y11,..,Y12 in this simple test has to be excluded to avoid
                    # that if mathexpression="Y11" and mathdictionary contains {"Y1":-1} -1 is returned instead of the correct value of Y11
                    # "x" occurs in "max" and has also to be excluded, as "t" and "b"
                    me = mathexpression.strip()
                    propagate_error:bool = True # if any variable occurring in me is bound to -1 the whole me evals to -1
                    try:
                        if me[0] == '(' and me[-1] == ')':
                            # only if the whole expression is in brackets, errors bound to variables are not propagated
                            propagate_error = False
                    except Exception: # pylint: disable=broad-except
                        pass
                    if propagate_error and any((((k in me) if k not in (['Y1','x','t','b'] if ('max' in me) else ['Y1','t','b']) else False) for k,v in mathdictionary.items() if (v == -1 and (k not in main_events)))):
                        # if any variable is bound to the error value -1 we return -1 for the full formula
                        reslt = -1
                    else:
                        reslt = float(eval(me,{'__builtins__':None},mathdictionary)) # pylint: disable=eval-used
                except TypeError:
                    reslt = -1
                except ValueError:
                    reslt = -1
                except ZeroDivisionError:
                    reslt = -1
                except IndexError:
                    reslt = -1
                #stack (use in feedback "F" in same formula)
                self.plotterstack.insert(10,reslt)
                self.plotterstack.pop(0)
                #Pnumber results storage
                if equeditnumber:
                    self.plotterequationresults[equeditnumber-1].append(reslt)
                return reslt

            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                #if plotter
                if equeditnumber:
                    self.plottermessage = f'P{equeditnumber}: {e}'
                    return -1
                #if sample()
                #virtual devices with symbolic may need 2 samples min.
                if len(sample_timex) > 2:
                    _, _, exc_tb = sys.exc_info()
                    mathexpression = mathexpression.replace('{','(').replace('}',')') # avoid {x} leading to key arrows
                    self.adderror(f"{QApplication.translate('Error Message', 'Exception:')} eval_curve_expression(): {mathexpression} {e}",getattr(exc_tb, 'tb_lineno', '?'))
                return -1
        return -1

    #format X axis labels
    def xaxistosm(self,redraw:bool = True, min_time:Optional[float] = None, max_time:Optional[float] = None, set_xlim:bool = True) -> None:
        if self.ax is None:
            return
        try:
            startofx:float
            endofx:float
            starttime:float
            endtime:float

            startofx = self.startofx if min_time is None else min_time
            endofx = self.endofx if max_time is None else max_time

            if bool(self.aw.comparator):
                starttime = 0
            elif -1 < self.timeindex[0] < len(self.timex):
                starttime = self.timex[self.timeindex[0]]
            else:
                starttime = 0

            endtime = endofx + starttime

            if set_xlim:
                self.ax.set_xlim(startofx,endtime)

            if self.xgrid != 0:

                first_reading_time = startofx-starttime
                last_reading_time = endofx
                if not self.flagon and min_time is None and max_time is None:
                    if len(self.timex)>0:
                        first_reading_time = min(first_reading_time, self.timex[0]-starttime)
                        last_reading_time = max(last_reading_time, self.timex[-1]-starttime)
                    if self.background and len(self.timeB)>0:
                        first_reading_time = min(first_reading_time, self.timeB[0]-starttime)
                        last_reading_time = max(last_reading_time, self.timeB[-1]-starttime)
                # mfactor1: number of ticks before CHARGE
                mfactor1 =  round(float(2. + abs( int(round(first_reading_time)) / int(round(self.xgrid)) )))
                # mfactor2: number of ticks after CHARGE
                mfactor2 =  round(float(2. + abs( int(round(last_reading_time)) / int(round(self.xgrid)) )))

                majorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid)
                if self.xgrid == 60:
                    minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 30)
                else:
                    minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 60)

                majorlocator = ticker.FixedLocator(majorloc.tolist())
                minorlocator = ticker.FixedLocator(minorloc.tolist())

                self.ax.xaxis.set_major_locator(majorlocator)
                self.ax.xaxis.set_minor_locator(minorlocator)

                formatter = ticker.FuncFormatter(self.formtime)
                self.ax.xaxis.set_major_formatter(formatter)


                #adjust the length of the minor ticks
                for i in self.ax.xaxis.get_minorticklines() + self.ax.yaxis.get_minorticklines():
                    i.set_markersize(4)

                #adjust the length of the major ticks
                for i in self.ax.get_xticklines() + self.ax.get_yticklines():
                    i.set_markersize(6)
                    #i.set_markeredgewidth(2)   #adjust the width

#                # check x labels rotation
#                if self.xrotation != 0:
#                    for label in self.ax.xaxis.get_ticklabels():
#                        label.set_rotation(self.xrotation)

            if not self.LCDdecimalplaces:
                if self.ax:
                    self.ax.minorticks_off()
                if self.delta_ax is not None:
                    self.delta_ax.minorticks_off()

            # we have to update the canvas cache
            if redraw:
                self.updateBackground()
            else:
                self.ax_background = None
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def fmt_timedata(self, x:float) -> str:
        starttime:float

        if bool(self.aw.comparator):
            starttime = 0
        elif self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0
        sign = '' if x >= starttime else '-'
        m,s = divmod(abs(x - starttime), 60.)
#        return '%s%d:%02d'%(sign,m,s)
        return f'{sign}{m:.0f}:{int(s):02.0f}'

    def fmt_data(self, x:float) -> str:
        res = x
        if self.fmt_data_ON and self.delta_ax is not None and self.ax is not None and self.fmt_data_RoR and self.twoAxisMode():
            try:
                # depending on the z-order of ax vs delta_ax the one or the other one is correct
                #res = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,x))[1]))[1])
                res = float(self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,x))[1]))[1])
            except Exception: # pylint: disable=broad-except
                pass
        if self.LCDdecimalplaces:
            return str(float2float(res))
        return str(int(round(res)))

    #used by xaxistosm(). Provides also negative time
    def formtime(self, x:float, _pos:Optional[int]) -> str:
        starttime:float
        if bool(self.aw.comparator):
            starttime = 0
        elif self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        if x >=  starttime:
            m,s = divmod((x - round(starttime)), 60)  #**NOTE**: divmod() returns here type numpy.float64, which could create problems
            #print type(m),type(s)                    #it is used in: formatter = ticker.FuncFormatter(self.formtime) in xaxistosm()
            s = int(round(s))
            m = int(m)

            if s >= 59:
                return f'{m+1:.0f}'
            if abs(s - 30) < 1:
                return f'{m:d}.5'
            if s > 1:
                return  f'{m:.0f}:{s:02.0f}'
            return f'{m:.0f}'

        m,s = divmod(abs(x - round(starttime)), 60.)
        s = int(round(s))
        m = int(m)

        if s >= 59:
            return f'-{m+1:.0f}'
        if abs(s-30) < 1:
            return f'-{m:d}.5'
        if s > 1:
            return  f'-{m:.0f}:{s:02.0f}'
        if m == 0:
            return '0'
        return f'-{m:.0f}'

    # returns True if nothing to save, discard or save was selected and False if canceled by the user
    def checkSaved(self,allow_discard:bool = True) -> bool:
        #prevents deleting accidentally a finished roast
        flag = self.safesaveflag
        self.safesaveflag = False
        if flag and len(self.timex) > 3:
            string = QApplication.translate('Message','Save profile?')
            if allow_discard:
                buttons = QMessageBox.StandardButton.Discard|QMessageBox.StandardButton.Save|QMessageBox.StandardButton.Cancel
            else:
                buttons = QMessageBox.StandardButton.Save|QMessageBox.StandardButton.Cancel
#On macOS, if the modality is set to Qt::WindowModal and the message box has a parent, then the message box will be a Qt::Sheet,
#otherwise the message box will be a standard dialog.
# setWindowModality(Qt.WindowModality.WindowModal)
            reply = QMessageBox.warning(None, #self.aw,  # only without super this one shows the native dialog on macOS under Qt 6.6.2 and later
                QApplication.translate('Message','Profile unsaved'), string, buttons)
            self.safesaveflag = flag
            if reply == QMessageBox.StandardButton.Save:
                return bool(self.aw.fileSave(self.aw.curFile))  #if accepted, calls fileClean() and thus turns safesaveflag = False
            if reply == QMessageBox.StandardButton.Discard:
                self.fileCleanSignal.emit()
                return True
            if reply == QMessageBox.StandardButton.Cancel:
                self.aw.sendmessage(QApplication.translate('Message','Action canceled'))
            return False
        # nothing to be saved
        return True

    def clearLCDs(self) -> None:
        zz = '-.-' if self.LCDdecimalplaces else '--'
        self.aw.lcd2.display(zz)
        self.aw.lcd3.display(zz)
        self.aw.lcd4.display(zz)
        self.aw.lcd5.display(zz)
        self.aw.lcd6.display(zz)
        self.aw.lcd7.display(zz)
        for i in range(self.aw.nLCDS):
            zz0 = '--' if self.intChannel(i, 0) else zz
            self.aw.extraLCD1[i].display(zz0)
            zz1 = '--' if self.intChannel(i, 1) else zz
            self.aw.extraLCD2[i].display(zz1)
        if self.aw.largeLCDs_dialog is not None:
            self.aw.largeLCDs_dialog.updateDecimals()
        if self.aw.largeDeltaLCDs_dialog is not None:
            self.aw.largeDeltaLCDs_dialog.updateDecimals()
        if self.aw.largePIDLCDs_dialog is not None:
            self.aw.largePIDLCDs_dialog.updateDecimals()
        if self.aw.largeExtraLCDs_dialog is not None:
            self.aw.largeExtraLCDs_dialog.updateDecimals()
        if self.aw.largePhasesLCDs_dialog is not None:
            self.aw.largePhasesLCDs_dialog.updateDecimals()

    def clearMeasurements(self, andLCDs:bool=True) -> None:
        try:
            #### lock shared resources #####
            self.profileDataSemaphore.acquire(1)
            self.fileCleanSignal.emit()
            self.rateofchange1 = 0.0
            self.rateofchange2 = 0.0
            charge:float= 0
            if self.timeindex[0] > -1:
                charge = self.timex[self.timeindex[0]]
            # initialize temperature and delta data
            self.temp1, self.temp2, self.delta1, self.delta2, self.timex, self.stemp1, self.stemp2, self.ctimex1, self.ctimex2, self.ctemp1, self.ctemp2 = [],[],[],[],[],[],[],[],[],[],[]
            self.tstemp1,self.tstemp2 = [],[]
            self.unfiltereddelta1,self.unfiltereddelta2 = [],[]
            self.unfiltereddelta1_pure,self.unfiltereddelta2_pure = [],[]
            # initialize projections data:
            self.BTprojection_tx, self.BTprojection_temp, self.ETprojection_tx, self.ETprojection_temp = [],[],[],[]
            self.DeltaBTprojection_tx, self.DeltaBTprojection_temp, self.DeltaETprojection_tx, self.DeltaETprojection_temp = [],[],[],[]
            # timeindex
            self.timeindex = [-1,0,0,0,0,0,0,0]
            # we set startofx to x-axis min limit as timeindex[0] is no cleared, to keep the axis limits constant (note that startx depends on timeindex[0]!)
            self.startofx = self.startofx - charge
            #extra devices
            for i in range(min(len(self.extradevices),len(self.extratimex),len(self.extratemp1),len(self.extratemp2),len(self.extrastemp1),len(self.extrastemp2))):
                self.extratimex[i],self.extratemp1[i],self.extratemp2[i],self.extrastemp1[i],self.extrastemp2[i] = [],[],[],[],[]            #reset all variables that need to be reset (but for the actually measurements that will be treated separately at the end of this function)
                self.extractimex1[i],self.extractimex2[i],self.extractemp1[i],self.extractemp2[i] = [],[],[],[]
            self.replayedBackgroundEvents=set()
            self.beepedBackgroundEvents=set()
            self.clearEvents() # clear special events
            self.aw.lcd1.display('00:00')
            if self.aw.WebLCDs:
                self.updateWebLCDs(time='00:00')
            if self.aw.largeLCDs_dialog is not None:
                self.updateLargeLCDsTimeSignal.emit('00:00')
            if andLCDs:
                self.clearLCDs()

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' clearMeasurements() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)

    @pyqtSlot(bool)
    def resetButtonAction(self,_:bool=False) -> None:
        self.disconnectProbes() # release serial/S7/MODBUS connections
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.KeyboardModifier.AltModifier:  #alt click
            # detach IO Phidgets
            try:
                self.closePhidgetOUTPUTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            try:
                self.closePhidgetAMBIENTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        self.reset()

    #Resets graph. Called from reset button. Deletes all data. Calls redraw() at the end
    # returns False if action was canceled, True otherwise
    # if keepProperties=True (a call from OnMonitor()), we keep all the pre-set roast properties
    # onMonitor is set if called from onMonitor
    def reset(self,redraw:bool = True, soundOn:bool = True, keepProperties:bool = False, fireResetAction:bool = True, onMonitor:bool = False) -> bool:
        try:
            focused_widget = QApplication.focusWidget()
            if focused_widget and focused_widget != self.aw.centralWidget():
                focused_widget.clearFocus()
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

        if not self.checkSaved():
            return False

        # restore and clear extra device settings which might have been created on loading a profile with different extra devices settings configuration
        self.aw.restoreExtraDeviceSettingsBackup()

        if onMonitor and self.flagOpenCompleted and self.aw.curFile is not None:
            # always if ON is pressed while a profile is loaded, the profile is send to the Viewer
            # the file URL of the saved profile (if any) is send to the ArtisanViewer app to be opened if already running
            try:
                fileURL = QUrl.fromLocalFile(self.aw.curFile)
                fileURL.setQuery('background') # open the file URL without raising the app to the foreground
                self.aw.app.sendmessage2ArtisanViewerSignal.emit(fileURL.toString())
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

        if soundOn:
            self.aw.soundpopSignal.emit()

        if fireResetAction:
            try:
                # the RESET button action needs to be fired outside of the semaphore to avoid lockups
                self.aw.eventactionx(self.xextrabuttonactions[0],self.xextrabuttonactionstrings[0])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        try:
            #### lock shared resources #####
            self.profileDataSemaphore.acquire(1)
            #reset time
            self.resetTimer()

            self.roastUUID = None # reset UUID
            self.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
            self.roastbatchpos = 1 # initialized to 1, set to increased batchsequence on DROP
            self.roastbatchprefix = self.batchprefix

            # reset scheduleID/Date (prevents reusing a previous loaded profiles scheduleID to be 'reused')
            self.scheduleID = None
            self.scheduleDate = None

            self.aw.sendmessage(QApplication.translate('Message','Scope has been reset'))
            self.aw.AUClcd.setNumDigits(3)
            self.aw.buttonFCs.setDisabled(False)
            self.aw.buttonFCe.setDisabled(False)
            self.aw.buttonSCs.setDisabled(False)
            self.aw.buttonSCe.setDisabled(False)
            self.aw.buttonRESET.setDisabled(False)
            self.aw.buttonCHARGE.setDisabled(False)
            self.aw.buttonDROP.setDisabled(False)
            self.aw.buttonDRY.setDisabled(False)
            self.aw.buttonCOOL.setDisabled(False)
            self.aw.buttonFCs.setFlat(False)
            self.aw.buttonFCe.setFlat(False)
            self.aw.buttonSCs.setFlat(False)
            self.aw.buttonSCe.setFlat(False)
            self.aw.buttonRESET.setFlat(False)
            self.aw.buttonCHARGE.setFlat(False)
            self.aw.buttonCHARGE.stopAnimation()
            self.aw.buttonDROP.setFlat(False)
            self.aw.buttonDRY.setFlat(False)
            self.aw.buttonCOOL.setFlat(False)
            self.aw.buttonONOFF.setText(QApplication.translate('Button', 'ON'))
            if self.aw.simulator:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles_simulator['OFF'])
            else:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles['OFF'])
            self.aw.buttonSTARTSTOP.setText(QApplication.translate('Button', 'START'))
            if self.aw.simulator:
                self.aw.buttonSTARTSTOP.setStyleSheet(self.aw.pushbuttonstyles_simulator['STOP'])
            else:
                self.aw.buttonSTARTSTOP.setStyleSheet(self.aw.pushbuttonstyles['STOP'])

            # quantification is blocked if lock_quantification_sampling_ticks is not 0
            # (eg. after a change of the event value by button or slider actions)
            self.aw.block_quantification_sampling_ticks = [0,0,0,0]
            #self.aw.extraeventsactionslastvalue = [None,None,None,None] # used by +-% event buttons in ON mode when no event was registered yet

            # reset plus sync
            self.plus_sync_record_hash = None
            self.plus_file_last_modified = None

            # initialize recording version to be stored to new profiles recorded
            self.aw.recording_version = str(__version__)
            self.aw.recording_revision = str(__revision__)
            self.aw.recording_build = str(__build__)

            # if we are in KeepON mode, the reset triggered by ON should respect the roastpropertiesflag ("Delete Properties on Reset")
            if self.roastpropertiesflag and (self.flagKeepON or not keepProperties):
                self.title = QApplication.translate('Scope Title', 'Roaster Scope')
                self.beans = ''
                self.plus_store = None
                self.plus_coffee = None
                self.plus_blend_spec = None
                # copy setup
                self.organization = self.organization_setup
                self.operator = self.operator_setup
                self.roastertype = self.roastertype_setup
                self.roastersize = self.roastersize_setup
                self.roasterheating = self.roasterheating_setup
                self.drumspeed = self.drumspeed_setup
                # set energy defaults
                self.restoreEnergyLoadDefaults()
                self.restoreEnergyProtocolDefaults()
                #
                if (self.backgroundprofile is not None and 'weight' in self.backgroundprofile and
                    self.setBatchSizeFromBackground and self.aw.schedule_window is None):
                    self.weight = (float(self.backgroundprofile['weight'][0]),0,str(self.backgroundprofile['weight'][2]))
                else:
                    self.weight = (self.last_batchsize,0,self.weight[2])
                self.volume = (0,0,self.volume[2])
                self.density = (0,self.density[1],1,self.density[3])
                # we reset ambient values to the last sampled readings in this session
                self.ambientTemp = self.ambientTemp_sampled
                self.ambient_humidity = self.ambient_humidity_sampled
                self.ambient_pressure = self.ambient_pressure_sampled
                self.beansize = 0.
                self.beansize_min = 0
                self.beansize_max = 0
                self.moisture_greens = 0.
                self.greens_temp = 0.
                self.volumeCalcWeightInStr = ''
                self.volumeCalcWeightOutStr = ''
            else:
                self.weight = (self.weight[0],0,self.weight[2])
                self.volume = (self.volume[0],0,self.volume[2])
            if len(self.timex) > 20:
                # roast notes of an existing roast are reset
                self.roastingnotes = ''
            self.cuppingnotes = ''
            self.whole_color = 0
            self.ground_color = 0
            self.moisture_roasted = 0.
            self.density_roasted = (0,self.density_roasted[1],1,self.density_roasted[3])

            # reset running AUC values
            self.AUCvalue = 0
            self.AUCsinceFCs = 0
            self.AUCguideTime = 0

            self.profile_sampling_interval = None

            self.statisticstimes = [0,0,0,0,0]

            self.roastdate = QDateTime.currentDateTime()
            self.roastepoch = QDateTime.currentDateTime().toSecsSinceEpoch()
            self.roasttzoffset = libtime.timezone
            if not self.flagon: # just if the RESET button is manually pressed we clear the error log
                self.errorlog = []
                self.aw.seriallog = []

            self.aw.resetBBPMetrics()
            self.meterreads = self.meterreads_default.copy()

            self.zoom_follow = False # reset the zoom follow feature

            self.specialevents = []
            self.specialeventstype = []
            self.specialeventsStrings = []
            self.specialeventsvalue = []

            self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
            self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
            self.aw.eNumberSpinBox.setValue(0)
            self.aw.lineEvent.setText('')
            self.aw.etypeComboBox.setCurrentIndex(0)
            self.aw.valueEdit.setText('')
            #used to find length of arms in annotations
            self.ystep_down = 0
            self.ystep_up = 0

            #reset extra device +Program_34, +Program_56, +Program_78 and +Program_910
            self.program_t3 = -1
            self.program_t4 = -1
            self.program_t5 = -1
            self.program_t6 = -1
            self.program_t7 = -1
            self.program_t8 = -1
            self.program_t9 = -1
            self.program_t10 = -1

            # reset keyboard mode
            self.aw.keyboardmoveindex = 0 # points to the last activated button in keyboardButtonList; we start with the CHARGE button
            self.aw.resetKeyboardButtonMarks()

            self.aw.setTimerColor('timer')

            try:
                self.aw.ntb.update() # reset the MPL navigation history
            except Exception as e: # pylint: disable=broad-except
                _log.error(e)

            #roast flags
            self.heavyFC_flag = False
            self.lowFC_flag = False
            self.lightCut_flag = False
            self.darkCut_flag = False
            self.drops_flag = False
            self.oily_flag = False
            self.uneven_flag = False
            self.tipping_flag = False
            self.scorching_flag = False
            self.divots_flag = False

            # re-enable autoCHARGE/autoDRY/autoFCs/autoDROP; all of those get set to False on UNDO of the event for the current roast
            self.autoCHARGEenabled = True
            self.autoDRYenabled = True
            self.autoFCsenabled = True
            self.autoDROPenabled = True

            #Designer variables
            self.indexpoint = 0
            self.workingline = 2            #selects ET or BT
            self.currentx = 0               #used to add point when right click
            self.currenty = 0               #used to add point when right click
            self.designertemp1init = []
            self.designertemp2init = []
#            if self.mode == 'C':
#                #CH, DE, FCs,FCe,SSs,SCe,DROP, COOL
#                self.designertemp1init = [290.,290.,290.,290.,280.,270.,260.,250]
#                self.designertemp2init = [230.,150.,190.,212.,218.,225.,230.,230.]
#            elif self.mode == 'F':
#                self.designertemp1init = [500,500,500,500,500,500,500]
#                self.designertemp2init = [380,300,390,395,410,412,420]
            self.disconnect_designer()  #sets designer flag false
            self.setCursor(Qt.CursorShape.ArrowCursor)

            # disconnect analyzer signal
            if self.analyzer_connect_id is not None:
                self.fig.canvas.mpl_disconnect(self.analyzer_connect_id)

            #reset cupping flavor values
            self.flavors = [5.]*len(self.flavorlabels)
            self.flavors_total_correction = 0

            try:
                # reset color of last pressed button
                if self.aw.lastbuttonpressed != -1:
                    self.aw.setExtraEventButtonStyle(self.aw.lastbuttonpressed, style='normal')
                # reset lastbuttonpressed
                self.aw.lastbuttonpressed = -1
            except Exception: # pylint: disable=broad-except
                pass

            #self.aw.pidcontrol.sv = None
            self.aw.fujipid.sv = None
            self.dutycycle = -1
            self.dutycycleTX = 0.
            self.currentpidsv = 0.

            self.aw.extraMODBUStx = 0.
            self.aw.extraS7tx = 0.

            # we remove the filename to force writing a new file
            # and avoid accidental overwriting of existing data
            #current file name
            self.aw.curFile = None
            self.aw.updateWindowTitle()

            # if on turn mouse crosslines off
            if self.crossmarker:
                self.togglecrosslines()

            #remove the analysis results annotation if it exists
            self.analysisresultsstr = ''

            #autodetected CHARGE and DROP index
            self.autoChargeIdx = 0
            self.autoDropIdx = 0

            self.l_annotations = [] # initiate the event annotations
            # we initialize the annotation position dict of the foreground profile
            self.deleteAnnoPositions(foreground=True, background=False)
            self.l_event_flags_dict = {} # initiate the event id to temp/time annotation dict for flags
            self.l_background_annotations = [] # initiate the background event annotations

            self.l_timeline = None # clear timeline Artist to get the linecount correct after changning a machine setup

            if not self.flagon:
                self.aw.hideDefaultButtons()
                self.aw.updateExtraButtonsVisibility()
                self.aw.enableEditMenus()

            #reset alarms
            self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
            #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
            self.TPalarmtimeindex = None

            self.aw.pidcontrol.pidActive = False

            self.wheelflag = False
            self.designerflag = False

            #check and turn off mouse cross marker
            if self.crossmarker:
                self.togglecrosslines()

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' reset() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        # now clear all measurements and redraw

        self.clearMeasurements()
        #clear PhasesLCDs
        self.aw.updatePhasesLCDs()
        #clear AUC LCD
        self.aw.updateAUCLCD()

        # if background is loaded we move it back to its original position (after regular load):
        if self.backgroundprofile is not None:
            moved = self.backgroundprofile_moved_x != 0 or self.backgroundprofile_moved_y != 0
            if self.backgroundprofile_moved_x != 0:
                self.movebackground('left',self.backgroundprofile_moved_x)
            if self.backgroundprofile_moved_y != 0:
                self.movebackground('down',self.backgroundprofile_moved_y)
            if moved:
                self.timealign(redraw=False)

        if not (self.autotimex and self.background):
            if self.locktimex:
                self.startofx = self.locktimex_start
                self.endofx = self.locktimex_end
            elif keepProperties:
                self.startofx = self.chargemintime
                self.endofx = self.resetmaxtime
        if self.endofx < 1:
            self.endofx = 60

        self.aw.qmc.timealign(redraw=False)

        if self.aw is not None:
            self.aw.updatePlusStatus()

        ### REDRAW  ##
        if redraw:
            self.aw.autoAdjustAxis(background=not keepProperties) # if reset() triggered by ON, we ignore background on adjusting the axis and adjust according to RESET min/max
            self.redraw(True,re_smooth_foreground=False)

        try:
            gc.collect()
            _log.debug('gc_stats: %s', gc.get_stats())
        except Exception: # pylint: disable=broad-except
            pass
        # write memory stats to the log
        try:
            vm = psutil.virtual_memory()
            _log.info('memory used %s, %s (%s%%) available', bytes2human(psutil.Process().memory_full_info().uss),bytes2human(vm[1]),int(round(100-vm[2])))
        except Exception: # pylint: disable=broad-except
            pass


        #QApplication.processEvents() # this one seems to be needed for a proper redraw in fullscreen mode on OS X if a profile was loaded and NEW is pressed
        #   this processEvents() seems not to be needed any longer!?
        return True

    # https://gist.github.com/bhawkins/3535131
    @staticmethod
    def medfilt(x:'npt.NDArray[numpy.double]', k:int) -> 'npt.NDArray[numpy.double]':
        """Apply a length-k median filter to a 1D array x.
        Boundaries are extended by repeating endpoints.
        """
        assert k % 2 == 1, 'Median filter length must be odd.'
        assert x.ndim == 1, 'Input must be one-dimensional.'
        if len(x) == 0:
            return x
        k2 = (k - 1) // 2
        y = numpy.zeros ((len (x), k), dtype=x.dtype)
        y[:,k2] = x
        for i in range (k2):
            j = k2 - i
            y[j:,i] = x[:-j]
            y[:j,i] = x[0]
            y[:-j,-(i+1)] = x[j:]
            y[-j:,-(i+1)] = x[-1]
        return cast('npt.NDArray[numpy.double]', numpy.median(y, axis=1))
#        return numpy.nanmedian(y, axis=1) # produces artefacts

    # smoothes a list (or numpy.array) of values 'y' at taken at times indicated by the numbers in list 'x'
    # 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
    # 'flat' results in moving average
    # window_len should be odd
    # based on http://wiki.scipy.org/Cookbook/SignalSmooth
    # returns a smoothed numpy array or the original y argument
    def smooth(self, x:'npt.NDArray[numpy.float64]', y:'npt.NDArray[numpy.float64]', window_len:int = 15, window:str = 'hanning') -> 'npt.NDArray[numpy.float64]':
        try:
            if len(x) == len(y) and len(x) > 1:
                if window_len > 2:
                    # smooth curves
                    #s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
                    #s=numpy.r_[y[window_len-1:0:-1],y,y[-2:-window_len-1:-1]]
                    #s = y
                    s = numpy.r_[y[window_len-1:0:-1],y,y[-1:-window_len:-1]]
                    if window == 'flat': #moving average
                        w = numpy.ones(window_len,'d')
                    else:
                        w = eval('numpy.'+window+'(window_len)') # pylint: disable=eval-used
                    try:
                        ys = numpy.convolve(w/w.sum(), s, mode='valid')
                    except Exception: # pylint: disable=broad-except
                        return y
                    hwl = int(window_len/2)
                    res = ys[hwl:-hwl]
                    if len(res)+1 == len(y) and len(res) > 0:
                        try:
                            return ys[hwl-1:-hwl]
                        except Exception: # pylint: disable=broad-except
                            return y
                    elif len(res) != len(y):
                        return y
                    else:
                        return res
                else:
                    return y
            else:
                return y
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' smooth() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            return x

    # re-sample, filter and smooth slice
    # takes numpy arrays a (time) and b (temp) of the same length and returns a numpy array representing the processed b values
    # delta: True if b is a RoR signal
    # precondition: (self.filterDropOuts or window_len>2)
    def smooth_slice(self, a:'npt.NDArray[numpy.double]', b:'npt.NDArray[numpy.float64]',
        window_len:int = 7, window:str = 'hanning', decay_weights:Optional[List[int]] = None, decay_smoothing:bool = False,
        re_sample:bool = True, back_sample:bool = True, a_lin:Optional['npt.NDArray[numpy.double]'] = None,
        delta:bool=False) -> 'npt.NDArray[numpy.double]':
        # 1. re-sample
        if re_sample:
            if a_lin is None or len(a_lin) != len(a):
                a_mod = numpy.linspace(a[0],a[-1],len(a))
            else:
                a_mod = a_lin
            b = numpy.interp(a_mod, a, b) # resample data to linear spaced time
        else:
            a_mod = a
        res:npt.NDArray[numpy.float64] = b # just in case the precondition (self.filterDropOuts or window_len>2) does not hold
        # 2. filter spikes (only applied offline)
        if self.filterDropOuts and not self.flagon:
            try:
#                if self.flagon:
#                    online_medfilt = LiveMedian(median_filter_factor)
#                    b = numpy.array(list(map(online_medfilt, b)))
                b = self.medfilt(b, (self.median_filter_factor_RoR if delta else self.median_filter_factor))
# scipyernative which performs equal, but produces larger artefacts at the borders and for intermediate NaN values for k>3
#                from scipy.signal import medfilt as scipy_medfilt
#                b = scipy_medfilt(b,3)
                res = b
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                res = b
        # 3. smooth data
        if window_len>2:
            if decay_smoothing:
                # decay smoothing
                decay_weights_internal:npt.NDArray[numpy.int_]
                if decay_weights is None:
                    decay_weights_internal = numpy.arange(1,window_len+1)
                else:
                    window_len = len(decay_weights)
                    decay_weights_internal = numpy.array(decay_weights)
                # invariant: window_len = len(decay_weights_internal)
                if decay_weights_internal.sum() == 0:
                    res = b
                else:
                    result:List[float] = []
                    # ignore -1 readings in averaging and ensure a good ramp
                    for i, v in enumerate(b):
                        seq = b[max(0,i-window_len + 1):i+1]
                        w = decay_weights_internal[max(0,window_len-len(seq)):]  # preCond: len(decay_weights_internal)=window_len and len(seq) <= window_len; postCond: len(w)=len(seq)
                        if len(w) == 0:
                            # we don't average if there is are no weights (e.g. if the original seq did only contain -1 values and got empty)
                            result.append(v)
                        else:
                            result.append(numpy.average(seq,axis=0,weights=w)) # works only if len(seq) = len(w)
                    res = numpy.array(result)
                    # postCond: len(res) = len(b)
            else:
                # optimal smoothing (the default)
                win_len = max(0,window_len)
                if win_len != 1: # at the lowest level we turn smoothing completely off
                    res = self.smooth(a_mod,b,win_len,window)
                else:
                    res = b
        # 4. sample back
        if re_sample and back_sample:
            res = numpy.interp(a, a_mod, res) # re-sampled back to original timestamps
        return numpy.array(res)

    # takes lists a (time array) and b (temperature array) containing invalid segments of -1/None values and returns a list with all segments of valid values smoothed
    # a: list of timestamps
    # b: list of readings
    # re_sample: if true re-sample readings to a linear spaced time before smoothing
    # back_sample: if true results are back-sampled to original timestamps given in "a" after smoothing
    # a_lin: pre-computed linear spaced timestamps of equal length than a
    # delta: True if b is a RoR signal
    # NOTE: result can contain NaN items on places where the input array contains the error element -1
    # result is a numpy array or the b as numpy array with drop out readings -1 replaced by NaN
    def smooth_list(self, aa:Union['npt.NDArray[numpy.double]', Sequence[float]], b:Union['npt.NDArray[numpy.double]', Sequence[float]], window_len:int = 7, window:str = 'hanning',
            decay_weights:Optional[List[int]] = None, decay_smoothing:bool = False, fromIndex:int = -1, toIndex:int = 0,
            re_sample:bool = True, back_sample:bool = True, a_lin:Optional['npt.NDArray[numpy.double]'] = None, delta:bool=False) -> 'npt.NDArray[numpy.double]':
        if len(aa) > 1 and len(aa) == len(b) and (self.filterDropOuts or window_len>2):
            #pylint: disable=E1103
            # 1. truncate
            if fromIndex > -1: # if fromIndex is set, replace prefix up to fromIndex by None
                if toIndex==0: # no limit
                    toIndex=len(aa)
            else: # smooth list on full length
                fromIndex = 0
                toIndex = len(aa)
            a = numpy.array(aa[fromIndex:toIndex], dtype=numpy.double)
            # we mask the error value -1 and Numpy  in the temperature array
            mb = numpy.ma.masked_equal(numpy.ma.masked_equal(b[fromIndex:toIndex], -1), None) # type:ignore[no-untyped-call]
            # split in masked and
            unmasked_slices = [(x,False) for x in numpy.ma.clump_unmasked(mb)] # type:ignore[no-untyped-call] # the valid readings
            masked_slices = [(x,True) for x in numpy.ma.clump_masked(mb)]  # type:ignore[no-untyped-call] # the dropped values
            sorted_slices = sorted(unmasked_slices + masked_slices, key=lambda tup: tup[0].start) # pyright: ignore[reportGeneralTypeIssues]
            b_smoothed = [] # b_smoothed collects the smoothed segments in order
            b_smoothed.append(numpy.full(fromIndex, numpy.nan, dtype=numpy.double)) # append initial segment to the list of resulting segments
            # we just smooth the unmsked slices and add the unmasked slices with NaN values
            for (s, m) in sorted_slices:
                if m:
                    # a slice with all masked (invalid) readings
                    b_smoothed.append(numpy.full(s.stop - s.start, numpy.nan, dtype=numpy.double))
                else:
                    # a slice with proper data
                    b_smoothed.append(self.smooth_slice(a[s], mb[s], window_len, window, decay_weights, decay_smoothing, re_sample, back_sample, a_lin, delta))
            b_smoothed.append(numpy.full(len(a)-toIndex, numpy.nan, dtype=numpy.double)) # append the final segment to the list of resulting segments
            return numpy.concatenate(b_smoothed)
        bb = numpy.array(b, dtype=numpy.double)
        bb[bb == -1] = numpy.nan
        return bb

    # deletes saved annotation positions from l_annotations_dict
    # foreground annotations have position keys <=6, background annotation positions have keys > 6,
    def deleteAnnoPositions(self, foreground:bool = False, background:bool = False) -> None:
        if background and foreground:
            self.l_annotations_dict = {}
        else:
            for k in list(self.l_annotations_dict.keys()):
                if (background and k > 6) or (foreground and k <= 6):
                    self.l_annotations_dict.pop(k)

    def moveBackgroundAnnoPositionsX(self, step:int) -> None:
        for k in list(self.l_annotations_dict.keys()):
            if k > 6:
                for anno in self.l_annotations_dict[k]:
                    x,y = anno.get_position()
                    anno.set_position((x+step,y))

    def moveBackgroundAnnoPositionsY(self, step:int) -> None:
        for k in list(self.l_annotations_dict.keys()):
            if k > 6:
                for anno in self.l_annotations_dict[k]:
                    x,y = anno.get_position()
                    anno.set_position((x,y+step))

    # returns the position of the main event annotations as list of lists of the form
    #   [[id,temp_x,temp_y,time_x,time_y],...]
    # with id the main event id like -1 for TP, 0 for CHARGE, 1 for DRY,.., 6 for DROP (keys above 6 as used for background profile annotations are ignored)
    def getAnnoPositions(self) -> List[List[float]]:
        res:List[List[float]] = []
        for k,v in self.l_annotations_dict.items():
            if k<7:
                temp_anno = v[0].xyann
                time_anno = v[1].xyann
                if all(not numpy.isnan(e) for e in temp_anno + time_anno):
                    # we add the entry only if all of the coordinates are proper numpers and not nan
                    res.append([k,float(temp_anno[0]),float(temp_anno[1]),float(time_anno[0]),float(time_anno[1])])
        return res

    def setAnnoPositions(self, anno_positions:List[List[Union[int,float]]]) -> None:
        for ap in anno_positions:
            if len(ap) == 5:
                i:int = int(ap[0])
                temp_x = ap[1]
                temp_y = ap[2]
                time_x = ap[3]
                time_y = ap[4]
                self.l_annotations_pos_dict[i] = ((temp_x,temp_y),(time_x,time_y))

    # returns the position of the custom event flag annotations as list of lists of the form
    #   [[id,x,y],...]
    # with id the event id
    def getFlagPositions(self) -> List[List[float]]:
        res = []
        for k,v in self.l_event_flags_dict.items():
            flag_anno = v.xyann
            if all(not numpy.isnan(e) for e in flag_anno):
                res.append([k,float(flag_anno[0]),float(flag_anno[1])])
        return res

    def setFlagPositions(self, flag_positions:List[List[float]]) -> None:
        for fp in flag_positions:
            if len(fp) == 3:
                i = int(fp[0])
                x = fp[1]
                y = fp[2]
                self.l_event_flags_pos_dict[i] = (x,y)

    # temp and time are the two annotation
    # x,y is the position of the annotation line start
    # e is the x-axis offset, yup/ydown are the y-axis offsets of the annotations line ends and the annotation text
    # a is the alpha value
    def annotate(self, temp:float, time_str:str, x:float, y:float, yup:int, ydown:int, e:int = 0, a:float = 1.,
            draggable:bool = True, draggable_anno_key:Optional[int] = None) -> Optional[List['Annotation']]:
        if self.ax is None:
            return None
        fontprop_small = self.aw.mpl_fontproperties.copy()
        fontsize = 'x-small'
        fontprop_small.set_size(fontsize)
        path_effects = self.line_path_effects(False, self.patheffects, self.aw.light_background_p, self.patheffects) # don't glow annotations!
        #annotate temp
        fmtstr = '%.1f' if self.LCDdecimalplaces else '%.0f'
        xytext: Optional[Tuple[float, float]]
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file, those are removed after first rendering
            xytext = self.l_annotations_pos_dict[draggable_anno_key][0]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            # next we check the "live" dictionary
            xytext = self.l_annotations_dict[draggable_anno_key][0].xyann
        else:
            xytext = (x+e,y + yup)
        temp_str = ('' if temp == -1 else fmtstr%(temp))
        temp_anno = self.ax.annotate(temp_str, xy=(x,y),
                            xytext=xytext,
                            color=self.palette['text'],
                            arrowprops={'arrowstyle':'-','color':self.palette['text'],'alpha':a},
                            fontsize=fontsize,
                            alpha=a,
                            fontproperties=fontprop_small,
                            path_effects=path_effects)
        try:
            temp_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            if draggable:
                temp_anno.draggable(use_blit=True)
                temp_anno.set_picker(self.aw.draggable_text_box_picker)
        except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
            pass
        #annotate time
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file
            xytext = self.l_annotations_pos_dict[draggable_anno_key][1]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            xytext = self.l_annotations_dict[draggable_anno_key][1].xyann
        else:
            xytext = (x+e,y - ydown)
        time_anno = self.ax.annotate(time_str,
                        xy=(x,y),
                        xytext=xytext,
                        color=self.palette['text'],
                        arrowprops={'arrowstyle':'-','color':self.palette['text'],'alpha':a},
                        fontsize=fontsize,alpha=a,
                        fontproperties=fontprop_small,
                        path_effects=path_effects)
        try:
            time_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            if draggable:
                time_anno.draggable(use_blit=True)
                time_anno.set_picker(self.aw.draggable_text_box_picker)
        except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
            pass
        if draggable and draggable_anno_key is not None:
            self.l_annotations_dict[draggable_anno_key] = [temp_anno, time_anno]
        return [temp_anno, time_anno]

    def place_annotations(self, TP_index:Optional[int], d:float, timex:List[float], timeindex:List[int], temp:List[float], stemp:Union[List[float],'npt.NDArray[numpy.double]'],
            startB:Optional[float] = None, timeindex2:Optional[List[int]] = None, TP_time_loaded:Optional[float] = None,
            draggable:bool = True) -> List['Annotation']:
        ystep_down = ystep_up = 0
        anno_artists:List[Annotation] = []
        if self.ax is None:
            return anno_artists
        #Add markers for CHARGE
        # add offset to annotation keys for background annotations to prevent them from being confused with those of the foreground profile and to prevent persisting them to alog files
        anno_key_offset = 0 if startB is None else 10
        try:
            if len(timex) > 0:
                if timeindex[0] != -1 and len(timex) > timeindex[0]:
                    t0idx = timeindex[0] # time idx at CHARGE
                    t0 = timex[t0idx]    # time at CHARGE in sec.
                else:
                    t0idx = 0
                    t0 = 0
                if timeindex[0] != -1:
                    y = stemp[t0idx]
                    if is_proper_temp(y):
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                        if startB is not None:
                            st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                            st1 = self.__dijkstra_to_ascii(st1)
                            e = 0
                            a = self.backgroundalpha
                        else:
                            st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                            st1 = self.__dijkstra_to_ascii(st1)
                            e = 0
                            a = 1.
                        time_temp_annos = self.annotate(temp[t0idx],st1,t0,y,ystep_up,ystep_down,e,a,draggable,0+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos

                #Add TP marker
                if self.markTPflag:
                    if TP_index is not None and TP_index > 0:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}'), stringfromseconds(timex[TP_index]-t0,False))
                        a = 1.
                        e = 0
                        time_temp_annos = self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                    elif TP_time_loaded is not None:
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        shift = timex[timeindex[0]]
                        TP_index = self.backgroundtime2index(TP_time_loaded + shift)
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}'),stringfromseconds(TP_time_loaded,False))
                        time_temp_annos = self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                #Add Dry End markers
                if timeindex[1]:
                    tidx = timeindex[1]
                    y0 = stemp[t0idx]
                    y = stemp[tidx]
                    if is_proper_temp(y):
                        if timeindex[0] != -1 and is_proper_temp(y0):
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y0,y,d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}'),stringfromseconds(timex[tidx]-t0,False))
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],y,ystep_up,ystep_down,e,a,draggable,1+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos

                #Add 1Cs markers
                if timeindex[2]:
                    tidx = timeindex[2]
                    if is_proper_temp(stemp[tidx]):
                        if timeindex[1] and is_proper_temp(stemp[timeindex[1]]): #if dryend
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[1]],stemp[tidx],d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}'),stringfromseconds(timex[tidx]-t0,False))
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,2+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                #Add 1Ce markers
                if timeindex[3]:
                    tidx = timeindex[3]
                    if is_proper_temp(stemp[tidx]):
                        if timeindex[2] and is_proper_temp(stemp[timeindex[2]]):
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[2]],stemp[tidx],d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tidx],stemp[tidx],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}'),stringfromseconds(timex[tidx]-t0,False))
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,3+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                        #add a water mark if FCs
                        if timeindex[2] and not timeindex2 and self.watermarksflag:
                            self.ax.axvspan(
                                    timex[timeindex[2]],
                                    timex[tidx],
                                    facecolor=self.palette['watermarks'],
                                    alpha=0.2,
                                    path_effects=[])
                #Add 2Cs markers
                if timeindex[4]:
                    tidx = timeindex[4]
                    if is_proper_temp(stemp[tidx]):
                        if timeindex[3] and is_proper_temp(stemp[timeindex[3]]):
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[3]],stemp[tidx],d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}'),stringfromseconds(timex[tidx]-t0,False))
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,4+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                #Add 2Ce markers
                if timeindex[5]:
                    tidx = timeindex[5]
                    if is_proper_temp(stemp[tidx]):
                        if timeindex[4] and is_proper_temp(stemp[timeindex[4]]):
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[4]],stemp[tidx],d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tidx],stemp[tidx],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}'),stringfromseconds(timex[tidx]-t0,False))
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0
                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,5+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                        #do water mark if SCs
                        if timeindex[4] and not timeindex2 and self.watermarksflag:
                            self.ax.axvspan(
                                timex[timeindex[4]],
                                timex[tidx],
                                facecolor=self.palette['watermarks'],
                                alpha=0.2,
                                path_effects=[])
                #Add DROP markers
                if timeindex[6]:
                    tidx = timeindex[6]
                    if is_proper_temp(stemp[tidx]):
                        if timeindex[5]:
                            tx = timeindex[5]
                        elif timeindex[4]:
                            tx = timeindex[4]
                        elif timeindex[3]:
                            tx = timeindex[3]
                        elif timeindex[2]:
                            tx = timeindex[2]
                        elif timeindex[1]:
                            tx = timeindex[1]
                        else:
                            tx = t0idx
                        if is_proper_temp(stemp[tx]):
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tx],stemp[tidx],d)
                        else:
                            ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tidx],stemp[tidx],d)
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}'),stringfromseconds(timex[tidx]-t0,False))
                        if self.graphfont == 1:
                            st1 = self.__to_ascii(st1)
                        a = self.backgroundalpha if timeindex2 else 1.0
                        e = 0

                        time_temp_annos = self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,6+anno_key_offset)
                        if time_temp_annos is not None:
                            anno_artists += time_temp_annos
                    if len(anno_artists) == 0: # HACK: if add a fake anno if None was added up to here to avoid this fc axvspan to render in darker yellow
                        fake_anno = self.annotate(-1, '', 0,0,0,0)
                        if fake_anno is not None:
                            anno_artists += fake_anno
                    #do water mark if FCs, but no FCe nor SCs nor SCe
                    if timeindex[2] and not timeindex[3] and not timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        fc_artist = self.ax.axvspan(
                            timex[timeindex[2]],
                            timex[tidx],
                            facecolor=self.palette['watermarks'],
                            alpha=0.2,
                            path_effects=[])
                        try:
                            fc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                    #do water mark if SCs, but no SCe
                    if timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        sc_artist = self.ax.axvspan(
                            timex[timeindex[4]],
                            timex[tidx],
                            facecolor=self.palette['watermarks'],
                            alpha=0.2,
                            path_effects=[])
                        try:
                            sc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass

                if len(anno_artists) == 0: # HACK: if add a fake anno if None was added up to here to avoid this fc axvspan to render in darker yellow
                    fake_anno = self.annotate(-1, '', 0,0,0,0)
                    if fake_anno is not None:
                        anno_artists += fake_anno

                # add COOL mark
                if timeindex[7] and not timeindex2:
                    tidx = timeindex[7]
                    # as the right most data value of the axis in self.ax.get_xlim()[1] is only correctly set after the initial draw,
                    # we simply set it to twice as wide and trust that the clipping will cut of the part not within the axis system
                    endidx = 2*max(self.timex[-1],self.endofx,self.ax.get_xlim()[0],self.ax.get_xlim()[1])
                    if timex[tidx] < endidx and self.watermarksflag:
                        cool_mark = self.ax.axvspan(
                            timex[tidx],endidx,
                            facecolor=self.palette['rect4'],
                            ec='none',
                            alpha=0.3,
                            clip_on=True,
                            lw=None,
                            path_effects=[])
                        try:
                            cool_mark.set_in_layout(False) # remove title from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' place_annotations() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return anno_artists

    def apply_symbolic_delta_formula(self, fct:str, deltas:List[float], timex:'npt.NDArray[numpy.double]', RTsname:Optional[str]) -> List[float]:
        try:
            if len(deltas) == len(timex):
                return [self.eval_math_expression(fct, timex[i], RTsname=RTsname, RTsval=d) for i,d in enumerate(deltas)]
            return deltas
        except Exception: # pylint: disable=broad-except
            return deltas

    # computes the RoR over the time and temperature arrays tx and temp via polynoms of degree 1 at index i using a window of wsize
    # the window size wsize needs to be at least 1 (two succeeding readings)
    @staticmethod
    def polyRoR(tx:'npt.NDArray[numpy.double]', temp:'npt.NDArray[numpy.double]', wsize:int, i:int) -> float:
        if i == 0: # we duplicate the first possible RoR value instead of returning a 0
            i = 1
        if 0 < i < min(len(tx), len(temp)):
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                left_index = max(0,i-wsize)
                LS_fit = numpy.polynomial.polynomial.polyfit(tx[left_index:i+1],temp[left_index:i+1], 1)
                return float(LS_fit[1]*60.)
        else:
            return 0

    @staticmethod
    # with window size wsize=1 the RoR is computed over succeeding readings; tx and temp assumed to be of type numpy.array
    def arrayRoR(tx:'npt.NDArray[numpy.double]', temp:'npt.NDArray[numpy.double]', wsize:int) -> 'npt.NDArray[numpy.double]': # with wsize >=1
        # length compensation done downstream, not necessary here!
        return cast('npt.NDArray[numpy.double]', (temp[wsize:] - temp[:-wsize]) / ((tx[wsize:] - tx[:-wsize])/60.))


    # returns deltas and linearized timex;  both results can be None
    # timex: the time array
    # temp: the temperature array
    # ds: the number of delta samples
    # timex_lin: the linearized time array or None
    # delta_symbolic_function: the symbolic function to be applied to the delta or None
    # RTsname: the symbolic variable name of the delta
    # deltaFilter: the deltaFilter setting
    # roast_start_idx: the index of CHARGE
    # roast_end_idx: the index of DROP
    def computeDeltas(self, timex:'npt.NDArray[numpy.double]', temp:Optional[Union[List[float], 'npt.NDArray[numpy.double]']],
            ds:int, optimalSmoothing:bool,
            timex_lin:Optional['npt.NDArray[numpy.double]'], delta_symbolic_function:str,
            RTsname:str, deltaFilter:int,
            roast_start_idx:int, roast_end_idx:int) -> Tuple[Optional[List[Optional[float]]], Optional['npt.NDArray[numpy.double]']]:
        if temp is not None:
            with numpy.errstate(divide='ignore'):
                lt = len(timex)
                ntemp = numpy.array([0 if x is None else x for x in temp])

                if optimalSmoothing and self.polyfitRoRcalc:
                    # optimal RoR computation using polynoms with out timeshift
                    dss = ds + 1 if ds % 2 == 0 else ds
                    z1:npt.NDArray[numpy.double]
                    if len(ntemp) > dss:
                        try:
                            # ntemp is not linearized yet:
                            lin: npt.NDArray[numpy.double]
                            if timex_lin is None or len(timex_lin) != len(ntemp):
                                lin = numpy.linspace(timex[0],timex[-1],lt)
                            else:
                                lin = timex_lin
                            ntemp_lin = numpy.interp(lin, timex, ntemp) # resample data in ntemp to linear spaced time
                            dist = (lin[-1] - lin[0]) / (len(lin) - 1)
                            from scipy.signal import savgol_filter # type: ignore # @Reimport
                            z1 = savgol_filter(ntemp_lin, dss, 1, deriv=1, delta=dss)
                            z1 = z1 * (60./dist) * dss
                        except Exception: # pylint: disable=broad-except
                            # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                            # https://github.com/numpy/numpy/issues/16744
                            # original version just picking the corner values:
                            z1 = self.arrayRoR(timex,ntemp,ds)
                    else:
                        # in this case we use the standard algo
                        try:
                            # variant using incremental polyfit RoR computation
                            z1 = numpy.array([self.polyRoR(timex,ntemp,ds,i) for i in range(len(ntemp))])
                        except Exception: # pylint: disable=broad-except
                            # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                            # https://github.com/numpy/numpy/issues/16744
                            # original version just picking the corner values:
                            z1 = self.arrayRoR(timex,ntemp,ds)
                elif self.polyfitRoRcalc:
                    try:
                        # variant using incremental polyfit RoR computation
                        z1 = numpy.array([self.polyRoR(timex,ntemp,ds,i) for i in range(len(ntemp))]) # windows size ds needs to be at least 2
                    except Exception: # pylint: disable=broad-except
                        # a numpy/OpenBLAS polyfit bug can cause polyfit to throw an exception "SVD did not converge in Linear Least Squares" on Windows Windows 10 update 2004
                        # https://github.com/numpy/numpy/issues/16744
                        # original version just picking the corner values:
                        z1 = self.arrayRoR(timex,ntemp,ds)
                else:
                    z1 = self.arrayRoR(timex,ntemp,ds)

            ld1 = len(z1)
            # make lists equal in length
            if lt > ld1:
                z1 = numpy.append([z1[0] if ld1 else 0.]*(lt - ld1),z1)
            # apply smybolic formula
            if delta_symbolic_function:
                z1 = numpy.array(self.apply_symbolic_delta_formula(delta_symbolic_function, z1.tolist(), timex, RTsname=RTsname))
            # apply smoothing
            if optimalSmoothing:
                user_filter = deltaFilter
            else:
                user_filter = int(round(deltaFilter/2.))
            delta1 = self.smooth_list(timex,z1,window_len=user_filter,decay_smoothing=(not optimalSmoothing),a_lin=timex_lin,delta=True)

            # cut out the part after DROP and before CHARGE and remove values beyond the RoRlimit
            return [
                d if ((roast_start_idx <= i <= roast_end_idx) and (d is not None and (not self.RoRlimitFlag or
                    max(-self.maxRoRlimit,self.RoRlimitm) < d < min(self.maxRoRlimit,self.RoRlimit))))
                else None
                for i,d in enumerate(delta1)
            ], timex_lin
        return None, timex_lin

    # computes the RoR deltas and returns the smoothed versions for both temperature channels
    # if t1 or t2 is not given (None), its RoR signal is not computed and None is returned instead
    # timex_lin: a linear spaced version of timex
    def recomputeDeltas(self, timex:Union[List[float], 'npt.NDArray[numpy.double]'], CHARGEidx:int, DROPidx:int,
            t1:Optional[Union[List[float], 'npt.NDArray[numpy.double]']], t2:Optional[Union[List[float], 'npt.NDArray[numpy.double]']],
            optimalSmoothing:bool = True, timex_lin:Optional['npt.NDArray[numpy.double]'] = None,
            deltaETsamples:Optional[int] = None,
            deltaBTsamples:Optional[int] = None) -> Tuple[Optional[List[Optional[float]]], Optional[List[Optional[float]]]]:
        try:
            tx_roast = numpy.array(timex) # timex non-linearized as numpy array
            lt = len(tx_roast)
            roast_start_idx = CHARGEidx if CHARGEidx > -1 else 0
            roast_end_idx = DROPidx if DROPidx > 0 else lt
            if deltaBTsamples is None:
                dsBT = max(1, self.deltaBTsamples) # now as in sample_processing()
            else:
                dsBT = deltaBTsamples
            if deltaETsamples is None:
                dsET = max(1, self.deltaETsamples) # now as in sample_processing()
            else:
                dsET = deltaETsamples
            if timex_lin is not None:
                if len(timex_lin) == len(timex):
                    timex_lin = numpy.array(timex_lin)
                else:
                    timex_lin = None
            delta1, timex_lin = self.computeDeltas(
                    tx_roast,
                    t1,
                    dsET,
                    optimalSmoothing,
                    timex_lin,
                    self.DeltaETfunction,
                    'R1',
                    self.deltaETfilter,
                    roast_start_idx,
                    roast_end_idx)
            delta2, _ = self.computeDeltas(
                    tx_roast,
                    t2,
                    dsBT,
                    optimalSmoothing,
                    timex_lin,
                    self.DeltaBTfunction,
                    'R2',
                    self.deltaBTfilter,
                    roast_start_idx,
                    roast_end_idx)

            return delta1, delta2
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' recomputeDeltas() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return None, None

    @staticmethod
    def bisection(array:List[float], value:float) -> int:
        """Given an ``array`` , and given a ``value`` , returns an index j such that ``value`` is between array[j]
        and array[j+1]. ``array`` must be monotonic increasing. j=-1 or j=len(array) is returned
        to indicate that ``value`` is out of range below and above respectively."""
        #Algorithm presumes 'array' is monotonic increasing.  This is not guaranteed for profiles so there
        #may be results that are not strictly correct.
        n = len(array)
        if value < array[0]:
            return -1
        if value > array[n-1]:
            return n
        if value == array[0]: # edge cases at bottom
            return 0
        if value == array[n-1]: # and top
            return n-1
        jl = 0   # Initialize lower
        ju = n-1 # and upper limits.
        while ju-jl > 1:# If we are not yet done,
            jm=(ju+jl) >> 1 # compute a midpoint with a bitshift
            if value >= array[jm]:
                jl=jm # and replace either the lower limit
            else:
                ju=jm # or the upper limit, as appropriate.
            # Repeat until the test condition is satisfied.
        if abs(value - array[jl]) > abs(array[ju] - value):
            return ju
        return jl

    def drawAUC(self) -> None:
        if self.ax is None:
            return
        try:
            TP_Index = self.aw.findTP()
            if self.AUCbaseFlag:
                _,_,_,idx = self.aw.ts()
                # ML: next line seems not to alter the idx in any way and is just not needed
#                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],self.stemp2[idx])
            else:
                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],self.AUCbase)
            rtbt = self.stemp2[idx]

            ix = self.timex[idx:self.timeindex[6]+1]
            iy = self.stemp2[idx:self.timeindex[6]+1]

            # Create the shaded region
            if len(ix)>1:
                a = ix[0]
                b = ix[-1]
                verts = [ xy for xy in [(a, rtbt)] + list(zip(ix, iy)) + [(b, rtbt)] if xy[1] > 0 ]
                if verts:
                    poly = Polygon(numpy.array(verts), facecolor=self.palette['aucarea'], edgecolor='0.5', alpha=0.3)
                    self.ax.add_patch(poly)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def set_xlabel(self, xlabel:str) -> None:
        fontprop_medium = self.aw.mpl_fontproperties.copy()
        fontprop_medium.set_size('medium')
        self.xlabel_text = xlabel
        if self.ax is not None:
            self.xlabel_artist = self.ax.set_xlabel(xlabel,color = self.palette['xlabel'],
                fontsize='medium',
                fontfamily=fontprop_medium.get_family())
        if self.xlabel_artist is not None:
            try:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.xlabel_width = self.xlabel_artist.get_window_extent(renderer=self.fig.canvas.get_renderer()).width # type: ignore
            except Exception: # pylint: disable=broad-except
                pass
            try:
                self.xlabel_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass

    def setProfileBackgroundTitle(self, backgroundtitle:str) -> None:
        suptitleX:float = 1
        try:
            if self.ax is not None:
                ax_width = self.ax.get_window_extent(renderer=self.fig.canvas.get_renderer()).width # type: ignore # total width of axis in display coordinates
                ax_begin = self.ax.transAxes.transform((0,0))[0] # left of axis in display coordinates
                suptitleX = float(self.fig.transFigure.inverted().transform((ax_width + ax_begin,0))[0])
        except Exception: # pylint: disable=broad-except
            pass

        self.background_title_width = 0
        backgroundtitle = backgroundtitle.strip()
        if backgroundtitle != '':
            backgroundtitle = self.__dijkstra_to_ascii(backgroundtitle)
            backgroundtitle = f'\n{abbrevString(backgroundtitle, 32)}'

        self.l_subtitle = self.fig.suptitle(backgroundtitle,
                horizontalalignment='right',verticalalignment='top',
                fontsize='x-small',
                x=suptitleX,y=1,
                color=(self.palette['title_hidden'] if not self.background else (self.palette['title_focus'] if (self.backgroundprofile is not None and self.backgroundPlaybackEvents) else self.palette['title'])))
        try:
            self.l_subtitle.set_in_layout(False)  # remove title from tight_layout calculation
        except Exception: # pylint: disable=broad-except  # set_in_layout not available in mpl<3.x
            pass
        try:
            if len(backgroundtitle)>0:
                self.background_title_width = self.l_subtitle.get_window_extent(renderer=self.fig.canvas.get_renderer()).width # type: ignore
            else:
                self.background_title_width = 0
        except Exception: # pylint: disable=broad-except
            self.background_title_width = 0

    # if updatebackground is True, the profileDataSemaphore is caught and updatebackground() is called
    @pyqtSlot(str, bool)
    def setProfileTitle(self,title:str,updatebackground:bool = False) -> None:
        if ((self.flagon and not self.aw.curFile) or self.flagstart):
            bprefix = self.batchprefix
            bnr = self.batchcounter + 1
        else:
            bprefix = self.roastbatchprefix
            bnr = self.roastbatchnr
        if bnr != 0 and title != '':
            title = f'{bprefix}{str(bnr)} {title}'
        elif bnr == 0 and title != '' and title != self.title != QApplication.translate('Scope Title', 'Roaster Scope') and bprefix != '':
            title = f'{bprefix} {title}'

        title = self.__dijkstra_to_ascii(title)

        self.title_text = self.aw.arabicReshape(title.strip())
        if self.ax is not None and self.title_text is not None:
            self.title_artist = self.ax.set_title(self.title_text, color=self.palette['title'], loc='left',
                        fontsize='xx-large',
                        horizontalalignment='left',verticalalignment='top',x=0)
        if self.title_artist is not None:
            try: # this one seems not to work for titles, subtitles and axis!?
                self.title_artist.set_in_layout(False) # remove title from tight_layout calculation
            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass
            try:
                self.title_width = self.title_artist.get_window_extent(renderer=self.fig.canvas.get_renderer()).width # type: ignore
            except Exception: # pylint: disable=broad-except
                pass

        if updatebackground:
            #### lock shared resources #####
            self.profileDataSemaphore.acquire(1)
            try:
                self.updateBackground()
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)

    # resize the given list to the length ln by cutting away elements or padding with trailing -1 items
    # used to resize temperature data to the length of the corresponding timex times
    @staticmethod
    def resizeList(lst:Optional[List[Any]], ln:int) -> Optional[List[Any]]:
        if lst is None:
            return None
        return (lst + [-1]*(ln-len(lst)))[:ln]
    @staticmethod
    def resizeListStrict(lst:List[Any], ln:int) -> List[Any]:
        return (lst + [-1]*(ln-len(lst)))[:ln]

    @functools.lru_cache(maxsize=50) # noqa: B019 # pylint: disable=W1518 #for Python >= 3.9 can use @functools.cache; Not relevant here, as qmc is only created once: [B019] Use of `functools.lru_cache` or `functools.cache` on methods can lead to memory leaks
    def line_path_effects(self, glow:int, patheffects:int, light_background:bool, linewidth:float, color:Optional[str]=None, alpha:Optional[float]=None) -> List[PathEffects.AbstractPathEffect]:
        path_effects:List[PathEffects.AbstractPathEffect] = []
        foreground:str = self.palette['background']
        if patheffects:
            if alpha is not None:
                hex_alpha:str = f'{int(alpha*255):02x}'
                if len(foreground) == 9:
                    foreground = foreground[:7] + hex_alpha
                elif len(foreground) == 7:
                    foreground = foreground + hex_alpha
            elif color is not None and len(color) == 9 and color[0] == '#':
                if len(foreground) == 9:
                    foreground = foreground[:7] + color[7:9]
                elif len(foreground) == 7:
                    foreground = foreground + color[7:9]
            path_effects.append(PathEffects.Stroke(linewidth=linewidth+self.patheffects,foreground=foreground))
        if glow:
            glow_alpha = (0.03 if light_background else 0.13)
            path_effects.extend(
                [
                    PathEffects.Stroke(linewidth=linewidth+6,alpha=glow_alpha/1.5),
                    PathEffects.Stroke(linewidth=linewidth+3,alpha=glow_alpha),
                    PathEffects.Stroke(linewidth=linewidth+2,alpha=glow_alpha),
                    PathEffects.Stroke(linewidth=linewidth+1,alpha=glow_alpha)
                ])
        path_effects.append(PathEffects.Normal())
        return path_effects

    def drawET(self, temp:'npt.NDArray[numpy.double]') -> None:
        if self.ETcurve and self.ax is not None:
            try:
                if self.l_temp1 is not None:
                    self.l_temp1.remove()
            except Exception: # pylint: disable=broad-except
                pass
            # don't draw -1:
            temp = numpy.ma.masked_where(temp == -1, temp) # type:ignore[no-untyped-call]
            self.l_temp1, = self.ax.plot(
                self.timex,
                temp,
                markersize=self.ETmarkersize,
                marker=self.ETmarker,
                sketch_params=None,
                path_effects = self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.ETlinewidth, self.palette['et']),
                linewidth=self.ETlinewidth,
                linestyle=self.ETlinestyle,
                drawstyle=self.ETdrawstyle,
                color=self.palette['et'],
                label=self.aw.arabicReshape(QApplication.translate('Label', 'ET')))

    def drawBT(self, temp:'npt.NDArray[numpy.double]') -> None:
        if self.BTcurve and self.ax is not None:
            try:
                if self.l_temp2 is not None:
                    self.l_temp2.remove()
            except Exception: # pylint: disable=broad-except
                pass
            # don't draw -1:
            temp = numpy.ma.masked_where(temp == -1, temp) # type:ignore[no-untyped-call]
            self.l_temp2, = self.ax.plot(
                self.timex,
                temp,
                markersize=self.BTmarkersize,
                marker=self.BTmarker,
                sketch_params=None,
                path_effects = self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.BTlinewidth, self.palette['bt']),
                linewidth = self.BTlinewidth,
                linestyle = self.BTlinestyle,
                drawstyle = self.BTdrawstyle,
                color = self.palette['bt'],
                label = self.aw.arabicReshape(QApplication.translate('Label', 'BT')))

    def drawDeltaET(self, trans:Transform, start:int, end:int) -> None:
        if self.DeltaETflag and self.ax is not None:
            try:
                if self.l_delta1 is not None:
                    self.l_delta1.remove()
            except Exception: # pylint: disable=broad-except
                pass
            timex:npt.NDArray[numpy.double]
            delta1:npt.NDArray[numpy.double]
            if start < end < len(self.timex):
                timex = numpy.array(self.timex[start:end])
                delta1 = numpy.array(self.delta1[start:end])
            else:
                timex = numpy.array([])
                delta1 = numpy.array([])
            self.l_delta1, = self.ax.plot(
                    timex,
                    delta1,
                    transform=trans,
                    markersize=self.ETdeltamarkersize,
                    marker=self.ETdeltamarker,
                    sketch_params=None,
                    path_effects = self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.ETdeltalinewidth, self.palette['deltaet']),
                    linewidth=self.ETdeltalinewidth,
                    linestyle=self.ETdeltalinestyle,
                    drawstyle=self.ETdeltadrawstyle,
                    color=self.palette['deltaet'],
                    label=self.aw.arabicReshape(f"{deltaLabelUTF8}{QApplication.translate('Label', 'ET')}"))

    def drawDeltaBT(self, trans:Transform, start:int, end:int) -> None:
        if self.DeltaBTflag and self.ax is not None:
            try:
                if self.l_delta2 is not None:
                    self.l_delta2.remove()
            except Exception: # pylint: disable=broad-except
                pass
            if start < end < len(self.timex):
                timex = numpy.array(self.timex[start:end])
                delta2 = numpy.array(self.delta2[start:end])
            else:
                timex = numpy.array([])
                delta2 = numpy.array([])
            self.l_delta2, = self.ax.plot(
                    timex,
                    delta2,
                    transform=trans,
                    markersize=self.BTdeltamarkersize,
                    marker=self.BTdeltamarker,
                    sketch_params=None,
                    path_effects = self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.BTdeltalinewidth, self.palette['deltabt']),
                    linewidth=self.BTdeltalinewidth,
                    linestyle=self.BTdeltalinestyle,
                    drawstyle=self.BTdeltadrawstyle,
                    color=self.palette['deltabt'],
                    label=self.aw.arabicReshape(f"{deltaLabelUTF8}{QApplication.translate('Label', 'BT')}"))

    # if profileDataSemaphore lock cannot be fetched the redraw is not performed
    def lazyredraw(self, recomputeAllDeltas:bool = True, smooth:bool = True) -> None:
        gotlock = self.profileDataSemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this redraw round (prevents stacking of waiting calls)
        if gotlock:
            try:
                self.redraw(recomputeAllDeltas,smooth,takelock=False)
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
        else:
            _log.info('lazyredraw(): failed to get profileDataSemaphore lock')

    def smoothETBT(self, smooth:bool, recomputeAllDeltas:bool, decay_smoothing_p:bool) -> None:
        try:
            # we resample the temperatures to regular interval timestamps
            timex_lin = None

            if smooth or len(self.stemp1) != len(self.timex):
                temp1_nogaps = self.resizeListStrict(self.temp1,len(self.timex))
                if self.interpolateDropsflag:
                    temp1_nogaps = fill_gaps(temp1_nogaps)
                if self.flagon: # we don't smooth, but remove the dropouts
                    self.stemp1 = temp1_nogaps
                else:
                    if timex_lin is None and self.timex is not None and self.timex and len(self.timex)>1:
                        timex_lin = numpy.linspace(self.timex[0],self.timex[-1],len(self.timex))
                    self.stemp1 = list(self.smooth_list(self.timex,temp1_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin,delta=False))
            if smooth or len(self.stemp2) != len(self.timex):
                temp2_nogaps = self.resizeListStrict(self.temp2,len(self.timex))
                if self.interpolateDropsflag:
                    temp2_nogaps = fill_gaps(temp2_nogaps)
                if self.flagon:  # we don't smooth, but remove the dropouts
                    self.stemp2 = temp2_nogaps
                else:
                    if timex_lin is None and self.timex is not None and self.timex and len(self.timex)>1:
                        timex_lin = numpy.linspace(self.timex[0],self.timex[-1],len(self.timex))
                    self.stemp2 = list(self.smooth_list(self.timex,temp2_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin,delta=False))

            #populate delta ET (self.delta1) and delta BT (self.delta2)
            # calculated here to be available for parsepecialeventannotations(). the curve are plotted later.
            if not self.flagstart and (recomputeAllDeltas or (self.DeltaETflag and self.delta1 == []) or (self.DeltaBTflag and self.delta2 == [])): # during recording we don't recompute the deltas
                t1 = self.stemp1
                t2 = self.stemp2
                # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                if self.timeindex[0]>-1:
                    RoR_start = min(self.timeindex[0]+10, len(self.timex)-1)
                else:
                    RoR_start = -1
                d1, d2 = self.recomputeDeltas(self.timex,RoR_start,self.timeindex[6],t1,t2,optimalSmoothing=not decay_smoothing_p,timex_lin=timex_lin)
                if d1 is not None and d2 is not None:
                    self.delta1 = d1
                    self.delta2 = d2
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' smoothETBT() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def smoothETBTBkgnd(self, recomputeAllDeltas:bool, decay_smoothing_p:bool) -> None:
        try:
            if recomputeAllDeltas or (self.DeltaETBflag and self.delta1B == []) or (self.DeltaBTBflag and self.delta2B == []):

                timeB_lin = None

                # we populate temporary smoothed ET/BT data arrays
                if self.flagon or len(self.stemp1B) != len(self.timex):
                    if timeB_lin is None and self.timeB is not None and self.timeB:
                        timeB_lin = numpy.linspace(self.timeB[0],self.timeB[-1],len(self.timeB))
                    st1 = self.smooth_list(self.timeB,
                        (fill_gaps(self.temp1B) if self.interpolateDropsflag else self.temp1B),
                        window_len=self.curvefilter,
                        decay_smoothing=decay_smoothing_p,
                        a_lin=timeB_lin,
                        delta=False)
                else:
                    st1 = self.stemp1B
                if self.flagon or len(self.stemp2B) != len(self.timex):
                    if timeB_lin is None and self.timeB is not None and self.timeB:
                        timeB_lin = numpy.linspace(self.timeB[0],self.timeB[-1],len(self.timeB))
                    st2 = self.smooth_list(self.timeB,
                        (fill_gaps(self.temp2B) if self.interpolateDropsflag else self.temp2B),
                        window_len=self.curvefilter,
                        decay_smoothing=decay_smoothing_p,
                        a_lin=timeB_lin,
                        delta=False)
                else:
                    st2 = self.stemp2B

                # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                if self.timeindexB[0]>-1:
                    RoRstart = min(self.timeindexB[0]+10, len(self.timeB)-1)
                else:
                    RoRstart = -1
                if self.background_profile_sampling_interval is None:
                    dsET = None
                else:
                    dsET = max(1,int(round(self.deltaETspan / self.background_profile_sampling_interval)))
                if self.background_profile_sampling_interval is None:
                    dsBT = None
                else:
                    dsBT = max(1,int(round(self.deltaBTspan / self.background_profile_sampling_interval)))
                d1B, d2B = self.recomputeDeltas(self.timeB,RoRstart,self.timeindexB[6],st1,st2,optimalSmoothing=not decay_smoothing_p,timex_lin=timeB_lin,deltaETsamples=dsET,deltaBTsamples=dsBT)
                if d1B is not None and d2B is not None:
                    self.delta1B = d1B
                    self.delta2B = d2B
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' smmothETBTBkgnd() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def twoAxisMode(self) -> bool:
        return (self.DeltaETflag or self.DeltaBTflag or
                    (self.background and self.backgroundprofile is not None and (self.DeltaETBflag or self.DeltaBTBflag) or
                    any(self.aw.extraDelta1[:len(self.extratimex)]) or
                    any(self.aw.extraDelta2[:len(self.extratimex)])))

    @pyqtSlot(bool,bool,bool,bool,bool)
    def redraw_keep_view(self, *args:bool, **kwargs:bool) -> None:
        xlimit_min: Optional[float] = None
        xlimit: Optional[float] = None
        ylimit_min: Optional[float] = None
        ylimit: Optional[float] = None
        zlimit_min: Optional[float] = None
        zlimit: Optional[float] = None
        # save current view axes min max
        if self.ax is not None:
            xlimit_min, xlimit = self.ax.get_xlim()
            ylimit_min, ylimit = self.ax.get_ylim()
        if self.delta_ax is not None:
            zlimit_min, zlimit = self.delta_ax.get_ylim()
        # redraw
        self.redraw(*args, **kwargs)
        if self.ax is not None and xlimit_min is not None and xlimit is not None and ylimit_min is not None and ylimit is not None:
            # restore the view
            self.ax.set_xlim(xlimit_min, xlimit)
            self.ax.set_ylim(ylimit_min, ylimit)
        if self.delta_ax is not None and xlimit_min is not None and xlimit is not None and zlimit_min is not None and zlimit is not None:
            self.delta_ax.set_xlim(xlimit_min, xlimit)
            self.delta_ax.set_ylim(zlimit_min, zlimit)

    def default_xlabel_text(self) -> str:
        if self.flagstart or self.xgrid == 0:
            return ''
        if right_to_left(self.locale_str):
            return f"{(render_weight(self.roastersize_setup, 1, weight_units.index(self.weight[2]), right_to_left_lang=True) if self.roastersize_setup>=0 else '')}  {self.__dijkstra_to_ascii(self.roastertype_setup)}"
        return f"{self.__dijkstra_to_ascii(self.roastertype_setup)} {(render_weight(self.roastersize_setup, 1, weight_units.index(self.weight[2])) if self.roastersize_setup>0 else '')}"


    #Redraws data
    # if recomputeAllDeltas, the delta arrays and if smooth the smoothed line arrays are recomputed (incl. those of the background curves)
    # re_smooth_foreground: the foreground curves (incl. extras) will be re-smoothed if called while not recording. During recording foreground will never be smoothed here.
# re_smooth_background: the background curves (incl. extras) will be re-smoothed if True (default False), also during recording
    # NOTE: points for error values represented by None or masked arrays (where values are -1) are not drawn and lines are broken there
    #   see https://matplotlib.org/stable/gallery/lines_bars_and_markers/masked_demo.html
    #   to keep points and lines drawn without those breaks data should be interpolated via util:fill_gaps (controlled by the "Interpolate Drops" filter)
    @pyqtSlot(bool,bool,bool,bool,bool)
    def redraw(self, recomputeAllDeltas:bool = True, re_smooth_foreground:bool = True, takelock:bool = True, forceRenewAxis:bool = False, re_smooth_background:bool = False) -> None: # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths
#        _log.info("PRINT redraw(recomputeAllDeltas: %s, re_smooth_foreground: %s, takelock: %s, forceRenewAxis: %s, re_smooth_background: %s)",recomputeAllDeltas, re_smooth_foreground, takelock, forceRenewAxis, re_smooth_background)
        if self.designerflag:
            self.redrawdesigner(force=True)
        elif self.aw.comparator is not None:
            self.aw.comparator.redraw()
            self.aw.qpc.redraw_phases()
        else:
            try:
                #### lock shared resources   ####
                if takelock:
                    self.profileDataSemaphore.acquire(1)
                try:
                    # prevent interleaving of updateBackground() and redraw()
                    self.updateBackgroundSemaphore.acquire(1)

                    if self.flagon:
                        # on redraw during recording we reset the linecounts to avoid issues with projection lines
                        self.resetlines()

                    decay_smoothing_p = (not self.optimalSmoothing) or self.flagon

                    scale = 1 if self.graphstyle == 1 else 0
                    length = 700 # 100 (128 the default)
                    randomness = 12 # 2 (16 default)
                    rcParams['path.sketch'] = (scale, length, randomness)

                    rcParams['axes.linewidth'] = 0.8
                    rcParams['xtick.major.size'] = 6
                    rcParams['xtick.major.width'] = 1
                    rcParams['xtick.minor.width'] = 0.8

                    rcParams['ytick.major.size'] = 4
                    rcParams['ytick.major.width'] = 1
                    rcParams['ytick.minor.width'] = 1

                    xlabel_alpha_color = to_hex(to_rgba(self.palette['xlabel'], 0.47), keep_alpha=True)
                    ylabel_alpha_color = to_hex(to_rgba(self.palette['ylabel'], 0.47), keep_alpha=True)

                    rcParams['xtick.color'] = xlabel_alpha_color
                    rcParams['ytick.color'] = ylabel_alpha_color

                    #rcParams['text.antialiased'] = True

                    if forceRenewAxis:
                        self.fig.clf()

                    if self.ax is None or forceRenewAxis:
                        self.ax = self.fig.add_subplot(111,facecolor=self.palette['background'])
                    if self.delta_ax is None or forceRenewAxis:
                        self.delta_ax = self.ax.twinx()

                    # instead to remove and regenerate the axis object (we just clear and reuse it)

                    if self.ax is not None:
                        with warnings.catch_warnings():
                            warnings.simplefilter('ignore')
                            self.ax.clear()
                        self.ax.set_facecolor(self.palette['background'])
                        self.ax.set_yticks([])
                        self.ax.set_xticks([])
                        self.ax.set_ylim(self.ylimit_min, self.ylimit)
                        self.ax.set_autoscale_on(False)
                    if self.delta_ax is not None:
                        with warnings.catch_warnings():
                            warnings.simplefilter('ignore')
                            self.delta_ax.clear()
                        self.delta_ax.set_yticks([])
                        self.delta_ax.set_xticks([])

                    prop = self.aw.mpl_fontproperties.copy()
                    prop.set_size('small')
                    fontprop_small = self.aw.mpl_fontproperties.copy()
                    fontprop_small.set_size('xx-small')

                    grid_axis = None
                    if self.temp_grid and self.time_grid:
                        grid_axis = 'both'
                    elif self.temp_grid:
                        grid_axis = 'y'
                    elif self.time_grid:
                        grid_axis = 'x'
                    if grid_axis is not None:
                        self.ax.grid(True,
                            axis=grid_axis, # type: ignore # "grid" of "_AxesBase" has incompatible type "str"; expected "Literal['both', 'x', 'y']
                            color=self.palette['grid'],
                            linestyle=self.gridstyles[self.gridlinestyle],
                            linewidth=self.gridthickness,
                            alpha=self.gridalpha,
                            sketch_params=0,
                            path_effects=[])

                    if self.flagstart and not self.title_show_always:
                        self.setProfileTitle('')
                    else:
                        self.setProfileTitle(self.title)

                    titleB = ''
                    if not ((self.flagstart and not self.title_show_always) or self.title is None or self.title.strip() == ''):
                        if self.backgroundprofile is not None:
                            if self.roastbatchnrB == 0:
                                titleB = self.titleB
                            else:
                                titleB = f'{self.roastbatchprefixB}{self.roastbatchnrB} {self.titleB}'
                        elif __release_sponsor_domain__:
                            sponsor = QApplication.translate('About','Star Roaster by {}').format(__release_sponsor_domain__)
                            titleB = f'\n{sponsor}'

                    # extra event names with substitution of event names applied
                    extraname1_subst = self.extraname1[:]
                    extraname2_subst = self.extraname2[:]
                    for i in range(len(self.extratimex)):
                        extraname1_subst[i] = self.device_name_subst(extraname1_subst[i])
                        extraname2_subst[i] = self.device_name_subst(extraname2_subst[i])

                    if self.flagstart or self.ygrid == 0:
                        y_label = self.ax.set_ylabel('')
                    else:
                        y_label = self.ax.set_ylabel(self.mode,color=self.palette['ylabel'],rotation=0,labelpad=10,
                                fontsize='medium',
                                fontfamily=prop.get_family())
                    self.set_xlabel(self.default_xlabel_text())

                    try:
                        y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                    except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                        pass


                    two_ax_mode = self.twoAxisMode()

                    tick_dir = 'in' if self.flagon else 'inout'
                    self.ax.tick_params(\
                        axis='x',           # changes apply to the x-axis
                        which='both',       # both major and minor ticks are affected
                        bottom=True,        # ticks along the bottom edge are on
                        top=False,          # ticks along the top edge are off
                        direction=tick_dir,
                        labelbottom=True)   # labels along the bottom edge are on
                    self.ax.tick_params(\
                        axis='y',           # changes apply to the y-axis
                        which='both',       # both major and minor ticks are affected
                        right=False,
                        bottom=True,        # ticks along the bottom edge are on
                        top=False,          # ticks along the top edge are off
                        direction=tick_dir,
                        labelbottom=True)   # labels along the bottom edge are on

                    # format temperature as int, not float in the cursor position coordinate indicator
                    self.ax.fmt_ydata = self.fmt_data
                    self.ax.fmt_xdata = self.fmt_timedata

                    if self.delta_ax is not None:
                        self.ax.set_zorder(self.delta_ax.get_zorder()+1) # put ax in front of delta_ax (which remains empty!)

                    self.ax.patch.set_visible(True)

                    self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                    if self.zgrid > 0:
                        self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                        self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                        for ii in self.delta_ax.get_yticklines():
                            ii.set_markersize(10)
                        for iiii in self.delta_ax.yaxis.get_minorticklines():
                            iiii.set_markersize(5)
                        for label in self.delta_ax.get_yticklabels() :
                            label.set_fontsize('small')
                        if not self.LCDdecimalplaces:
                            self.delta_ax.minorticks_off()
                    # translate y-coordinate from delta into temp range to ensure the cursor position display (x,y) coordinate in the temp axis
                    self.delta_ax.fmt_ydata = self.fmt_data
                    self.delta_ax.fmt_xdata = self.fmt_timedata
                    self.delta_ax.yaxis.set_label_position('right')

                    if two_ax_mode:
                        #create a second set of axes in the same position as self.ax
                        self.delta_ax.tick_params(\
                            axis='y',           # changes apply to the y-axis
                            which='both',       # both major and minor ticks are affected
                            left=False,         # ticks along the left edge are off
                            bottom=False,       # ticks along the bottom edge are off
                            top=False,          # ticks along the top edge are off
                            direction='inout',  # tick_dir # this does not work as ticks are not drawn at all in ON mode with this!?
                            labelright=True,
                            labelleft=False,
                            labelbottom=False)   # labels along the bottom edge are off

                        if self.flagstart or self.zgrid == 0:
                            y_label = self.delta_ax.set_ylabel('')
                        else:
                            y_label = self.delta_ax.set_ylabel(f"{self.mode}{self.aw.arabicReshape('/min')}",
                                color = self.palette['ylabel'],
                                fontsize='medium',
                                fontfamily=prop.get_family()
                                )
                        try:
                            y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass
                    else:
                        self.delta_ax.patch.set_visible(False)
                        self.delta_ax.tick_params(\
                            axis='y',
                            which='both',
                            right=False,
                            labelright=False)

                    self.ax.spines['top'].set_color(xlabel_alpha_color)
                    self.ax.spines['bottom'].set_color(xlabel_alpha_color)
                    self.ax.spines['left'].set_color(ylabel_alpha_color)
                    self.ax.spines['right'].set_color(ylabel_alpha_color)

                    self.ax.spines.top.set_visible(self.xgrid != 0 and self.ygrid != 0 and self.zgrid != 0)
                    self.ax.spines.bottom.set_visible(self.xgrid != 0)
                    self.ax.spines.left.set_visible(self.ygrid != 0)
                    self.ax.spines.right.set_visible(self.zgrid != 0)

                    if self.graphstyle:
                        self.ax.spines['left'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['bottom'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['right'].set_sketch_params(scale, length, randomness)
                        self.ax.spines['top'].set_sketch_params(scale, length, randomness)
                    # hide all spines from the delta_ax
                    if self.delta_ax is not None:
                        self.delta_ax.set_frame_on(False) # hide all splines (as the four lines above)

                    if self.ygrid > 0:
                        self.ax.yaxis.set_major_locator(ticker.MultipleLocator(self.ygrid))
                        self.ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                        for j in self.ax.get_yticklines():
                            j.set_markersize(10)
                        for m in self.ax.yaxis.get_minorticklines():
                            m.set_markersize(5)

                    for ldots in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots,
                            self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]:
                        try:
                            if ldots is not None:
                                self.ldots.remove()
                        except Exception: # pylint: disable=broad-except
                            pass

                    self.l_eventtype1dots = None
                    self.l_eventtype2dots = None
                    self.l_eventtype3dots = None
                    self.l_eventtype4dots = None
                    self.l_eteventannos = []
                    self.l_bteventannos = []
                    self.l_eventtype1annos = []
                    self.l_eventtype2annos = []
                    self.l_eventtype3annos = []
                    self.l_eventtype4annos = []
                    self.l_eventflagannos = []
                    self.l_backgroundeventtype1dots = None
                    self.l_backgroundeventtype2dots = None
                    self.l_backgroundeventtype3dots = None
                    self.l_backgroundeventtype4dots = None
                    self.l_eventtype1backannos = []
                    self.l_eventtype2backannos = []
                    self.l_eventtype3backannos = []
                    self.l_eventtype4backannos = []
                    self.l_eventflagbackannos = []

                    #update X ticks, labels, and rotating_colors
                    self.xaxistosm(redraw=False)

                    if forceRenewAxis:
                        for label in self.ax.get_xticklabels() :
                            label.set_fontsize('small')
                        for label in self.ax.get_yticklabels() :
                            label.set_fontsize('small')

                    rcParams['path.sketch'] = (0,0,0)
                    trans:Transform = transforms.blended_transform_factory(self.ax.transAxes,self.ax.transData)

                    #draw water marks for dry phase region, mid phase region, and finish phase region
                    if self.watermarksflag:
                        rect1 = patches.Rectangle((0,self.phases[0]), width=1, height=(self.phases[1]-self.phases[0]),
                                                  transform=trans, color=self.palette['rect1'],alpha=0.15,
                                                  path_effects=[])
                        rect2 = patches.Rectangle((0,self.phases[1]), width=1, height=(self.phases[2]-self.phases[1]),
                                                  transform=trans, color=self.palette['rect2'],alpha=0.15,
                                                  path_effects=[])
                        rect3 = patches.Rectangle((0,self.phases[2]), width=1, height=(self.phases[3] - self.phases[2]),
                                                  transform=trans, color=self.palette['rect3'],alpha=0.15,
                                                  path_effects=[])
                        self.ax.add_patch(rect1)
                        self.ax.add_patch(rect2)
                        self.ax.add_patch(rect3)

                    #if self.eventsGraphflag == 0 then that means don't plot event bars

                    step:float
                    if self.eventsGraphflag == 1: #plot event bars by type
                        # make blended transformations to help identify EVENT types
                        if self.mode == 'C':
                            step = 5
                            start = 20
                        else:
                            step = 10
                            start = 60
                        jump = 20.
                        for i in range(4):
                            if self.showEtypes[3-i]:
                                rectEvent = patches.Rectangle(
                                    (0,self.phases[0]-start-jump),
                                    width=1,
                                    height = step,
                                    transform=trans,
                                    color=self.palette['rect5'],
                                    alpha=.15,
                                    path_effects=[])
                                self.ax.add_patch(rectEvent)
                            if self.mode == 'C':
                                jump -= 10.
                            else:
                                jump -= 20.

                    #plot events bars by value
                    elif self.eventsGraphflag in {2, 3, 4}: # 2: step lines, 3: step+, 4: combo
                        # make blended transformations to help identify EVENT types
                        if self.clampEvents:
                            top = 100
                            bot = 0
                        else:
                            if self.step100temp is None:
                                top = self.phases[0]
                            else:
                                top = self.step100temp
                            bot = self.ylimit_min
                        step = (top-bot)/10
                        start = top - bot
                        small_step = step/10 # as we have 100 items
                        jump = 0.

                        for jj in range(110):
                            i = int(jj/10)
                            barposition = top - start - jump
                            if i == jj/10.:
                                c1 = 'rect5'
                                c2 = 'background'
                                if i == 0:
                                    color = self.palette[c1] #self.palette["rect3"] # brown
                                elif i%2:
                                    color = self.palette[c2] #self.palette["rect2"] # orange # the uneven ones
                                else:
                                    color = self.palette[c1] #self.palette["rect1"] # green # the even ones
                                if i != 10: # don't draw the first and the last bar in clamp mode
                                    rectEvent = patches.Rectangle(
                                        (0,barposition),
                                        width=1,
                                        height = step,
                                        transform=trans,
                                        color=color,
                                        alpha=.15,
                                        path_effects=[])
                                    self.ax.add_patch(rectEvent)
                            self.eventpositionbars[jj] = barposition
                            jump -= small_step

                    rcParams['path.sketch'] = (scale, length, randomness)

                    #check BACKGROUND flag
                    if self.background and self.backgroundprofile is not None:
                        if re_smooth_background:
                            # re-smooth background curves
                            tb = self.timeB
                            t1 = self.temp1B
                            t2 = self.temp2B
                            if tb is not None and len(tb)>1:
                                tb_lin = numpy.linspace(tb[0],tb[-1],len(tb))
                            else:
                                tb_lin = None
                            self.stemp1B = self.smooth_list(tb,t1,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin,delta=False)
                            self.stemp2B = self.smooth_list(tb,t2,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin,delta=False)

                        self.l_background_annotations = []

                        bcharge_idx = 0
                        if self.timeindexB[0] > -1:
                            bcharge_idx = self.timeindexB[0]
                        bdrop_idx = len(self.timeB)-1
                        if self.timeindexB[6] > 0:
                            bdrop_idx = self.timeindexB[6]

                        #draw one extra device on background stemp1BX
                        if self.xtcurveidx > 0:
                            idx3 = self.xtcurveidx - 1
                            n3 = idx3 // 2
                            if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                                if re_smooth_background:
                                    # re-smooth the extra background curve
                                    tx = self.extratimexB[n3]
                                    if tx is not None and tx:
                                        tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                                    else:
                                        tx_lin = None
                                if self.xtcurveidx % 2:
                                    if self.temp1Bdelta[n3] and self.delta_ax is not None:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if re_smooth_background:
                                        self.stemp1BX[n3] = self.smooth_list(tx,self.temp1BX[n3],window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin,delta=False)
                                    if self.flagon:
                                        # during recording we draw the unsmoothed background curves, with drops interpolated
                                        stemp3B = self.temp1BX[n3]
                                    else:
                                        stemp3B = self.stemp1BX[n3]
                                else:
                                    if self.temp2Bdelta[n3] and self.delta_ax is not None:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if re_smooth_background:
                                        self.stemp2BX[n3] = self.smooth_list(tx,self.temp2BX[n3],window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin,delta=False)
                                    if self.flagon:
                                        # during recording we draw the unsmoothed background curves, with drops interpolated
                                        stemp3B = self.temp2BX[n3]
                                    else:
                                        stemp3B = self.stemp2BX[n3]
                                if not self.backgroundShowFullflag:
                                    if not self.autotimex or self.autotimexMode == 0:
                                        stemp3B = numpy.concatenate((
                                            numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                            stemp3B[bcharge_idx:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                    else:
                                        stemp3B = numpy.concatenate((
                                            stemp3B[0:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                try:
                                    if self.l_back3 is not None:
                                        self.l_back3.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                # don't draw -1:
                                stemp3B = numpy.ma.masked_where(stemp3B == -1, stemp3B) # type:ignore[no-untyped-call]
                                self.l_back3, = self.ax.plot(self.extratimexB[n3], stemp3B, markersize=self.XTbackmarkersize,marker=self.XTbackmarker,
                                                            sketch_params=None,path_effects=[],transform=trans,
                                                            linewidth=self.XTbacklinewidth,linestyle=self.XTbacklinestyle,drawstyle=self.XTbackdrawstyle,color=self.backgroundxtcolor,
                                                            alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundXT')))
                        if self.ytcurveidx > 0:
                            idx4 = self.ytcurveidx - 1
                            n4 = idx4 // 2
                            if len(self.stemp1BX) > n4 and len(self.stemp2BX) > n4 and len(self.extratimexB) > n4:
                                if re_smooth_background:
                                    # re-smooth the extra background curve
                                    tx = self.extratimexB[n4]
                                    if tx is not None and tx:
                                        tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                                    else:
                                        tx_lin = None
                                if self.ytcurveidx % 2:
                                    if self.temp1Bdelta[n4] and self.delta_ax is not None:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if re_smooth_background:
                                        self.stemp1BX[n4] = self.smooth_list(tx,self.temp1BX[n4],window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin,delta=False)
                                    if self.flagon:
                                        # during recording we draw the unsmoothed background curves, with drops interpolated
                                        stemp4B = self.temp1BX[n4]
                                    else:
                                        stemp4B = self.stemp1BX[n4]
                                else:
                                    if self.temp2Bdelta[n4] and self.delta_ax is not None:
                                        trans = self.delta_ax.transData
                                    else:
                                        trans = self.ax.transData
                                    if re_smooth_background:
                                        self.stemp2BX[n4] = self.smooth_list(tx,self.temp2BX[n4],window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin,delta=False)
                                    if self.flagon:
                                        # during recording we draw the unsmoothed background curves, with drops interpolated
                                        stemp4B = self.temp2BX[n4]
                                    else:
                                        stemp4B = self.stemp2BX[n4]
                                if not self.backgroundShowFullflag:
                                    if not self.autotimex or self.autotimexMode == 0:
                                        stemp4B = numpy.concatenate((
                                            numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                            stemp4B[bcharge_idx:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                    else:
                                        stemp4B = numpy.concatenate((
                                            stemp4B[0:bdrop_idx+1],
                                            numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                                try:
                                    if self.l_back4 is not None:
                                        self.l_back4.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                # don't draw -1:
                                stemp4B = numpy.ma.masked_where(stemp4B == -1, stemp4B) # type:ignore[no-untyped-call]
                                self.l_back4, = self.ax.plot(self.extratimexB[n4], stemp4B, markersize=self.YTbackmarkersize,marker=self.YTbackmarker,
                                                            sketch_params=None,path_effects=[],transform=trans,
                                                            linewidth=self.YTbacklinewidth,linestyle=self.YTbacklinestyle,drawstyle=self.YTbackdrawstyle,color=self.backgroundytcolor,
                                                            alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundYT')))


                        #draw background
                        if self.backgroundETcurve:
                            if self.flagon:
                                # during recording we draw the unsmoothed background curves, with drops interpolated
                                stemp1B = numpy.array(self.temp1B, dtype=numpy.double)
                            else:
                                stemp1B = self.stemp1B
                            if self.backgroundShowFullflag:
                                temp_etb = stemp1B
                            elif not self.autotimex or self.autotimexMode == 0:
                                # only draw background curve from CHARGE to DROP
                                temp_etb = numpy.concatenate((
                                    numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                    stemp1B[bcharge_idx:bdrop_idx+1],
                                    numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                            else:
                                temp_etb = numpy.concatenate((
                                    stemp1B[0:bdrop_idx+1],
                                    numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                        else:
                            temp_etb = numpy.full(len(self.timeB), numpy.nan, dtype=numpy.double)
                        try:
                            if self.l_back1 is not None:
                                self.l_back1.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                        # don't draw -1:
                        temp_etb = numpy.ma.masked_where(temp_etb == -1, temp_etb) # type:ignore[no-untyped-call]
                        self.l_back1, = self.ax.plot(self.timeB,temp_etb,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                    sketch_params=None,path_effects=[],
                                                    linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                    alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundET')))
                        if self.backgroundBTcurve:
                            if self.flagon:
                                # during recording we draw the unsmoothed background curves, with drops interpolated
                                stemp2B = numpy.array(self.temp2B, dtype=numpy.double)
                            else:
                                stemp2B = self.stemp2B
                            if self.backgroundShowFullflag:
                                temp_btb = stemp2B
                            elif not self.autotimex or self.autotimexMode == 0:
                                # only draw background curve from CHARGE to DROP
                                temp_btb = numpy.concatenate((
                                    numpy.full(bcharge_idx, numpy.nan, dtype=numpy.double),
                                    stemp2B[bcharge_idx:bdrop_idx+1],
                                    numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                            else:
                                temp_btb = numpy.concatenate((
                                    stemp2B[0:bdrop_idx+1],
                                    numpy.full(len(self.timeB)-bdrop_idx-1, numpy.nan, dtype=numpy.double)))
                        else:
                            temp_btb = numpy.full(len(self.timeB), numpy.nan, dtype=numpy.double)
                        try:
                            if self.l_back2 is not None:
                                self.l_back2.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                        # don't draw -1:
                        temp_btb = numpy.ma.masked_where(temp_btb == -1, temp_btb) # type:ignore[no-untyped-call]
                        self.l_back2, = self.ax.plot(self.timeB, temp_btb,markersize=self.BTbackmarkersize,marker=self.BTbackmarker,
                                                    linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                    sketch_params=None,path_effects=[],
                                                    alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundBT')))

                        self.smoothETBTBkgnd(recomputeAllDeltas,decay_smoothing_p)

                        #populate background delta ET (self.delta1B) and delta BT (self.delta2B)
                        ##### DeltaETB,DeltaBTB curves
                        if (self.DeltaETBflag or self.DeltaBTBflag) and self.delta_ax is not None:
                            trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                            if self.DeltaETBflag and len(self.timeB) == len(self.delta1B):
                                try:
                                    if self.l_delta1B is not None:
                                        self.l_delta1B.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                self.l_delta1B, = self.ax.plot(
                                    self.timeB,
                                    numpy.array(self.delta1B),
                                    transform=trans,
                                    markersize=self.ETBdeltamarkersize,
                                    sketch_params=None,path_effects=[],
                                    marker=self.ETBdeltamarker,
                                    linewidth=self.ETBdeltalinewidth,
                                    linestyle=self.ETBdeltalinestyle,
                                    drawstyle=self.ETBdeltadrawstyle,
                                    color=self.backgrounddeltaetcolor,
                                    alpha=self.backgroundalpha,
                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundDeltaET')))
                            if self.DeltaBTBflag and len(self.timeB) == len(self.delta2B):
                                try:
                                    if self.l_delta2B is not None:
                                        self.l_delta2B.remove()
                                except Exception: # pylint: disable=broad-except
                                    pass
                                self.l_delta2B, = self.ax.plot(
                                    self.timeB,
                                    numpy.array(self.delta2B),
                                    transform=trans,
                                    markersize=self.BTBdeltamarkersize,
                                    sketch_params=None,path_effects=[],
                                    marker=self.BTBdeltamarker,
                                    linewidth=self.BTBdeltalinewidth,
                                    linestyle=self.BTBdeltalinestyle,
                                    drawstyle=self.BTBdeltadrawstyle,
                                    color=self.backgrounddeltabtcolor,
                                    alpha=self.backgroundalpha,
                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundDeltaBT')))
                        #check backgroundevents flag
                        if self.backgroundeventsflag and (self.backgroundETcurve or self.backgroundBTcurve):
                            height = 50 if self.mode == 'F' else 20

                            for p, bge in enumerate(self.backgroundEvents):
                                if self.eventsGraphflag not in [2,4] or self.backgroundEtypes[p] > 3:
                                    event_idx = bge
                                    if (not self.showEtypes[self.backgroundEtypes[p]] or
                                        (not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx))):
                                        continue
                                    if self.backgroundEtypes[p] < 4:
                                        st1 = f'{self.Betypesf(self.backgroundEtypes[p])[0]}{self.eventsvaluesShort(self.backgroundEvalues[p])}'
                                    else:
                                        st1 = self.backgroundEStrings[p].strip()[:self.eventslabelschars]
                                        if len(st1) == 0:
                                            st1 = 'E'
                                    # plot events on BT when showeventsonbt is true
                                    if self.backgroundETcurve and (not self.backgroundBTcurve or
                                            not self.showeventsonbt or self.temp1B[event_idx] > self.temp2B[event_idx]):
                                        temp = self.temp1B[event_idx]
                                    else:
                                        temp = self.temp2B[event_idx]
                                    anno = self.ax.annotate(st1, xy=(self.timeB[event_idx], temp),path_effects=[],
                                                        xytext=(self.timeB[event_idx], temp+height),
                                                        va='center', ha='center',
                                                        fontsize='x-small',
                                                        color=self.palette['bgeventtext'],
                                                        arrowprops={'arrowstyle':'wedge',
                                                                        'color':self.palette['bgeventmarker'],
                                                                        'alpha':self.backgroundalpha},#relpos=(0,0)),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0))
                                    try:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                        pass
                                    self.l_background_annotations.append(anno)
                                    self.l_eventflagbackannos.append(anno)
                            #background events by value
                            if self.eventsGraphflag in {2, 3, 4}: # 2: step, 3: step+, 4: combo
                                self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
                                self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
                                E1b_last = E2b_last = E3b_last = E4b_last = 0  #not really necessary but guarantees that Exb_last is defined
                                # remember event value @CHARGE (or last before CHARGE) to add if not self.backgroundShowFullflag
                                E1_CHARGE_B:Optional[float] = None
                                E2_CHARGE_B:Optional[float] = None
                                E3_CHARGE_B:Optional[float] = None
                                E4_CHARGE_B:Optional[float] = None
                                event_pos_offset = self.eventpositionbars[0]
                                event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                                #properties for the event annotation
                                eventannotationprop = self.aw.mpl_fontproperties.copy()
                                hoffset = 3  #relative to the event dot
                                voffset = 3  #relative to the event dot
                                eventannotationprop.set_size('x-small')
                                self.overlapList = []
                                for i, event_idx in enumerate(self.backgroundEvents):
                                    txx = self.timeB[event_idx]
#                                    pos:float = max(0,int(round((self.backgroundEvalues[i]-1)*10)))
                                    pos:float = max(0, self.eventsInternal2ExternalValue(self.backgroundEvalues[i]))
                                    skip_event = (not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx))
                                    if self.backgroundEtypes[i] == 0 and self.showEtypes[0]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and txx < self.timeB[self.timeindexB[0]]):
                                                E1_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E1_CHARGE_B = (E1_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E1backgroundtimex.append(self.timeB[event_idx])
                                        if self.clampEvents:
                                            self.E1backgroundvalues.append(pos)
                                        else:
                                            self.E1backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E1b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[0] != 0:
                                                E1b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i, applyto='background')
                                                temp = self.E1backgroundvalues[-1]
                                                anno = self.ax.annotate(E1b_annotation, xy=(hoffset + self.timeB[int(event_idx)], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontsize='x-small',
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno)# , i, E1b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 1 and self.showEtypes[1]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and txx < self.timeB[self.timeindexB[0]]):
                                                E2_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E2_CHARGE_B = (E2_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E2backgroundtimex.append(self.timeB[event_idx])
                                        if self.clampEvents:
                                            self.E2backgroundvalues.append(pos)
                                        else:
                                            self.E2backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E2b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[1] != 0:
                                                E2b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i, applyto='background')
                                                temp = self.E2backgroundvalues[-1]
                                                anno = self.ax.annotate(E2b_annotation, xy=(hoffset + self.timeB[int(event_idx)], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E2b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 2 and self.showEtypes[2]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and txx < self.timeB[self.timeindexB[0]]):
                                                E3_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E3_CHARGE_B = (E3_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E3backgroundtimex.append(self.timeB[event_idx])
                                        if self.clampEvents:
                                            self.E3backgroundvalues.append(pos)
                                        else:
                                            self.E3backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E3b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[2] != 0:
                                                E3b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i, applyto='background')
                                                temp = self.E3backgroundvalues[-1]
                                                anno = self.ax.annotate(E3b_annotation, xy=(hoffset + self.timeB[int(event_idx)], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E3b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.backgroundEtypes[i] == 3 and self.showEtypes[3]:
                                        if skip_event:
                                            if (self.timeindexB[0] > -1 and txx < self.timeB[self.timeindexB[0]]):
                                                E4_CHARGE_B = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E4_CHARGE_B = (E4_CHARGE_B*event_pos_factor)+event_pos_offset
                                            continue
                                        self.E4backgroundtimex.append(self.timeB[event_idx])
                                        if self.clampEvents:
                                            self.E4backgroundvalues.append(pos)
                                        else:
                                            self.E4backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                        E4b_last = i
                                        try:
                                            if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.specialeventannovisibilities[3] != 0:
                                                E4b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i, applyto='background')
                                                temp = self.E4backgroundvalues[-1]
                                                anno = self.ax.annotate(E4b_annotation, xy=(hoffset + self.timeB[int(event_idx)], voffset + temp),
                                                            alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E4b_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
    #                            every = None
                                if len(self.E1backgroundtimex)>0 and len(self.E1backgroundtimex)==len(self.E1backgroundvalues):
                                    if (self.timeindexB[6] > 0 and self.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E1b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E1backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E1b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E1backgroundvalues.append(pos)
                                        else:
                                            self.E1backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E1_CHARGE_B is not None and len(self.E1backgroundvalues)>1 and self.E1backgroundvalues[0] != E1_CHARGE_B:
                                        E1xB = [self.timeB[self.timeindexB[0]]] + self.E1backgroundtimex
                                        E1yB = [E1_CHARGE_B] + self.E1backgroundvalues
                                    else:
                                        E1xB = self.E1backgroundtimex
                                        E1yB = self.E1backgroundvalues
                                    self.l_backgroundeventtype1dots, = self.ax.plot(E1xB, E1yB, color=self.EvalueColor[0],
                                                                                marker=(self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[0],
                                                                                picker=True,
                                                                                pickradius=4,
                                                                                #markevery=every,
                                                                                linestyle='-',
                                                                                drawstyle=(self.drawstyle_default if self.specialeventplaybackramp[0] else 'steps-post'),
                                                                                linewidth = self.Evaluelinethickness[0],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(0,True))
                                if len(self.E2backgroundtimex)>0 and len(self.E2backgroundtimex)==len(self.E2backgroundvalues):
                                    if (self.timeindexB[6] > 0 and self.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E2b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E2backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E2b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E2backgroundvalues.append(pos)
                                        else:
                                            self.E2backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E2_CHARGE_B is not None and len(self.E2backgroundvalues)>1 and self.E2backgroundvalues[0] != E2_CHARGE_B:
                                        E2xB = [self.timeB[self.timeindexB[0]]] + self.E2backgroundtimex
                                        E2yB = [E2_CHARGE_B] + self.E2backgroundvalues
                                    else:
                                        E2xB = self.E2backgroundtimex
                                        E2yB = self.E2backgroundvalues
                                    self.l_backgroundeventtype2dots, = self.ax.plot(E2xB, E2yB, color=self.EvalueColor[1],
                                                                                marker=(self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[1],
                                                                                picker=True,
                                                                                pickradius=4,
                                                                                #markevery=every,
                                                                                linestyle='-',
                                                                                drawstyle=(self.drawstyle_default if self.specialeventplaybackramp[1] else 'steps-post'),
                                                                                linewidth = self.Evaluelinethickness[1],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(1,True))
                                if len(self.E3backgroundtimex)>0 and len(self.E3backgroundtimex)==len(self.E3backgroundvalues):
                                    if (self.timeindexB[6] > 0 and self.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E3b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E3backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E3b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E3backgroundvalues.append(pos)
                                        else:
                                            self.E3backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E3_CHARGE_B is not None and len(self.E3backgroundvalues)>1 and self.E3backgroundvalues[0] != E3_CHARGE_B:
                                        E3xB = [self.timeB[self.timeindexB[0]]] + self.E3backgroundtimex
                                        E3yB = [E3_CHARGE_B] + self.E3backgroundvalues
                                    else:
                                        E3xB = self.E3backgroundtimex
                                        E3yB = self.E3backgroundvalues
                                    self.l_backgroundeventtype3dots, = self.ax.plot(E3xB, E3yB, color=self.EvalueColor[2],
                                                                                marker=(self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[2],
                                                                                picker=True,
                                                                                pickradius=4,
                                                                                #markevery=every,
                                                                                linestyle='-',
                                                                                drawstyle=(self.drawstyle_default if self.specialeventplaybackramp[2] else 'steps-post'),
                                                                                linewidth = self.Evaluelinethickness[2],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(2,True))
                                if len(self.E4backgroundtimex)>0 and len(self.E4backgroundtimex)==len(self.E4backgroundvalues):
                                    if (self.timeindexB[6] > 0 and self.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E4b_last]]):   #if drop exists and last event was earlier
                                        # repeat last value at time of DROP
                                        self.E4backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                        pos = max(0,int(round((self.backgroundEvalues[E4b_last]-1)*10)))
                                        if self.clampEvents:
                                            self.E4backgroundvalues.append(pos)
                                        else:
                                            self.E4backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    if E4_CHARGE_B is not None and len(self.E4backgroundvalues)>1 and self.E4backgroundvalues[0] != E4_CHARGE_B:
                                        E4xB = [self.timeB[self.timeindexB[0]]] + self.E4backgroundtimex
                                        E4yB = [E4_CHARGE_B] + self.E4backgroundvalues
                                    else:
                                        E4xB = self.E4backgroundtimex
                                        E4yB = self.E4backgroundvalues
                                    self.l_backgroundeventtype4dots, = self.ax.plot(E4xB, E4yB, color=self.EvalueColor[3],
                                                                                marker=(self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                                                markersize = self.EvalueMarkerSize[3],
                                                                                picker=True,
                                                                                pickradius=4,
                                                                                #markevery=every,
                                                                                linestyle='-',
                                                                                drawstyle=(self.drawstyle_default if self.specialeventplaybackramp[3] else 'steps-post'),
                                                                                linewidth = self.Evaluelinethickness[3],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(3,True))

                            if len(self.backgroundEvents) > 0:
                                Bevalues:List[List[float]] = [[],[],[],[]]
                                if self.eventsGraphflag == 4:
                                    # we prepare copies of the background Evalues
                                    Bevalues = [self.E1backgroundvalues[:],self.E2backgroundvalues[:],self.E3backgroundvalues[:],self.E4backgroundvalues[:]]
                                for i, event_idx in enumerate(self.backgroundEvents):
                                    if not self.backgroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < bcharge_idx) or event_idx > bdrop_idx):
                                        continue
                                    if self.backgroundEtypes[i] == 4 or self.eventsGraphflag in {0, 3, 4}:
                                        if self.backgroundEtypes[i] < 4 and (not self.renderEventsDescr or len(self.backgroundEStrings[i].strip()) == 0):
                                            Betype = self.Betypesf(self.backgroundEtypes[i])
                                            firstletter = self.etypeAbbrev(Betype)
                                            secondletter = self.eventsvaluesShort(self.backgroundEvalues[i])
                                            if self.aw.eventslidertemp[self.backgroundEtypes[i]]:
                                                thirdletter = self.mode # postfix
                                            else:
                                                thirdletter = self.aw.eventsliderunits[self.backgroundEtypes[i]] # postfix
                                        else:
                                            firstletter = self.backgroundEStrings[i].strip()[:self.eventslabelschars]
                                            if firstletter == '':
                                                firstletter = 'E'
                                            secondletter = ''
                                            thirdletter = ''
                                        height = 50 if self.mode == 'F' else 20

                                        if self.eventsGraphflag == 4 and self.backgroundEtypes[i] < 4 and self.showEtypes[self.backgroundEtypes[i]] and len(Bevalues[self.backgroundEtypes[i]])>0:
                                            Btemp = Bevalues[self.backgroundEtypes[i]][0]
                                            Bevalues[self.backgroundEtypes[i]] = Bevalues[self.backgroundEtypes[i]][1:]
                                        else:
                                            Btemp = None

                                        if Btemp is not None and self.showEtypes[self.backgroundEtypes[i]]:
                                            if self.backgroundEtypes[i] == 0:
                                                boxstyle = 'roundtooth,pad=0.4'
                                                boxcolor = self.EvalueColor[0]
                                                textcolor = self.EvalueTextColor[0]
                                            elif self.backgroundEtypes[i] == 1:
                                                boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                                boxcolor = self.EvalueColor[1]
                                                textcolor = self.EvalueTextColor[1]
                                            elif self.backgroundEtypes[i] == 2:
                                                boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                                boxcolor = self.EvalueColor[2]
                                                textcolor = self.EvalueTextColor[2]
                                            elif self.backgroundEtypes[i] == 3:
                                                boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                                boxcolor = self.EvalueColor[3]
                                                textcolor = self.EvalueTextColor[3]
                                            #elif self.backgroundEtypes[i] == 4:
                                            else:
                                                boxstyle = 'square,pad=0.1'
                                                boxcolor = self.palette['specialeventbox']
                                                textcolor = self.palette['specialeventtext']
                                            if self.eventsGraphflag in {0, 3} or self.backgroundEtypes[i] > 3:
                                                anno = self.ax.annotate('f{firstletter}{secondletter}', xy=(self.timeB[int(event_idx)], Btemp),
                                                             xytext=(self.timeB[int(event_idx)],Btemp+height),
                                                             alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                             color=self.palette['bgeventtext'],
                                                             va='center', ha='center',
                                                             arrowprops={'arrowstyle':'-','color':boxcolor,'alpha':self.backgroundalpha}, # ,relpos=(0,0)
                                                             bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none', 'alpha':self.backgroundalpha},
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                            elif self.eventsGraphflag == 4:
                                                if thirdletter != '':
                                                    firstletter = ''
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timeB[int(event_idx)], Btemp),
                                                             xytext=(self.timeB[int(event_idx)],Btemp),
                                                             alpha=min(self.backgroundalpha + 0.3, 1.0),
                                                             color=self.palette['bgeventtext'],
                                                             va='center', ha='center',
                                                             bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none',
                                                                'alpha':min(self.backgroundalpha, 1.0)},
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                if self.backgroundEtypes[i] == 0:
                                                    self.l_eventtype1backannos.append(anno)
                                                elif self.backgroundEtypes[i] == 1:
                                                    self.l_eventtype2backannos.append(anno)
                                                elif self.backgroundEtypes[i] == 2:
                                                    self.l_eventtype3backannos.append(anno)
                                                elif self.backgroundEtypes[i] == 3:
                                                    self.l_eventtype4backannos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                        #check backgroundDetails flag
                        if self.backgroundDetails:
                            d:float = self.ylimit - self.ylimit_min
                            d = d - d/5
                            #if there is a profile loaded with CHARGE, then save time to get the relative time
                            if self.timeindex[0] != -1:   #verify it exists before loading it, otherwise the list could go out of index
                                startB = self.timex[self.timeindex[0]]
                            elif self.timeindexB[0] > 0:
                                startB = self.timeB[self.timeindexB[0]]
                            else:
                                startB = 0
                            try:
                                # background annotations are not draggable
                                if self.backgroundETcurve or self.backgroundBTcurve:
                                    if self.backgroundBTcurve:
                                        temp_curve = self.temp2B
                                        stemp_curve = self.stemp2B
                                    else:
                                        temp_curve = self.temp1B
                                        stemp_curve = self.stemp1B
                                    self.l_background_annotations.extend(self.place_annotations(
                                        -1, # TP_index
                                        d,
                                        self.timeB,
                                        self.timeindexB,
                                        temp_curve,
                                        stemp_curve,
                                        startB,
                                        self.timeindex, # timeindex2
                                        TP_time_loaded=self.TP_time_B_loaded,
                                        draggable=True))
                            except Exception: # pylint: disable=broad-except
                                pass

                        #show the analysis results if they exist
    #                    if len(self.analysisresultsstr) > 0:
    #                        self.aw.analysisShowResults(redraw=False)

                        #END of Background

                    self.handles = []
                    self.labels = []
                    self.legend_lines = []

                    self.smoothETBT(re_smooth_foreground,recomputeAllDeltas,decay_smoothing_p)

    ## Output Idle Noise StdDev of BT RoR
#                    try:
#                        print("*** IdleNoise ***")
#                        start = self.timeindex[0]
#                        end = self.timeindex[6]
#                        if start == -1:
#                            start = 0
#                        else:
#                            print("CHARGE set")
#                        start = start + 20 # avoiding the empty begin of heavy smoothed data
#                        if end == 0:
#                            end = len(self.timex) - 1
##                            end = min(len(self.delta2) -1,100)
#                        print("start",start)
#                        print("end",end)
#                        print("total", end-start)
#                        if end>start:
#                            print("ET RoR mean:",numpy.mean([x for x in self.delta1[start:end] if x is not None]))
#                            print("ET RoR std:",numpy.std([x for x in self.delta1[start:end] if x is not None]))
#                            print("BT RoR mean:",numpy.mean([x for x in self.delta2[start:end] if x is not None]))
#                            print("BT RoR std:",numpy.std([x for x in self.delta2[start:end] if x is not None]))
#                            print("BT mean:",numpy.mean([x for x in self.temp2[start:end] if x is not None]))
#                            print("BT std:",numpy.std([x for x in self.temp2[start:end] if x is not None]))
#                            max_BT = numpy.max([x for x in self.temp2[start:end] if x is not None])
#                            min_BT = numpy.max([x for x in self.temp2[start:end] if x is not None])
#                            mean_BT = numpy.mean([x for x in self.temp2[start:end] if x is not None])
#                            print("BT max delta:", max(mean_BT - min_BT,max_BT - mean_BT))
#                    except Exception as e: # pylint: disable=broad-except
#                        _log.exception(e)

                    # CHARGE-DROP curve index limits
                    charge_idx = 0
                    if self.timeindex[0] > -1:
                        charge_idx = self.timeindex[0]
                    drop_idx = len(self.timex)-1
                    if self.timeindex[6] > 0:
                        drop_idx = self.timeindex[6]

                    E1_nonempty:bool = False
                    E2_nonempty:bool = False
                    E3_nonempty:bool = False
                    E4_nonempty:bool = False

                    if self.eventsshowflag != 0:
                        Nevents = len(self.specialevents)
                        #three modes of drawing events.
                        # the first mode just places annotations. They are text annotations.
                        # the second mode aligns the events types to a bar height so that they can be visually identified by type. They are text annotations
                        # the third mode plots the events by value. They are not annotations but actual lines.

                        if self.eventsGraphflag == 1 and Nevents:

                            char1 = self.etypeAbbrev(self.etypes[0])
                            char2 = self.etypeAbbrev(self.etypes[1])
                            char3 = self.etypeAbbrev(self.etypes[2])
                            char4 = self.etypeAbbrev(self.etypes[3])

                            if self.mode == 'F':
                                row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                            else:
                                row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}

                            #draw lines of color between events of the same type to help identify areas of events.
                            #count (as length of the list) and collect their times for each different type. Each type will have a different plot height
                            netypes:List[List[float]] = [[],[],[],[]]
                            for i in range(Nevents):
                                try:
                                    txx = self.timex[self.specialevents[i]]
                                    event_idx = int(self.specialevents[i])

                                    if self.flagstart or self.foregroundShowFullflag or (charge_idx <= event_idx <= drop_idx) or (self.autotimex and self.autotimexMode != 0 and event_idx < charge_idx):
                                        if self.specialeventstype[i] == 0 and self.showEtypes[0]:
                                            netypes[0].append(txx)
                                        elif self.specialeventstype[i] == 1 and self.showEtypes[1]:
                                            netypes[1].append(txx)
                                        elif self.specialeventstype[i] == 2 and self.showEtypes[2]:
                                            netypes[2].append(txx)
                                        elif self.specialeventstype[i] == 3 and self.showEtypes[3]:
                                            netypes[3].append(txx)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.debug(e)

                            letters = ''.join((char1,char2,char3,char4))   #"NPDF" first letter for each type (None, Power, Damper, Fan)
                            rotating_colors = [self.palette['rect2'],self.palette['rect3']] #rotating rotating_colors
                            for p,ltr in enumerate(letters):
                                if len(netypes[p]) > 1:
                                    for i in range(len(netypes[p])-1):
                                        #draw differentiating color bars between events and place then in a different height according with type
                                        rect = patches.Rectangle(
                                            (netypes[p][i], row[ltr]),
                                            width = (netypes[p][i+1]-netypes[p][i]),
                                            height = step,
                                            color = rotating_colors[i%2],
                                            alpha=0.5,
                                            path_effects=[])
                                        self.ax.add_patch(rect)

                            # annotate event
                            for i in range(Nevents):
                                if self.specialeventstype[i] > 3:
                                    # a special event of type "--"
                                    pass
                                elif self.showEtypes[self.specialeventstype[i]]:
                                    event_idx = int(self.specialevents[i])
                                    try:
                                        if not(self.flagstart or self.foregroundShowFullflag or
                                                (charge_idx <= event_idx <= drop_idx) or (self.autotimex and self.autotimexMode != 0 and event_idx < charge_idx)):
                                            continue

                                        firstletter = self.etypeAbbrev(self.etypes[self.specialeventstype[i]])
                                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])

                                        #some times ET is not drawn (ET = 0) when using device NONE
                                        if self.ETcurve or self.BTcurve:
                                            # plot events on BT when showeventsonbt is true
                                            if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[event_idx] >= self.temp2[event_idx]):
                                                col = self.palette['et']
                                                if self.flagon:
                                                    temps = self.temp1
                                                else:
                                                    temps = self.stemp1
                                            else:
                                                col = self.palette['bt']
                                                if self.flagon:
                                                    temps = self.temp2
                                                else:
                                                    temps = self.stemp2
        #                                    fcolor=self.EvalueColor[self.specialeventstype[i]]
                                            if platform.system() == 'Windows':
                                                vert_offset = 5.0
                                            else:
                                                vert_offset = 2.5
                                            anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                                             xy=(self.timex[event_idx],
                                                             temps[event_idx]),
                                                             xytext=(self.timex[event_idx],row[firstletter] + vert_offset),
                                                             alpha=1.,
                                                             va='center', ha='left',
                                                             bbox={'boxstyle':'square,pad=0.1', 'fc':self.palette['specialeventbox'], 'ec':'none'},
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             color=self.palette['specialeventtext'],
                                                             arrowprops={'arrowstyle':'-','color':col,'alpha':0.4,'relpos':(0,0)},
                                                             fontsize='xx-small',
                                                             fontproperties=fontprop_small)
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as e: # pylint: disable=broad-except
                                        _log.exception(e)

                        elif self.eventsGraphflag in {2, 3, 4}: # in this mode we have to generate the plots even if Nevents=0 to avoid redraw issues resulting from an incorrect number of plot count
                            self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                            self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                            #not really necessary but guarantees that Ex_last is defined
                            E1_last:int = 0
                            E2_last:int = 0
                            E3_last:int = 0
                            E4_last:int = 0
                            # remember event value @CHARGE (or last before CHARGE) to add if not self.foregroundShowFullflag
                            E1_CHARGE:Optional[float] = None
                            E2_CHARGE:Optional[float] = None
                            E3_CHARGE:Optional[float] = None
                            E4_CHARGE:Optional[float] = None
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            #properties for the event annotations
                            eventannotationprop = self.aw.mpl_fontproperties.copy()
                            hoffset = 3  #relative to the event dot
                            voffset = 1  #relative to the event dot
                            self.overlapList = []
                            eventannotationprop.set_size('x-small')
                            for i in range(Nevents):
                                pos = max(0,int(round((self.specialeventsvalue[i]-1)*10)))
                                txx = self.timex[self.specialevents[i]]
                                skip_event = not self.flagstart and ((not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and self.timeindex[0] > -1 and txx < self.timex[self.timeindex[0]]) or
                                            (not self.foregroundShowFullflag and self.timeindex[6] > 0 and txx > self.timex[self.timeindex[6]]))
                                try:
                                    if self.specialeventstype[i] == 0 and self.showEtypes[0]:
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and txx < self.timex[self.timeindex[0]]):
                                                E1_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E1_CHARGE = (E1_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E1timex.append(txx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E1values.append(pos)
                                        else:
                                            self.E1values.append((pos*event_pos_factor)+event_pos_offset)
                                        E1_nonempty = True
                                        E1_last = i
                                        try:
                                            if not self.flagon and self.eventsGraphflag!=4 and self.specialeventannovisibilities[0] != 0:
                                                E1_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i)
                                                temp = self.E1values[-1]
                                                anno = self.ax.annotate(E1_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype1annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E1_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 1 and self.showEtypes[1]:
                                        txx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and txx < self.timex[self.timeindex[0]]):
                                                E2_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E2_CHARGE = (E2_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E2timex.append(txx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E2values.append(pos)
                                        else:
                                            self.E2values.append((pos*event_pos_factor)+event_pos_offset)
                                        E2_nonempty = True
                                        E2_last = i
                                        try:
                                            if not self.flagon and self.eventsGraphflag!=4 and self.specialeventannovisibilities[1] != 0:
                                                E2_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i)
                                                temp = self.E2values[-1]
                                                anno = self.ax.annotate(E2_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype2annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E2_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass

                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 2 and self.showEtypes[2]:
                                        txx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and txx < self.timex[self.timeindex[0]]):
                                                E3_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E3_CHARGE = (E3_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E3timex.append(txx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E3values.append(pos)
                                        else:
                                            self.E3values.append((pos*event_pos_factor)+event_pos_offset)
                                        E3_nonempty = True
                                        E3_last = i
                                        try:
                                            if not self.flagon and self.eventsGraphflag!=4 and self.specialeventannovisibilities[2] != 0:
                                                E3_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i)
                                                temp = self.E3values[-1]
                                                anno = self.ax.annotate(E3_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype3annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E3_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                    elif self.specialeventstype[i] == 3 and self.showEtypes[3]:
                                        txx = self.timex[self.specialevents[i]]
                                        if skip_event:
                                            if (self.timeindex[0] > -1 and txx < self.timex[self.timeindex[0]]):
                                                E4_CHARGE = pos # remember event value at CHARGE
                                                if not self.clampEvents:
                                                    E4_CHARGE = (E4_CHARGE*event_pos_factor)+event_pos_offset
                                            # don't draw event lines before CHARGE if foregroundShowFullflag is not set
                                            continue
                                        self.E4timex.append(txx)
                                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                            self.E4values.append(pos)
                                        else:
                                            self.E4values.append((pos*event_pos_factor)+event_pos_offset)
                                        E4_nonempty = True
                                        E4_last = i
                                        try:
                                            if not self.flagon and self.eventsGraphflag!=4 and self.specialeventannovisibilities[3] != 0:
                                                E4_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i)
                                                temp = self.E4values[-1]
                                                anno = self.ax.annotate(E4_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                            alpha=.9,
                                                            color=self.palette['text'],
                                                            va='bottom', ha='left',
                                                            fontproperties=eventannotationprop,
                                                            path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette['background'])],
                                                            )
                                                self.l_eventtype4annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                try:
                                                    overlap = self.checkOverlap(anno) #, i, E4_annotation)
                                                    if overlap:
                                                        anno.remove()
                                                except Exception: # pylint: disable=broad-except
                                                    pass
                                        except Exception as ex: # pylint: disable=broad-except
                                            _log.exception(ex)
                                            _, _, exc_tb = sys.exc_info()
                                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() anno {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                            E1x:List[Optional[float]]
                            E1y:List[Optional[float]]
                            E2x:List[Optional[float]]
                            E2y:List[Optional[float]]
                            E3x:List[Optional[float]]
                            E3y:List[Optional[float]]
                            E4x:List[Optional[float]]
                            E4y:List[Optional[float]]
                            if len(self.E1timex) > 0 and len(self.E1values) == len(self.E1timex):
                                pos = max(0,int(round((self.specialeventsvalue[E1_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        self.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E1_last]]):   #if cool exists and last event was earlier
                                    self.E1timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E1values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and self.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E1_last]]):   #if drop exists and last event was earlier
                                    self.E1timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E1values.append(pos) #repeat last event value
                                #TODO insert bbp values starting here # pylint: disable=fixme
                                E1x = list(self.E1timex) # E1x:List(Optional[float] while E1timex:List[float], but List is invariant
                                E1y = list(self.E1values)
                                if E1_CHARGE is not None and len(E1y)>1 and E1y[0] != E1_CHARGE:
                                    E1x = list([self.timex[self.timeindex[0]]] + E1x)
                                    E1y = list([E1_CHARGE] + E1y)
                                ds = 'steps-post'
                            else:
                                E1x = [None]
                                E1y = [None]
                                ds = 'steps-post'
                            self.l_eventtype1dots, = self.ax.plot(numpy.array(E1x), numpy.array(E1y), color=self.EvalueColor[0],
                                                                marker = (self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[0],
                                                                picker=True,
                                                                pickradius=4,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0],label=self.etypesf(0))
                            if len(self.E2timex) > 0 and len(self.E2values) == len(self.E2timex):
                                pos = max(0,int(round((self.specialeventsvalue[E2_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        self.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E2_last]]):   #if cool exists and last event was earlier
                                    self.E2timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E2values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and self.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E2_last]]):   #if drop exists and last event was earlier
                                    self.E2timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E2values.append(pos) #repeat last event value
                                E2x = list(self.E2timex)
                                E2y = list(self.E2values)
                                if E2_CHARGE is not None and len(E2y)>1 and E2y[0] != E2_CHARGE:
                                    E2x = list([self.timex[self.timeindex[0]]] + E2x)
                                    E2y = list([E2_CHARGE] + E2y)
                                ds = 'steps-post'
                            else:
                                E2x = [None]
                                E2y = [None]
                                ds = 'steps-post'
                            self.l_eventtype2dots, = self.ax.plot(numpy.array(E2x), numpy.array(E2y), color=self.EvalueColor[1],
                                                                marker = (self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[1],
                                                                picker=True,
                                                                pickradius=4,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1],label=self.etypesf(1))
                            if len(self.E3timex) > 0 and len(self.E3values) == len(self.E3timex):
                                pos = max(0,int(round((self.specialeventsvalue[E3_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        self.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E3_last]]):   #if cool exists and last event was earlier
                                    self.E3timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E3values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and self.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E3_last]]):   #if drop exists and last event was earlier
                                    self.E3timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E3values.append(pos) #repeat last event value
                                E3x = list(self.E3timex)
                                E3y = list(self.E3values)
                                if E3_CHARGE is not None and len(E3y)>1 and E3y[0] != E3_CHARGE:
                                    E3x = list([self.timex[self.timeindex[0]]] + E3x)
                                    E3y = list([E3_CHARGE] + E3y)
                                ds = 'steps-post'
                            else:
                                E3x = [None]
                                E3y = [None]
                                ds = 'steps-post'
                            self.l_eventtype3dots, = self.ax.plot(numpy.array(E3x), numpy.array(E3y), color=self.EvalueColor[2],
                                                                marker = (self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[2],
                                                                picker=True,
                                                                pickradius=4,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2],label=self.etypesf(2))
                            if len(self.E4timex) > 0 and len(self.E4values) == len(self.E4timex):
                                pos = max(0,int(round((self.specialeventsvalue[E4_last]-1)*10)))
                                if not self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    pos = (pos*event_pos_factor)+event_pos_offset
                                if self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and (self.timeindex[7] > 0 and
                                        self.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E4_last]]):   #if cool exists and last event was earlier
                                    self.E4timex.append(self.timex[self.timeindex[7]]) #time of cool
                                    self.E4values.append(pos) #repeat last event value
                                elif (self.timeindex[6] > 0 and self.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E4_last]]):   #if drop exists and last event was earlier
                                    self.E4timex.append(self.timex[self.timeindex[6]]) #time of drop
                                    self.E4values.append(pos) #repeat last event value
                                E4x = list(self.E4timex)
                                E4y = list(self.E4values)
                                if E4_CHARGE is not None and len(E4y)>1 and E4y[0] != E4_CHARGE:
                                    E4x = list([self.timex[self.timeindex[0]]] + E4x)
                                    E4y = list([E4_CHARGE] + E4y)
                                ds = 'steps-post'
                            else:
                                E4x = [None]
                                E4y = [None]
                                ds = 'steps-post'
                            self.l_eventtype4dots, = self.ax.plot(numpy.array(E4x), numpy.array(E4y), color=self.EvalueColor[3],
                                                                marker = (self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                                markersize = self.EvalueMarkerSize[3],
                                                                picker=True,
                                                                pickradius=4,#markevery=every,
                                                                linestyle='-',drawstyle=ds,linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3],label=self.etypesf(3))
                        if Nevents:
                            evalues:List[List[float]] = [[],[],[],[]]
                            if self.eventsGraphflag == 4:
                                # we prepare copies of the Evalues
                                evalues = [self.E1values[:],self.E2values[:],self.E3values[:],self.E4values[:]]
                            for i in range(Nevents):
                                event_idx = int(self.specialevents[i])
                                try:
                                    if self.specialeventstype[i] == 4 or self.eventsGraphflag in {0, 3, 4}:
                                        if self.specialeventstype[i] < 4 and (not self.renderEventsDescr or len(self.specialeventsStrings[i].strip()) == 0):
                                            etype = self.etypesf(self.specialeventstype[i])
                                            firstletter = self.etypeAbbrev(etype)
                                            secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                                            if self.aw.eventslidertemp[self.specialeventstype[i]]:
                                                thirdletter = self.mode # postfix
                                            else:
                                                thirdletter = self.aw.eventsliderunits[self.specialeventstype[i]] # postfix
                                        else:
                                            firstletter = self.specialeventsStrings[i].strip()[:self.eventslabelschars]
                                            if firstletter == '':
                                                firstletter = 'E'
                                            secondletter = ''
                                            thirdletter = ''
                                        height = 50 if self.mode == 'F' else 20

                                        #some times ET is not drawn (ET = 0) when using device NONE
                                        # plot events on BT when showeventsonbt is true
                                        tempo:Optional[float]
                                        if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[event_idx] > self.temp2[event_idx]):
                                            if self.flagon:
                                                tempo = self.temp1[event_idx]
                                            else:
                                                tempo = self.stemp1[event_idx]
                                        elif self.BTcurve:
                                            if self.flagon:
                                                tempo = self.temp2[event_idx]
                                            else:
                                                tempo = self.stemp2[event_idx]
                                        else:
                                            tempo = None

                                        if not self.flagstart and not self.foregroundShowFullflag and (((not self.autotimex or self.autotimexMode == 0) and event_idx < charge_idx) or event_idx > drop_idx):
                                            continue

                                        # combo events
                                        if self.eventsGraphflag == 4 and self.specialeventstype[i] < 4 and self.showEtypes[self.specialeventstype[i]] and len(evalues[self.specialeventstype[i]])>0:
                                            tempo = evalues[self.specialeventstype[i]][0]
                                            evalues[self.specialeventstype[i]] = evalues[self.specialeventstype[i]][1:]

                                        if tempo is not None and self.showEtypes[self.specialeventstype[i]]:
                                            if self.specialeventstype[i] == 0:
                                                boxstyle = 'roundtooth,pad=0.4'
                                                boxcolor = self.EvalueColor[0]
                                                textcolor = self.EvalueTextColor[0]
                                            elif self.specialeventstype[i] == 1:
                                                boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                                boxcolor = self.EvalueColor[1]
                                                textcolor = self.EvalueTextColor[1]
                                            elif self.specialeventstype[i] == 2:
                                                boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                                boxcolor = self.EvalueColor[2]
                                                textcolor = self.EvalueTextColor[2]
                                            elif self.specialeventstype[i] == 3:
                                                boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                                boxcolor = self.EvalueColor[3]
                                                textcolor = self.EvalueTextColor[3]
                                            #elif self.specialeventstype[i] == 4:
                                            else:
                                                boxstyle = 'square,pad=0.1'
                                                boxcolor = self.palette['specialeventbox']
                                                textcolor = self.palette['specialeventtext']
                                            if self.eventsGraphflag in {0, 3} or self.specialeventstype[i] > 3:
                                                xytext: Tuple[float, float]
                                                if i in self.l_event_flags_pos_dict:
                                                    xytext = self.l_event_flags_pos_dict[i]
                                                elif i in self.l_event_flags_dict:
                                                    xytext = self.l_event_flags_dict[i].xyann
                                                else:
                                                    xytext = (self.timex[event_idx],tempo+height)
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[event_idx], tempo),
                                                             xytext=xytext,
                                                             alpha=0.9,
                                                             color=textcolor,
                                                             va='center', ha='center',
                                                             arrowprops={'arrowstyle':'-','color':boxcolor,'alpha':0.4}, # ,relpos=(0,0)
                                                             bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none'},
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                    anno.draggable(use_blit=True)
                                                    anno.set_picker(self.aw.draggable_text_box_picker)
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                                # register draggable flag annotation to be re-created after re-positioning on redraw
                                                self.l_event_flags_dict[i] = anno
                                                if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[event_idx] > self.temp2[event_idx]):
                                                    self.l_eteventannos.append(anno)
                                                else:
                                                    self.l_bteventannos.append(anno)
                                                self.l_eventflagannos.append(anno)
                                            elif self.eventsGraphflag == 4:
                                                if thirdletter != '':
                                                    firstletter = ''
                                                anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timex[event_idx], tempo),
                                                             xytext=(self.timex[event_idx],tempo),
                                                             alpha=0.9,
                                                             color=textcolor,
                                                             va='center', ha='center',
                                                             bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none'},
                                                             fontproperties=fontprop_small,
                                                             path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                             )
                                                if self.specialeventstype[i] == 0:
                                                    self.l_eventtype1annos.append(anno)
                                                elif self.specialeventstype[i] == 1:
                                                    self.l_eventtype2annos.append(anno)
                                                elif self.specialeventstype[i] == 2:
                                                    self.l_eventtype3annos.append(anno)
                                                elif self.specialeventstype[i] == 3:
                                                    self.l_eventtype4annos.append(anno)
                                                try:
                                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                                    pass
                                except Exception as e: # pylint: disable=broad-except
                                    _log.exception(e)

                    #plot delta ET (self.delta1) and delta BT (self.delta2)
                    ##### DeltaET,DeltaBT curves
                    if (self.DeltaETflag or self.DeltaBTflag) and self.delta_ax is not None:
                        trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                        # if not recording or if during recording CHARGE was set already
                        if ((not self.flagon or self.timeindex[0] > 1) and
                                len(self.timex) == len(self.delta1) and len(self.timex) == len(self.delta2) and len(self.timex)>charge_idx+2):
                            # to avoid drawing of RoR artifacts directly after CHARGE we skip the first few samples after CHARGE before starting to draw
                            # as well as the last two readings before DROP
                            skip = max(2,min(20,int(round(5000/self.delay))))
                            skip2 = max(2,int(round(skip/2)))
                            if self.swapdeltalcds:
                                self.drawDeltaET(trans,charge_idx+skip,drop_idx-skip2)
                                self.drawDeltaBT(trans,charge_idx+skip,drop_idx-skip2)
                            else:
                                self.drawDeltaBT(trans,charge_idx+skip,drop_idx-skip2)
                                self.drawDeltaET(trans,charge_idx+skip,drop_idx-skip2)
                        else:
                            # instead of drawing we still have to establish the self.ax artists to keep the linecount correct!
                            self.drawDeltaET(trans,0,0)
                            self.drawDeltaBT(trans,0,0)

                    if self.delta_ax is not None and two_ax_mode:
                        self.aw.autoAdjustAxis(timex=False)
                        self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                        if self.zgrid > 0:
                            self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                            self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            delta_major_tick_lines:List[Line2D] = self.delta_ax.get_yticklines()
                            for ytl in delta_major_tick_lines:
                                ytl.set_markersize(10)
                            delta_minor_tick_lines:List[Line2D] = self.delta_ax.yaxis.get_minorticklines()
                            for mtl in delta_minor_tick_lines:
                                mtl.set_markersize(5)
                            for label in self.delta_ax.get_yticklabels() :
                                label.set_fontsize('small')
                            if not self.LCDdecimalplaces:
                                self.delta_ax.minorticks_off()

                    ##### Extra devices-curves
                    for l in self.extratemp1lines + self.extratemp2lines:
                        try:
                            if l is not None:
                                l.remove()
                        except Exception: # pylint: disable=broad-except
                            pass
                    self.extratemp1lines,self.extratemp2lines = [],[]
                    for i in range(min(
                            len(self.extratimex),
                            len(self.extratemp1),
                            len(self.extradevicecolor1),
                            len(self.extraname1),
                            len(self.extratemp2),
                            len(self.extradevicecolor2),
                            len(self.extraname2))):
                        if self.extratimex[i] is not None and self.extratimex[i] and len(self.extratimex[i])>1:
                            timexi_lin = numpy.linspace(self.extratimex[i][0],self.extratimex[i][-1],len(self.extratimex[i]))
                        else:
                            timexi_lin = None
                        try:
                            if self.aw.extraCurveVisibility1[i]:
                                if not self.flagon and (re_smooth_foreground or len(self.extrastemp1[i]) != len(self.extratimex[i])):
                                    self.extrastemp1[i] = self.smooth_list(self.extratimex[i],
                                        (fill_gaps(self.extratemp1[i]) if self.interpolateDropsflag else self.extratemp1[i]),
                                        window_len=self.curvefilter,
                                        decay_smoothing=decay_smoothing_p,
                                        a_lin=timexi_lin,
                                        delta=False).tolist()
                                elif self.interpolateDropsflag: # we don't smooth, but remove the dropouts
                                    self.extrastemp1[i] = fill_gaps(self.extratemp1[i])
                                if self.aw.extraDelta1[i] and self.delta_ax is not None:
                                    trans = self.delta_ax.transData
                                else:
                                    trans = self.ax.transData
                                visible_extratemp1 : npt.NDArray[numpy.double]
                                if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and len(self.extrastemp1[i]) > 0:
                                    visible_extratemp1 = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        numpy.array(self.extrastemp1[i][charge_idx:drop_idx+1]),
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and len(self.extrastemp1[i]) > 0:
                                    visible_extratemp1 = numpy.concatenate((
                                        numpy.array(self.extrastemp1[i][0:drop_idx+1]),
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    visible_extratemp1 = numpy.array(self.extrastemp1[i], dtype=numpy.double)
                                # first draw the fill if any, but not during recording!
                                if not self.flagstart and self.aw.extraFill1[i] > 0:
                                    self.ax.fill_between(self.extratimex[i], 0, visible_extratemp1,transform=trans,color=self.extradevicecolor1[i],alpha=self.aw.extraFill1[i]/100.,sketch_params=None)
                                self.extratemp1lines.append(self.ax.plot(self.extratimex[i],visible_extratemp1,transform=trans,color=self.extradevicecolor1[i],
                                    sketch_params=None,
                                    path_effects=self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.extralinewidths1[i],self.extradevicecolor1[i]),
                                    markersize=self.extramarkersizes1[i],
                                    marker=self.extramarkers1[i],
                                    linewidth=self.extralinewidths1[i],
                                    linestyle=self.extralinestyles1[i],
                                    drawstyle=self.extradrawstyles1[i],
                                    label=extraname1_subst[i])[0])
                        except Exception as ex: # pylint: disable=broad-except
                            _log.exception(ex)
                            _, _, exc_tb = sys.exc_info()
                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                        try:
                            if self.aw.extraCurveVisibility2[i]:
                                if not self.flagon and (re_smooth_foreground or len(self.extrastemp2[i]) != len(self.extratimex[i])):
                                    self.extrastemp2[i] = self.smooth_list(self.extratimex[i],
                                        (fill_gaps(self.extratemp2[i]) if self.interpolateDropsflag else self.extratemp2[i]),
                                        window_len=self.curvefilter,
                                        decay_smoothing=decay_smoothing_p,
                                        a_lin=timexi_lin,
                                        delta=False).tolist()
                                elif self.interpolateDropsflag:
                                    self.extrastemp2[i] = fill_gaps(self.extratemp2[i])
                                if self.aw.extraDelta2[i] and self.delta_ax is not None:
                                    trans = self.delta_ax.transData
                                else:
                                    trans = self.ax.transData
                                visible_extratemp2 : npt.NDArray[numpy.double]
                                if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0) and len(self.extrastemp2[i]) > 0:
                                    visible_extratemp2 = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        numpy.array(self.extrastemp2[i][charge_idx:drop_idx+1]),
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0 and len(self.extrastemp2[i]) > 0:
                                    visible_extratemp2 = numpy.concatenate((
                                        numpy.array(self.extrastemp2[i][0:drop_idx+1]),
                                        numpy.full(len(self.extratimex[i])-drop_idx-1, numpy.nan, dtype=numpy.double)))
                                else:
                                    visible_extratemp2 = numpy.array(self.extrastemp2[i], dtype=numpy.double)
                                # first draw the fill if any
                                if not self.flagstart and self.aw.extraFill2[i] > 0:
                                    self.ax.fill_between(self.extratimex[i], 0, visible_extratemp2,transform=trans,color=self.extradevicecolor2[i],alpha=self.aw.extraFill2[i]/100.,sketch_params=None)
                                self.extratemp2lines.append(self.ax.plot(self.extratimex[i],visible_extratemp2,transform=trans,color=self.extradevicecolor2[i],
                                    sketch_params=None,
                                    path_effects=self.line_path_effects(self.glow, self.patheffects, self.aw.light_background_p, self.extralinewidths2[i],self.extradevicecolor2[i]),
                                    markersize=self.extramarkersizes2[i],
                                    marker=self.extramarkers2[i],
                                    linewidth=self.extralinewidths2[i],
                                    linestyle=self.extralinestyles2[i],
                                    drawstyle=self.extradrawstyles2[i],
                                    label= extraname2_subst[i])[0])
                        except Exception as ex: # pylint: disable=broad-except
                            _log.exception(ex)
                            _, _, exc_tb = sys.exc_info()
                            self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                    ##### ET,BT curves
                    visible_et : npt.NDArray[numpy.double]
                    visible_bt : npt.NDArray[numpy.double]
                    if not self.flagstart and not self.foregroundShowFullflag and (not self.autotimex or self.autotimexMode == 0):
                        visible_et = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        numpy.array(self.stemp1[charge_idx:drop_idx+1]),
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                        visible_bt = numpy.concatenate((
                                        numpy.full(charge_idx, numpy.nan, dtype=numpy.double),
                                        numpy.array(self.stemp2[charge_idx:drop_idx+1]),
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                    elif not self.flagstart and not self.foregroundShowFullflag and self.autotimex and self.autotimexMode != 0:
                        visible_et = numpy.concatenate((
                                        numpy.array(self.stemp1[0:drop_idx+1]),
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                        visible_bt = numpy.concatenate((
                                        numpy.array(self.stemp2[0:drop_idx+1]),
                                        numpy.full(len(self.timex)-drop_idx-1, numpy.nan, dtype=numpy.double)))
                    else:
                        visible_et = numpy.array(self.stemp1)
                        visible_bt = numpy.array(self.stemp2)

                    if self.swaplcds:
                        self.drawET(visible_et)
                        self.drawBT(visible_bt)
                    else:
                        self.drawBT(visible_bt)
                        self.drawET(visible_et)

                    if self.ETcurve and self.l_temp1 is not None:
                        self.handles.append(self.l_temp1)
                        self.labels.append(self.aw.arabicReshape(self.aw.ETname))
                    if self.BTcurve and self.l_temp2 is not None:
                        self.handles.append(self.l_temp2)
                        self.labels.append(self.aw.arabicReshape(self.aw.BTname))

                    if self.DeltaETflag and self.l_delta1 is not None:
                        self.handles.append(self.l_delta1)
                        if self.aw.locale_str in {'ar', 'fa'}:
                            self.labels.append(f'{self.aw.arabicReshape(self.aw.ETname)}{deltaLabelMathPrefix}')
                        else:
                            self.labels.append(f'{deltaLabelMathPrefix}{self.aw.ETname}')
                    if self.DeltaBTflag and self.l_delta2 is not None:
                        self.handles.append(self.l_delta2)
                        if self.aw.locale_str in {'ar', 'fa'}:
                            self.labels.append(f'{self.aw.arabicReshape(self.aw.BTname)}{deltaLabelMathPrefix}')
                        else:
                            self.labels.append(f'{deltaLabelMathPrefix}{self.aw.BTname}')

                    nrdevices = len(self.extradevices)

                    if nrdevices and not self.designerflag:
                        xtmpl1idx = 0
                        xtmpl2idx = 0
                        for i in range(nrdevices):
                            if self.aw.extraCurveVisibility1[i]:
                                idx1 = xtmpl1idx
                                xtmpl1idx = xtmpl1idx + 1
                                l1 = extraname1_subst[i]
                                if not l1.startswith('_'):
                                    self.handles.append(self.extratemp1lines[idx1])
                                    try:
                                        self.labels.append(self.aw.arabicReshape(l1.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3],self.mode)))
                                    except Exception: # pylint: disable=broad-except
                                        # a key error can occur triggered by the format if curley braces are used without reference
                                        self.labels.append(self.aw.arabicReshape(l1))
                            if self.aw.extraCurveVisibility2[i]:
                                idx2 = xtmpl2idx
                                xtmpl2idx = xtmpl2idx + 1
                                l2 = extraname2_subst[i]
                                if not l2.startswith('_'):
                                    self.handles.append(self.extratemp2lines[idx2])
                                    try:
                                        self.labels.append(self.aw.arabicReshape(l2.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3],self.mode)))
                                    except Exception: # pylint: disable=broad-except
                                        # a key error can occur triggered by the format if curley braces are used without reference
                                        self.labels.append(self.aw.arabicReshape(l2))

                    if self.eventsshowflag != 0 and self.eventsGraphflag in {2, 3, 4} and Nevents:
                        if E1_nonempty and self.showEtypes[0] and self.l_eventtype1dots is not None:
                            self.handles.append(self.l_eventtype1dots)
                            self.labels.append(self.aw.arabicReshape(self.etypesf(0)))
                        if E2_nonempty and self.showEtypes[1] and self.l_eventtype2dots is not None:
                            self.handles.append(self.l_eventtype2dots)
                            self.labels.append(self.aw.arabicReshape(self.etypesf(1)))
                        if E3_nonempty and self.showEtypes[2] and self.l_eventtype3dots is not None:
                            self.handles.append(self.l_eventtype3dots)
                            self.labels.append(self.aw.arabicReshape(self.etypesf(2)))
                        if E4_nonempty and self.showEtypes[3] and self.l_eventtype4dots is not None:
                            self.handles.append(self.l_eventtype4dots)
                            self.labels.append(self.aw.arabicReshape(self.etypesf(3)))

                    if not self.designerflag:
                        if self.BTcurve or self.ETcurve:
                            if self.BTcurve:
                                temp_curve = self.temp2
                                stemp_curve_foreground = self.stemp2
                            else:
                                temp_curve = self.temp1
                                stemp_curve_foreground = self.stemp1
                            if self.flagstart: # no smoothed lines in this case, pass normal BT
                                self.l_annotations = self.place_annotations(
                                    self.TPalarmtimeindex,
                                    self.ylimit - self.ylimit_min,
                                    self.timex,self.timeindex,
                                    temp_curve, temp_curve)
                            else:
                                TP_index = self.aw.findTP()
                                if self.annotationsflag != 0:
                                    self.l_annotations = self.place_annotations(
                                        TP_index,self.ylimit - self.ylimit_min,
                                        self.timex,
                                        self.timeindex,
                                        temp_curve,
                                        stemp_curve_foreground)
                                if self.timeindex[6]:
                                    self.writestatistics(TP_index)
                            #add the time and temp annotations to the bt list
                            for x in self.l_annotations:
                                self.l_bteventannos.append(x)
                        elif self.timeindex[6]:
                            TP_index = self.aw.findTP()
                            self.writestatistics(TP_index)

                    if not self.flagon and self.timeindex[6] and self.AUCshowFlag:
                        self.drawAUC()
                    #update label rotating_colors
                    for label in self.ax.xaxis.get_ticklabels():
                        label.set_color(self.palette['xlabel'])
                    for label in self.ax.yaxis.get_ticklabels():
                        label.set_color(self.palette['ylabel'])
                    if two_ax_mode and self.delta_ax is not None:
                        for label in self.delta_ax.yaxis.get_ticklabels():
                            label.set_color(self.palette['ylabel'])

                    #write legend
                    if self.legendloc and not self.flagon and len(self.timex) > 2:
                        prop = self.aw.mpl_fontproperties.copy()
                        prop.set_size('x-small')
                        if len(self.handles) > 7:
                            ncol = int(math.ceil(len(self.handles)/4.))
                        elif len(self.handles) > 3:
                            ncol = int(math.ceil(len(self.handles)/2.))
                        else:
                            ncol = int(math.ceil(len(self.handles)))
                        self.labels = [self.__dijkstra_to_ascii(l) for l in self.labels]
                        loc:Union[int, Tuple[float,float]]
                        if self.legend is None:
                            if self.legendloc_pos is None:
                                loc = self.legendloc # a position selected in the axis dialog
                            else:
                                loc = self.legendloc_pos # a user define legend position set by drag-and-drop
                        else:
                            loc = self.legend._loc # type: ignore # "Legend" has no attribute "_loc" # pylint: disable=protected-access
                        try:
                            try:
                                leg = self.ax.legend(self.handles,self.labels, loc=loc,
                                    ncols=ncol,fancybox=True,prop=prop,shadow=False,frameon=True)
                            except Exception: # pylint: disable=broad-except
                                # ncol keyword argument to legend renamed to ncols in MPL 3.6, thus for older MPL versions we need to still use ncol
                                leg = self.ax.legend(self.handles,self.labels,loc=loc,ncol=ncol,fancybox=True,prop=prop,shadow=False,frameon=True)
                            try:
                                leg.set_in_layout(False) # remove legend from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                                pass
                            self.legend = leg
                            self.legend_lines = leg.get_lines()
                            try:
                                # for mpl>=3.9
                                for h in leg.legend_handles:
                                    if h is not None:
                                        h.set_picker(False) # we disable the click to hide on the handles feature
                            except Exception: # pylint: disable=broad-except # leg.legendHandles renamed in mpl 3.9 into leg.legend_handles
                                # for mpl <3.9:
                                for h in leg.legendHandles: # type:ignore[attr-defined]
                                    if h is not None:
                                        h.set_picker(False) # we disable the click to hide on the handles feature
                            for ll in leg.texts:
                                #l.set_picker(5)
                                ll.set_picker(self.aw.draggable_text_box_picker)
                            try:
                                leg.set_draggable(state=True,use_blit=True)  #,update='bbox')
                                leg.set_picker(self.aw.draggable_text_box_picker)
                            except Exception: # pylint: disable=broad-except # not available in mpl<3.x
                                leg.draggable(state=True) # type: ignore # for mpl 2.x
                            frame = leg.get_frame()
                            frame.set_facecolor(self.palette['legendbg'])
                            frame.set_alpha(self.alpha['legendbg'])
                            frame.set_edgecolor(self.palette['legendborder'])
                            frame.set_linewidth(0.5)
                            for line,text in zip(leg.get_lines(), leg.get_texts()):
                                text.set_color(line.get_color())
                        except Exception as e: # pylint: disable=broad-except
                            _log.error(e)

                    else:
                        self.legend = None

                    # we create here the project line plots to have the accurate time axis after CHARGE
                    dashes_setup = [0.4,0.8,0.1,0.8] # simulating matplotlib 1.5 default on 2.0

                    if not self.flagon and self.timeindex[6] and self.statssummary:
                        self.statsSummary()
                    else:
                        self.stats_summary_rect = None

                    #watermark image
                    self.placelogoimage()
                finally:
                    if self.updateBackgroundSemaphore.available() < 1:
                        self.updateBackgroundSemaphore.release(1)

                # add projection and AUC guide lines last as those are removed by updategraphics for optimized redrawing and not cached
                if self.ETprojectFlag:
                    if self.ETcurve:
                        self.l_ETprojection, = self.ax.plot(self.ETprojection_tx, self.ETprojection_temp,color = self.palette['et'],
                                                    dashes=dashes_setup,
                                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'ETprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                    if self.projectDeltaFlag and self.DeltaETflag and self.delta_ax is not None:
                        trans = self.delta_ax.transData
                        self.l_DeltaETprojection, = self.ax.plot(self.DeltaETprojection_tx, self.DeltaETprojection_temp,color = self.palette['deltaet'],
                                                    dashes=dashes_setup,
                                                    transform=trans,
                                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'DeltaETprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                if self.BTprojectFlag:
                    if self.BTcurve:
                        self.l_BTprojection, = self.ax.plot(self.BTprojection_tx, self.BTprojection_temp,color = self.palette['bt'],
                                                    dashes=dashes_setup,
                                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'BTprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                    if self.projectDeltaFlag and self.DeltaBTflag and self.delta_ax is not None:
                        trans = self.delta_ax.transData
                        self.l_DeltaBTprojection, = self.ax.plot(self.DeltaBTprojection_tx, self.DeltaBTprojection_temp,color = self.palette['deltabt'],
                                                    dashes=dashes_setup,
                                                    transform=trans,
                                                    label=self.aw.arabicReshape(QApplication.translate('Label', 'DeltaBTprojection')),
                                                    linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                if (self.device == 18 and self.aw.simulator is None) or self.showtimeguide: # not NONE device
                    self.l_timeline = self.ax.axvline(self.timeclock.elapsedMilli(),color = self.palette['timeguide'],
                                            label=self.aw.arabicReshape(QApplication.translate('Label', 'TIMEguide')),
                                            visible=self.flagstart,
                                            linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])
                if self.AUCguideFlag:
                    self.l_AUCguide = self.ax.axvline(self.AUCguideTime,visible=(self.AUCguideTime > 0 and self.AUCguideTime < self.endofx),color = self.palette['aucguide'],
                                                label=self.aw.arabicReshape(QApplication.translate('Label', 'AUCguide')),
                                                linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])

                ############  ready to plot ############
                self.updateBackground() # update bitlblit backgrounds
                #######################################

            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message','Exception:') + ' redraw() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                # we initialize at the end of the redraw the event and flag annotation custom position loaded from a profile as those should have been consumed by now
                self.l_annotations_pos_dict = {}
                self.l_event_flags_pos_dict = {}
                self.legendloc_pos = None
                if takelock and self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)

                self.setProfileBackgroundTitle(titleB)

                # to allow the fit_title to work on the proper value we ping the redraw explicitly again after processing events
                # we need to use draw_idle here to allow Qt for relayout event processing
                # calling QApplication.processEvents() is not an option here as the event loop might not have been started yet
                # alternatively one could call canvas.draw() using a QTimer.singleShot(self.fig.canvas.draw())

                # also the background title set above is not always redrawn and sometimes requires a window resiize to trigger the redraw without the draw_idle() below

                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw_idle()

    def checkOverlap(self, anno:'Annotation') -> bool:
        if self.ax is None:
            return False
        overlapallowed = max(0,min(self.overlappct,100))/100  #the input is validated but this here to prevent any escapes
        overlap = False
        try:
            annocorners = self.annoboxCorners(anno)
            anno_x = anno.get_unitless_position()[0]
            ax_xlim = self.ax.get_xlim()
            # if annotation is off canvas, the display coordinates are not reliable thus we exclude this one from the check
            if anno_x < ax_xlim[0] or anno_x > ax_xlim[1]:
                #_log.debug('Event annotation off canvas: %s, ax_xlim=%s', anno,ax_xlim)
                return False
            xl = annocorners[0]
            xr = annocorners[1]
            yl = annocorners[2]
            yu = annocorners[3]
            area = (xr - xl) * (yu - yl)
            for ol in self.overlapList:
                o_xl = ol[0]
                o_xr = ol[1]
                o_yl = ol[2]
                o_yu = ol[3]
                o_area = (o_xr - o_xl) * (o_yu - o_yl)
                dx = min(xr, o_xr) - max(xl, o_xl)
                dy = min(yu, o_yu) - max(yl, o_yl)
                if (dx>=0) and (dy>=0) and dx*dy/min(area,o_area) > overlapallowed:
                    overlap = True
                    break
            if not overlap:
                # note to self, the eventno and annotext can be removed from the list.
                self.overlapList.append((xl,xr,yl,yu))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' checkOverlap() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return overlap

    def annoboxCorners(self, anno:'Annotation') -> Tuple[float,float,float,float]:
        if self.ax is None:
            return 0,0,0,0
        f = self.ax.get_figure()
        if f is None:
            return 0,0,0,0
        r = None
        try:
            r = f.canvas.get_renderer() # type: ignore # this can fail for PDF generation with 'FigureCanvasPdf' object has no attribute 'get_renderer'
        except Exception: # pylint: disable=broad-except
            pass
        if r is not None:
            anno.update_bbox_position_size(renderer=r)
            bb = anno.get_window_extent(renderer=r) # bounding box in display space
            bbox_data = self.ax.transData.inverted().transform(bb)
            bbox = Bbox(bbox_data) # x0, y0, width, height
            return (bbox.bounds[0],bbox.bounds[0]+bbox.bounds[2],bbox.bounds[1],bbox.bounds[1]+bbox.bounds[3])  # x0, x1, y0, y1
        return 0,0,0,0

    def parseSpecialeventannotation(self, eventanno:str, eventnum:int, applyto:str = 'foreground', postFCs:bool = False) -> str:
        try:
            #background curve values
            if applyto == 'background':
                e = self.backgroundEvalues[eventnum]
                y1 = str(float2float(self.temp1B[self.backgroundEvents[eventnum]],self.LCDdecimalplaces))
                y2 = str(float2float(self.temp2B[self.backgroundEvents[eventnum]],self.LCDdecimalplaces))
                try:
                    d1b = self.delta1B[self.backgroundEvents[eventnum]]
                    delta1 = str(float2float(d1b)) if d1b is not None else '--'
                except Exception: # pylint: disable=broad-except
                    delta1 = '\u03C5\u03c5'
                try:
                    d2b = self.delta2B[self.backgroundEvents[eventnum]]
                    delta2 = str(float2float(d2b)) if d2b is not None else '--'
                except Exception: # pylint: disable=broad-except
                    delta2 = '\u03C5\u03c5'
                descr = str(self.backgroundEStrings[eventnum])
                etype = str(self.Betypes[self.backgroundEtypes[eventnum]])
                sliderunit = str(self.aw.eventsliderunits[self.backgroundEtypes[eventnum]])

                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] > self.timeB[self.timeindexB[2]]:
                    postFCs = True
                    dtr = str(float2float(100 * (self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]]) / (self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[0]]),1))
                else:
                    postFCs = False
                    dtr = '0'
                if self.timeindexB[2] > 0:
                    _dfcs = float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]],0)
                    dfcs = str(_dfcs)
                    dfcs_ms = stringfromseconds(_dfcs,False)
                else:
                    dfcs = '*'
                    dfcs_ms = '*'
                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] < self.timeB[self.timeindexB[2]]:
                    _prefcs = float2float(self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]],0)
                    prefcs = str(_prefcs)
                    prefcs_ms = stringfromseconds(_prefcs,False)
                else:
                    prefcs = '*'
                    prefcs_ms = '*'
                if self.timeindexB[0] > -1:
                    _dcharge = float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[0]],0)
                    dcharge = str(_dcharge)
                    dcharge_ms = stringfromseconds(_dcharge,False)
                else:
                    dcharge = '*'
                    dcharge_ms = '*'
                fcsWindow = not postFCs and (self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]]) < 90

            # plug values for the previews
            elif applyto == 'preview':
                if eventnum == 1:
                    e = 8.0  #70
                if eventnum == 2:
                    e = 8.0  #70
                e = 7.0 if eventnum == 3 else 6.0
                y1 = '420' if self.mode=='F' else '210'
                y2 = '340' if self.mode=='F' else '170'
                delta1 = '18.2' if self.mode=='F' else '9.1'
                delta2 = '33.4' if self.mode=='F' else '16.2'
                descr = 'Full'
                etype = 'Air'
                sliderunit = 'kPa'
                dcharge = '340' if self.mode=='F' else '170'
                dcharge_ms = stringfromseconds(int(dcharge))
                dfcs = '47'
                dfcs_ms = stringfromseconds(int(dfcs))
                prefcs = '50'
                prefcs_ms = stringfromseconds(int(prefcs))
                dtr = '12'
                fcsWindow = not bool(postFCs)
                #postFCs supplied in the parseSpecialeventannotation() call

            # foreground curve values
            else:
                e = self.specialeventsvalue[eventnum]
                y1 = str(float2float(self.temp1[self.specialevents[eventnum]],self.LCDdecimalplaces))
                y2 = str(float2float(self.temp2[self.specialevents[eventnum]],self.LCDdecimalplaces))
                try:
                    d1 = self.delta1[self.specialevents[eventnum]]
                    delta1 = str(float2float(d1)) if d1 is not None else '--'
                except Exception: # pylint: disable=broad-except
                    delta1 = '\u03C5\u03c5'
                try:
                    d2 = self.delta2[self.specialevents[eventnum]]
                    delta2 = str(float2float(d2)) if d2 is not None else '--'
                except Exception: # pylint: disable=broad-except
                    delta2 = '\u03C5\u03c5'
                descr = str(self.specialeventsStrings[eventnum])
                etype = str(self.etypes[self.specialeventstype[eventnum]])
                sliderunit = str(self.aw.eventsliderunits[self.specialeventstype[eventnum]])

                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] > self.timex[self.timeindex[2]]:
                    postFCs = True
                    dtr = str(float2float(100 * (self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]]) / (self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[0]]),1))
                else:
                    postFCs = False
                    dtr = '0'
                if self.timeindex[2] > 0:
                    _dfcs = float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]],0)
                    dfcs = str(_dfcs)
                    dfcs_ms = stringfromseconds(_dfcs,False)
#                    print(f'{dfcs_ms=}')
                else:
                    dfcs = '*'
                    dfcs_ms = '*'
                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] < self.timex[self.timeindex[2]]:
                    _prefcs = float2float(self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]],0)
                    prefcs = str(_prefcs)
                    prefcs_ms = stringfromseconds(_prefcs,False)
                else:
                    prefcs = '*'
                    prefcs_ms = '*'
                if self.timeindex[0] > -1:
                    _dcharge = float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[0]],0)
                    dcharge = str(_dcharge)
                    dcharge_ms = stringfromseconds(_dcharge,False)
                else:
                    dcharge = '*'
                    dcharge_ms = '*'
                fcsWindow = not postFCs and self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]] < 90

            # Caution - the event field "E" is position dependent and must be the first entry in the fields list
            fields = [
                ('E', str(self.eventsInternal2ExternalValue(e))),
                ('Y1', y1),
                ('Y2', y2),
                ('descr', descr),
                ('type', etype),
                ('sldrunit', sliderunit),
                ('dCHARGE_ms', dcharge_ms),
                ('dFCs_ms', dfcs_ms),
                ('dCHARGE', dcharge),
                ('dFCs', dfcs),
                ('preFCs_ms', prefcs_ms),
                ('preFCs', prefcs),
                ('DTR', dtr),
                ('mode', self.mode),
                ('degmode', f'\u00b0{self.mode}'),
                ('degmin', f'\u00b0{self.mode}/min'),
                ('deg', '\u00b0'),
                ('R1degmin', f'{delta1}\u00b0{self.mode}/min'),
                ('R2degmin', f'{delta2}\u00b0{self.mode}/min'),
                ('R1', delta1),
                ('R2', delta2),
                ('squot', "'"),
                ('quot', '"'),
                ]

            fieldDelim = '~'
            #delimiter to show before FCs only
            preFCsDelim = "'"
            #delimiter to show after FCs only
            postFCsDelim = '"'
            #delimiter to show within a window before FCs only
            fcsWindowDelim = '`'
            #delimiter for explicit value substitutions
            nominalDelimopen = '{'
            nominalDelimclose = '}'
            nominalstringDelim = '|'
            _ignorecase = re.IGNORECASE  # @UndefinedVariable

            #newlines can sneak in from cut and paste from help page
            eventanno = eventanno.replace('\n', '')

            #text between single quotes ' will show only before FCs

            eventanno = re.sub(fr'{preFCsDelim}([^{preFCsDelim}]+){preFCsDelim}',
                r'\1',eventanno) if not postFCs else re.sub(fr'{preFCsDelim}([^{preFCsDelim}]+){preFCsDelim}',
                r'',eventanno)
            #text between double quotes " will show only after FCs
            eventanno = re.sub(fr'{postFCsDelim}([^{postFCsDelim}]+){postFCsDelim}',
                r'\1',eventanno) if postFCs else re.sub(fr'{postFCsDelim}([^{postFCsDelim}]+){postFCsDelim}',
                r'',eventanno)

            #text between back ticks ` will show only within 90 seconds before FCs
            eventanno = re.sub(fr'{fcsWindowDelim}([^{fcsWindowDelim}]+){fcsWindowDelim}',
                r'\1',eventanno) if (fcsWindow) else re.sub(fr'{fcsWindowDelim}([^{fcsWindowDelim}]+){fcsWindowDelim}',
                r'',eventanno)

            # substitute numeric to nominal values if in the annotationstring
            #
            # Caution - the event field "E" is position dependent and must be the first entry in the fields list
            # The event field E is implied in the Annotation string which should take the following form.  Enclosed by
            #    curly brackets, entries consist of a value followed immediately (no space) by a text string.  Entries are
            #    separated by a vertical bar '|'.
            #   {20Fresh Cut Grass|50Hay|80Baking Bread|100A Point}
            # Event values that do not match any value in the Annotation string return an empty string ''.
            #
            ##debug - things to watch out for in testing:
            # does the matchedgroup(4) always persist after the pattern.sub() above?
            # does the pattern.split always result in the same list pattern?  ex:
            #     ['', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '|', '100', 'A Point', '']
#            pattern = re.compile(r'.*{ndo}(?P<nominalstr>[^{ndc}]+){ndc}'.format(ndo=nominalDelimopen,ndc=nominalDelimclose),_ignorecase)
            pattern = re.compile(fr'.*{nominalDelimopen}(?P<nominalstr>[^{nominalDelimclose}]+){nominalDelimclose}',_ignorecase)
            matched = pattern.match(eventanno)
            if matched is not None:
                pattern = re.compile(r'([0-9]+)([A-Za-z]+[A-Za-z 0-9]+)',_ignorecase)
                matches = pattern.split(matched.group('nominalstr'))
                #example form of the matches list ['', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '']
                replacestring = ''
                j = 1
                while j < len(matches):
                    if fields[0][1] == matches[j]:
                        replacestring = matches[j+1]
                        break
                    j += 3
#                pattern = re.compile(r'({ndo}[^{ndc}]+{ndc})'.format(ndo=nominalDelimopen,ndc=nominalDelimclose))
                pattern = re.compile(fr'({nominalDelimopen}[^{nominalDelimclose}]+{nominalDelimclose})')
                eventanno = pattern.sub(replacestring,eventanno)

            # make all the remaining substitutions
            for field in fields:
#                pattern = re.compile(r'(.*{})({})(?P<mathop>[/*+-][0-9.]+)?(({}[0-9]+[A-Za-z]+[A-Za-z 0-9]+)+)?'.format(
#                    fieldDelim,field[0],nominalstringDelim),_ignorecase)
                pattern = re.compile(fr'(.*{fieldDelim})({field[0]})(?P<mathop>[/*+-][0-9.]+)?(({nominalstringDelim}[0-9]+[A-Za-z]+[A-Za-z 0-9]+)+)?',_ignorecase)
                matched = pattern.match(eventanno)
                if matched is not None:

                    # get the value associated with the field
                    replacestring = str(field[1])
                    # do simple math if an operator is in the string
                    if matched.group('mathop') is not None:
                        replacestring += matched.group('mathop')
                        replacestring = str(float2float(eval(replacestring),1)) # pylint: disable=eval-used

                    pattern = re.compile(fr'{fieldDelim}{field[0]}([/*+-][0-9.]+)?',_ignorecase)
                    eventanno = pattern.sub(replacestring,eventanno)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' parseSpecialeventannotation() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            eventanno = ''

        return eventanno

    #watermark image
    def placelogoimage(self) -> None:
        if (self.flagon and self.aw.logoimgflag) or self.ax is None:  #if hide during roast
            return
        try:
            if len(self.aw.logofilename) == 0 or self.logoimg is None:
                return
            img_height_pixels, img_width_pixels, _ = self.logoimg.shape
            img_aspect = img_height_pixels / img_width_pixels
            coord_axes_middle_Display = self.ax.transAxes.transform((.5,.5))
            coord_axes_upperright_Display = self.ax.transAxes.transform((1.,1.))
            coord_axes_lowerleft_Display = self.ax.transAxes.transform((0.,0.))
            coord_axes_height_pixels = float(coord_axes_upperright_Display[1]) - float(coord_axes_lowerleft_Display[1])
            coord_axes_width_pixels = float(coord_axes_upperright_Display[0]) - float(coord_axes_lowerleft_Display[0])
            coord_axes_aspect = coord_axes_height_pixels / coord_axes_width_pixels
            if img_aspect >= coord_axes_aspect:
                scale = min(1., coord_axes_height_pixels / img_height_pixels)
            else:
                scale = min(1., coord_axes_width_pixels / img_width_pixels)

            corner_pixels:List[float] = [0.,0.,0.,0.]
            corner_pixels[0] = coord_axes_middle_Display[0] - (scale * img_width_pixels / 2)
            corner_pixels[1] = coord_axes_middle_Display[1] - (scale * img_height_pixels / 2)
            corner_pixels[2] = corner_pixels[0] + scale * img_width_pixels
            corner_pixels[3] = corner_pixels[1] + scale * img_height_pixels
            transformed_point1 = self.ax.transData.inverted().transform_point((corner_pixels[0],corner_pixels[1]))
            transformed_point2 = self.ax.transData.inverted().transform_point((corner_pixels[2],corner_pixels[3]))
            ll_corner_axes:List[float] = [float(transformed_point1[0]), float(transformed_point1[1])]
            ur_corner_axes:List[float] = [float(transformed_point2[0]), float(transformed_point2[1])]
            extent = (ll_corner_axes[0], ur_corner_axes[0], ll_corner_axes[1], ur_corner_axes[1])
            if self.ai is not None:
                try:
                    self.ai.remove()
                except Exception: # pylint: disable=broad-except
                    pass
            self.ai = self.ax.imshow(self.logoimg, zorder=0, extent=extent, alpha=self.aw.logoimgalpha/10, aspect='auto', resample=False)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' placelogoimage() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # Convert QImage to numpy array
    @staticmethod
    def convertQImageToNumpyArray(img:QImage) -> 'npt.NDArray[numpy.double]':
        img = img.convertToFormat(QImage.Format.Format_RGBA8888)
        width = img.width()
        height = img.height()
        imgsize = img.bits()
        try:
            if imgsize is not None:
                imgsize.setsize(img.sizeInBytes())
        except Exception: # pylint: disable=broad-except
            imgsize.setsize(img.byteCount()) # type:ignore # byteCount() is deprecated, but kept here for compatibility with older Qt versions
        return numpy.array(imgsize).reshape((height, width, int(32/8)))

    #watermark image
    def logoloadfile(self, filename:Optional[str] = None) -> None:
        try:
            if filename is None or not filename:
                filename = self.aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Image File'),ext='*.png *.jpg')
            if filename is None or len(filename) == 0:
                return
            newImage = QImage()
            if newImage.load(filename):
                self.logoimg = self.convertQImageToNumpyArray(newImage)
                self.aw.logofilename = filename
                self.aw.sendmessage(QApplication.translate('Message','Loaded watermark image {0}').format(filename))
#                QTimer.singleShot(500, lambda : self.redraw(recomputeAllDeltas=False)) #some time needed before the redraw on artisan start with no profile loaded.  processevents() does not work here.
                # we avoid a potentially leaking QTimer.signleShot with lambda by emitting a signal
                self.redrawSignal.emit(
                    False, # recomputeAllDeltas (default: True)
                    True, # re_smooth_foreground (default: True)
                    True,  # takelock (default: True)
                    False, # forceRenewAxis (default: False)
                    False, # re_smooth_background (default: False)
                    )
            else:
                self.aw.sendmessage(QApplication.translate('Message','Unable to load watermark image {0}').format(filename))
                _log.info('Unable to load watermark image %s', filename)
                self.aw.logofilename = ''
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' logoloadfile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            self.aw.logofilename = ''


    # Return a 'roast of the day' string with ordinals when english
    def roastOfTheDay(self, roastbatchpos:Optional[int]) -> str:
        if roastbatchpos is not None:
            #add an ordinal suffix for english
            if self.locale_str == 'en':
                prefix = ''
                suffix = f"{ {1: 'st', 2: 'nd', 3: 'rd'}.get(0 if roastbatchpos % 100 in {11, 12, 13} else roastbatchpos % 10, 'th')}" # noqa: E731
            else:
                prefix = '#'
                suffix = ''
            return f"{prefix}{roastbatchpos}{suffix} {QApplication.translate('AddlInfo', 'Roast of the Day')}"
        return '' #return an empty string if roastbatchpos is None

    #add stats summary to graph, called from redraw()
    def statsSummary(self, txt:bool=False) -> Optional[str]:
        if self.ax is None:
            return None

        newline = '\n'

        # Format a text block of notes for stats display
        def wrapNotes(notes:str) -> str:
            notestr = ''
            notes_lines = textwrap.wrap(notes, width=self.statsmaxchrperline)
            if len(notes_lines) > 0:
                notestr += f'{newline}{notes_lines[0]}'
                if len(notes_lines) > 1:
                    notestr += f'{newline}  {notes_lines[1]}'
                    if len(notes_lines) > 2:
                        notestr += '..'
            return notestr

        def dropZeroDecimal(value:float, decimals:int) -> float:
            if int(value) == float2float(value,decimals):
                return float2float(value,0)
            return float2float(value, decimals)

        # Create each statistic
        # Statistic entries are made here and corresponding entries in statistics.py:self.summarystats_types[]
        # Add new stats at the end of the list.
        # To remove a stat:
        #   Do not delete it, change its entry in self.summarystats_types[] in statistics.py to'Unused' and do not translate it.
        #   The handler in canvas:statsSummary():buildStat() for the stattype must remain, it should be changed to "stattype_str = f'{newline}'".
        #       This is to maintain compatibility with previous settings.
        #   Once the createSummarystatsTable is opened the change(s) to 'Blank Line' will be updated in settings.
        def buildStat(n:int) -> str:
            stattype_str = ''
            degree = '\u00b0'
            charge = QApplication.translate('Button', 'CHARGE')
            begin = QApplication.translate('Button', 'DROP') if self.aw.bbp_begin == 'DROP' else QApplication.translate('Button', 'START')
            from_s = QApplication.translate('AddlInfo', 'From')
            bottom = QApplication.translate('AddlInfo', 'Bottom')
            if n == 0:  #Blank line
                stattype_str = f'{newline}'
            elif n == 1:  #Title
                if self.roastbatchnr > 0 or len(self.title) > 0:
                    stattype_str = f'{newline}'
                    if self.roastbatchnr > 0:
                        stattype_str += f'{self.roastbatchprefix}{self.roastbatchnr} '
                    if len(self.title) > 0:
                        stattype_str += f'{self.title}'
            elif n == 2:  #Date and Time
                stattype_str = f'{newline}{self.roastdate.date().toString()} {self.roastdate.time().toString()}'
            elif n == 3:  #Roast of the day
                if self.roastbatchpos is not None and self.roastbatchpos != 0:
                    stattype_str = f'{newline}{self.roastOfTheDay(self.roastbatchpos)}'
            elif n == 4:  #Ambient Temp, Hum, Pressure
                if self.ambientTemp not in [None,0] or self.ambient_humidity not in [None,0] or self.ambient_pressure not in [None,0]:
                    stattype_str = f'{newline}'
                    if self.ambientTemp not in [None,0]:
                        stattype_str += f'{str(int(round(self.ambientTemp)))}{degree}{self.mode}  '
                    if self.ambient_humidity not in [None,0]:
                        stattype_str += f'{str(int(round(self.ambient_humidity)))}% RH '
                    if self.ambient_pressure not in [None,0]:
                        stattype_str += f'{str(float2float(self.ambient_pressure,2))}hPa'
            elif n == 5:  #Roaster, RPM
                if self.roastertype or self.drumspeed:
                    stattype_str = f'{newline}'
                    if self.roastertype:
                        stattype_str += f'{self.roastertype} '
                    if self.drumspeed:
                        stattype_str += f'({self.drumspeed}RPM)'
            elif n == 6:  #Bean
                if self.beans is not None and len(self.beans)>0:
                    stattype_str = wrapNotes(self.beans)
            elif n == 7:  #Screen Size
                if self.beansize_min or self.beansize_max:
                    stattype_str += f"{newline}{QApplication.translate('AddlInfo', 'Screen Size')}: "
                    if self.beansize_min:
                        stattype_str += f'{int(round(self.beansize_min))}'
                    if self.beansize_max:
                        if self.beansize_min:
                            stattype_str += '/'
                        stattype_str += f'{int(round(self.beansize_max))}'
            elif n == 8:  #Density Green
                if self.density[0]!=0 and self.density[2] != 0:
                    stattype_str += (f"{newline}{QApplication.translate('Label', 'Density')} {QApplication.translate('Label', 'Green')}: "
                        f'{dropZeroDecimal(self.density[0]/self.density[2],1)}'
                        f'{self.density[1]}/{self.density[3]}')
            elif n == 9:  #Moisture Green
                if self.moisture_greens:
                    stattype_str += f"{newline}{QApplication.translate('Label', 'Moisture')} {QApplication.translate('Label', 'Green')}: {dropZeroDecimal(self.moisture_greens,1)}%"
            elif n == 10:  #Batch Size
                if self.weight[0] != 0:
                    weight_unit_index = weight_units.index(self.weight[2])
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Batch Size')}: "
                        f'{render_weight(self.weight[0],weight_unit_index,weight_unit_index)} ')

                    if self.weight[1]:
                        stattype_str += f'(-{dropZeroDecimal(self.aw.weight_loss(self.weight[0],self.weight[1]),1)}%)'
            elif n == 11:  #Density Roasted
                roasted_density = (self.aw.qmc.density_roasted[0] if self.aw.qmc.density_roasted[0] != 0 else cp.get('roasted_density', 0))
                if roasted_density:
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Density Roasted')}: "
                        f'{dropZeroDecimal(roasted_density,1)}{self.density_roasted[1]}/{self.density_roasted[3]}')
            elif n == 12:  #Moisture Roasted
                if self.moisture_roasted:
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Moisture Roasted')}: "
                        f'{dropZeroDecimal(self.moisture_roasted,1)}%')
            elif n == 13:  #Ground Color
                if self.ground_color > 0:
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Ground Color')}: #"
                        f'{self.ground_color} {self.color_systems[self.color_system_idx]}')
            elif n == 14:  #Energy
                if 'BTU_batch' in cp and cp['BTU_batch']:
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Energy')}: "
                        f"{dropZeroDecimal(self.convertHeat(cp['BTU_batch'],'BTU','kWh'),2)}kWh")
                    if 'BTU_batch_per_green_kg' in cp and cp['BTU_batch_per_green_kg']:
                        stattype_str += f" ({dropZeroDecimal(self.convertHeat(cp['BTU_batch_per_green_kg'],'BTU','kWh'), 2)}kWh/kg)"
            elif n == 15:  #CO2
                if 'CO2_batch' in cp and cp['CO2_batch']:
                    stattype_str += f"{newline}{QApplication.translate('AddlInfo', 'CO2')}: {float2float(cp['CO2_batch'],0)}g"
                    if 'CO2_batch_per_green_kg' in cp and cp['CO2_batch_per_green_kg']:
                        stattype_str += f" ({float2float(cp['CO2_batch_per_green_kg'],0)}g/kg)"
            elif n == 16:  #AUC
                if 'AUC' in cp and 'AUCbase' in cp and cp['AUC']:
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'AUC')}: "
                        f"{cp['AUC']}{degree}C*min [{cp['AUCbase']}{degree}{self.mode}]")
            elif n == 17:  #Notes (Roast)
                if self.roastingnotes is not None and len(self.roastingnotes)>0:
                    stattype_str = wrapNotes(self.roastingnotes)
            elif n == 18:  #Cupping Score
                cupping_score, cupping_all_default = self.aw.cuppingSum(self.flavors)
                if not cupping_all_default:
                    stattype_str += (f"{newline}{QApplication.translate('HTML Report Template', 'Cupping:')} "
                        f'{dropZeroDecimal(cupping_score, 1)}')
            elif n == 19:  #Notes (Cupping)
                if self.cuppingnotes is not None and len(self.cuppingnotes)>0:
                    stattype_str = wrapNotes(self.cuppingnotes)
            elif n == 20:  #Weight Green
                if self.weight[0] != 0:
                    weight_unit_index = weight_units.index(self.weight[2])
                    stattype_str += (f"{newline}{QApplication.translate('Label', 'Weight')} {QApplication.translate('Label', 'Green')}: "
                        f'{render_weight(self.weight[0],weight_unit_index,weight_unit_index)}')
            elif n == 21:  #Weight Roasted
                if self.weight[1] != 0:
                    if self.weight[2] == 'g':
                        w = f'{float2float(self.weight[1],0)}'
                    else:
                        w = f'{dropZeroDecimal(self.weight[1],2)}'
                    stattype_str += (f"{newline}{QApplication.translate('AddlInfo', 'Weight Roasted')}: "
                        f'{w}{self.weight[2]} ')
            elif n == 22:  #Weight Loss
                if self.weight[0] != 0 and self.weight[1] != 0:  # noqa: SIM102
                    stattype_str += f"{newline}{QApplication.translate('AddlInfo', 'Weight Loss')} -{dropZeroDecimal(self.aw.weight_loss(self.weight[0],self.weight[1]),1)}%"
            elif n == 23:  # BBP total time
                if self.aw.bbp_total_time:
                    stattype_str += f"{newline}{QApplication.translate('HTML Report Template', 'BBP Total Time')} {stringfromseconds(self.aw.bbp_total_time)}"
            elif n == 24:  # BBP bottom temp (BT)
                if self.aw.bbp_bottom_temp:
                    stattype_str += f"{newline}{QApplication.translate('HTML Report Template', 'BBP Bottom Temp')} {self.aw.bbp_bottom_temp:.1f}{degree}{self.aw.qmc.mode}"
            elif n == 25:  # BBP summary
                if self.aw.bbp_total_time:  # noqa: SIM102
                    stattype_str += f'{newline}{bottom}@{self.aw.bbp_bottom_temp:.0f}{degree}{self.mode}, '
                    stattype_str += f'{stringfromseconds(self.aw.bbp_begin_to_bottom_time,False)} {from_s} {begin}'
                    stattype_str += f'{newline}{charge}@{self.temp2[self.timeindex[0]]:.0f}{degree}{self.mode}, '
                    stattype_str += f'{stringfromseconds(self.aw.bbp_bottom_to_charge_time,False)} {from_s} {bottom}'
            elif n == 26:  # BBP summary long  (2 lines minimum)
                # removed
                stattype_str = f'{newline}'
            elif n == 27:  # BBP summary compact
                if self.aw.bbp_total_time:  # noqa: SIM102
                    startingtemp = self.aw.bbp_dropbt if self.aw.bbp_begin == 'DROP' else self.temp2[0]
                    stattype_str += f'{newline}{startingtemp:.0f}{degree}{self.mode} '
                    stattype_str += f'({stringfromseconds(self.aw.bbp_begin_to_bottom_time,False)}) '
                    stattype_str += f'{self.aw.bbp_bottom_temp:.0f}{degree}{self.mode} '
                    stattype_str += f'({stringfromseconds(self.aw.bbp_bottom_to_charge_time,False)}) '
                    stattype_str += f'{self.temp2[self.timeindex[0]]:.0f}{degree}{self.mode}'
            elif n == 28:  # Finish Phase Time and Temp
                if 'finish_phase_delta_temp' in cp and 'finishphasetime' in cp and 'totaltime' in cp:  # noqa: SIM102
                    stattype_str += (f"{newline}{QApplication.translate('Button', 'Finishing Phase')}: "
                                     f"{int(cp['finish_phase_delta_temp'])}{degree}{self.mode}, "
                                     f"{stringfromseconds(cp['finishphasetime'])}, "
                                     f"{int(round(cp['finishphasetime']*100./cp['totaltime']))}%"
                                     )

            elif n == 29:  # Finish Phase Time and Temp
                if 'mid_phase_delta_temp' in cp and 'midphasetime' in cp and 'totaltime' in cp:  # noqa: SIM102
                    stattype_str += (f"{newline}{QApplication.translate('Button', 'Maillard Phase')}: "
                                     f"{int(cp['mid_phase_delta_temp'])}{degree}{self.mode}, "
                                     f"{stringfromseconds(cp['midphasetime'])}, "
                                     f"{int(round(cp['midphasetime']*100./cp['totaltime']))}%"
                                     )
            elif n == 30:  # Finish Phase Time and Temp
                if 'dry_phase_delta_temp' in cp and 'dryphasetime' in cp and 'totaltime' in cp:  # noqa: SIM102
                    stattype_str += (f"{newline}{QApplication.translate('Button', 'Drying Phase')}: "
                                     f"{int(cp['dry_phase_delta_temp'])}{degree}{self.mode}, "
                                     f"{stringfromseconds(cp['dryphasetime'])}, "
                                     f"{int(round(cp['dryphasetime']*100./cp['totaltime']))}%"
                                     )
            elif n == 31:  #Whole Bean Color
                if self.whole_color > 0:
                    stattype_str += (f"{newline}{QApplication.translate('HTML Report Template','Whole Color')}: #"
                        f'{self.whole_color} {self.color_systems[self.color_system_idx]}')
            elif n == 32:  #Cupper correction
                if self.aw.qmc.flavors_total_correction != 0:
                    stattype_str += (f"{newline}{QApplication.translate('Label','Correction')} {self.aw.qmc.flavors_total_correction}")
            else:
                errmsg = (f"{QApplication.translate('Error Message','Exception:')} buildStat() "
                          f"{QApplication.translate('Error Message','Unexpected value for n, got')} {n}")
                _log.debug(errmsg)

            #TODO add more stats  MET, CM, RoR, Profile quality, RoR at FCs, RMSE BT (Bckgd) # pylint: disable=fixme

            # reformat string as necessary
            stattype_str = self.__dijkstra_to_ascii(stattype_str)
            stattype_str = self.aw.arabicReshape(stattype_str)

            # Trim the long lines
            trimmedstatype_segments:List[str] = []
            for line in stattype_str.split('\n'):
                if trimmedstatype_segments:
                    trimmedstatype_segments.append('\n')
                if txt:
                    trimmedstatype_segments.append(line)
                else:
                    trimmedstatype_segments.append(line[:self.statsmaxchrperline])
                    if len(line) > self.statsmaxchrperline:
                        trimmedstatype_segments.append('..')

            return ''.join(trimmedstatype_segments)

        # Create the SummaryStats box
            # NOTES
            # self.ax.get_xlim() "x-axis view limits".  In other words, x-axis min and max values relative to
            #   the start of the curve, thus they could be negative.
            #
            # self.startofx is the number of seconds from start of curve to the left side x-axis (can be negative)
            # self.endofx is the max, or right side, x-axis value
            #
            # statstextboxBounds() takes x,y positions in data coordinates, returns in data coordinates relative to start of curve
            # eventtextBounds() takes x,y positions in data coordinates, returns in data coordinates
            # legendboxbounds() returns legend bounds in data coordinates x relative to start of curve, y relative to self.ylimit_min
            #
            # time0 is number of seconds from start of curve or x-axis min, whichever is earlier, to CHARGE
            #
            # patch_originX is seconds from start of curve to the origin of the patch
            #
            # eventtext_end is seconds from left min x-axis to right side x of the event text
            #
            # stats_summary_rect() is a patches.Rectangle whose origin is the lower left corner
            # text is a self.ax.text() whose origin is the upper left corner
            #

        try:
            newline = '\n'
            statstr_segments = []
            cp = self.aw.computedProfileInformation()  # get all the computed profile information

            # build the summary stats string
            for _,statitem in enumerate(self.aw.summarystatstypes):
                statstr_segments.append(buildStat(statitem))
            statstr = ''.join(statstr_segments)
            if len(statstr) > 1 and statstr[0] == newline:
                statstr = statstr[1:]

            if txt:
                return statstr

            # font properties for event annos
            event_prop = self.aw.mpl_fontproperties.copy()
            event_prop.set_size('x-small')  # to match the prop size used for event annos in redraw())

            # font properties for Summary Statistics
            prop = self.aw.mpl_fontproperties.copy()
            font_sizes = ['x-small','x-small','small','medium','large']
            prop_size = font_sizes[self.aw.summarystatsfontsize]
            prop.set_size(prop_size)
            fc = self.palette['statsanalysisbkgnd']  #fill color
            tc = self.aw.labelBorW(fc)               #text color
            a = self.alpha['statsanalysisbkgnd']     #background alpha
            ls = 1.7                                 #linespacing
            ls = 1.5                                 #linespacing

            # sizing factor used because some fonts bleed over the textbox bounds returned by MPL
            font_bleed = 1.0
            # adjustments for other fonts
            if self.graphfont == 1:   #Humor
                font_bleed = 1.04
            if self.graphfont == 2:   #Comic
                ls = 1.2
            if self.graphfont == 4:   #Source Han Sans CN
                font_bleed = 1.01
            if self.graphfont == 9:   #Dijkstra
                ls = 1.2
                font_bleed = 1.02 #1.009

            # size borders and margins
            borderX = 0.007 * (self.ax.get_xlim()[1] - self.ax.get_xlim()[0])  # space around outside of patch rect (in seconds)
            borderY = max( 11, 0.015 * (self.ax.get_ylim()[1] - self.ax.get_ylim()[0]) ) # space around outside of patch rect (in degrees)
            marginX = 4.0          # text to edge of patch rect (in seconds)
            marginX_factor = 0.05  #scaling factor to size relative to stats_textbox_width
            marginY = 4.0          # text to edge of patch rect (in degrees)

            # geometry in data (graph) coordinates
            patch_originX:float = 0  #lower left
            patch_originY = self.ylimit_min + borderY
            patch_upperY = self.ylimit - borderY # standard positioning
            patch_height = patch_upperY -self.ylimit_min - borderY
            avail_height = patch_height - 2*marginY

            # time0 is number of seconds from start of curve or x-axis min, whichever is earlier, to CHARGE
            if self.timeindex[0] != -1:
                time0 = self.timex[self.timeindex[0]]
                #TODO look at potential issues where the timex values before CHARGE are negative # pylint: disable=fixme
                # correct for the case where the curve starts after the graph origin
                if self.ax.get_xlim()[0] < 0:
                    time0 = self.timex[self.timeindex[0]] - self.ax.get_xlim()[0]
            else:
                time0 = 0

            # set the right side x value of the patch rect
            # patch_originX is seconds from start of curve to the origin of the patch
            _,_,stats_textbox_width,_ = self.statstextboxBounds(time0,self.ylimit,statstr,ls,prop,fc)
            marginX = stats_textbox_width * marginX_factor
            # this presumes the origin of the event label is on the event, it is independent of the actual label position
            patch_originX = time0 + min(self.ax.get_xlim()[0],0) + self.endofx - stats_textbox_width - borderX - 2*marginX
            adjust = 0.

            if self.autotimex:
                # position the stats summary relative to the right hand edge of the graph
                # when in BBP mode the graph will end at CHARGE, so we must look for the CHARGE annotation instead of DROP.
                if self.autotimexMode in {0,1}:  #Roast, BBP+Roast
                    event_label = QApplication.translate('Scope Annotation','DROP {0}').replace(' {0}','')
                else:  #BBP
                    event_label = QApplication.translate('Scope Annotation','CHARGE')

                # find right side of the event label
                _,_,eventtext_end = self.eventtextBounds(time0,patch_upperY,event_label,ls,event_prop,fc)
                self.endofx = eventtext_end + stats_textbox_width + 2*borderX + 2*marginX # provide room for the stats
                self.xaxistosm(redraw=False)  # recalculate the x axis

                prev_stats_textbox_width:float = 0
                #set the maximum number of iterations
                for _ in range(2, 20):
                    # this presumes the origin of the event label is on the event, it is independent of the actual label position
                    eventtext_width,_,eventtext_end = self.eventtextBounds(time0,self.ylimit,event_label,ls,event_prop,fc)

                    _,_,stats_textbox_width,_ = self.statstextboxBounds(0,self.ylimit,statstr,ls,prop,fc)
                    marginX = stats_textbox_width * marginX_factor

                    # position the stats summary relative to the right edge of the drop text
                    if self.ax.get_xlim()[0] < 0 and time0 > self.timex[self.timeindex[0]]:
                        adjust = time0 - self.timex[self.timeindex[0]]
                    else:
                        adjust = 0.

                    # instead of using eventtext_end, how about drop (or charge for bbp)?
                    self.endofx = adjust + eventtext_end + stats_textbox_width + 2*borderX + 2*marginX  #provide room for the stats
                    self.endofx = adjust + max(eventtext_width,eventtext_end) + stats_textbox_width + 2*borderX + 2*marginX  #provide room for the stats

                    self.xaxistosm(redraw=False)

                    #break the loop if it looks like stats_textbox_width has converged
                    if abs(prev_stats_textbox_width - stats_textbox_width) < .2:
                        break
                    prev_stats_textbox_width = stats_textbox_width

                # patch_originX is seconds from start of curve to the origin of the patch
                patch_originX = self.timex[self.timeindex[0]] + self.endofx - stats_textbox_width - borderX - 2*marginX

                # adjust the stats size and position if the legend overlaps above or below.
                _,legend_xmax,legend_ymin,legend_ymax = self.legendboxbounds()
                # legend overlaps above the stats
                if legend_xmax > patch_originX and legend_ymax > patch_upperY:
                    patch_upperY = legend_ymin - borderY
                    patch_height = patch_upperY - self.ylimit_min - borderY
                    avail_height = patch_height - borderY - 2*marginY
                # legend overlaps below the stats
                if legend_xmax > patch_originX and legend_ymin < self.ylimit_min + borderY:
                    patch_originY = legend_ymax + borderY
                    patch_upperY = self.ax.get_ylim()[1] - borderY
                    patch_height = patch_upperY - patch_originY
                    avail_height = patch_height - 2*marginY

            # adjust height of the patch rect
            linecount = statstr.count(newline) + 1
            for i in range(linecount, 0, -1):
                stats_textbox_bounds = self.statstextboxBounds(self.ax.get_xlim()[1]+borderX,patch_upperY,statstr,ls,prop,fc)
                stats_textbox_height = stats_textbox_bounds[3]
                stats_textbox_height = stats_textbox_height * font_bleed

                # Exit the loop when the avail_height exceeds the current stats_textbox_height
                if avail_height > stats_textbox_height:
                    patch_height = stats_textbox_height + 2*marginY
                    patch_originY = max(patch_originY, patch_upperY - patch_height)
                    break

                # Truncate the stats if they run below the patch rect and add a marker to indicate there are hidden stats
                # Find the index of each newline character using regex
                match = re.finditer(newline, statstr)
                indices = [m.start() for m in match]
                if len(indices) > i-1:
                    trunc_index = indices[i-1]
                    # if the last line to be displayed is full width shrink it by one character to leave room for the indicator
                    if len(statstr[indices[i-2]:indices[i-1]]) == self.statsmaxchrperline +1:
                        trunc_index = trunc_index - 1
                    # Truncate the string just before newline character and add a marker to indicate the stats were truncated
                    if self.graphfont == 9:   #Dijkstra
                        statstr = statstr[:trunc_index] + '*'
                    else:
                        statstr = statstr[:trunc_index] + uchr(187) # '»'

            # the rectangular patch is used as background to allow for transparency
            self.stats_summary_rect = patches.Rectangle(
                    (patch_originX,                   #x
                    patch_originY),                   #y
                    stats_textbox_width + 2*marginX,  #width
                    patch_height,                     #height
                    linewidth=0.5,
                    edgecolor=self.palette['grid'],
                    facecolor=fc,
                    fill=True,
                    alpha=a,
                    zorder=10,
                    path_effects=[])
            self.ax.add_patch(self.stats_summary_rect)

            # this is the statistics text box
            text = self.ax.text(
                patch_originX + marginX,   #x
                patch_upperY - marginY,    #y
                statstr,                   #statistics text string
                verticalalignment='top',
                linespacing=ls,
                fontsize=prop_size,
                #backgroundcolor='y',
                color=tc,zorder=11,
                path_effects=[])
            text.set_in_layout(False)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' statsSummary() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        return None

    # Find the bounds for the graph legend.
    # Returns in data coordinates relative to start of curve and self.ylimit_min
    def legendboxbounds(self) -> Tuple[float,float,float,float]:
        try:
            if self.legendloc > 0 and self.ax is not None and self.legend is not None:
                # Get the legend bounding box in axes-relative coordinates

                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    # suppress font warnings (eg. with language arabic on using Han Sans TW font) like: UserWarning: Glyph 65166 (\N{ARABIC LETTER ALEF FINAL FORM}) missing from font(s) Source Han Sans TW.
                    legend_bb_axes = self.legend.get_window_extent().transformed(self.ax.transAxes.inverted())

                # Get the data range
                x_min, x_max = self.ax.get_xlim()
                y_min, y_max = self.ax.get_ylim()

                # Calculate the width and height of the data range
                x_range = x_max - x_min
                y_range = y_max - y_min

                # Convert legend bounding box coordinates from axes-relative to data coordinates
                # Relative to the start of the curve and self.ylimit_min
                xmin = x_min + x_range * legend_bb_axes.x0
                xmax = x_min + x_range * legend_bb_axes.x1
                ymin = y_min + y_range * legend_bb_axes.y0
                ymax = y_min + y_range * legend_bb_axes.y1

                return xmin,xmax,ymin,ymax
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        return 0.,0.,0.,0.

    # Find the bounds for the statistics text box.
    # Input x,y positions in data coordinates, returns in data coordinates relative to start of curve
    def statstextboxBounds(self, x_pos:float, y_pos:float, textstr:str, ls:float, prop:'FontProperties', fc:str) -> Tuple[float,float,float,float]:
        if self.ax is None:
            return 0.,0.,0.,0.

        with warnings.catch_warnings():
            # MPL will generate warnings for missing glyphs in some fonts
            warnings.simplefilter('ignore')
            t = self.ax.text(x_pos, y_pos, textstr, verticalalignment='top',linespacing=ls,fontproperties=prop,color=fc,path_effects=[])
            f = self.ax.get_figure()
            r = None
            try:
                if f is not None:
                    r = f.canvas.get_renderer() # type: ignore # this might fail with 'FigureCanvasPdf' object has no attribute 'get_renderer' for PDF generation
            except Exception: # pylint: disable=broad-except
                pass
            if r is not None:
                t.update_bbox_position_size(r)
                bb = t.get_window_extent(renderer=r) # bounding box in display space
                bbox_data = self.ax.transData.inverted().transform(bb) # bounding box in data space
                bbox = Bbox(bbox_data)
                t.remove()
                return bbox.bounds  # x0, y0, width, height.  Relative to the start of the curve and self.ylimit_min
            return 0,0,0,0

    # Find the bounds for an event annotation text box
    # Input a reference x,y position in data coordinates, returns in data coordinates relative to start of curve
    def eventtextBounds(self, x_pos:float, y_pos:float, event_label:str, ls:float, prop:'FontProperties', fc:str) -> Tuple[float,float,float]:
        eventtext_width:float = 0
        eventtext_start:float = 0
        eventtext_end:float = 0
        try:
            if self.ax:
                eventtext_end = self.timex[-1] - x_pos #default for when Events Annotations is unchecked
                for child in reversed(self.ax.get_children()):  # reversed() needed when there is a background profile (which is plotted first)
                    if isinstance(child, Annotation):
                        eventtext = re.search(fr'.*\((.*?),.*({event_label}[ 0-9:]*)',str(child))
                        if eventtext:
                            eventtext_start = float(eventtext.group(1)) - x_pos
                            eventtext_width = self.statstextboxBounds(x_pos,y_pos,eventtext.group(2),ls,prop,fc)[2]
                            eventtext_end = eventtext_start + eventtext_width
                            break
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        return eventtext_width,eventtext_start,eventtext_end

    # adjusts height of annotations
    #supporting function for self.redraw() used to find best height of annotations in graph to avoid annotating over previous annotations (unreadable) when close to each other
    def findtextgap(self, ystep_down:int, ystep_up:int, height1:float, height2:float, dd:float = 0) -> Tuple[int,int]:
        d = self.ylimit - self.ylimit_min if dd <= 0 else dd
        init = int(d/12.0)
        gap = int(d/20.0)
        maxx = int(d/3.6)
        i = 0
        j = 0
        for i in range(init,maxx):
            if abs((height1 + ystep_up) - (height2+i)) > gap:
                break
        for j in range(init,maxx):
            if abs((height1 - ystep_down) - (height2 - j)) > gap:
                break
        return j,i  #return height of arm

    # adjust min/max limits of temperature sliders to the actual temperature mode
    def adjustTempSliders(self) -> None:
        if self.aw is not None and self.mode != self.mode_tempsliders:
            for i in range(4):
                if self.aw.eventslidertemp[i]:
                    # a minimum of 0 will be mapped to 0 always!
                    if self.mode == 'C':
                        self.aw.eventslidermin[i] = (0 if self.aw.eventslidermin[i] == 0 else max(0, min(999, int(round(fromFtoCstrict(self.aw.eventslidermin[i]))))))
                        self.aw.eventslidermax[i] = max(0, min(999, int(round(fromFtoCstrict(self.aw.eventslidermax[i])))))
                    else:
                        self.aw.eventslidermin[i] = (0 if self.aw.eventslidermin[i] == 0 else max(0, min(999, int(round(fromCtoFstrict(self.aw.eventslidermin[i]))))))
                        self.aw.eventslidermax[i] = max(0, min(999, int(round(fromCtoFstrict(self.aw.eventslidermax[i])))))
            self.aw.updateSliderMinMax()
            # adjust SV slider limits
            if self.mode == 'C':
                self.aw.pidcontrol.conv2celsius()
            else:
                self.aw.pidcontrol.conv2fahrenheit()
            self.mode_tempsliders = self.mode

    #sets the graph display in Fahrenheit mode
    def fahrenheitMode(self, setdefaultaxes:bool = True) -> None:
        if setdefaultaxes:
            # just set it to the defaults to avoid strange conversion issues
            self.ylimit = self.ylimit_F_default
            self.ylimit_min = self.ylimit_min_F_default
            self.ygrid = self.ygrid_F_default
            self.zlimit = self.zlimit_F_default
            self.zlimit_min = self.zlimit_min_F_default
            self.zgrid = self.zgrid_F_default
        if self.mode == 'C':
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(fromCtoFstrict(self.phases[i])))
            if self.step100temp is not None:
                self.step100temp = int(round(fromCtoFstrict(self.step100temp)))
            self.AUCbase = int(round(fromCtoFstrict(self.AUCbase)))
            self.dropDuplicatesLimit = float2float(fromCtoFstrict(100 + self.dropDuplicatesLimit) - fromCtoFstrict(100),2)
            self.RoRlimitm = int(round(fromCtoFstrict(self.RoRlimitm)))
            self.RoRlimit = int(round(fromCtoFstrict(self.RoRlimit)))
            self.alarmtemperature = [(fromCtoFstrict(t) if t != 500 else t) for t in self.alarmtemperature]
        if self.ax is not None:
            self.ax.set_ylabel('F',size=16,color = self.palette['ylabel']) #Write "F" on Y axis
        self.mode = 'F'
        if self.aw is not None: # during initialization aw is still None!
            self.aw.FahrenheitAction.setDisabled(True)
            self.aw.CelsiusAction.setEnabled(True)
            self.aw.ConvertToFahrenheitAction.setDisabled(True)
            self.aw.ConvertToCelsiusAction.setEnabled(True)
            # configure dropfilter
            self.filterDropOut_tmin = self.filterDropOut_tmin_F_default
            self.filterDropOut_tmax = self.filterDropOut_tmax_F_default
            self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_F_default
            self.adjustTempSliders()
            self.aw.realignbuttons() # reset button labels as they might refer to the temperature mode via {TEMP}

    #sets the graph display in Celsius mode
    def celsiusMode(self, setdefaultaxes:bool = True) -> None:
        if setdefaultaxes:
            self.ylimit = self.ylimit_C_default
            self.ylimit_min = self.ylimit_min_C_default
            self.ygrid = self.ygrid_C_default
            self.zlimit = self.zlimit_C_default
            self.zlimit_min = self.zlimit_min_C_default
            self.zgrid = self.zgrid_C_default
        if self.mode == 'F':
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(fromFtoCstrict(self.phases[i])))
            if self.step100temp is not None:
                self.step100temp = int(round(fromFtoCstrict(self.step100temp)))
            self.AUCbase = int(round(fromFtoCstrict(self.AUCbase)))
            self.dropDuplicatesLimit = float2float(fromFtoCstrict(212 + self.dropDuplicatesLimit) - fromFtoCstrict(212),2)
            self.RoRlimitm = int(round(fromFtoCstrict(self.RoRlimitm)))
            self.RoRlimit = int(round(fromFtoCstrict(self.RoRlimit)))
            self.alarmtemperature = [(fromFtoCstrict(t) if t != 500 else t) for t in self.alarmtemperature]
        if self.ax is not None:
            self.ax.set_ylabel('C',size=16,color = self.palette['ylabel']) #Write "C" on Y axis
        self.mode = 'C'
        if self.aw is not None: # during initialization aw is still None
            self.aw.CelsiusAction.setDisabled(True)
            self.aw.FahrenheitAction.setEnabled(True)
            self.aw.ConvertToCelsiusAction.setDisabled(True)
            self.aw.ConvertToFahrenheitAction.setEnabled(True)
            # configure dropfilter
            self.filterDropOut_tmin = self.filterDropOut_tmin_C_default
            self.filterDropOut_tmax = self.filterDropOut_tmax_C_default
            self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_C_default
            self.adjustTempSliders()
            self.aw.realignbuttons() # reset button labels as they might refer to the temperature mode via {TEMP}

    @pyqtSlot()
    @pyqtSlot(bool)
    def fahrenheitModeRedraw(self, _:bool = False) -> None:
        self.fahrenheitMode()
        self.redraw()

    @pyqtSlot()
    @pyqtSlot(bool)
    def celsiusModeRedraw(self, _:bool = False) -> None:
        self.celsiusMode()
        self.redraw()

    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureF(self, _:bool = False) -> None:
        self.convertTemperature('F')

    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureC(self, _:bool = False) -> None:
        self.convertTemperature('C')

    #converts a loaded profile to a different temperature scale. t input is the requested mode (F or C).
    def convertTemperature(self, t:str, silent:bool = False, setdefaultaxes:bool = True) -> None:
        #verify there is a loaded profile
        profilelength = len(self.timex)
        if profilelength > 0 or self.background:
            if t == 'F':
                if silent:
                    reply = QMessageBox.StandardButton.Yes
                else:
                    string = QApplication.translate('Message', 'Convert profile data to Fahrenheit?')
                    reply = QMessageBox.question(self.aw, QApplication.translate('Message', 'Convert Profile Temperature'),string,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                if reply == QMessageBox.StandardButton.Yes:
                    if self.mode == 'C':
                        self.aw.CelsiusAction.setDisabled(True)
                        self.aw.FahrenheitAction.setEnabled(True)
                        self.aw.ConvertToCelsiusAction.setDisabled(True)
                        self.aw.ConvertToFahrenheitAction.setEnabled(True)
                        self.l_annotations_dict = {}
                        self.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = fromCtoFstrict(self.temp1[i])    #ET
                            self.temp2[i] = fromCtoFstrict(self.temp2[i])    #BT
                            if self.delta1:
                                self.delta1[i] = RoRfromCtoF(self.delta1[i])  #Delta ET
                            if self.delta2:
                                self.delta2[i] = RoRfromCtoF(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(self.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(self.extraNoneTempHint1) > e and self.extraNoneTempHint1[e]):
                                            self.extratemp1[e][i] = fromCtoFstrict(self.extratemp1[e][i])
                                        if not (len(self.extraNoneTempHint2) > e and self.extraNoneTempHint2[e]):
                                            self.extratemp2[e][i] = fromCtoFstrict(self.extratemp2[e][i])
                                    except Exception: # pylint: disable=broad-except
                                        pass
                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = fromCtoFstrict(self.ambientTemp)  #ambient temperature
                        if self.greens_temp is not None and self.greens_temp != 0:
                            self.greens_temp = fromCtoFstrict(self.greens_temp)

                        #prevents accidentally deleting a modified profile.
                        self.fileDirtySignal.emit()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = fromCtoFstrict(self.temp1B[i])
                            self.temp2B[i] = fromCtoFstrict(self.temp2B[i])
                            self.stemp1B[i] = fromCtoF(self.stemp1B[i])
                            self.stemp2B[i] = fromCtoF(self.stemp2B[i])

                        self.fahrenheitMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            self.aw.sendmessage(QApplication.translate('Message','Profile changed to Fahrenheit'))

                    elif not silent:
                        QMessageBox.information(self.aw, QApplication.translate('Message', 'Convert Profile Temperature'),
                                                QApplication.translate('Message', 'Unable to comply. You already are in Fahrenheit'))
                        self.aw.sendmessage(QApplication.translate('Message','Profile not changed'))
                        return

            elif t == 'C':
                if silent:
                    reply = QMessageBox.StandardButton.Yes
                else:
                    string = QApplication.translate('Message', 'Convert profile data to Celsius?')
                    reply = QMessageBox.question(self.aw, QApplication.translate('Message', 'Convert Profile Temperature'),string,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                if reply == QMessageBox.StandardButton.Yes:
                    if self.mode == 'F':
                        self.aw.ConvertToFahrenheitAction.setDisabled(True)
                        self.aw.ConvertToCelsiusAction.setEnabled(True)
                        self.aw.FahrenheitAction.setDisabled(True)
                        self.aw.CelsiusAction.setEnabled(True)
                        self.l_annotations_dict = {}
                        self.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = fromFtoCstrict(self.temp1[i])    #ET
                            self.temp2[i] = fromFtoCstrict(self.temp2[i])    #BT
                            if self.device != 18 or self.aw.simulator is not None:
                                if self.delta1:
                                    self.delta1[i] = RoRfromFtoC(self.delta1[i])  #Delta ET
                                if self.delta2:
                                    self.delta2[i] = RoRfromFtoC(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(self.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(self.extraNoneTempHint1) > e and self.extraNoneTempHint1[e]):
                                            self.extratemp1[e][i] = fromFtoCstrict(self.extratemp1[e][i])
                                        if not (len(self.extraNoneTempHint2) > e and self.extraNoneTempHint2[e]):
                                            self.extratemp2[e][i] = fromFtoCstrict(self.extratemp2[e][i])
                                    except Exception: # pylint: disable=broad-except
                                        pass

                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = fromFtoCstrict(self.ambientTemp)  #ambient temperature
                        if self.greens_temp is not None and self.greens_temp != 0:
                            self.greens_temp = fromFtoCstrict(self.greens_temp)

                        #prevents accidentally deleting a modified profile.
                        self.fileDirtySignal.emit()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = fromFtoCstrict(self.temp1B[i]) #ET B
                            self.temp2B[i] = fromFtoCstrict(self.temp2B[i]) #BT B
                            self.stemp1B[i] = fromFtoC(self.stemp1B[i])
                            self.stemp2B[i] = fromFtoC(self.stemp2B[i])

                        self.celsiusMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            self.aw.sendmessage(QApplication.translate('Message','Profile changed to Celsius'))

                    elif not silent:
                        QMessageBox.information(self.aw, QApplication.translate('Message', 'Convert Profile Temperature'),
                                                QApplication.translate('Message', 'Unable to comply. You already are in Celsius'))
                        self.aw.sendmessage(QApplication.translate('Message','Profile not changed'))
                        return

            if not silent:
                self.redraw(recomputeAllDeltas=True,re_smooth_foreground=True)

        elif not silent:
            QMessageBox.information(self.aw, QApplication.translate('Message', 'Convert Profile Scale'),
                                          QApplication.translate('Message', 'No profile data found'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def changeGColor3(self, _:bool = False) -> None:
        self.changeGColor(3)

    #selects color mode: input 1=color mode; input 2=black and white mode (printing); input 3 = customize colors
    def changeGColor(self, color:int) -> None:
        #load selected dictionary
        if color == 1:
            self.aw.sendmessage(QApplication.translate('Message','Colors set to defaults'))
            fname = os.path.join(getResourcePath(), 'Themes', application_name, 'Default.athm')
            if os.path.isfile(fname) and not self.flagon:
                self.aw.loadSettings_theme(fn=fname,remember=False,reset=False)
                self.aw.sendmessage(QApplication.translate('Message','Colors set to Default Theme'))
            else:
                for k in list(self.palette1.keys()):
                    self.palette[k] = self.palette1[k]
                self.backgroundmetcolor     = self.palette['et']
                self.backgroundbtcolor      = self.palette['bt']
                self.backgrounddeltaetcolor = self.palette['deltaet']
                self.backgrounddeltabtcolor = self.palette['deltabt']
                self.backgroundxtcolor      = self.palette['xt']
                self.backgroundytcolor      = self.palette['yt']
                self.EvalueColor = self.EvalueColor_default.copy()
                self.EvalueTextColor = self.EvalueTextColor_default.copy()
                self.aw.sendmessage(QApplication.translate('Message','Colors set to defaults'))
                self.aw.closeEventSettings()

        elif color == 2:
            self.aw.sendmessage(QApplication.translate('Message','Colors set to grey'))
            for k in list(self.palette.keys()):
                c = self.palette[k]
                nc = self.aw.convertToGreyscale(c)
                self.palette[k] = nc
            for i in range(len(self.extradevices)):
                c = self.extradevicecolor1[i]
                self.extradevicecolor1[i] = self.aw.convertToGreyscale(c)
                c = self.extradevicecolor2[i]
                self.extradevicecolor2[i] = self.aw.convertToGreyscale(c)
            for i,c in enumerate(self.EvalueColor):
                self.EvalueColor[i] = self.aw.convertToGreyscale(c)
            self.backgroundmetcolor     = self.aw.convertToGreyscale(self.backgroundmetcolor)
            self.backgroundbtcolor      = self.aw.convertToGreyscale(self.backgroundbtcolor)
            self.backgrounddeltaetcolor = self.aw.convertToGreyscale(self.backgrounddeltaetcolor)
            self.backgrounddeltabtcolor = self.aw.convertToGreyscale(self.backgrounddeltabtcolor)
            self.backgroundxtcolor      = self.aw.convertToGreyscale(self.backgroundxtcolor)
            self.backgroundytcolor      = self.aw.convertToGreyscale(self.backgroundytcolor)
            self.aw.setLCDsBW()
            self.aw.closeEventSettings()

        elif color == 3:
            from artisanlib.colors import graphColorDlg
            dialog = graphColorDlg(self.aw, self.aw, self.aw.graphColorDlg_activeTab)
            if dialog.exec():
                self.aw.graphColorDlg_activeTab = dialog.TabWidget.currentIndex()
                #
                self.palette['background'] = str(dialog.backgroundButton.text())
                self.palette['grid'] = str(dialog.gridButton.text())
                self.palette['ylabel'] = str(dialog.yButton.text())
                self.palette['xlabel'] = str(dialog.xButton.text())
                self.palette['title'] = str(dialog.titleButton.text())
                self.palette['rect1'] = str(dialog.rect1Button.text())
                self.palette['rect2'] = str(dialog.rect2Button.text())
                self.palette['rect3'] = str(dialog.rect3Button.text())
                self.palette['rect4'] = str(dialog.rect4Button.text())
                self.palette['rect5'] = str(dialog.rect5Button.text())
                self.palette['et'] = str(dialog.metButton.text())
                self.palette['bt'] = str(dialog.btButton.text())
                self.palette['deltaet'] = str(dialog.deltametButton.text())
                self.palette['deltabt'] = str(dialog.deltabtButton.text())
                self.palette['markers'] = str(dialog.markersButton.text())
                self.palette['text'] = str(dialog.textButton.text())
                self.palette['watermarks'] = str(dialog.watermarksButton.text())
                self.palette['timeguide'] = str(dialog.timeguideButton.text())
                self.palette['aucguide'] = str(dialog.aucguideButton.text())
                self.palette['aucarea'] = str(dialog.aucareaButton.text())
                self.palette['canvas'] = str(dialog.canvasButton.text())
                self.palette['legendbg'] = str(dialog.legendbgButton.text())
#                self.palette["legendbgalpha"] = str(dialog.legendbgalphaButton.text())
                self.palette['legendborder'] = str(dialog.legendborderButton.text())
                self.palette['specialeventbox'] = str(dialog.specialeventboxButton.text())
                self.palette['specialeventtext'] = str(dialog.specialeventtextButton.text())
                self.palette['bgeventmarker'] = str(dialog.bgeventmarkerButton.text())
                self.palette['bgeventtext'] = str(dialog.bgeventtextButton.text())
                self.palette['mettext'] = str(dialog.mettextButton.text())
                self.palette['metbox'] = str(dialog.metboxButton.text())
                self.backgroundmetcolor = str(dialog.bgmetButton.text())
                self.backgroundbtcolor  = str(dialog.bgbtButton.text())
                self.backgrounddeltaetcolor = str(dialog.bgdeltametButton.text())
                self.backgrounddeltabtcolor = str(dialog.bgdeltabtButton.text())
                self.backgroundxtcolor = str(dialog.bgextraButton.text())
                self.backgroundytcolor = str(dialog.bgextra2Button.text())
                self.aw.closeEventSettings()
#            #deleteLater() will not work here as the dialog is still bound via the parent
#            #dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
#            # the following will immediately release the memory despite this parent link
#            QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
#            try: # sip not supported on older PyQt versions (RPi!)
#                sip.delete(dialog)
#                #print(sip.isdeleted(dialog))
#            except Exception:  # pylint: disable=broad-except
#                pass

        #update screen with new colors
        self.aw.updateCanvasColors()
        self.aw.applyStandardButtonVisibility()
        self.aw.update_extraeventbuttons_visibility()
        self.fig.canvas.draw_idle() #.redraw()

    def clearFlavorChart(self) -> None:
        self.flavorchart_plotf = None
        self.flavorchart_angles = None
        self.flavorchart_plot = None
        self.flavorchart_fill = None
        self.flavorchart_labels = None
        self.flavorchart_total = None

    #draws a polar star graph to score cupping. It does not delete any profile data.
    def flavorchart(self) -> None:
        try:
            pi = math.pi

            # to trigger a recreation of the standard axis in redraw() we remove them completely
            self.ax = None
            self.delta_ax = None

            self.fig.clf()

            #create a new name ax1 instead of ax (ax is used when plotting profiles)

            if self.ax1 is not None:
                try:
                    self.fig.delaxes(self.ax1)
                except Exception: # pylint: disable=broad-except
                    pass
            self.ax1 = self.fig.add_subplot(111,projection='polar',facecolor='None') #) radar green facecolor='#d5de9c'

            # fixing yticks with matplotlib.ticker "FixedLocator"
            self.updateFlavorChartData()
            if self.ax1 is not None and self.flavorchart_angles is not None:
                try:
                    ticks_loc = [float(tick) for tick in self.ax1.get_yticks()]
                    self.ax1.yaxis.set_major_locator(ticker.FixedLocator(ticks_loc))
                except Exception: # pylint: disable=broad-except
                    pass

                self.ax1.set_aspect(self.flavoraspect)

                self.aw.setFonts(redraw=False)

                #find number of divisions
                nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])


                sa = self.flavorstartangle % (360./nflavors)
                g_angle = numpy.arange(sa,(360.+sa),(360./nflavors))  #angles in degree
                if isinstance(self.ax1, PolarAxes):
                    self.ax1.set_thetagrids(g_angle)
                    self.ax1.set_rmax(1.)
                self.ax1.set_autoscale_on(False)
                self.ax1.grid(True,linewidth=1.,color='#212121', linestyle = '-',alpha=.3)
                # hack to make flavor labels visible also on top and bottom
                if self.flavors_total_correction != 0:
                    xlabel_artist = self.ax1.set_xlabel(f"\n\n\n{QApplication.translate('Label','Correction')}: {self.flavors_total_correction}".rstrip('0').rstrip('.'), fontsize='small', alpha=0.6)
                else:
                    xlabel_artist = self.ax1.set_xlabel(' -\n ', alpha=0.0)

                title_artist = self.ax1.set_title(' -\n ', alpha=0.0)
                try:
                    xlabel_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
                except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass
                try:
                    title_artist.set_in_layout(False) # remove x-axis labels from tight_layout calculation
                except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass

                #create water marks 6-7 anf 8-9
                self.ax1.bar(.1, .1, width=2.*pi, bottom=.6,color='#0c6aa6',linewidth=0.,alpha = .1)
                self.ax1.bar(.1, .1, width=2.*pi, bottom=.8,color='#0c6aa6',linewidth=0.,alpha = .1)

                #delete degrees ticks to annotate flavor characteristics
                for tick in self.ax1.xaxis.get_major_ticks():
                    #tick.label1On = False
                    tick.label1.set_visible(False)

                fontprop_small = self.aw.mpl_fontproperties.copy()
                fontprop_small.set_size('x-small')

                #rename yaxis
                locs = self.ax1.get_yticks()
                labels = []
                for loc in locs:
                    stringlabel = str(int(round(loc*10)))
                    labels.append(stringlabel)
                self.ax1.set_yticklabels(labels,color=self.palette['xlabel'],fontproperties=fontprop_small)

                #annotate labels
                self.flavorchart_labels = []
                for i in range(len(self.flavorlabels)):
                    if self.flavorchart_angles[i] > 2.*pi or self.flavorchart_angles[i] < 0.:
                        _,self.flavorchart_angles[i] = divmod(self.flavorchart_angles[i],(2.*pi))
                    if self.flavorchart_angles[i] <= (pi/2.) or self.flavorchart_angles[i] >= (1.5*pi): #if < 90 or smaller than 270 degrees
                        ha = 'left'
                    else:
                        ha = 'right'
                    anno = self.ax1.annotate(self.flavorChartLabelText(i),xy =(self.flavorchart_angles[i],.9),
                                        fontproperties=fontprop_small,
                                        xytext=(self.flavorchart_angles[i],1.1),horizontalalignment=ha,verticalalignment='center')
                    try:
                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                        pass
                    self.flavorchart_labels.append(anno)

                # total score
                score = self.calcFlavorChartScore()
                txt = f'{score:.2f}'.rstrip('0').rstrip('.')
                self.flavorchart_total = self.ax1.text(0.,0.,txt,fontsize='x-large',fontproperties=self.aw.mpl_fontproperties,color='#FFFFFF',horizontalalignment='center',bbox={'facecolor':'#212121', 'alpha':0.5, 'pad':10})

                #add background to plot if found
                if self.background and self.flavorbackgroundflag:
                    if len(self.backgroundFlavors) != len(self.flavors):
                        message = QApplication.translate('Message','Background does not match number of labels')
                        self.aw.sendmessage(message)
                        self.flavorbackgroundflag = False
                    else:
                        backgroundplotf = self.backgroundFlavors[:]
                        backgroundplotf.append(self.backgroundFlavors[0])
                        #normalize flavor values to 0-1 range
                        for i,_ in enumerate(backgroundplotf):
                            backgroundplotf[i] /= 10.

                        self.ax1.plot(self.flavorchart_angles,backgroundplotf,color='#cc0f50',marker='o',alpha=.5)
                        #needs matplotlib 1.0.0+
                        self.ax1.fill_between(self.flavorchart_angles,0,backgroundplotf, facecolor='#ff5871', alpha=0.1, interpolate=True)

                #add to plot
                self.flavorchart_plot, = self.ax1.plot(self.flavorchart_angles,numpy.array(self.flavorchart_plotf),color='#0c6aa6',marker='o')

                self.flavorchart_fill = self.ax1.fill_between(self.flavorchart_angles,0,numpy.array(self.flavorchart_plotf), facecolor='#1985ba', alpha=0.1, interpolate=True)

                #self.fig.canvas.draw()
                self.fig.canvas.draw_idle()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def flavorChartLabelText(self, i:int) -> str:
        return f'{self.aw.arabicReshape(self.flavorlabels[i])}\n{self.flavors[i]:.2f}'.rstrip('0').rstrip('.')

    #To close circle we need one more element. angle and values need same dimension in order to plot.
    def updateFlavorChartData(self) -> None:
        # update angles
        nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])
        step = 2.*math.pi/nflavors
        startradian = math.radians(self.flavorstartangle)
        self.flavorchart_angles = [startradian]   #angles in radians
        for _ in range(nflavors-1):
            self.flavorchart_angles.append(self.flavorchart_angles[-1] + step)
        self.flavorchart_angles.append(self.flavorchart_angles[-1]+step)
        # update values
        self.flavorchart_plotf = self.flavors[:]
        self.flavorchart_plotf.append(self.flavors[0])
        #normalize flavor values to 0-1 range
        for i,_ in enumerate(self.flavorchart_plotf):
            self.flavorchart_plotf[i] /= 10.

    @staticmethod
    def calcFlavorChartScoreFromFlavors(flavors:List[float], flavors_total_correction:float) -> float:
        if len(flavors) < 1:
            return 50
        score:float = 0.
        nflavors = len(flavors)
        for i in range(nflavors):
            score += flavors[i]
        score /= (nflavors)
        score *= 10.
        score += flavors_total_correction
        return score

    def calcFlavorChartScore(self) -> float:
        return self.calcFlavorChartScoreFromFlavors(self.flavors, self.flavors_total_correction)

    # set the flavor chart scores such that the given overall score is reached
    def setFlavorChartScore(self, value:float) -> None:
        if value <= 0 or value > 100:
            # we treat the nonset value 0 as the (default) 50
            value = 50
        nflavors = len(self.flavors)
        nValue = value / 10
        for i in range(nflavors):
            self.flavors[i] = nValue

    # an incremental redraw of the existing flavorchart
    def updateFlavorchartValues(self) -> None:
        # update data
        self.updateFlavorChartData()
        if self.flavorchart_plot is not None:
            self.flavorchart_plot.set_xdata(numpy.array(self.flavorchart_angles))
            self.flavorchart_plot.set_ydata(numpy.array(self.flavorchart_plotf))

        # collections need to be redrawn completely
        try:
            if self.flavorchart_fill is not None:
                self.flavorchart_fill.remove()
        except Exception: # pylint: disable=broad-except
            pass
        if self.ax1 is not None:
            self.flavorchart_fill = self.ax1.fill_between(numpy.array(self.flavorchart_angles), 0, numpy.array(self.flavorchart_plotf), facecolor='#1985ba', alpha=0.1, interpolate=True)

        # total score
        score = self.calcFlavorChartScore()
        if self.flavorchart_total is not None:
            txt = f'{score:.2f}'.rstrip('0').rstrip('.')
            self.flavorchart_total.set_text(txt)

        if self.aw.qmc.ax1 is not None:
            if self.aw.qmc.flavors_total_correction != 0:
                self.aw.qmc.ax1.set_xlabel(f"\n\n\n{QApplication.translate('Label','Correction')}: {self.aw.qmc.flavors_total_correction}".rstrip('0').rstrip('.'), fontsize='small', alpha=0.6)
            else:
                self.aw.qmc.ax1.set_xlabel(' -\n ', alpha=0.0)

        # update canvas
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def updateFlavorchartLabel(self, i:int) -> None:
        if self.flavorchart_labels is not None:
            label_anno = self.flavorchart_labels[i]
            label_anno.set_text(self.flavorChartLabelText(i))

            # update canvas
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                self.fig.canvas.draw()
            self.fig.canvas.flush_events()

    def samplingAction(self) -> None:
        _log.debug('async samplingAction()')
        try:
            ###  lock resources ##
            self.profileDataSemaphore.acquire(1)
            if self.extra_event_sampling_delay != 0:
                self.aw.eventactionx(self.extrabuttonactions[2],self.extrabuttonactionstrings[2])
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)

    @pyqtSlot()
    def AsyncSamplingActionTrigger(self) -> None:
        if self.extra_event_sampling_delay and self.extrabuttonactions[2]:
            if self.flagon:
                self.samplingAction()
            self.StopAsyncSamplingAction()
            self.aw.AsyncSamplingTimer = QTimer()
            self.aw.AsyncSamplingTimer.timeout.connect(self.AsyncSamplingActionTrigger)
            self.aw.AsyncSamplingTimer.setSingleShot(True)
            self.aw.AsyncSamplingTimer.start(int(round(self.extra_event_sampling_delay)))

    @pyqtSlot()
    def StartAsyncSamplingAction(self) -> None:
        if self.aw.AsyncSamplingTimer is None and self.flagon and self.extra_event_sampling_delay != 0:
            self.AsyncSamplingActionTrigger()

    def StopAsyncSamplingAction(self) -> None:
        if self.aw.AsyncSamplingTimer is not None:
            self.aw.AsyncSamplingTimer.stop() # kill the running timer
            self.aw.AsyncSamplingTimer.deleteLater()
            try: # sip not supported on older PyQt versions (RPi!)
                sip.delete(self.aw.AsyncSamplingTimer)
                #print(sip.isdeleted(dialog))
            except Exception:  # pylint: disable=broad-except
                pass
            self.aw.AsyncSamplingTimer = None


    # fill the self.extraNoneTempHint1 and self.extraNoneTempHint2 lists
    # indicating which curves should not be temperature converted
    # True indicates a non-temperature device (data should not be converted)
    # False indicates a temperature device (data should be converted if temperature unit changes)
    def generateNoneTempHints(self) -> None:
        self.extraNoneTempHint1 = []
        self.extraNoneTempHint2 = []
        for d in self.extradevices:
            if d in self.nonTempDevices:
                self.extraNoneTempHint1.append(True)
                self.extraNoneTempHint2.append(True)
            elif d == 29: # MODBUS
                self.extraNoneTempHint1.append(self.aw.modbus.inputModes[0] == '')
                self.extraNoneTempHint2.append(self.aw.modbus.inputModes[1] == '')
            elif d == 33: # +MODBUS 34
                self.extraNoneTempHint1.append(self.aw.modbus.inputModes[2] == '')
                self.extraNoneTempHint2.append(self.aw.modbus.inputModes[3] == '')
            elif d == 55: # +MODBUS 56
                self.extraNoneTempHint1.append(self.aw.modbus.inputModes[4] == '')
                self.extraNoneTempHint2.append(self.aw.modbus.inputModes[5] == '')
            elif d == 109: # +MODBUS 78
                self.extraNoneTempHint1.append(self.aw.modbus.inputModes[6] == '')
                self.extraNoneTempHint2.append(self.aw.modbus.inputModes[7] == '')
            elif d == 79: # S7
                self.extraNoneTempHint1.append(not bool(self.aw.s7.mode[0]))
                self.extraNoneTempHint2.append(not bool(self.aw.s7.mode[1]))
            elif d == 80: # +S7 34
                self.extraNoneTempHint1.append(not bool(self.aw.s7.mode[2]))
                self.extraNoneTempHint2.append(not bool(self.aw.s7.mode[3]))
            elif d == 81: # +S7 56
                self.extraNoneTempHint1.append(not bool(self.aw.s7.mode[4]))
                self.extraNoneTempHint2.append(not bool(self.aw.s7.mode[5]))
            elif d == 82: # +S7 78
                self.extraNoneTempHint1.append(not bool(self.aw.s7.mode[6]))
                self.extraNoneTempHint2.append(not bool(self.aw.s7.mode[7]))
            elif d == 110: # +S7 910
                self.extraNoneTempHint1.append(not bool(self.aw.s7.mode[8]))
                self.extraNoneTempHint2.append(not bool(self.aw.s7.mode[9]))
            elif d == 111: # WebSocket
                self.extraNoneTempHint1.append(not bool(self.aw.ws.channel_modes[0]))
                self.extraNoneTempHint2.append(not bool(self.aw.ws.channel_modes[1]))
            elif d == 112: # +S7 34
                self.extraNoneTempHint1.append(not bool(self.aw.ws.channel_modes[2]))
                self.extraNoneTempHint2.append(not bool(self.aw.ws.channel_modes[3]))
            elif d == 113: # +S7 56
                self.extraNoneTempHint1.append(not bool(self.aw.ws.channel_modes[4]))
                self.extraNoneTempHint2.append(not bool(self.aw.ws.channel_modes[5]))
            elif d == 118: # +S7 78
                self.extraNoneTempHint1.append(not bool(self.aw.ws.channel_modes[6]))
                self.extraNoneTempHint2.append(not bool(self.aw.ws.channel_modes[7]))
            elif d == 119: # +S7 910
                self.extraNoneTempHint1.append(not bool(self.aw.ws.channel_modes[8]))
                self.extraNoneTempHint2.append(not bool(self.aw.ws.channel_modes[9]))
            else:
                self.extraNoneTempHint1.append(False)
                self.extraNoneTempHint2.append(False)

    def addPhidgetServer(self) -> None:
        if not self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork # type: ignore
            if self.phidgetServerID == '' and not self.phidgetServiceDiscoveryStarted:
                try:
                    # we enable the automatic service discovery if no server host is given
                    from Phidget22.PhidgetServerType import PhidgetServerType # type: ignore
                    PhidgetNetwork.enableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = True
                    self.aw.sendmessage(QApplication.translate('Message','Phidget service discovery started...'))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            else:
                PhidgetNetwork.addServer('PhidgetServer',self.phidgetServerID,self.phidgetPort,self.phidgetPassword,0)
                self.phidgetServerAdded = True

    def removePhidgetServer(self) -> None:
        if self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            try:
                PhidgetNetwork.removeServer('PhidgetServer')
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.phidgetServerAdded = False
            if self.phidgetServiceDiscoveryStarted:
                try:
                    from Phidget22.PhidgetServerType import PhidgetServerType
                    PhidgetNetwork.disableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = False
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    @staticmethod
    def deviceLogDEBUG() -> None:
        from Phidget22.Devices.Log import Log as PhidgetLog # type: ignore
        from Phidget22.LogLevel import LogLevel as PhidgetLogLevel # type: ignore
        PhidgetLog.setLevel(PhidgetLogLevel.PHIDGET_LOG_VERBOSE)

    @staticmethod
    def deviceLLogINFO() -> None:
        from Phidget22.Devices.Log import Log as PhidgetLog
        from Phidget22.LogLevel import LogLevel as PhidgetLogLevel
        PhidgetLog.setLevel(PhidgetLogLevel.PHIDGET_LOG_INFO)

    # returns True if any device (main or extra) is a Phidget, ambient sensor or button/slider actions contain Phidget commands
    # the PhidgetManager which makes Phidgets accessible is only started if PhdigetsConfigured returns True
    def PhidgetsConfigured(self) -> bool:

        # searching sets is faster than lists
        phidget_device_ids = set(self.phidgetDevices)

        # collecting all device ids in use (from main or extra)
        device_ids_in_use = self.extradevices[:]
        device_ids_in_use.append(self.device)

        # collecting ambient device ids in use (ids 1 and 3 indicate Phidgets modules)
        ambient_device_ids = [
            self.ambient_temperature_device,
            self.ambient_humidity_device,
            self.ambient_pressure_device]

        # IO Command, PWM Command, VOUT Command, RC Command
        # Note that those commands could also trigger Yoctopuce actions
        main_button_phidget_action_ids = { 5, 11, 12, 19 }

        # Note that the ids for the same Command types are different here:
        custom_button_phidget_action_ids = { 6, 13, 14, 21 }

        # Note that the ids for the same Command types are different here:
        slider_phidget_action_ids = { 9, 10, 11, 17 }

        return (
            any(i in phidget_device_ids for i in device_ids_in_use) or                    # phidget main/extra device
            any(i in {1, 3} for i in ambient_device_ids) or                               # phidget ambient device
            any(i in main_button_phidget_action_ids for i in self.buttonactions) or       # phidget actions in event button commands (CHARGE, .., COOL)
            any(i in main_button_phidget_action_ids for i in self.extrabuttonactions) or  # phidget actions in main event button commandss (ON, OFF, SAMPLE)
            any(i in main_button_phidget_action_ids for i in self.xextrabuttonactions) or # phidget actions in special event commands (RESET, START)
            any(i in custom_button_phidget_action_ids for i in self.aw.extraeventsactions) or  # phidget actions in custom event buttons commands
            any(i in slider_phidget_action_ids for i in self.aw.eventslideractions))           # phidget actions in slider commands


    # the PhidgetManager needs to run to allow Phidgets to attach
    # the PhidgetManager is only started if self.PhidgetsConfigured() returns True signaling
    # that Phidget modules are configured as main/extra devices, ambient devices, or in button/slider actions
    @pyqtSlot()
    def startPhidgetManager(self) -> None:
        # this is needed to suppress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/suppress_error.py fails to suppress this)
        if not self.aw.app.artisanviewerMode and self.PhidgetsConfigured():
            # Phidget server is only started if any device or action addressing Phidgets is configured
            if self.phidgetManager is None:
                try:
                    from Phidget22.Devices.Log import Log as PhidgetLog
                    from Phidget22.LogLevel import LogLevel as PhidgetLogLevel
                    PhidgetLog.enable(PhidgetLogLevel.PHIDGET_LOG_DEBUG, self.device_log_file)
                    PhidgetLog.enableRotating()
                    _log.info('phidgetLog started')
                except Exception: # pylint: disable=broad-except
                    pass # logging might already be enabled
            if self.phidgetRemoteFlag:
                try:
                    self.addPhidgetServer()
                    _log.info('phidgetServer added')
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    if self.device in self.phidgetDevices:
                        self.adderror(QApplication.translate('Error Message',"Exception: phidgetServer couldn't be added. Verify that the Phidget driver is correctly installed!"))
            if self.phidgetManager is None:
                try:
                    self.phidgetManager = PhidgetManager()
                    _log.info('phidgetManager started')
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                    if self.device in self.phidgetDevices:
                        self.adderror(QApplication.translate('Error Message',"Exception: PhidgetManager couldn't be started. Verify that the Phidget driver is correctly installed!"))

    def stopPhidgetManager(self) -> None:
        if not self.flagon:
            if self.phidgetManager is not None:
                self.phidgetManager.close()
                self.phidgetManager = None
                _log.info('phidgetManager stopped')
                try:
                    from Phidget22.Devices.Log import Log as PhidgetLog
                    PhidgetLog.disable()
                    _log.info('phidgetLog stopped')
                except Exception: # pylint: disable=broad-except
                    pass
            self.removePhidgetServer()

    def restartPhidgetManager(self) -> None:
        if not self.flagon:
            _log.info('restart phidgetManager')
            self.stopPhidgetManager()
            self.startPhidgetManager()

    # this one is protected by the sampleSemaphore not to mess up with the timex during sampling
    def resetTimer(self) -> None:
        try:
            self.samplingSemaphore.acquire(1)
            self.timeclock.start()
        finally:
            if self.samplingSemaphore.available() < 1:
                self.samplingSemaphore.release(1)

    @pyqtSlot()
    def OnMonitor(self) -> None:
        try:
            self.generateNoneTempHints()
            self.block_update = True # block the updating of the bitblit canvas (unblocked at the end of this function to avoid multiple redraws)
            res = self.reset(redraw=False, soundOn=False, keepProperties=True, onMonitor=True)
            if not res: # reset canceled
                return

#SCHEDULER:
            # set properties from selected Schedule
            if self.aw.schedule_window is not None and self.aw.plus_account is not None:
                # NOTE: scheduler is only active if connected to artisan.plus
                self.aw.schedule_window.set_selected_remaining_item_roast_properties()
                self.aw.schedule_window.load_selected_remaining_item_template()

            if self.aw.simulator is None:
                self.startPhidgetManager()
                # collect ambient data if any
                if self.ambient_pressure_device or self.ambient_humidity_device or self.ambient_temperature_device:
                    self.ambiThread = QThread()
                    self.ambiWorker = AmbientWorker(self.aw)
                    if self.ambiWorker is not None:
                        self.ambiWorker.moveToThread(self.ambiThread)
                        self.ambiThread.started.connect(self.ambiWorker.run)
                        self.ambiWorker.finished.connect(self.ambiThread.quit)
                        self.ambiWorker.finished.connect(self.ambiWorker.deleteLater)
                        self.ambiThread.finished.connect(self.ambiThread.deleteLater)
                        self.ambiThread.start()

            # warm up software PID (write current p-i-d settings,..)
            self.aw.pidcontrol.confSoftwarePID()

            # ADD DEVICE:
            if not bool(self.aw.simulator):
                if self.device == 53:
                    # connect HOTTOP
                    from artisanlib.hottop import Hottop
                    hottop_serial:SerialSettings = {
                                'port': self.aw.ser.comport,
                                'baudrate': self.aw.ser.baudrate,
                                'bytesize': self.aw.ser.bytesize,
                                'stopbits': self.aw.ser.stopbits,
                                'parity': self.aw.ser.parity,
                                'timeout': self.aw.ser.timeout}
                    self.aw.hottop = Hottop(
                        serial=hottop_serial,
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Hottop'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Hottop'),True,None))
                    self.aw.hottop.setLogging(self.device_logging)
                    self.aw.hottop.start()
                elif self.device == 134:
                    # connect Santoker
                    from artisanlib.santoker import Santoker
                    santoker_serial:Optional[SerialSettings] = None
                    if self.aw.santokerSerial and not self.aw.santokerBLE:
                        santoker_serial = {
                                'port': self.aw.ser.comport,
                                'baudrate': self.aw.ser.baudrate,
                                'bytesize': self.aw.ser.bytesize,
                                'stopbits': self.aw.ser.stopbits,
                                'parity': self.aw.ser.parity,
                                'timeout': self.aw.ser.timeout}
                    self.aw.santoker = Santoker(self.aw.santokerHost, self.aw.santokerPort,
                        santoker_serial, self.aw.santokerBLE,
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Santoker'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Santoker'),True,None),
                        # CHARGE handler disactivated to not trigger CHARGE after CHARGE is signalled to the machine by START
                        # NOTE: only after CHARGE the heater
#                        charge_handler=lambda : (self.markChargeDelaySignal.emit(0) if (self.timeindex[0] == -1) else None),
                        dry_handler=lambda : (self.markDRYSignal.emit(False) if (self.timeindex[1] == 0) else None),
                        fcs_handler=lambda : (self.markFCsSignal.emit(False) if (self.timeindex[2] == 0) else None),
                        scs_handler=lambda : (self.markSCsSignal.emit(False) if (self.timeindex[4] == 0) else None),
                        drop_handler=lambda : (self.markDropSignal.emit(False) if (self.timeindex[6] == 0) else None))
                    self.aw.santoker.setLogging(self.device_logging)
                    self.aw.santoker.start()
                elif self.device == 171:
                    # connect Santoker R
                    from artisanlib.santoker_r import SantokerR
                    self.aw.santokerR = SantokerR(
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Santoker R'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Santoker R'),True,None))
                    self.aw.santokerR.setLogging(self.device_logging)
                    self.aw.santokerR.start(case_sensitive=False)
                elif self.device == 175:
                    # connect Thermoworks BlueDOT
                    from artisanlib.bluedot import BlueDOT
                    self.aw.thermoworksBlueDOT = BlueDOT(
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Thermoworks BlueDOT'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Thermoworks BlueDOT'),True,None))
                    self.aw.thermoworksBlueDOT.setLogging(self.device_logging)
                    self.aw.thermoworksBlueDOT.start(case_sensitive=False)
                elif self.device == 138:
                    # connect Kaleido
                    from artisanlib.kaleido import KaleidoPort
                    self.aw.kaleido = KaleidoPort()
                    self.aw.kaleido.setLogging(self.device_logging)
                    kaleido_serial:Optional[SerialSettings] = None
                    if self.aw.kaleidoSerial:
                        kaleido_serial = {
                                'port': self.aw.ser.comport,
                                'baudrate': self.aw.ser.baudrate,
                                'bytesize': self.aw.ser.bytesize,
                                'stopbits': self.aw.ser.stopbits,
                                'parity': self.aw.ser.parity,
                                'timeout': self.aw.ser.timeout}
                    self.aw.kaleido.start(self.mode, self.aw.kaleidoHost, self.aw.kaleidoPort,
                        serial=kaleido_serial,
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Kaleido'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Kaleido'),True,None))
                elif self.device == 142:
                    try:
                        from artisanlib.ikawa import IKAWA_BLE
                        self.aw.ikawa = IKAWA_BLE(
                            connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('IKAWA'),True,None),
                            disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('IKAWA'),True,None))
                        if self.aw.ikawa is not None:
                            self.aw.ikawa.setLogging(self.device_logging)
                            self.aw.ikawa.start_sampling()
                            self.aw.sendmessageSignal.emit(QApplication.translate('Message', 'scanning for device'),True,None)
                    except Exception as ex:  # pylint: disable=broad-except
                        _log.error(ex)
                        _, _, exc_tb = sys.exc_info()
                        self.adderror((QApplication.translate('Error Message', 'Exception:') + ' Bluetooth BLE support not available {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                elif self.device == 164:
                    # connect Mugma
                    from artisanlib.mugma import Mugma
                    self.aw.mugma = Mugma(self.aw.mugmaHost, self.aw.mugmaPort, self.device_logging,
                        connected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} connected').format('Mugma'),True,None),
                        disconnected_handler=lambda : self.aw.sendmessageSignal.emit(QApplication.translate('Message', '{} disconnected').format('Mugma'),True,None))
                    self.aw.mugma.setLogging(self.device_logging)
                    self.aw.mugma.start()


            self.aw.initializedMonitoringExtraDeviceStructures()

            # reset LCD int/float cache
            #_log.info("intChannel cache: %s",self.intChannel.cache_info())
            self.intChannel.cache_clear()

            #reset alarms
            self.silent_alarms = False
            self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
            #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
            self.TPalarmtimeindex = None

            self.flagon = True
            self.redraw(True,re_smooth_foreground=False, re_smooth_background=True) # there is now foreground at this point; we need to re-smooth background with no curve-smoothing and standard instead of optimal-smoothing on ON

            if self.designerflag:
                return
            self.aw.sendmessage(QApplication.translate('Message','Scope monitoring...'))
            #disable RESET button:
            self.aw.buttonRESET.setEnabled(False)
            self.aw.buttonRESET.setVisible(False)

            # disable "green flag" menu:
            try:
                self.aw.ntb.disable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            if self.aw.simulator:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles_simulator['ON'])
            else:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles['ON'])

            self.aw.buttonONOFF.setText(QApplication.translate('Button', 'OFF')) # text means click to turn OFF (it is ON)
            self.aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Stop monitoring'))
            self.aw.buttonSTARTSTOP.setEnabled(True) # ensure that the START button is enabled
            self.aw.disableEditMenus()
            self.aw.update_extraeventbuttons_visibility()
            self.aw.updateExtraButtonsVisibility()
            self.aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            self.aw.update_minieventline_visibility()
            self.aw.pidcontrol.activateONOFFeasySV(self.aw.pidcontrol.svButtons and self.aw.buttonONOFF.isVisible())
            self.aw.pidcontrol.activateSVSlider(self.aw.pidcontrol.svSlider and self.aw.buttonONOFF.isVisible())
            self.block_update = False # unblock the updating of the bitblit canvas
            self.aw.updateReadingsLCDsVisibility() # this one triggers the resize and the recreation of the bitblit canvas

            if self.device == 138:
                # if Kaleido Serial or Network is selected we run the ON action before starting the sample thread
                try:
                    self.aw.eventactionx(self.extrabuttonactions[0],self.extrabuttonactionstrings[0])
                except Exception as e: # pylint: disable=broad-except
                    _log.error(e)
                QApplication.processEvents()
            self.threadserver.createSampleThread()
            if self.device != 138:
                # if not Kaleido Serial or Network we run the ON action after starting the sample thread which might start the connection in the first place
                try:
                    self.aw.eventactionx(self.extrabuttonactions[0],self.extrabuttonactionstrings[0])
                except Exception as e: # pylint: disable=broad-except
                    _log.error(e)

            if not bool(self.aw.simulator):
                QTimer.singleShot(300,self.StartAsyncSamplingAction)
            _log.info('MODE: ON MONITOR (sampling @%ss)', float2float(self.delay/1000))
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OnMonitor() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            self.block_update = False # unblock the updating of the bitblit canvas

    # OffMonitorCloseDown is called after the sampling loop stopped
    @pyqtSlot()
    def OffMonitorCloseDown(self) -> None:
        _log.debug('MODE: OffMonitorCloseDown')
        try:
            self.threadserver.terminatingSignal.disconnect(self.OffMonitorCloseDown)

            # reset WebLCDs
            resLCD = '-.-' if self.LCDdecimalplaces else '--'
            if self.aw.WebLCDs:
                self.updateWebLCDs(bt=resLCD,et=resLCD)

            if len(self.timex) < 3:
                # clear data from monitoring-only mode
                self.clearMeasurements()
            else:
                # we only reset the LCDs, but keep the readings
                self.clearLCDs()

            #if self.device != 138: # don't forward pidOff command to connected Kaleido machine
            self.aw.pidcontrol.pidOff(send_command=self.device != 138)

            try:
                if not bool(self.aw.simulator) and self.device == 53 and self.aw.hottop is not None and \
                        not self.aw.hottop.hasHottopControl():
                    # disconnect HOTTOP only if not under Artisan control
                    self.aw.hottop.stop()
                    self.aw.hottop = None

                # disconnect Santoker
                if not bool(self.aw.simulator) and self.device == 134 and self.aw.santoker is not None:
                    self.aw.santoker.stop()
                    self.aw.santoker = None

                # disconnect Santoker R
                if not bool(self.aw.simulator) and self.device == 171 and self.aw.santokerR is not None:
                    self.aw.santokerR.stop()
                    self.aw.santokerR = None

                # disconnect Thermoworks BlueDOT
                if not bool(self.aw.simulator) and self.device == 175 and self.aw.thermoworksBlueDOT is not None:
                    self.aw.thermoworksBlueDOT.stop()
                    self.aw.thermoworksBlueDOT = None

                # disconnect Kaleido
                if not bool(self.aw.simulator) and self.device == 138 and self.aw.kaleido is not None:
                    self.aw.kaleido.stop()
                    self.aw.kaleido = None

                # disconnect IKAWA
                if not bool(self.aw.simulator) and self.device == 142 and self.aw.ikawa is not None:
                    self.aw.ikawa.stop_sampling()
                    try:
                        if self.aw.ikawa.ambient_pressure != -1:
                            self.ambient_pressure = self.aw.ikawa.ambient_pressure
                    except Exception as e: # pylint: disable=broad-except
                        _log.error(e)
                    self.aw.ikawa = None

                # disconnect Mugma
                if not bool(self.aw.simulator) and self.device == 164 and self.aw.mugma is not None:
                    self.aw.mugma.stop()
                    self.aw.mugma = None

                # at OFF we stop the follow-background on FujiPIDs and set the SV to 0
                if self.device == 0 and self.aw.fujipid.followBackground and self.aw.fujipid.sv and self.aw.fujipid.sv > 0:
                    try:
                        self.aw.fujipid.setsv(0,silent=True)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                    self.aw.fujipid.sv = 0
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            QTimer.singleShot(5,self.disconnectProbes)
            # reset the canvas color when it was set by an alarm but never reset
            if 'canvas_alt' in self.palette:
                self.palette['canvas'] = self.palette['canvas_alt']
                self.aw.updateCanvasColors(checkColors=False)
            #enable RESET button:
            self.aw.buttonRESET.setStyleSheet(self.aw.pushbuttonstyles['RESET'])
            self.aw.buttonRESET.setEnabled(True)
            self.aw.buttonRESET.setVisible(True)

            # reset a stopped simulator
            self.aw.sample_loop_running = True
            self.aw.time_stopped = 0

            # enable "green flag" menu:
            try:
                self.aw.ntb.enable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            if self.aw.simulator:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles_simulator['OFF'])
            else:
                self.aw.buttonONOFF.setStyleSheet(self.aw.pushbuttonstyles['OFF'])
            self.aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Start monitoring'))
            self.aw.sendmessage(QApplication.translate('Message','Scope stopped'))
            self.aw.buttonONOFF.setText(QApplication.translate('Button', 'ON')) # text means click to turn OFF (it is ON)
            # reset time LCD color to the default (might have been changed to red due to long cooling!)
            self.aw.updateReadingsLCDsVisibility()

            if not self.aw.HottopControlActive:
                self.aw.hideExtraButtons(changeDefault=False)
            self.aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            self.aw.update_minieventline_visibility()
            self.aw.updateExtraButtonsVisibility()
            self.aw.pidcontrol.activateONOFFeasySV(False)
            self.StopAsyncSamplingAction()
            self.aw.enableEditMenus()

            self.aw.autoAdjustAxis()
            self.redraw(recomputeAllDeltas=True,re_smooth_foreground=True, re_smooth_background=True)
            # HACK:
            # with visible (draggable) legend a click (or several) on the canvas makes the extra lines disappear
            # this happens after real recordings or simlator runs and also if signals onclick/onpick/ondraw are disconnected
            # solutions are to run an updateBackground() or another redraw() about in 100s using a QTimer
            # also a call  to self.fig.canvas.flush_events() or QApplication.processEvents() here resolves it. A libtime.sleep(1) does not solve the issue
            QTimer.singleShot(100,self.updateBackground) # solves the issue and is faster than the other 2 options
#            self.fig.canvas.flush_events() # solves the issue (takes ~1sec)
#            QApplication.processEvents()  # solves the issue (but is more general as the MPL flush_events (takes ~1sec)

            # we autosave after full redraw after OFF to have the optional generated PDF containing all information
            if len(self.timex) > 2 and self.autosaveflag != 0 and self.autosavepath:
                try:
                    self.aw.automaticsave()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

            # update error dlg
            if self.aw.error_dlg:
                self.aw.error_dlg.update_log()
            #update serial_dlg
            if self.aw.serial_dlg:
                try:
                    self.aw.serial_dlg.update_log()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

            try:
                # Artisan Commands are executed after the OFFMonitor action is fully executed as they might trigger other buttons
                if self.extrabuttonactions[1] == 18:
                    self.aw.eventactionx(self.extrabuttonactions[1],self.extrabuttonactionstrings[1])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            self.aw.buttonONOFF.setEnabled(True)
            self.aw.buttonONOFF.setGraphicsEffect(self.aw.makeShadow())
            self.aw.buttonSTARTSTOP.setEnabled(True)
            self.aw.buttonSTARTSTOP.setGraphicsEffect(self.aw.makeShadow())
            self.aw.buttonCONTROL.setEnabled(True)
            self.aw.buttonCONTROL.setGraphicsEffect(self.aw.makeShadow())

            if self.flagKeepON and len(self.timex) > 10:
                QTimer.singleShot(300, self.onMonitorSignal.emit)

            self.aw.updatePlusStatusSignal.emit() # update plus icon (roast might not have been uploaded yet)

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OffMonitorCloseDown() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def OffMonitor(self) -> None:
        _log.info('MODE: OFF MONITOR')
        if self.flagon:
            try:
                # first activate "Stopping Mode" to ensure that sample() is not resetting the timer now (independent of the flagstart state)

                self.aw.buttonONOFF.setEnabled(False)
                ge:Optional[QGraphicsEffect] = self.aw.buttonONOFF.graphicsEffect()
                if ge is not None:
                    ge.setEnabled(False)
                self.aw.buttonSTARTSTOP.setEnabled(False)
                ge = self.aw.buttonSTARTSTOP.graphicsEffect()
                if ge is not None:
                    ge.setEnabled(False)
                self.aw.buttonSTARTSTOP.setEnabled(False)

                self.aw.buttonCONTROL.setEnabled(False)
                ge = self.aw.buttonCONTROL.graphicsEffect()
                if ge is not None:
                    ge.setEnabled(False)

                # stop Recorder if still running
                if self.flagstart:
                    self.OffRecorder(autosave=False, enableButton=False) # we autosave after the monitor is turned off to get all the data in the generated PDF!

                try:
                    # trigger event action before disconnecting from devices
                    if self.extrabuttonactions[1] != 18: # Artisan Commands are executed after the OFFMonitor action is fully executed as they might trigger another buttons
                        self.aw.eventactionx(self.extrabuttonactions[1],self.extrabuttonactionstrings[1])
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)


                self.threadserver.terminatingSignal.connect(self.OffMonitorCloseDown)
                self.flagon = False

                self.getMeterReads()

            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OffMonitor() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # input: extratemp, outputs: modified extratemp, rollover_index, error_flag
    def conditionMeterData(self,extratemp:List[float]) -> Tuple[List[float], int, bool]:
        try:
            # Don't accept a zero length list
            if len(extratemp) == 0:
                return extratemp, -1, True

            # Look for invalid (-1) meter values in the begin and end samples
            max_begin_invalid_samples = 10  # allows for some invalid meter samples after startup
            max_end_invalid_samples = 3     # allows for some invalid meter samples before ending
            pct_invalid_samples = .1        # percent invalid samples

            # Convert the list to a numpy array
            arr = numpy.array(extratemp)

            # Find the indexes of non-negative elements
            positive_value_indexes = numpy.where(arr >= 0)[0]

            # Check for too many invalid readings at begin and end
            if (positive_value_indexes[0] > max_begin_invalid_samples or
                positive_value_indexes[-1] < (len(extratemp) - max_end_invalid_samples -1)):
                return extratemp, -1, True  # invalid meter read

            # Reject if there are less than 90% valid samples
            if len(positive_value_indexes) / len(extratemp) < (1 - pct_invalid_samples):
                self.adderror(QApplication.translate('Error Message', 'Unstable meter data'))
                return extratemp, -1, True

            # Interpolate any -1 values from extratemp, set interpolate_max based on pct_invalid_samples
            arr = numpy.array(fill_gaps(arr, int(math.ceil(len(arr)*(pct_invalid_samples)))))

            # Replace rightmost -1's, if any, with last valid value from the left
            last_valid = -1
            for i in range(1, len(arr), 1):
                if arr[i] != -1:
                    last_valid = arr[i]
                else:
                    arr[i] = last_valid

            # Create a boolean array to find decreases in succeeding values
            decreases = arr[1:] < arr[:-1]

            # Count the number of decreases
            count_decreases:numpy.double = numpy.sum(decreases)

            # Check for any decreases
            rollover_index:int = -1
            if count_decreases == 1:
                # Rollover detected, get the index of the first occurrence of the decrease
                rollover_index = int(numpy.argmax(decreases))
            if count_decreases > 1:
                self.adderror(QApplication.translate('Error Message', 'Unstable meter data'))
                return extratemp, -1, True

            # All good
            return arr.tolist(), rollover_index, False

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            return extratemp, -1, True


    @staticmethod
    # Helper function to calculate the meter difference and correct for rollover
    def calc_meter_read(extratemp:List[float], event_index:int=-1, rollover_index:int=-1) -> float:
        try:
            # Calculate the meter read
            begin = extratemp[0]
            if event_index == -1:
                end = extratemp[-1]
            elif event_index > 0:
                end = extratemp[event_index]
            else:
                return 0 # invalid meter read
            # Test for rollover in the range of the meter read
            if (event_index == -1 and rollover_index > 0) or (0 < rollover_index < event_index) :
                # rollover detected
                rollover_value = extratemp[rollover_index]
                return  float2float(end + rollover_value - begin,5)
            # no rollover
            return  float2float(end - begin,5)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            return 0

    def getMeterReads(self) -> None:
        # Read meters
        self.meterreads = self.meterreads_default.copy()  # init to zero in case of an exception
        event_meterread = [-1]*8
        for i in range(2):
            if self.metersources[i] > 0:
                x = self.metersources[i]-1
                try:
                    if x % 2 == 0:  #even
                        if len(self.extratemp1) > (x/2):
                            meterarray,rolloveridx,failed = self.conditionMeterData(self.extratemp1[x // 2])
                        else:
                            break
                    elif len(self.extratemp2) > (x/2):  # odd
                        meterarray,rolloveridx,failed = self.conditionMeterData(self.extratemp2[x // 2])
                    else:
                        break
                    if failed:
                        break

                    for event in range(8):
                        # if no timeindex then leave at initialized -1 value
                        if self.timeindex[event] > 0:
                            event_meterread[event] = self.timeindex[event]

                    self.meterreads[i] = [
                        float2float(
                            self.convertHeat(
                                self.calc_meter_read(meterarray, -1, rolloveridx),
                                self.meterunitnames[self.meterunits[i]],
                                'BTU'
                            ),
                            5
                        )
                    ] + [
                        float2float(
                            self.convertHeat(
                                self.calc_meter_read(meterarray, self.timeindex[j], rolloveridx),
                                self.powerunits[self.meterunits[i]],
                                'BTU'
                            ),
                            5
                        ) for j in range(len(self.timeindex))
                    ]

                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

    def getAmbientData(self) -> None:
        _log.debug('getAmbientData()')
        # this is needed to suppress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/suppresss_error.py fails to suppress this)
#        _stderr = sys.stderr
#        sys.stderr = object
        try:
            humidity = None
            temp = None # assumed to be gathered in C (not F!)
            pressure = None

            #--- humidity
            if self.ambient_humidity_device == 1: # Phidget HUM1000
                humidity = self.aw.ser.PhidgetHUM1000humidity()
            elif self.ambient_humidity_device == 2: # Yocto Meteo
                humidity = self.aw.ser.YoctoMeteoHUM()

            #--- temperature
            if self.ambient_temperature_device == 1: # Phidget HUM1000
                temp = self.aw.ser.PhidgetHUM1000temperature()
            elif self.ambient_temperature_device == 2: # Yocto Meteo
                temp = self.aw.ser.YoctoMeteoTEMP()
            elif self.ambient_temperature_device == 3: # Phidget TMP1000
                temp = self.aw.ser.PhidgetTMP1000temperature()

            #--- pressure
            if self.ambient_pressure_device == 1: # Phidget PRE1000
                pressure = self.aw.ser.PhidgetPRE1000pressure()
                if pressure is not None:
                    pressure = pressure * 10 # convert to hPa/mbar
            elif self.ambient_pressure_device == 2: # Yocto Meteo
                pressure = self.aw.ser.YoctoMeteoPRESS()

            # calc final values
            if pressure is not None:
                # we just assume 23C room temperature if no ambient temperature is given or ambient temperature is out of range
                t = 23 if temp is None or temp < -20 or temp > 40 else temp
                pressure = self.barometricPressure(pressure,t,self.elevation)

            # set and report
            if humidity is not None:
                self.ambient_humidity = float2float(humidity,1)
                self.ambient_humidity_sampled = self.ambient_humidity
                self.aw.sendmessage(QApplication.translate('Message','Humidity: {}%').format(self.ambient_humidity))
                libtime.sleep(1)

            if temp is not None:
                if self.mode == 'F':
                    temp = fromCtoFstrict(temp)
                self.ambientTemp = float2float(temp,1)
                self.ambientTemp_sampled = self.ambientTemp
                self.aw.sendmessage(QApplication.translate('Message','Temperature: {}{}').format(self.ambientTemp,self.mode))
                libtime.sleep(1)

            if pressure is not None:
                self.ambient_pressure = float2float(pressure,1)
                self.ambient_pressure_sampled = self.ambient_pressure
                self.aw.sendmessage(QApplication.translate('Message','Pressure: {}hPa').format(self.ambient_pressure))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
#        finally:
#            sys.stderr = _stderr

    # computes the barometric pressure from
    #   aap:  atmospheric pressure in hPa
    #   atc:  temperature in Celsius
    #   hasl: height above sea level in m
    # see https://www.wmo.int/pages/prog/www/IMOP/meetings/SI/ET-Stand-1/Doc-10_Pressure-red.pdf
    @staticmethod
    def barometricPressure(aap:float, atc:float, hasl:float) -> float:
        return float(aap * pow((1 - ((0.0065*hasl) / (atc + (0.0065*hasl) + 273.15))),-5.257))

    # close serial port, Phidgets and Yocto ports
    def disconnectProbesFromSerialDevice(self, ser:'serialport') -> None:
        try:
            self.samplingSemaphore.acquire(1)

            if ser.colorTrackBT is not None:
                ser.colorTrackBT.stop()
                libtime.sleep(0.05)
                ser.colorTrackBT = None

            if ser.colorTrackSerial is not None:
                ser.colorTrackSerial.stop()
                libtime.sleep(0.05)
                ser.colorTrackSerial = None

            # close main serial port
            try:
                ser.closeport()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # disconnect phidgets
            if ser.PhidgetTemperatureSensor is not None:
                try:
                    if ser.PhidgetTemperatureSensor[0].getAttached():
                        serial = ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber()
                        port = ser.PhidgetTemperatureSensor[0].getHubPort()  # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetTemperatureSensor[0].getDeviceID()
                        ser.PhidgetTemperatureSensor[0].close()
                        ser.phidget1048detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetTemperatureSensor) > 1 and ser.PhidgetTemperatureSensor[1].getAttached():
                        serial = ser.PhidgetTemperatureSensor[1].getDeviceSerialNumber()
                        port = ser.PhidgetTemperatureSensor[1].getHubPort()  # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetTemperatureSensor[1].getDeviceID()
                        ser.PhidgetTemperatureSensor[1].close()
                        ser.phidget1048detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.Phidget1048values = [[],[],[],[]]
                ser.Phidget1048lastvalues = [-1]*4
                ser.PhidgetTemperatureSensor = None
            if ser.PhidgetIRSensor is not None:
                try:
                    if ser.PhidgetIRSensor.getAttached():
                        serial = ser.PhidgetIRSensor.getDeviceSerialNumber()
                        port = ser.PhidgetIRSensor.getHubPort() # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetIRSensor.getDeviceID()
                        ser.PhidgetIRSensor.close()
                        ser.phidget1045detached(serial,port,deviceType) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if ser.PhidgetIRSensorIC is not None and ser.PhidgetIRSensorIC.getAttached():
                        ser.PhidgetIRSensorIC.close()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.PhidgetIRSensor = None
                ser.Phidget1045values = [] # async values of the one channel
                ser.Phidget1045lastvalue = -1
                ser.Phidget1045tempIRavg = None
                ser.PhidgetIRSensorIC = None
            if ser.PhidgetBridgeSensor is not None:
                try:
                    if ser.PhidgetBridgeSensor[0].getAttached():
                        serial = ser.PhidgetBridgeSensor[0].getDeviceSerialNumber()
                        port = ser.PhidgetBridgeSensor[0].getHubPort()   # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetBridgeSensor[0].getDeviceID()
                        ser.PhidgetBridgeSensor[0].close()
                        ser.phidget1046detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetBridgeSensor) > 1 and ser.PhidgetBridgeSensor[1].getAttached():
                        serial = ser.PhidgetBridgeSensor[1].getDeviceSerialNumber()
                        port = ser.PhidgetBridgeSensor[1].getHubPort()   # returns 0 for USB Phidgets!
                        deviceType = ser.PhidgetBridgeSensor[1].getDeviceID()
                        ser.PhidgetBridgeSensor[1].close()
                        ser.phidget1046detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.Phidget1046values = [[],[],[],[]]
                ser.Phidget1046lastvalues = [-1]*4
                ser.PhidgetBridgeSensor = None
            if ser.PhidgetIO is not None:
                try:
                    if ser.PhidgetIO[0].getAttached():
                        serial = ser.PhidgetIO[0].getDeviceSerialNumber()
                        port = ser.PhidgetIO[0].getHubPort()   # returns 0 for USB Phidgets!
                        className = ser.PhidgetIO[0].getChannelClassName()
                        deviceType = ser.PhidgetIO[0].getDeviceID()
                        ser.PhidgetIO[0].close()
                        ser.phidget1018detached(serial,port,className,deviceType,0)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                try:
                    if len(ser.PhidgetIO) > 1 and ser.PhidgetIO[1].getAttached():
                        serial = ser.PhidgetIO[1].getDeviceSerialNumber()
                        port = ser.PhidgetIO[1].getHubPort()   # returns 0 for USB Phidgets!
                        className = ser.PhidgetIO[1].getChannelClassName()
                        deviceType = ser.PhidgetIO[1].getDeviceID()
                        ser.PhidgetIO[1].close()
                        ser.phidget1018detached(serial,port,className,deviceType,1)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                ser.PhidgetIO = None
                ser.PhidgetIOvalues = [[],[],[],[],[],[],[],[]]
                ser.PhidgetIOlastvalues = [-1]*8
            if ser.YOCTOsensor is not None:
                try:
                    ser.YOCTOsensor = None
                    ser.YOCTOchan1 = None
                    ser.YOCTOchan2 = None
                    ser.YOCTOtempIRavg = None
                    if ser.YOCTOthread is not None:
                        ser.YOCTOthread.join()
                        ser.YOCTOthread = None
                    ser.YOCTOvalues = [[],[]]
                    ser.YOCTOlastvalues = [-1]*2
                    YAPI.FreeAPI() # type:ignore[reportUnboundVariable,unused-ignore]
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
        finally:
            if self.samplingSemaphore.available() < 1:
                self.samplingSemaphore.release(1)

    # close Phidget and and Yocto outputs
    def closePhidgetOUTPUTs(self) -> None:
        # close Phidget Digital Outputs
        self.aw.ser.phidgetOUTclose()
        # close Phidget Digital Outputs on Hub
        self.aw.ser.phidgetOUTcloseHub()
        # close Phidget IO Outputs
        self.aw.ser.phidgetBinaryOUTclose()
        # close Phidget Analog Outputs
        self.aw.ser.phidgetVOUTclose()
        # close Phidget DCMotors
        self.aw.ser.phidgetDCMotorClose()
        # close Phidget RC Servos
        self.aw.ser.phidgetRCclose()
        # close Phidget Stepper Motors
        self.aw.ser.phidgetStepperClose()
        # close Yocto Voltage Outputs
        self.aw.ser.yoctoVOUTclose()
        # close Yocto Current Outputs
        self.aw.ser.yoctoCOUTclose()
        # close Yocto Relay Outputs
        self.aw.ser.yoctoRELclose()
        # close Yocto Servo Outputs
        self.aw.ser.yoctoSERVOclose()
        # close Yocto PWM Outputs
        self.aw.ser.yoctoPWMclose()

    def closePhidgetAMBIENTs(self) -> None:
        # note that we do not unregister this detach in the self.phidgetManager as we only support one of those devices
        try:
            if self.aw.ser.TMP1000temp is not None and self.aw.ser.TMP1000temp.getAttached():
                self.aw.ser.TMP1000temp.close()
                _log.debug('Phidget TMP1000 temperature channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if self.aw.ser.PhidgetHUMtemp is not None and self.aw.ser.PhidgetHUMtemp.getAttached():
                self.aw.ser.PhidgetHUMtemp.close()
                _log.debug('Phidget HUM100x temperature channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if self.aw.ser.PhidgetHUMhum is not None and self.aw.ser.PhidgetHUMhum.getAttached():
                self.aw.ser.PhidgetHUMhum.close()
                _log.debug('Phidget HUM100x humidity channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        try:
            if self.aw.ser.PhidgetPREpre is not None and self.aw.ser.PhidgetPREpre.getAttached():
                self.aw.ser.PhidgetPREpre.close()
                _log.debug('Phidget PRE1000 pressure channel closed')
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)


    @pyqtSlot()
    def disconnectProbes(self) -> None:
        _log.debug('disconnectProbes')
        # close ports of main device
        self.disconnectProbesFromSerialDevice(self.aw.ser)
        # close (serial) port of Modbus device
        self.aw.modbus.disconnect()
        # close port of S7 device
        self.aw.s7.disconnect()
        # close WebSocket connection
        self.aw.ws.disconnect()
        # close ports of extra devices
        for xs in self.aw.extraser:
            self.disconnectProbesFromSerialDevice(xs)

    @pyqtSlot()
    def toggleMonitorTigger(self) -> None:
        self.ToggleMonitor()

    #Turns ON/OFF flag self.flagon to read and print values. Called from push buttonONOFF.
    @pyqtSlot(bool)
    def ToggleMonitor(self, _:bool = False) -> None:
        _log.debug('ToggleMonitor')
        #turn ON
        if not self.flagon:
            # the sample thread might still run, but should terminate soon. We do nothing and ignore this click on ON
            if not self.flagsamplingthreadrunning:
                if not self.checkSaved():
                    return
                self.aw.soundpopSignal.emit()
                self.OnMonitor()
        #turn OFF
        else:
            try:
                self.aw.soundpopSignal.emit()
            except Exception: # pylint: disable=broad-except
                pass
            self.OffMonitor()

    @pyqtSlot()
    def fireChargeTimer(self) -> None:
        #### lock shared resources #####
        try:
            self.profileDataSemaphore.acquire(1)
            self.autoChargeIdx = max(1,len(self.timex))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        self.markChargeSignal.emit(False) # this queues an event which forces a realignment/redraw by resetting the cache ax_background and fires the CHARGE action

    def registerLockScheduleSent(self) -> None:
        self.plus_lockSchedule_sent_account = self.aw.plus_account
        self.plus_lockSchedule_sent_date = str(datetime.datetime.now().astimezone().date())

    # returns True if the lockSchedule was already sent for today and the current account
    def lockScheduleSent(self) -> bool:
        return (self.plus_lockSchedule_sent_account is not None and self.plus_lockSchedule_sent_account == self.aw.plus_account and
            self.plus_lockSchedule_sent_date is not None and self.plus_lockSchedule_sent_date == str(datetime.datetime.now().astimezone().date()))

    def OnRecorder(self) -> None:
        try:
            # if on turn mouse crosslines off
            if self.crossmarker:
                self.togglecrosslines()
            self.set_xlabel('')
            if self.ax is not None:
                self.ax.set_ylabel('')
            if not self.title_show_always:
                self.setProfileTitle('')

            self.aw.cacheCurveVisibilities()

            # disable "green flag" menu:
            try:
                self.aw.ntb.disable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # reset LCD timer color that might have been reset by the RS PID in monitoring mode:
            self.aw.setTimerColor('timer')
            if self.delta_ax is not None:
                y_label = self.delta_ax.set_ylabel('')
                try:
                    y_label.set_in_layout(False) # remove y-axis labels from tight_layout calculation
                except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass

            self.resetTimer() #reset time, otherwise the recorded timestamps append to the time on START after ON!

            self.flagstart = True

            self.timealign(redraw=True)

            # start Monitor if not yet running
            if not self.flagon:
                self.OnMonitor()
            try:
                self.aw.eventactionx(self.xextrabuttonactions[1],self.xextrabuttonactionstrings[1])
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)

            # update the roasts start time
            self.roastdate = QDateTime.currentDateTime()
            self.roastepoch = self.roastdate.toSecsSinceEpoch()
            self.roasttzoffset = libtime.timezone

            self.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
            self.roastbatchpos = 1 # initialized to 1, set to increased batchsequence on DROP
            if not self.title_show_always:
                self.fig.suptitle('')
            self.profile_sampling_interval = self.delay / 1000.
            self.updateDeltaSamples()
            self.aw.disableSaveActions()
            self.aw.sendmessage(QApplication.translate('Message','Scope recording...'))
            self.aw.buttonSTARTSTOP.setEnabled(False)
            ge:Optional[QGraphicsEffect] = self.aw.buttonSTARTSTOP.graphicsEffect()
            if ge is not None:
                ge.setEnabled(False)
#            self.aw.buttonSTARTSTOP.setGraphicsEffect(None) # not type correct as setGraphicsEffect expects a QGraphicsEffect
            self.aw.buttonONOFF.setText(QApplication.translate('Button', 'OFF')) # text means click to turn OFF (it is ON)
            self.aw.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Stop recording'))
            self.aw.buttonONOFF.setEnabled(True) # ensure that the OFF button is enabled
            #disable RESET button:
            self.aw.buttonRESET.setEnabled(False)
            self.updateLCDtime()
            self.aw.lowerbuttondialog.setVisible(True)
            self.aw.applyStandardButtonVisibility()
            if self.aw.keyboardmoveflag:
                self.aw.keyboardmoveflag = 0
                self.aw.moveKbutton('enter', force=True)

            self.aw.update_extraeventbuttons_visibility()
            self.aw.updateExtraButtonsVisibility()

            if self.buttonvisibility[0]: # if CHARGE button is visible we let it blink on START
                self.aw.buttonCHARGE.startAnimation()

            self.aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            self.aw.update_minieventline_visibility()
            self.aw.updateReadingsLCDsVisibility() # update visibility of reading LCDs based on the user preference
            if self.phasesLCDflag:
                self.aw.phasesLCDs.show()
                self.aw.TP2DRYlabel.setStyleSheet("background-color:'transparent'; color: " + self.palette['messages'][:7] + ';')
                self.aw.DRY2FCslabel.setStyleSheet("background-color:'transparent'; color: " + self.palette['messages'][:7] + ';')
            if self.AUClcdFlag:
                self.aw.AUCLCD.show()

            self.phasesLCDmode = self.phasesLCDmode_l[0]

            self.aw.update_minieventline_visibility()

            # lock todays schedule
            if self.aw.plus_account is not None and self.aw.schedule_window is not None and len(self.aw.schedule_window.scheduled_items)>0 and not self.lockScheduleSent():
                try:
                    sendLockSchedule()
                except Exception: # pylint: disable=broad-except
                    pass

            # set CHARGEtimer
            if self.chargeTimerFlag:
                if self.chargeTimerPeriod > 0:
                    self.aw.setTimerColor('slowcoolingtimer')
                QTimer.singleShot(self.chargeTimerPeriod*1000, self.fireChargeTimer)

            _log.info('MODE: START RECORDING')
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OnRecorder() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def OffRecorder(self, autosave:bool = True, enableButton:bool = True) -> None:
        _log.info('MODE: STOP RECORDING')
        try:
            # mark DROP if not yet set (and DROP not undone), at least 7min roast time and CHARGE is set and either autoDROP is active or DROP button is hidden
            if self.timeindex[6] == 0 and self.timeindex[0] != -1 and self.autoDROPenabled and (self.autoDropFlag or not self.buttonvisibility[6]):
                start = self.timex[self.timeindex[0]]
                if (len(self.timex)>0 and self.timex[-1] - start) > 7*60: # only after 7min into the roast
                    self.markDrop()
            if self.timeindex[6] == 0 and self.autoDROPenabled:
                # if DROP is still not set (and was never set before, eg. autoDROP is still enabled), we reset the scheduleID not
                # to have this still incomplete roast be associated with any scheduleItem (rule: a roast without a DROP is never automatically registered as scheduleItem)
                self.scheduleID = None
            self.cacheforBbp()  # save items for bbp
            self.aw.enableSaveActions()
            self.aw.resetCurveVisibilities()
            self.flagstart = False
            if self.aw.simulator:
                self.aw.buttonSTARTSTOP.setStyleSheet(self.aw.pushbuttonstyles_simulator['STOP'])
            else:
                self.aw.buttonSTARTSTOP.setStyleSheet(self.aw.pushbuttonstyles['STOP'])
            if enableButton:
                self.aw.buttonSTARTSTOP.setEnabled(True)
                self.aw.buttonSTARTSTOP.setGraphicsEffect(self.aw.makeShadow())
            #enable RESET button:
            self.aw.buttonRESET.setStyleSheet(self.aw.pushbuttonstyles['RESET'])
            self.aw.buttonRESET.setEnabled(True)
            self.updateLCDtime()
            #prevents accidentally deleting a modified profile:
            if len(self.timex) > 2:
                self.fileDirtySignal.emit()
                self.aw.autoAdjustAxis() # automatic adjust axis after roast if auto axis is enabled
                try:
                    self.aw.ntb.update() # reset the MPL navigation history
                except Exception as e: # pylint: disable=broad-except
                    _log.error(e)
            try:
                if self.aw.clusterEventsFlag:
                    self.aw.clusterEvents()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            if autosave and self.autosaveflag != 0 and self.autosavepath and self.timeindex[0] != -1 and self.timeindex[6] != 0: # only autosave if CHARGE and DROP are set
                try:
                    self.aw.automaticsave()
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            self.aw.sendmessage(QApplication.translate('Message','Scope recording stopped'))
            self.aw.buttonSTARTSTOP.setText(QApplication.translate('Button', 'START'))
            self.aw.lowerbuttondialog.setVisible(False)
            self.aw.messagelabel.setVisible(True)
            self.aw.phasesLCDs.hide()
            self.aw.AUCLCD.hide()
            self.aw.hideEventsMinieditor()

            # enable "green flag" menu:
            try:
                self.aw.ntb.enable_edit_curve_parameters()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' OffRecorder() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    def toggleRecorderTigger(self) -> None:
        if self.flagstart:
            self.ToggleMonitor()
        else:
            self.ToggleRecorder()

    #Turns START/STOP flag self.flagon to read and plot. Called from push buttonSTARTSTOP.
    @pyqtSlot(bool)
    def ToggleRecorder(self, _:bool = False) -> None:
        #turn START
        if not self.flagstart:
            if not self.checkSaved():
                return
            self.aw.soundpopSignal.emit()
            if self.flagon and len(self.timex) == 1:
                # we are already in monitoring mode, we just clear this first measurement and go
                self.clearMeasurements(andLCDs=False)
            elif self.timex != []: # there is a profile loaded, we have to reset
                self.reset(True,False,keepProperties=True)
            try:
                settings = QSettings()
                starts = 0
                if settings.contains('starts'):
                    starts = toInt(settings.value('starts'))
                settings.setValue('starts',starts+1)
                settings.sync()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            self.OnRecorder()
        #turn STOP
        else:
            self.aw.soundpopSignal.emit()
            self.OffRecorder()

    # trigger to be called by the markChargeDelaySignal
    # if delay is not 0, the markCharge is issues after n milliseconds
    @pyqtSlot(int)
    def markChargeDelay(self, delay:int) -> None:
        if delay == 0:
            self.markCharge()
        else:
            QTimer.singleShot(delay,self.markChargeTrigger)

    @pyqtSlot()
    def markChargeTrigger(self) -> None:
        self.markCharge()

    #Records charge (put beans in) marker. called from push button 'Charge'
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def markCharge(self, noaction:bool = False) -> None:
        zoomed_in: bool = False # True if zoomed in; in that case we prevent xaxistoxm to reset the x-axis limits (set_xlim)
        try:
            if self.aw.ntb._nav_stack(): # pylint: disable=protected-access
                zoomed_in = True
        except Exception: # pylint: disable=broad-except
            pass
        removed = False
        try:
            self.profileDataSemaphore.acquire(1)
            if self.flagstart:
                try:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()
                    if self.aw.buttonCHARGE.isFlat() and self.timeindex[0] > -1:
                        self.autoChargeIdx = -1 # disable autoCharge to allow manual re-CHARGE
                        # undo wrongly set CHARGE
                        ## deactivate autoCHARGE
                        ##self.autoCHARGEenabled = False
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                        st1 = self.__dijkstra_to_ascii(st1)
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 0 in self.l_annotations_dict:
                                del self.l_annotations_dict[0]
                            self.timeindex[0] = -1
                            removed = True
                            self.xaxistosm(redraw=False, set_xlim=not zoomed_in)
                    elif not self.aw.buttonCHARGE.isFlat():
                        if self.device == 18 and self.aw.simulator is None: #manual mode
                            tx,et,bt = self.aw.ser.NONE()
                            if bt != 1 and et != -1:  #cancel
                                self.drawmanual(et,bt,tx)
                                self.timeindex[0] = len(self.timex)-1
                            else:
                                return
                        else:
                            if self.autoChargeIdx > 0:
                                # prevent CHARGE out of index:
                                if len(self.timex) > self.autoChargeIdx:
                                    self.timeindex[0] = self.autoChargeIdx
                                elif len(self.timex) > self.autoChargeIdx - 1:
                                    # not yet enough readings
                                    self.timeindex[0] = self.autoChargeIdx - 1
                                else:
                                    return
                            elif len(self.timex) > 0:
                                self.timeindex[0] = len(self.timex)-1
                            else:
                                self.autoChargeIdx = 1 # set CHARGE on next (first) reading
                                message = QApplication.translate('Message','Not enough data collected yet. Try again in a few seconds')
                                self.aw.sendmessage(message)
                                return
                            if self.aw.pidcontrol.pidOnCHARGE and not self.aw.pidcontrol.pidActive: # Arduino/TC4, Hottop, MODBUS
                                self.aw.pidcontrol.pidOn()
                        if self.chargeTimerPeriod > 0:
                            self.aw.setTimerColor('timer')
                        try:
                            # adjust startofx to the new timeindex[0] as it depends on timeindex[0]
                            if self.locktimex:
                                self.startofx = self.locktimex_start + self.timex[self.timeindex[0]]
                            else:
                                self.startofx = self.chargemintime + self.timex[self.timeindex[0]] # we set the min x-axis limit to the CHARGE Min time
                        except Exception: # pylint: disable=broad-except
                            pass

                        try:
                            # adjust endofx back to resetmaxtime (it might have been extended if "Expand" is ticked beyond the resetmaxtime at START)
                            if not self.locktimex and not self.fixmaxtime and self.endofx != self.resetmaxtime:
                                self.endofx = self.resetmaxtime
                        except Exception: # pylint: disable=broad-except
                            pass
                        self.xaxistosm(redraw=False, set_xlim=not zoomed_in) # need to fix uneven x-axis labels like -0:13

                        if self.BTcurve or self.ETcurve:
                            temp = (self.temp2[self.timeindex[0]] if self.BTcurve else self.temp1[self.timeindex[0]])
                            if is_proper_temp(temp):
                                d = self.ylimit - self.ylimit_min
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation', 'CHARGE'))
                                st1 = self.__dijkstra_to_ascii(st1)
                                tx = self.timex[self.timeindex[0]]
                                self.ystep_down,self.ystep_up = self.findtextgap(0,0,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,tx,temp,self.ystep_up,self.ystep_down,draggable_anno_key=0)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos

                        self.updateProjection() # we update the data here to have the projections drawn by the redraw() triggered by the call to timealign below

                        # mark active slider values that are not zero
                        for slidernr in range(4):
                            if self.aw.eventslidervisibilities[slidernr]:
                                # we record also for inactive sliders as some button press actions might have changed the event values also for those
                                slidervalue = 0
                                if slidernr == 0:
                                    slidervalue = self.aw.slider1.value()
                                elif slidernr == 1:
                                    slidervalue = self.aw.slider2.value()
                                elif slidernr == 2:
                                    slidervalue = self.aw.slider3.value()
                                elif slidernr == 3:
                                    slidervalue = self.aw.slider4.value()
                                # only mark events that are non-zero # and have not been marked before not to duplicate the event values
                                if slidervalue != 0: #  and slidernr not in self.specialeventstype:
                                    value = float2float((slidervalue + 10.0) / 10.0)
                                    # note that EventRecordAction avoids to generate events were type and value matches to the previously recorded one
                                    self.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,takeLock=False,doupdategraphics=False)
                                    # we don't take another lock in EventRecordAction as we already hold that lock!
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
            else:
                message = QApplication.translate('Message','CHARGE: Scope is not recording')
                self.aw.sendmessage(message)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' markCharge() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            self.timealign(redraw=True,recompute=False,force=True) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            if self.aw.buttonCHARGE.isFlat():
                if removed:
                    self.aw.buttonCHARGE.setFlat(False)
                    self.aw.buttonCHARGE.startAnimation()
            else:
                if not noaction:
                    self.aw.eventactionx(self.buttonactions[0],self.buttonactionstrings[0])
                self.aw.buttonCHARGE.setFlat(True)
                self.aw.buttonCHARGE.stopAnimation()
                try:
                    fmt = '%.1f' if self.LCDdecimalplaces else '%.0f'
                    bt_str = fmt%self.temp2[self.timeindex[0]] + self.mode
                    message = QApplication.translate('Message','Roast time starts now 00:00 BT = {0}').format(bt_str)
                    self.aw.sendmessage(message)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)
                if self.roastpropertiesAutoOpenFlag:
                    self.aw.openPropertiesSignal.emit()
            self.aw.onMarkMoveToNext(self.aw.buttonCHARGE)

    # called via markTPSignal (queued), triggered by external device
    # does directly call markTP()
    @pyqtSlot()
    def markTPTrigger(self) -> None:
        if self.markTPflag:
            if self.TPalarmtimeindex is None:
                self.TPalarmtimeindex = len(self.timex) - 1
            self.markTP()

    # called from sample() and marks the autodetected TP visually on the graph
    def markTP(self) -> None:
        try:
            self.profileDataSemaphore.acquire(1)
            if self.flagstart and self.markTPflag and self.TPalarmtimeindex is not None and self.timeindex[0] != -1 and len(self.timex) > self.TPalarmtimeindex and (self.BTcurve or self.ETcurve):
                temp = (self.temp2[self.TPalarmtimeindex] if self.BTcurve else self.temp1[self.TPalarmtimeindex])
                if is_proper_temp(temp):
                    st = stringfromseconds(self.timex[self.TPalarmtimeindex]-self.timex[self.timeindex[0]],False)
                    st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','TP {0}').format(st))
                    #annotate temperature
                    d = self.ylimit - self.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                    time_temp_annos = self.annotate(temp,st1,self.timex[self.TPalarmtimeindex],temp,self.ystep_up,self.ystep_down,0,1.,draggable_anno_key=-1)
                    if time_temp_annos is not None:
                        self.l_annotations += time_temp_annos
                    self.updateBackground() # but we need to update the background cache with the new annotation
                    st2 = f'{temp:.1f}{self.mode}'
                    message = QApplication.translate('Message','[TP] recorded at {0} BT = {1}').format(st,st2)
                    #set message at bottom
                    self.aw.sendmessage(message)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' markTP() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        if self.aw.kaleido is not None and self.TPalarmtimeindex is not None:
            self.aw.kaleido.markTP()

    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def markDryEnd(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonDRY.isFlat() and self.timeindex[1] > 0:
                        # undo wrongly set DRY
                        # deactivate autoDRY
                        self.autoDRYenabled = False
                        st = stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                        DE_str = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}').format(st))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == DE_str:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 1 in self.l_annotations_dict:
                                del self.l_annotations_dict[1]
                            self.timeindex[1] = 0
                            removed = True
                    elif not self.aw.buttonDRY.isFlat():
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[1] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[1] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.phasesbuttonflag and is_proper_temp(self.temp2[self.timeindex[1]]):
                            self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
                        if self.BTcurve or self.ETcurve:
                            temp_CHARGE = ((self.temp2[self.timeindex[0]] if self.BTcurve else self.temp1[self.timeindex[0]]) if self.timeindex[0] != -1 else -1)
                            temp = (self.temp2[self.timeindex[1]] if self.BTcurve else self.temp1[self.timeindex[1]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                #calculate time elapsed since charge time
                                st = stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DE {0}').format(st))
                                #annotate temperature
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[0] != -1 and is_proper_temp(temp_CHARGE):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_CHARGE,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[1]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=1)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {1, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground()

                        self.phasesLCDmode = self.phasesLCDmode_l[1]

                else:
                    message = QApplication.translate('Message','DRY END: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' markDryEnd() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                if self.alignEvent in {1, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                if self.aw.buttonDRY.isFlat():
                    if removed:
                        if self.alignEvent not in {1, 7}:
                            self.updateBackground() # no updateBackground needed in case the timealign above happens as this triggers a redraw() which itself triggers an updateBackground anyhow
                        self.aw.buttonDRY.setFlat(False)
                        if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                            self.aw.buttonCHARGE.setFlat(False)
                            if self.buttonvisibility[0]:
                                self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonDRY.setFlat(True) # deactivate DRY button
                    self.aw.buttonCHARGE.setFlat(True) # also deactivate CHARGE button
                    self.aw.buttonCHARGE.stopAnimation()
                    try:
                        if not noaction:
                            self.aw.eventactionx(self.buttonactions[1],self.buttonactionstrings[1])
                        if self.timeindex[0] > -1:
                            start = self.timex[self.timeindex[0]]
                        else:
                            start = 0
                        st = stringfromseconds(self.timex[self.timeindex[1]]-start)
                        st2 = f'{self.temp2[self.timeindex[1]]:.1f}{self.mode}'
                        message = QApplication.translate('Message','[DRY END] recorded at {0} BT = {1}').format(st,st2)
                        #set message at bottom
                        self.aw.sendmessage(message)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                self.aw.onMarkMoveToNext(self.aw.buttonDRY)

    #record 1C start markers of BT. called from push buttonFCs of application window
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def mark1Cstart(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonFCs.isFlat() and self.timeindex[2] > 0:
                        # undo wrongly set FCs
                        # deactivate autoFCs
                        self.autoFCsenabled = False
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}').format(stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 2 in self.l_annotations_dict:
                                del self.l_annotations_dict[2]
                            self.timeindex[2] = 0
                            removed = True
                    elif not self.aw.buttonFCs.isFlat():
                        # record 1Cs only if Charge mark has been done
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[2] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[2] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.phasesbuttonflag and is_proper_temp(self.temp2[self.timeindex[2]]):
                            self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
                        if self.BTcurve or self.ETcurve:
                            temp_DRY = ((self.temp2[self.timeindex[1]] if self.BTcurve else self.temp1[self.timeindex[1]]) if self.timeindex[1] else -1)
                            temp = (self.temp2[self.timeindex[2]] if self.BTcurve else self.temp1[self.timeindex[2]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                #calculate time elapsed since charge time
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCs {0}').format(stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[1] and is_proper_temp(temp_DRY):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_DRY,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[2]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=2)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {2, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground() # but we need

                        self.phasesLCDmode = self.phasesLCDmode_l[2]
                else:
                    message = QApplication.translate('Message','FC START: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark1Cstart() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                if self.alignEvent in {2, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                if self.aw.buttonFCs.isFlat():
                    if removed:
                        if self.alignEvent not in {2, 7}:
                            self.updateBackground() # no updateBackground needed in case the timealign above happens as this triggers a redraw() which triggers an updateBackground anyhow
                        self.aw.buttonFCs.setFlat(False)
                        if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                            self.aw.buttonDRY.setFlat(False)
                            if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                self.aw.buttonCHARGE.setFlat(False)
                                if self.buttonvisibility[0]:
                                    self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonFCs.setFlat(True)
                    self.aw.buttonCHARGE.setFlat(True)
                    self.aw.buttonCHARGE.stopAnimation()
                    self.aw.buttonDRY.setFlat(True)
                    if not noaction:
                        self.aw.eventactionx(self.buttonactions[2],self.buttonactionstrings[2])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[2]]-start)
                    st2 = f'{self.temp2[self.timeindex[2]]:.1f}{self.mode}'
                    message = QApplication.translate('Message','[FC START] recorded at {0} BT = {1}').format(st1,st2)
                    self.aw.sendmessage(message)
                self.aw.onMarkMoveToNext(self.aw.buttonFCs)


    #record 1C end markers of BT. called from buttonFCe of application window
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def mark1Cend(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonFCe.isFlat() and self.timeindex[3] > 0:
                        # undo wrongly set FCe
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}').format(stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 3 in self.l_annotations_dict:
                                del self.l_annotations_dict[3]
                            self.timeindex[3] = 0
                            removed = True
                    elif not self.aw.buttonFCe.isFlat():
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[3] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[3] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve or self.ETcurve:
                            temp_FCs = ((self.temp2[self.timeindex[2]] if self.BTcurve else self.temp1[self.timeindex[2]]) if self.timeindex[2] else -1)
                            temp = (self.temp2[self.timeindex[3]] if self.BTcurve else self.temp1[self.timeindex[3]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                #calculate time elapsed since charge time
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','FCe {0}').format(stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[2] and is_proper_temp(temp_FCs):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_FCs,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[3]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=3)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {3, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','FC END: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark1Cend() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
                if self.alignEvent in {3, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
                if self.aw.buttonFCe.isFlat():
                    if removed:
                        if self.alignEvent not in {3, 7}:
                            self.updateBackground() # no updateBackground needed in case the timealign above happens as this triggers a redraw() which triggers an updateBackground anyhow
                        self.aw.buttonFCe.setFlat(False)
                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                            self.aw.buttonFCs.setFlat(False)
                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                self.aw.buttonDRY.setFlat(False)
                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                    self.aw.buttonCHARGE.setFlat(False)
                                    if self.buttonvisibility[0]:
                                        self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonFCe.setFlat(True)
                    self.aw.buttonCHARGE.setFlat(True)
                    self.aw.buttonCHARGE.stopAnimation()
                    self.aw.buttonDRY.setFlat(True)
                    self.aw.buttonFCs.setFlat(True)
                    if not noaction:
                        self.aw.eventactionx(self.buttonactions[3],self.buttonactionstrings[3])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[3]]-start)
                    st2 = f'{self.temp2[self.timeindex[3]]:.1f}{self.mode}'
                    message = QApplication.translate('Message','[FC END] recorded at {0} BT = {1}').format(st1,st2)
                    self.aw.sendmessage(message)
                self.aw.onMarkMoveToNext(self.aw.buttonFCe)

    #record 2C start markers of BT. Called from buttonSCs of application window
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def mark2Cstart(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            st1 = ''
            st2 = ''
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonSCs.isFlat() and self.timeindex[4] > 0:
                        # undo wrongly set FCs
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}').format(stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 4 in self.l_annotations_dict:
                                del self.l_annotations_dict[4]
                            self.timeindex[4] = 0
                            removed = True
                    elif not self.aw.buttonSCs.isFlat():
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[4] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[4] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve or self.ETcurve:
                            temp_FCe = ((self.temp2[self.timeindex[3]] if self.BTcurve else self.temp1[self.timeindex[3]]) if self.timeindex[3] else -1)
                            temp = (self.temp2[self.timeindex[4]] if self.BTcurve else self.temp1[self.timeindex[4]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCs {0}').format(stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[3] and is_proper_temp(temp_FCe):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_FCe,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(0,0,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[4]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=4)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {4, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','SC START: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark2Cstart() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                if self.alignEvent in {4, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                if self.aw.buttonSCs.isFlat():
                    if removed:
                        if self.alignEvent not in {4, 7}: # no updateBackground needed in case the timealign above happens as this triggers a redraw() which triggers an updateBackground anyhow
                            self.updateBackground()
                        self.aw.buttonSCs.setFlat(False)
                        if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                            self.aw.buttonFCe.setFlat(False)
                            if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                self.aw.buttonFCs.setFlat(False)
                                if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                    self.aw.buttonDRY.setFlat(False)
                                    if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                        self.aw.buttonCHARGE.setFlat(False)
                                        if self.buttonvisibility[0]:
                                            self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonSCs.setFlat(True)
                    self.aw.buttonCHARGE.setFlat(True)
                    self.aw.buttonCHARGE.stopAnimation()
                    self.aw.buttonDRY.setFlat(True)
                    self.aw.buttonFCs.setFlat(True)
                    self.aw.buttonFCe.setFlat(True)
                    try:
                        if not noaction:
                            self.aw.eventactionx(self.buttonactions[4],self.buttonactionstrings[4])
                        if self.timeindex[0] > -1:
                            start = self.timex[self.timeindex[0]]
                        else:
                            start = 0
                        try:
                            st1 = stringfromseconds(self.timex[self.timeindex[4]]-start)
                            st2 = f'{self.temp2[self.timeindex[4]]:.1f}{self.mode}'
                        except Exception: # pylint: disable=broad-except
                            pass
                        message = QApplication.translate('Message','[SC START] recorded at {0} BT = {1}').format(st1,st2)
                        self.aw.sendmessage(message)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)
                self.aw.onMarkMoveToNext(self.aw.buttonSCs)

    #record 2C end markers of BT. Called from buttonSCe of application window
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def mark2Cend(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonSCe.isFlat() and self.timeindex[5] > 0:
                        # undo wrongly set FCs
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}').format(stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 5 in self.l_annotations_dict:
                                del self.l_annotations_dict[5]
                            self.timeindex[5] = 0
                            removed = True
                    elif not self.aw.buttonSCe.isFlat():
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[5] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[5] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve or self.ETcurve:
                            temp_SCs = ((self.temp2[self.timeindex[4]] if self.BTcurve else self.temp1[self.timeindex[4]]) if self.timeindex[4] else -1)
                            temp = (self.temp2[self.timeindex[5]] if self.BTcurve else self.temp1[self.timeindex[5]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','SCe {0}').format(stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[4] and is_proper_temp(self.temp2[self.timeindex[4]]):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_SCs,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[5]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=5)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {5, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','SC END: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' mark2Cend() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            if self.flagstart and len(self.timex) > 0:
                # redraw (within timealign) should not be called if semaphore is hold!
                if self.alignEvent in {5, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                if self.aw.buttonSCe.isFlat():
                    if removed:
                        if self.alignEvent not in {5, 7}:
                            self.updateBackground() # no updateBackground needed in case the timealign above happens as this triggers a redraw() which triggers an updateBackground anyhow
                        self.aw.buttonSCe.setFlat(False)
                        if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                            self.aw.buttonSCs.setFlat(False)
                            if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                self.aw.buttonFCe.setFlat(False)
                                if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                    self.aw.buttonFCs.setFlat(False)
                                    if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                        self.aw.buttonDRY.setFlat(False)
                                        if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                            self.aw.buttonCHARGE.setFlat(False)
                                            if self.buttonvisibility[0]:
                                                self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonSCe.setFlat(True)
                    self.aw.buttonCHARGE.setFlat(True)
                    self.aw.buttonCHARGE.stopAnimation()
                    self.aw.buttonDRY.setFlat(True)
                    self.aw.buttonFCs.setFlat(True)
                    self.aw.buttonFCe.setFlat(True)
                    self.aw.buttonSCs.setFlat(True)
                    if not noaction:
                        self.aw.eventactionx(self.buttonactions[5],self.buttonactionstrings[5])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[5]]-start)
                    st2 = f'{self.temp2[self.timeindex[5]]:.1f}{self.mode}'
                    message = QApplication.translate('Message','[SC END] recorded at {0} BT = {1}').format(st1,st2)
                    self.aw.sendmessage(message)
                self.aw.onMarkMoveToNext(self.aw.buttonSCe)

    #record end of roast (drop of beans). Called from push button 'Drop'
    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def markDrop(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    # we check if this is the first DROP mark on this roast
                    firstDROP = self.timeindex[6] == 0 # on UNDO DROP we do not send the record to plus
                    if self.aw.buttonDROP.isFlat() and self.timeindex[6] > 0:
                        self.autoDropIdx = -1 # disable autoDROP to allow manual re-DROP
                        # undo wrongly set FCs
                        # deactivate autoDROP
                        self.autoDROPenabled = False
                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}').format(stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 6 in self.l_annotations_dict:
                                del self.l_annotations_dict[6]
                            self.timeindex[6] = 0
                            #decrease BatchCounter again
                            self.decBatchCounter()
                            removed = True
                    elif not self.aw.buttonDROP.isFlat():
                        self.incBatchCounter()
                        # generate UUID
                        if self.roastUUID is None: # there might be already one assigned by undo and redo the markDROP!
                            import uuid
                            self.roastUUID = uuid.uuid4().hex
                        if self.device != 18 or self.aw.simulator is not None:
                            if self.autoDropIdx > 0:
                                # prevent DROP out of index:
                                if len(self.timex) > self.autoDropIdx:
                                    self.timeindex[6] = max(0,self.autoDropIdx)
                                else:
                                    return
                            else:
                                self.timeindex[6] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[6] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve or self.ETcurve:
                            temp = (self.temp2[self.timeindex[6]] if self.BTcurve else self.temp1[self.timeindex[6]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','DROP {0}').format(stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                                d = self.ylimit - self.ylimit_min

                                tx = -1
                                if self.timeindex[5] and is_proper_temp(self.temp2[self.timeindex[5]]):
                                    tx = self.timeindex[5]
                                elif self.timeindex[4] and is_proper_temp(self.temp2[self.timeindex[4]]):
                                    tx = self.timeindex[4]
                                elif self.timeindex[3] and is_proper_temp(self.temp2[self.timeindex[3]]):
                                    tx = self.timeindex[3]
                                elif self.timeindex[2] and is_proper_temp(self.temp2[self.timeindex[2]]):
                                    tx = self.timeindex[2]
                                elif self.timeindex[1] and is_proper_temp(self.temp2[self.timeindex[1]]):
                                    tx = self.timeindex[1]
                                if tx == -1:
                                    self.ystep_down = 19
                                    self.ystep_up = 19
                                else:
                                    temp_event = (self.temp2[tx] if self.BTcurve else self.temp1[tx])
                                    if is_proper_temp(temp_event):
                                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_event,temp,d)
                                    else:
                                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[6]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=6)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                if not self.flagstart or self.alignEvent not in {6, 7}: # in this case the updateBackground is triggered by the redraw of timealign below
                                    self.updateBackground() # but we need to update the background!

                        try:
                            # update ambient temperature if a ambient temperature source is configured and no value yet established
                            self.updateAmbientTempFromPhidgetModulesOrCurve()
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
    #PLUS
                        # only on first setting the DROP event (not set yet and no previous DROP undone) and (not anymore: if not in simulator modus, we upload to PLUS)
                        if firstDROP and self.autoDROPenabled and self.aw.plus_account is not None:  # and not bool(self.aw.simulator): # we also upload simulated roasts to PLUS
                            # NOTE: scheduler is only active if connected to artisan.plus
                            if self.aw.schedule_window is not None:
                                self.aw.schedule_window.register_completed_roast.emit()
                            try:
                                self.aw.updatePlusStatus()
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                                # add to out-queue
                            try:
                                addRoast()
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                else:
                    message = QApplication.translate('Message','DROP: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as ex: # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' markDrop() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
            if self.flagstart:
                # redraw (within timealign) should not be called if semaphore is hold!
                if self.alignEvent in {6, 7}:
                    self.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
                try:
                    if self.aw.buttonDROP.isFlat():
                        if removed:
                            if self.alignEvent not in {6, 7}:
                                self.updateBackground()
                            self.aw.buttonDROP.setFlat(False)
                            if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                                self.aw.buttonSCe.setFlat(False)
                                if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                    self.aw.buttonSCs.setFlat(False)
                                    if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                        self.aw.buttonFCe.setFlat(False)
                                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                            self.aw.buttonFCs.setFlat(False)
                                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                                self.aw.buttonDRY.setFlat(False)
                                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                    self.aw.buttonCHARGE.setFlat(False)
                                                    if self.buttonvisibility[0]:
                                                        self.aw.buttonCHARGE.startAnimation()
                    else:
                        self.aw.buttonDROP.setFlat(True)
                        self.aw.buttonCHARGE.setFlat(True)
                        self.aw.buttonCHARGE.stopAnimation()
                        self.aw.buttonDRY.setFlat(True)
                        self.aw.buttonFCs.setFlat(True)
                        self.aw.buttonFCe.setFlat(True)
                        self.aw.buttonSCs.setFlat(True)
                        self.aw.buttonSCe.setFlat(True)

                        try:
                            if not noaction:
                                self.aw.eventactionx(self.buttonactions[6],self.buttonactionstrings[6])
                            if self.timeindex[0] > -1:
                                start = self.timex[self.timeindex[0]]
                            else:
                                start = 0
                            st1 = stringfromseconds(self.timex[self.timeindex[6]]-start)
                            st2 = f'{self.temp2[self.timeindex[6]]:.1f} {self.mode}'
                            message = QApplication.translate('Message','Roast ended at {0} BT = {1}').format(st1,st2)
                            self.aw.sendmessage(message)
                        except Exception as e: # pylint: disable=broad-except
                            _log.exception(e)
                        # at DROP we stop the follow background on FujiPIDs and set the SV to 0
                        if self.device == 0 and self.aw.fujipid.followBackground and self.aw.fujipid.sv and self.aw.fujipid.sv > 0:
                            try:
                                self.aw.fujipid.setsv(0,silent=True)
                                self.aw.fujipid.sv = 0
                            except Exception as e: # pylint: disable=broad-except
                                _log.exception(e)
                        if self.roastpropertiesAutoOpenDropFlag:
                            self.aw.openPropertiesSignal.emit()
                    self.aw.onMarkMoveToNext(self.aw.buttonDROP)
                except Exception as e: # pylint: disable=broad-except
                    _log.exception(e)

    # if noaction is True, the button event action is not triggered
    @pyqtSlot(bool)
    def markCoolEnd(self, noaction:bool = False) -> None:
        if len(self.timex) > 1:
            removed = False
            try:
                self.profileDataSemaphore.acquire(1)
                if self.flagstart:
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()

                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if self.aw.buttonCOOL.isFlat() and self.timeindex[7] > 0:
                        # undo wrongly set COOL

                        st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','CE {0}').format(stringfromseconds(self.timex[self.timeindex[7]] - start)))

                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.ystep_down, self.ystep_up = 0, 0
                            try:
                                self.l_annotations[-1].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except Exception: # pylint: disable=broad-except
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 7 in self.l_annotations_dict:
                                del self.l_annotations_dict[7]
                            self.timeindex[7] = 0
                            removed = True

                    elif not self.aw.buttonCOOL.isFlat():
                        if self.device != 18 or self.aw.simulator is not None:
                            self.timeindex[7] = max(0,len(self.timex)-1)
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[7] = max(0,len(self.timex)-1)
                            else:
                                return
                        if self.BTcurve or self.ETcurve:
                            temp_DROP = ((self.temp2[self.timeindex[6]] if self.BTcurve else self.temp1[self.timeindex[6]]) if self.timeindex[6] else -1)
                            temp = (self.temp2[self.timeindex[7]] if self.BTcurve else self.temp1[self.timeindex[7]])
                            if is_proper_temp(temp):
                                # only if BT is shown we place the annotation:
                                #calculate time elapsed since charge time
                                st1 = self.aw.arabicReshape(QApplication.translate('Scope Annotation','CE {0}').format(stringfromseconds(self.timex[self.timeindex[7]] - start)))
                                #annotate temperature
                                d = self.ylimit - self.ylimit_min
                                if self.timeindex[6] and is_proper_temp(temp_DROP):
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp_DROP,temp,d)
                                else:
                                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,temp,temp,d)
                                time_temp_annos = self.annotate(temp,st1,self.timex[self.timeindex[7]],temp,self.ystep_up,self.ystep_down,draggable_anno_key=7)
                                if time_temp_annos is not None:
                                    self.l_annotations += time_temp_annos
                                self.updateBackground() # but we need
                else:
                    message = QApplication.translate('Message','COOL: Scope is not recording')
                    self.aw.sendmessage(message)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.adderror((QApplication.translate('Error Message', 'Exception:') + ' markCoolEnd() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)
            if self.flagstart:
                # NOTE: the following self.aw.eventaction might do serial communication that acquires a lock, so release it here
                if self.aw.buttonCOOL.isFlat():
                    if removed:
                        self.updateBackground()
                        self.aw.buttonCOOL.setFlat(False)
                        if self.timeindex[6] == 0: # reactivate the DROP button if not yet set
                            self.aw.buttonDROP.setFlat(False)
                            if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                                self.aw.buttonSCe.setFlat(False)
                                if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                    self.aw.buttonSCs.setFlat(False)
                                    if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                        self.aw.buttonFCe.setFlat(False)
                                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                            self.aw.buttonFCs.setFlat(False)
                                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                                self.aw.buttonDRY.setFlat(False)
                                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                    self.aw.buttonCHARGE.setFlat(False)
                                                    if self.buttonvisibility[0]:
                                                        self.aw.buttonCHARGE.startAnimation()
                else:
                    self.aw.buttonCOOL.setFlat(True)
                    self.aw.buttonCHARGE.setFlat(True)
                    self.aw.buttonCHARGE.stopAnimation()
                    self.aw.buttonDRY.setFlat(True)
                    self.aw.buttonFCs.setFlat(True)
                    self.aw.buttonFCe.setFlat(True)
                    self.aw.buttonSCs.setFlat(True)
                    self.aw.buttonSCe.setFlat(True)
                    self.aw.buttonDROP.setFlat(True)
                    if not noaction:
                        self.aw.eventactionx(self.buttonactions[7],self.buttonactionstrings[7])
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    st1 = stringfromseconds(self.timex[self.timeindex[7]]-start)
                    st2 = f'{self.temp2[self.timeindex[7]]:.1f}{self.mode}'
                    message = QApplication.translate('Message','[COOL END] recorded at {0} BT = {1}').format(st1,st2)
                    #set message at bottom
                    self.aw.sendmessage(message)
                self.aw.onMarkMoveToNext(self.aw.buttonCOOL)

    def decBatchCounter(self) -> None:
        if not bool(self.aw.simulator):
            if self.lastroastepoch + self.roastepoch_timeout < self.roastepoch:
                # reset the sequence counter
                self.batchsequence = 1
            elif self.batchsequence > 1:
                self.batchsequence -= 1
            self.roastbatchpos = self.batchsequence
        if self.batchcounter > -1 and not bool(self.aw.simulator):
            self.batchcounter -= 1 # we decrease the batch counter
            # set the batchcounter of the current profile
            self.roastbatchnr = 0
            # store updated batchcounter immediately in the app settings
            try:
                app_settings = QSettings()
                app_settings.beginGroup('Batch')
                app_settings.setValue('batchcounter',self.batchcounter)
                app_settings.setValue('batchsequence',self.batchsequence)
                app_settings.endGroup()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # decr. the batchcounter of the loaded app settings
            if self.aw.settingspath and self.aw.settingspath != '':
                try:
                    settings = QSettings(self.aw.settingspath,QSettings.Format.IniFormat)
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        bc = toInt(settings.value('batchcounter',self.batchcounter))
                        bprefix = toString(settings.value('batchprefix',self.batchprefix))
                        if bc > -1 and bc == self.batchcounter+1 and self.batchprefix == bprefix:
                            settings.setValue('batchcounter',bc - 1)
                            settings.setValue('batchsequence',self.batchsequence)
                    settings.endGroup()
                except Exception: # pylint: disable=broad-except
                    self.aw.settingspath = ''

    def incBatchCounter(self) -> None:
        if not bool(self.aw.simulator):
            # update batchsequence by estimating batch sequence (roastbatchpos) from lastroastepoch and roastepoch
            # if this roasts DROP is more than 1.5h after the last registered DROP, we assume a new session starts
            if self.lastroastepoch + 5400 < self.roastepoch:
                # reset the sequence counter
                self.batchsequence = 1
            else:
                self.batchsequence += 1
            self.roastbatchpos = self.batchsequence
        # update lastroastepoch to time of roastdate
        self.lastroastepoch = self.roastepoch
        # set roastbatchpos
        if self.batchcounter > -1 and not bool(self.aw.simulator):
            self.batchcounter += 1 # we increase the batch counter
            # set the batchcounter of the current profile
            self.roastbatchnr = self.batchcounter
            # set the batchprefix of the current profile
            self.roastbatchprefix = self.batchprefix
            # store updated batchcounter immediately in the app settings
            try:
                app_settings = QSettings()
                app_settings.beginGroup('Batch')
                app_settings.setValue('batchcounter',self.batchcounter)
                app_settings.setValue('batchsequence',self.batchsequence)
                app_settings.setValue('lastroastepoch',self.lastroastepoch)
                app_settings.endGroup()
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # incr. the batchcounter of the loaded app settings
            if self.aw.settingspath and self.aw.settingspath != '':
                try:
                    settings = QSettings(self.aw.settingspath,QSettings.Format.IniFormat)
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        bc = toInt(settings.value('batchcounter',self.batchcounter))
                        bprefix = toString(settings.value('batchprefix',self.batchprefix))
                        if bc > -1 and self.batchprefix == bprefix:
                            settings.setValue('batchcounter',self.batchcounter)
                            settings.setValue('batchsequence',self.batchsequence)
                            settings.setValue('lastroastepoch',self.lastroastepoch)
                    settings.endGroup()
                except Exception: # pylint: disable=broad-except
                    self.aw.settingspath = ''
        else: # batch counter system inactive
            # set the batchcounter of the current profiles
            self.roastbatchnr = 0

    # action of the EVENT button
    @pyqtSlot(bool)
    def EventRecord_action(self,_:bool = False) -> None:
        self.EventRecord()

    @pyqtSlot(int)
    def EventRecordSlot(self, ee:int) -> None:
        self.EventRecord(ee)

    @pyqtSlot(int,float,str,bool)
    def EventRecordActionSlot(self,eventtype:int,eventvalue:float,description:str,doupdategraphics:bool) -> None:
        self.EventRecordAction(extraevent=1,eventtype=eventtype,eventvalue=eventvalue,eventdescription=description,doupdategraphics=doupdategraphics)

    def EventRecord(self, extraevent:Optional[int] = None, takeLock:bool = True,
            doupdategraphics:bool = True, doupdatebackground:bool = True) -> None:
        try:
            if extraevent is not None:
                if self.aw.extraeventstypes[extraevent] <= 4:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=self.aw.extraeventstypes[extraevent],
                        eventvalue=self.aw.extraeventsvalues[extraevent],
                        eventdescription=self.aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
                elif self.aw.extraeventstypes[extraevent] == 9:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=4,  # we map back to the untyped event type
                        eventvalue=self.aw.extraeventsvalues[extraevent],
                        eventdescription=self.aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
                else: # on "relative" event values, we take the last value set per event via the recordextraevent call before
                    last_value:Optional[int] = self.aw.extraeventsactionslastvalue[self.aw.extraeventstypes[extraevent]-5]
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=self.aw.extraeventstypes[extraevent]-5,
                        eventvalue=(self.eventsExternal2InternalValue(last_value) if last_value else None),
                        eventdescription=self.aw.extraeventsdescriptions[extraevent],takeLock=takeLock,
                        doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
            else:
                self.EventRecordAction(extraevent=extraevent,takeLock=takeLock,
                doupdategraphics=doupdategraphics,doupdatebackground=doupdatebackground)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' EventRecord() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    #Marks location in graph of special events. For example change a fan setting.
    #Uses the position of the time index (variable self.timex) as location in time
    # extraevent is given when called from self.aw.recordextraevent() from an extra Event Button
    # if doupdategraphics is True (default) an updategraphicsSignal is emitted at the end
    # if doupdatebackground is True (default) the cached background is updated
    def EventRecordAction(self,extraevent:Optional[int] = None, eventtype:Optional[int] = None, eventvalue:Optional[float] = None, eventdescription:str = '',
            takeLock:bool = True, doupdategraphics:bool = True, doupdatebackground:bool = True) -> None:
        try:
            if takeLock:
                self.profileDataSemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0 or (self.device == 18 and self.aw.simulator is None):
                    self.aw.soundpopSignal.emit()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirtySignal.emit()
                    Nevents = len(self.specialevents)
                    #if in manual mode record first the last point in self.timex[]
                    if self.device == 18 and self.aw.simulator is None:
                        tx:float
                        et:float
                        bt:float
                        if not doupdategraphics and not doupdatebackground: # a call from a multiple event action
                            tx,et,bt = self.timeclock.elapsed()/1000.,-1,-1
                        else:
                            tx,et,bt = self.aw.ser.NONE()
                        if bt != -1 or et != -1:
                            self.drawmanual(et,bt,tx)
                        elif bt==-1 and et==-1:
                            return
                    #i = index number of the event (current length of the time list)
                    i = len(self.timex)-1
                    # if Description, Type and Value of the new event equals the last recorded one, we do not record this again!
                    if (not(self.specialeventstype) or not(self.specialeventsvalue) or not(self.specialeventsStrings) or
                            not(eventtype != 4 and self.specialeventstype[-1] == eventtype and self.specialeventsvalue[-1] == eventvalue and self.specialeventsStrings[-1] == eventdescription)):
                        fontprop_small = self.aw.mpl_fontproperties.copy()
                        fontsize = 'xx-small'
                        fontprop_small.set_size(fontsize)
                        self.addEvent(i,4,str(Nevents+1),0)
                        #if event was initiated by an Extra Event Button then change the type,value, and string
                        if extraevent is not None and eventtype is not None and eventvalue is not None:
                            self.specialeventstype[-1] = eventtype
                            self.specialeventsvalue[-1] = eventvalue
                            self.specialeventsStrings[-1] = eventdescription
                        etype = self.specialeventstype[-1]
                        tx = self.timex[self.specialevents[-1]]
                        sevalue = self.specialeventsvalue[-1]
                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                            val = int(round((sevalue-1)*10))
                        else:
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            pos = max(0,int(round((sevalue-1)*10)))
                            val = int((pos*event_pos_factor)+event_pos_offset)
                        if etype == 0:
                            self.E1timex.append(tx)
                            self.E1values.append(val)
                        elif etype == 1:
                            self.E2timex.append(tx)
                            self.E2values.append(val)
                        elif etype == 2:
                            self.E3timex.append(tx)
                            self.E3values.append(val)
                        elif etype == 3:
                            self.E4timex.append(tx)
                            self.E4values.append(val)
                        #if Event show flag
                        if self.eventsshowflag != 0 and self.showEtypes[etype] and self.ax is not None:
                            index = self.specialevents[-1]
                            if etype < 4  and (not self.renderEventsDescr or len(self.specialeventsStrings[-1].strip()) == 0):
                                firstletter = self.etypeAbbrev(self.etypesf(etype))
                                secondletter = self.eventsvaluesShort(sevalue)
                                if self.aw.eventslidertemp[etype]:
                                    thirdletter = self.mode # postfix
                                else:
                                    thirdletter = self.aw.eventsliderunits[etype] # postfix
                            else:
                                firstletter = self.specialeventsStrings[-1].strip()[:self.eventslabelschars]
                                if firstletter == '':
                                    firstletter = 'E'
                                secondletter = ''
                                thirdletter = ''
                            #if Event Type-Bars flag
                            if self.eventsGraphflag == 1 and etype < 4:
                                if self.mode == 'F':
                                    row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                                else:
                                    row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                anno = None
                                if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[index] >= self.temp2[index]):
                                    anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                        xy=(self.timex[index],
                                        self.temp1[index]),
                                        xytext=(self.timex[index],row[etype]),
                                        alpha=1.,
                                        bbox={'boxstyle':'square,pad=0.1', 'fc':self.EvalueColor[etype], 'ec':'none'},
                                        path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                        color=self.EvalueTextColor[etype],
                                        arrowprops={'arrowstyle':'-','color':self.palette['et'],'alpha':0.4,'relpos':(0,0)},
                                        fontsize=fontsize,
                                        fontproperties=fontprop_small)
                                elif self.BTcurve:
                                    anno = self.ax.annotate(f'{firstletter}{secondletter}',
                                            xy=(self.timex[index],
                                            self.temp2[index]),
                                            xytext=(self.timex[index],row[etype]),
                                            alpha=1.,
                                            bbox={'boxstyle':'square,pad=0.1', 'fc':self.EvalueColor[etype], 'ec':'none'},
                                            path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                            color=self.EvalueTextColor[etype],
                                            arrowprops={'arrowstyle':'-','color':self.palette['bt'],'alpha':0.4,'relpos':(0,0)},
                                            fontsize=fontsize,
                                            fontproperties=fontprop_small)
                                try:
                                    if anno is not None:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                    pass
                            elif self.eventsGraphflag in {2, 3, 4} and etype < 4:
                                # update lines data using the lists with new data
                                if etype == 0 and self.showEtypes[0] and self.l_eventtype1dots is not None:
                                    self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                                elif etype == 1 and self.showEtypes[1] and self.l_eventtype2dots is not None:
                                    self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                                elif etype == 2 and self.showEtypes[2] and self.l_eventtype3dots is not None:
                                    self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                                elif etype == 3 and self.showEtypes[3] and self.l_eventtype4dots is not None:
                                    self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                            if etype == 4 or (self.eventsGraphflag in {0, 3, 4} and len(self.showEtypes) > etype and self.showEtypes[etype]):
                                height = 50 if self.mode == 'F' else 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[index] > self.temp2[index]):
                                    temp = self.temp1[index]
                                elif self.BTcurve:
                                    temp = self.temp2[index]
                                else:
                                    temp = None

                                if self.eventsGraphflag == 4:
                                    if etype == 0:
                                        temp = self.E1values[-1]
                                    elif etype == 1:
                                        temp = self.E2values[-1]
                                    elif etype == 2:
                                        temp = self.E3values[-1]
                                    elif etype == 3:
                                        temp = self.E4values[-1]

                                if temp is not None and self.ax is not None:
                                    if etype == 0:
                                        boxstyle = 'roundtooth,pad=0.4'
                                        boxcolor = self.EvalueColor[0]
                                        textcolor = self.EvalueTextColor[0]
                                    elif etype == 1:
                                        boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                        boxcolor = self.EvalueColor[1]
                                        textcolor = self.EvalueTextColor[1]
                                    elif etype == 2:
                                        boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                        boxcolor = self.EvalueColor[2]
                                        textcolor = self.EvalueTextColor[2]
                                    elif etype == 3:
                                        boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                        boxcolor = self.EvalueColor[3]
                                        textcolor = self.EvalueTextColor[3]
                                    else: # etype == 4:
                                        boxstyle = 'square,pad=0.1'
                                        boxcolor = self.palette['specialeventbox']
                                        textcolor = self.palette['specialeventtext']
                                    anno = None
                                    if self.eventsGraphflag in {0, 3} or etype > 3:
                                        anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                                         color=textcolor,
                                                         va='center', ha='center',
                                                         arrowprops={'arrowstyle':'-','color':boxcolor,'alpha':0.4}, #,relpos=(0,0)),
                                                         bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none'},
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                         backgroundcolor=boxcolor)
                                    elif self.eventsGraphflag == 4:
                                        if thirdletter != '':
                                            firstletter = ''
                                        anno = self.ax.annotate(f'{firstletter}{secondletter}{thirdletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp),alpha=0.9,
                                                         color=textcolor,
                                                         va='center', ha='center',
                                                         bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none'},
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                                         backgroundcolor=boxcolor)

                                    try:
                                        if anno is not None:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                        pass
                        if doupdatebackground:
                            self.updateBackground() # call to canvas.draw() not needed as self.annotate does the (partial) redraw, but updateBackground() is needed
                        temp2 = f'{self.temp2[i]:.1f}{self.mode}'
                        if self.timeindex[0] != -1:
                            start = self.timex[self.timeindex[0]]
                        else:
                            start = 0
                        timed = stringfromseconds(self.timex[i] - start)
                        message = QApplication.translate('Message','Event # {0} recorded at BT = {1}{2} Time = {3}').format(str(Nevents+1),temp2,self.mode,timed)
                        self.aw.sendmessage(message)
                        #write label in mini recorder if flag checked
                        self.aw.eventlabel.setText(QApplication.translate('Label', 'Event #<b>{0} </b>').format(Nevents+1))
                        self.aw.eNumberSpinBox.blockSignals(True)
                        try:
                            self.aw.eNumberSpinBox.setValue(Nevents+1)
                        except Exception: # pylint: disable=broad-except
                            pass
                        finally:
                            self.aw.eNumberSpinBox.blockSignals(False)
                        if self.timeindex[0] > -1:
                            timez = stringfromseconds(self.timex[self.specialevents[Nevents]]-self.timex[self.timeindex[0]])
                        else:
                            timez = stringfromseconds(self.timex[self.specialevents[Nevents]])
                        self.aw.etimeline.setText(timez)
                        self.aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents])
                        self.aw.valueEdit.setText(self.eventsvalues(self.specialeventsvalue[Nevents]))
                        self.aw.lineEvent.setText(self.specialeventsStrings[Nevents])
            else:
                self.aw.sendmessage(QApplication.translate('Message','Timer is OFF'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' EventRecordAction() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if takeLock and self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)
        if self.flagstart and doupdategraphics:
            self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #called from controlling devices when roasting to record steps (commands) and produce a profile later
    def DeviceEventRecord(self, command:str) -> None:
        try:
            self.profileDataSemaphore.acquire(1)
            if self.flagstart:
                #prevents accidentally deleting a modified profile.
                self.fileDirtySignal.emit()
                #number of events
                Nevents = len(self.specialevents)
                #index number
                i = len(self.timex)-1
                if i > 0:
                    self.addEvent(i,0,command,0)
                    temp_str = str(self.temp2[i])
                    if self.timeindex[0] != -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    timed = stringfromseconds(self.timex[i]-start)
                    message = QApplication.translate('Message','Event # {0} recorded at BT = {1}{2} Time = {3}').format(str(Nevents+1),temp_str,self.mode,timed)
                    self.aw.sendmessage(message)
                    #write label in mini recorder if flag checked
                    self.aw.eNumberSpinBox.setValue(Nevents+1)
                    self.aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                    self.aw.valueEdit.setText(self.eventsvalues(self.specialeventsvalue[Nevents-1]))
                    self.aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                #if Event show flag
                if self.eventsshowflag != 0 and self.ax is not None:
                    index = self.specialevents[-1]
                    if self.specialeventstype[-1] < 4 and self.showEtypes[self.specialeventstype[-1]]:
                        fontprop_small = self.aw.mpl_fontproperties.copy()
                        fontsize = 'xx-small'
                        fontprop_small.set_size(fontsize)
                        firstletter = self.etypeAbbrev(self.etypesf(self.specialeventstype[-1]))
                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])

                        if self.eventsGraphflag == 0:
                            anno = None
                            height = 50 if self.mode == 'F' else 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[index] > self.temp2[index]):
                                temp = self.temp1[index]
                            else:
                                temp = self.temp2[index]
                            anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                            color=self.palette['specialeventtext'],arrowprops={'arrowstyle':'-','color':self.palette['bt'],'alpha':0.4,'relpos':(0,0)},
                                             fontsize=fontsize,fontproperties=fontprop_small,backgroundcolor=self.palette['specialeventbox'])
                            try:
                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        #if Event Type-Bars flag
                        if self.eventsGraphflag == 1:
                            anno = None
                            if self.mode == 'F':
                                row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                            else:
                                row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if self.ETcurve and (not self.BTcurve or not self.showeventsonbt or self.temp1[index] >= self.temp2[index]):
                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette['specialeventtext'],arrowprops={'arrowstyle':'-',
                                                    'color':self.palette['et'],'alpha':0.4,'relpos':(0,0)},fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=self.palette['specialeventbox'])
                            elif self.BTcurve:
                                anno = self.ax.annotate(f'{firstletter}{secondletter}', xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette['specialeventtext'],arrowprops={'arrowstyle':'-',
                                                    'color':self.palette['et'],'alpha':0.4,'relpos':(0,0)}, fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=self.palette['specialeventbox'])
                            try:
                                if anno is not None:
                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        if self.eventsGraphflag in {2, 3, 4}:
                            # update lines data using the lists with new data
                            etype = self.specialeventstype[-1]
                            if etype == 0 and self.l_eventtype1dots is not None:
                                self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                            elif etype == 1 and self.l_eventtype2dots is not None:
                                self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                            elif etype == 2 and self.l_eventtype3dots is not None:
                                self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                            elif etype == 3 and self.l_eventtype4dots is not None:
                                self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' DeviceEventRecord() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if self.profileDataSemaphore.available() < 1:
                self.profileDataSemaphore.release(1)

    def writecharacteristics(self, TP_index:Optional[int] = None, LP:Optional[float] = None) -> None:
        try:
            # Display MET marker
            if self.showmet and self.ETcurve and self.timeindex[0] > -1 and self.timeindex[6] > 0:
                if TP_index is None:
                    TP_index = self.aw.findTP()
                met_temp = max(self.temp1[TP_index:self.timeindex[6]])
                if TP_index is not None:
                    self.idx_met = TP_index + self.temp1[TP_index:self.timeindex[6]].index(met_temp)
                if self.idx_met is not None:
                    if self.timeindex[2] != 0:
                        # time between MET and FCs
                        met_delta = float2float(self.timex[self.timeindex[2]] - self.timex[self.idx_met],0)
                    else:
                        met_delta = None
                    self.met_timex_temp1_delta = ((self.timex[self.idx_met]-self.timex[self.timeindex[0]]), met_temp, met_delta) #used in onpick() to display the MET temp and time
                    # plot a MET marker
                    if self.ax is not None and self.showmet and self.ETcurve:
                        height = 0 if self.mode == 'F' else 0
                        boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                        boxcolor = self.palette['metbox'] #match the ET color
                        textcolor = self.palette['mettext']
                        fontprop_small = self.aw.mpl_fontproperties.copy()
                        fontprop_small.set_size('xx-small')
                        self.met_annotate = self.ax.annotate('MET', xy=(self.timex[self.idx_met], met_temp),
                                     xytext=(self.timex[self.idx_met], met_temp + height),
                                     ha = 'center',
                                     alpha=0.9,
                                     color=textcolor,
                                     bbox={'boxstyle':boxstyle, 'fc':boxcolor, 'ec':'none'},
                                     fontproperties=fontprop_small,
                                     path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette['background'])],
                                     picker=True,
                                     zorder=2,
                                     )
                        try:
                            if self.met_annotate is not None:
                                self.met_annotate.set_in_layout(False) # remove suptitle from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass

            if self.statisticsflags[3] and self.timeindex[0]>-1:
                statsprop = self.aw.mpl_fontproperties.copy()
                statsprop.set_size('small')
                if self.statisticsmode == 0:
                    if TP_index is None:
                        TP_index = self.aw.findTP()
                    if LP is None:
                        #find Lowest Point in BT
                        LP = 1000
                        if TP_index is not None and TP_index >= 0:
                            LP = self.temp2[TP_index]
                    # compute max ET between TP and DROP
                    ETmax = '--'
                    temp1_values_max = 0.
                    try:
                        if TP_index is not None:
                            if self.timeindex[6] > 0 and TP_index<self.timeindex[6]:
                                temp1_values = self.temp1[TP_index:self.timeindex[6]]
                            else:
                                temp1_values = self.temp1[TP_index:]
                            if self.LCDdecimalplaces:
                                lcdformat = '%.1f'
                            else:
                                lcdformat = '%.0f'
                            temp1_values_max = max(temp1_values)
                            ETmax = (self.mode + lcdformat%temp1_values_max  if self.locale_str == 'ar' else lcdformat%temp1_values_max + self.mode)
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    FCperiod = None
                    try:
                        if self.timeindex[2] > 0 and self.timeindex[3] > 0:
                            FCperiod = stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[2]])[1:]
                        elif self.timeindex[2] > 0 and self.timeindex[6] > 0:
                            FCperiod = stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])[1:]
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    ror = f'{((self.temp2[self.timeindex[6]]-LP)/(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))*60.:.1f}'
                    _,_,tsb,_ = self.aw.ts(tp=TP_index)

                    #curveSimilarity
                    det,dbt = self.aw.curveSimilarity() # we analyze from DRY-END as specified in the phases dialog to DROP

                    #end temperature
                    if det is None or det == -1 or numpy.isnan(det):
                        det_txt = '––'
                    else:
                        det_txt = f'{det:.1f}'
                    if dbt is None or dbt == -1 or numpy.isnan(dbt):
                        dbt_txt = '––'
                    else:
                        dbt_txt = f'{dbt:.1f}'
                    if right_to_left(self.locale_str):
                        strline = (
                                    f"C*min{int(tsb)}={self.aw.arabicReshape(QApplication.translate('Label', 'AUC'))}   "
                                    f"{self.aw.arabicReshape(self.mode + '/min')}"
                                    f"{ror}={self.aw.arabicReshape(QApplication.translate('Label', 'RoR'))}   "
                                    f"{ETmax}={self.aw.arabicReshape(QApplication.translate('Label', 'MET'))}"
                                   )
                        if det is not None:
                            strline = f"{self.mode}{det_txt}/{dbt_txt}={QApplication.translate('Label', 'CM')}  {strline}"
                        if FCperiod is not None:
                            strline = f"min{FCperiod}={QApplication.translate('Label', 'FC')}  {strline}"
                    else:
                        strline = ''
                        if temp1_values_max and temp1_values_max > 0:
                            strline = f"{QApplication.translate('Label', 'MET')}={ETmax}   "
                        strline += f"{QApplication.translate('Label', 'RoR')}={ror}{self.mode}/min   {QApplication.translate('Label', 'AUC')}={int(tsb)}C*min"
                        if (det is not None) or (dbt is not None):
                            strline = f"{strline}   {QApplication.translate('Label', 'CM')}={det_txt}/{dbt_txt}{self.mode}"
                        if FCperiod is not None:
                            strline = f"{strline}   {QApplication.translate('Label', 'FC')}={FCperiod}min"
                    self.set_xlabel(strline)
                elif self.statisticsmode == 1:
                    sep = '   '
                    tm = self.roastdate.time().toString()[:-3]
                    starttime = (self.timex[self.timeindex[0]] if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex) else 0)
                    endtime = (self.timex[self.timeindex[6]] if self.timeindex[6] > 0  and self.timeindex[6] < len(self.timex) else self.timex[-1])
                    totaltime = endtime - starttime
                    if right_to_left(self.locale_str):
                        msg = ''
                        if self.whole_color and self.ground_color:
                            msg += f'{self.ground_color}/{self.whole_color}#'
                        elif self.ground_color:
                            msg += f'{self.ground_color}#'
                        if self.volume[0] and self.volume[1]:
                            msg += f'{sep}%{float2float(self.aw.volume_increase(self.volume[0],self.volume[1]),1)}'
                        if self.weight[0]:
                            weight_idx = weight_units.index(self.weight[2])
                            msg += f'{sep}{render_weight(self.weight[0], weight_idx, weight_idx)}'
                            if self.weight[1]:
                                msg += f'{sep}%{float2float(self.aw.weight_loss(self.weight[0],self.weight[1]),1)}-'
                        if totaltime > 0:
                            msg = f'{msg}{sep}{stringfromseconds(totaltime)}'
                        if self.beans and self.beans != '':
                            msg = f"{msg}{sep}{abbrevString(self.beans.replace(chr(10),' '),25)}"
                        msg += sep
                        if tm != '00:00':
                            msg = f'{msg}{tm}, '
                        msg += self.roastdate.date().toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))
                    else:
                        msg = self.roastdate.date().toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))
                        if tm != '00:00':
                            msg = f'{msg}, {tm}'
                        if self.beans and self.beans != '':
                            msg = f"{msg}{sep}{abbrevString(self.beans.replace(chr(10),' '),25)}"
                        if totaltime > 0:
                            msg = f'{msg}{sep}{stringfromseconds(totaltime)}'
                        if self.weight[0]:
                            weight_idx = weight_units.index(self.weight[2])
                            msg += f'{sep}{render_weight(self.weight[0], weight_idx, weight_idx)}'
                            if self.weight[1]:
                                msg += f'{sep}{-1*float2float(self.aw.weight_loss(self.weight[0],self.weight[1]),1)}%'
                        if self.volume[0] and self.volume[1]:
                            msg += f'{sep}{float2float(self.aw.volume_increase(self.volume[0],self.volume[1]),1)}%'
                        if self.whole_color and self.ground_color:
                            msg += f'{sep}#{self.whole_color}/{self.ground_color}'
                        elif self.ground_color:
                            msg += f'{sep}#{self.ground_color}'
                    self.set_xlabel(msg)
                elif self.statisticsmode == 2:
                    # total energy/CO2
                    energy_label = QApplication.translate('GroupBox','Energy')
                    CO2_label = QApplication.translate('GroupBox','CO2')
                    if not (platform.system() == 'Windows' and int(platform.release()) < 10) and self.graphfont in {0, 3}:
                        # no subscript for legacy Windows, or graph fonts different to default and WenQuanYi
                        CO2_label = CO2_label.replace('CO2','CO₂')
                    energy_unit = self.energyunits[self.energyresultunit_setup]
                    energymetrics,_ = self.calcEnergyuse()
                    KWH_per_green = energymetrics.get('KWH_batch_per_green_kg', 0)
                    CO2_per_green = energymetrics.get('CO2_batch_per_green_kg', 0)

                    # energy per kg
                    if KWH_per_green > 0:
                        if KWH_per_green < 1:
                            if right_to_left(self.locale_str):
                                scaled_energy_kwh = 'Wh/kg ' + scaleFloat2String(KWH_per_green*1000.)
                            else:
                                scaled_energy_kwh = scaleFloat2String(KWH_per_green*1000.) + ' Wh/kg'
                        elif right_to_left(self.locale_str):
                            scaled_energy_kwh = 'kWh/kg ' + scaleFloat2String(KWH_per_green)
                        else:
                            scaled_energy_kwh = scaleFloat2String(KWH_per_green) + ' kWh/kg'
                        if right_to_left(self.locale_str):
                            energyPerKgCoffeeLabel = f'({scaled_energy_kwh})  '
                        else:
                            energyPerKgCoffeeLabel = f'  ({scaled_energy_kwh})'
                    # no weight is available
                    else:
                        energyPerKgCoffeeLabel = ''

                    # CO2 per kg
                    if CO2_per_green > 0:
                        if CO2_per_green < 1000:
                            if right_to_left(self.locale_str):
                                scaled_co2_kg = 'g/kg ' + scaleFloat2String(CO2_per_green)
                            else:
                                scaled_co2_kg = scaleFloat2String(CO2_per_green) + ' g/kg'
                        elif right_to_left(self.locale_str):
                            scaled_co2_kg = 'kg/kg ' + scaleFloat2String(CO2_per_green/1000.)
                        else:
                            scaled_co2_kg = scaleFloat2String(CO2_per_green/1000.) + ' kg/kg'
                        if right_to_left(self.locale_str):
                            CO2perKgCoffeeLabel = f'({scaled_co2_kg})  '
                        else:
                            CO2perKgCoffeeLabel = f'  ({scaled_co2_kg})'
                    # no weight is available
                    else:
                        CO2perKgCoffeeLabel = ''

                    total_energy = scaleFloat2String(self.convertHeat(energymetrics.get('BTU_batch', 0), 'BTU', self.energyunits[self.energyresultunit_setup]))
                    CO2_batch = energymetrics.get('CO2_batch', 0)
                    if right_to_left(self.locale_str):
                        scaled_co2_batch = f'g{scaleFloat2String(CO2_batch)}' if CO2_batch<1000 else f'kg{scaleFloat2String(CO2_batch/1000.)}'
                    else:
                        scaled_co2_batch = f'{scaleFloat2String(CO2_batch)}g' if CO2_batch<1000 else f'{scaleFloat2String(CO2_batch/1000.)}kg'

                    if right_to_left(self.locale_str):
                        msg = f'{CO2perKgCoffeeLabel}{scaled_co2_batch} :{CO2_label}   {energyPerKgCoffeeLabel}{energy_unit}{total_energy} :{energy_label}'
                    else:
                        msg = f'{energy_label}: {total_energy}{energy_unit}{energyPerKgCoffeeLabel}   {CO2_label}: {scaled_co2_batch}{CO2perKgCoffeeLabel}'
                    self.set_xlabel(msg)
                elif self.statisticsmode == 3:
                    # just roast energy/CO2
                    energy_label = QApplication.translate('GroupBox','Energy')
                    CO2_label = QApplication.translate('GroupBox','CO2')
                    if not (platform.system() == 'Windows' and int(platform.release()) < 10) and self.graphfont in {0, 3}:
                        # no subscript for legacy Windows, or graph fonts different to default and WenQuanYi
                        CO2_label = CO2_label.replace('CO2','CO₂')
                    energy_unit = self.energyunits[self.energyresultunit_setup]
                    roast_label = self.__dijkstra_to_ascii(QApplication.translate('Label','Roast'))
                    energymetrics,_ = self.calcEnergyuse()
                    KWH_per_green_roast = energymetrics.get('KWH_roast_per_green_kg', 0)
                    CO2_per_green_roast = energymetrics.get('CO2_roast_per_green_kg', 0)

                    # energy per kg
                    if KWH_per_green_roast > 0:
                        if KWH_per_green_roast < 1:
                            if right_to_left(self.locale_str):
                                scaled_energy_kwh = f'Wh/kg {scaleFloat2String(KWH_per_green_roast*1000.)}'
                            else:
                                scaled_energy_kwh = f'{scaleFloat2String(KWH_per_green_roast*1000.)} Wh/kg'
                        elif right_to_left(self.locale_str):
                            scaled_energy_kwh = f'kWh/kg {scaleFloat2String(KWH_per_green_roast)}'
                        else:
                            scaled_energy_kwh = f'{scaleFloat2String(KWH_per_green_roast)} kWh/kg'
                        if right_to_left(self.locale_str):
                            energyPerKgCoffeeLabel = f'({scaled_energy_kwh})  '
                        else:
                            energyPerKgCoffeeLabel = f'  ({scaled_energy_kwh})'
                    # no weight is available
                    else:
                        energyPerKgCoffeeLabel = ''

                    # CO2 per kg
                    if CO2_per_green_roast > 0:
                        if CO2_per_green_roast < 1000:
                            if right_to_left(self.locale_str):
                                scaled_co2_kg = f'g/kg {scaleFloat2String(CO2_per_green_roast)}'
                            else:
                                scaled_co2_kg = f'{scaleFloat2String(CO2_per_green_roast)} g/kg'
                        elif right_to_left(self.locale_str):
                            scaled_co2_kg = f'kg/kg {scaleFloat2String(CO2_per_green_roast/1000.)}'
                        else:
                            scaled_co2_kg = f'{scaleFloat2String(CO2_per_green_roast/1000.)} kg/kg'
                        if right_to_left(self.locale_str):
                            CO2perKgCoffeeLabel = f'({scaled_co2_kg})  '
                        else:
                            CO2perKgCoffeeLabel = f'  ({scaled_co2_kg})'
                    # no weight is available
                    else:
                        CO2perKgCoffeeLabel = ''

                    total_energy = (scaleFloat2String(self.convertHeat(energymetrics['BTU_roast'],'BTU',self.energyunits[self.energyresultunit_setup])) if 'BTU_roast' in energymetrics else '0')
                    if right_to_left(self.locale_str):
                        scaled_co2_batch = (f"g{scaleFloat2String(energymetrics['CO2_roast'])}" if energymetrics['CO2_roast']<1000 else f"kg{scaleFloat2String(energymetrics['CO2_roast']/1000.)}") if 'CO2_roast' in energymetrics else '0'
                    else:
                        scaled_co2_batch = (f"{scaleFloat2String(energymetrics['CO2_roast'])}g" if energymetrics['CO2_roast']<1000 else f"{scaleFloat2String(energymetrics['CO2_roast']/1000.)}kg") if 'CO2_roast' in energymetrics else '0'

                    if right_to_left(self.locale_str):
                        msg = f'{CO2perKgCoffeeLabel}{scaled_co2_batch} :{CO2_label} {roast_label}    {energyPerKgCoffeeLabel}{energy_unit}{total_energy}:{energy_label} {roast_label}'
                    else:
                        msg = f'{roast_label} {energy_label}: {total_energy}{energy_unit}{energyPerKgCoffeeLabel}    {roast_label} {CO2_label}: {scaled_co2_batch}{CO2perKgCoffeeLabel}'
                    self.set_xlabel(msg)
                else:
                    self.set_xlabel('')
            else:
                self.set_xlabel(self.default_xlabel_text())

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' writecharacteristics() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    # calculates self.statisticstimes values and returns dryEndIndex as well as the calculated statisticstimes array of length 5
    def calcStatistics(self, TP_index:int) -> Tuple[int,List[float]]:
        statisticstimes:List[float] = [0,0,0,0,0]
        try:
            if self.timeindex[1]:
                #manual dryend available
                dryEndIndex = self.timeindex[1]
            else:
                #find when dry phase ends
                dryEndIndex = self.aw.findDryEnd(TP_index)
            if len(self.timex) > dryEndIndex:
                dryEndTime = self.timex[dryEndIndex]

                #if DROP
                if self.timeindex[6] and self.timeindex[2]:
                    starttime = (self.timex[self.timeindex[0]] if -1 < self.timeindex[0] < len(self.timex) else 0)
                    totaltime = self.timex[self.timeindex[6]]-starttime
                    if totaltime == 0:
                        return dryEndIndex, statisticstimes

                    statisticstimes[0] = totaltime
                    dryphasetime = dryEndTime - starttime # float2float(dryEndTime - starttime)
                    midphasetime = self.timex[self.timeindex[2]] - dryEndTime # float2float(self.timex[self.timeindex[2]] - dryEndTime)
                    finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]] # float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                    if self.timeindex[7]:
                        coolphasetime = self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]] # int(round(self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]]))
                    else:
                        coolphasetime = 0

                    statisticstimes[1] = dryphasetime
                    statisticstimes[2] = midphasetime
                    statisticstimes[3] = finishphasetime
                    statisticstimes[4] = coolphasetime
                return dryEndIndex, statisticstimes
            return self.timeindex[1], statisticstimes
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            return self.timeindex[1], statisticstimes

    # Writes information about the finished profile in the graph
    # TP_index is the TP index calculated by findTP and might be -1 if no TP could be detected
    def writestatistics(self, TP_index:int) -> None:
        try:
            if self.ax is None:
                return

            LP:Optional[float] = None

            starttime = (self.timex[self.timeindex[0]] if -1 < self.timeindex[0] < len(self.timex) else 0)

            dryEndIndex, statisticstimes = self.calcStatistics(TP_index)

            if statisticstimes[0] == 0:
                self.writecharacteristics(TP_index,LP)
                return
            self.statisticstimes = statisticstimes

            #if DROP
            if self.timeindex[6] and self.timeindex[2]:

                #dry time string
                st1 = stringfromseconds(self.statisticstimes[1],False)

                #mid time string
                st2 = stringfromseconds(self.statisticstimes[2],False)

                #finish time string
                st3 = stringfromseconds(self.statisticstimes[3],False)

                if self.statisticstimes[4]:
                    st4 = stringfromseconds(self.statisticstimes[4],False)
                else:
                    st4 = ''

                #calculate the positions for the statistics elements
                ydist = self.ylimit - self.ylimit_min
                statisticsbarheight = ydist/70

                if self.legendloc in {1, 2, 9}:
                    # legend on top
                    statisticsheight = self.ylimit - (0.13 * ydist) # standard positioning
                else:
                    # legend not on top
                    statisticsheight = self.ylimit - (0.08 * ydist)

                if self.mode == 'C':
                    statisticsupper = statisticsheight + statisticsbarheight + 4
                    statisticslower = statisticsheight - 3.5*statisticsbarheight
                else:
                    statisticsupper = statisticsheight + statisticsbarheight + 10
                    statisticslower = statisticsheight - 2.5*statisticsbarheight

                if self.statisticsflags[1]:

                    #Draw cool phase rectangle
                    if self.timeindex[7]:
                        rect = patches.Rectangle(
                                (self.timex[self.timeindex[6]], statisticsheight),
                                width = self.statisticstimes[4],
                                height = statisticsbarheight,
                                color = self.palette['rect4'],
                                alpha=0.5,
                                path_effects=[])
                        self.ax.add_patch(rect)

                    if self.timeindex[2]: # only if FCs exists
                        #Draw finish phase rectangle
                        #check to see if end of 1C exists. If so, use half between start of 1C and end of 1C. Otherwise use only the start of 1C
                        rect = patches.Rectangle(
                                (self.timex[self.timeindex[2]], statisticsheight),
                                width = self.statisticstimes[3],
                                height = statisticsbarheight,
                                color = self.palette['rect3'],
                                alpha=0.5,
                                path_effects=[])
                        self.ax.add_patch(rect)

                        # Draw mid phase rectangle
                        rect = patches.Rectangle(
                                (starttime+self.statisticstimes[1],
                                statisticsheight),
                                width = self.statisticstimes[2],
                                height = statisticsbarheight,
                                color = self.palette['rect2'],
                                alpha=0.5,
                                path_effects=[])
                        self.ax.add_patch(rect)

                    # Draw dry phase rectangle
                    if self.timeindex[0] > -1:
                        # only if CHARGE is set
                        rect = patches.Rectangle(
                                (starttime,
                                statisticsheight),
                                width = self.statisticstimes[1],
                                height = statisticsbarheight,
                                color = self.palette['rect1'],
                                alpha=0.5,
                                path_effects=[])
                        self.ax.add_patch(rect)

                fmtstr = '{0:.1f}' if self.LCDdecimalplaces else '{0:.0f}'
                if self.statisticstimes[0]:
                    dryphaseP = fmtstr.format(self.statisticstimes[1]*100./self.statisticstimes[0])
                    midphaseP = fmtstr.format(self.statisticstimes[2]*100./self.statisticstimes[0])
                    finishphaseP = fmtstr.format(self.statisticstimes[3]*100./self.statisticstimes[0])
                else:
                    dryphaseP = ' --- '
                    midphaseP = ' --- '
                    finishphaseP = ' --- '

                #find Lowest Point in BT
                LP = 1000
                if TP_index >= 0:
                    LP = self.temp2[TP_index]

                if self.statisticsflags[0]:
                    if self.timeindex[0] > -1:
                        # only if CHARGE is set
                        if right_to_left(self.locale_str):
                            text = self.ax.text(starttime + self.statisticstimes[1]/2.,statisticsupper,
                                    f'%{dryphaseP}  {st1}',
                                    color=self.palette['text'],ha='center',
                                fontsize='medium'
                                )
                        else:
                            text = self.ax.text(starttime + self.statisticstimes[1]/2.,statisticsupper,
                                    f'{st1}  {dryphaseP}%',
                                    color=self.palette['text'],ha='center',
                                fontsize='medium'
                                )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                    if self.timeindex[2]: # only if FCs exists
                        if self.statisticstimes[2]*100./self.statisticstimes[0]>1: # annotate only if mid phase is at least 1% of the total
                            if right_to_left(self.locale_str):
                                text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticsupper,
                                        (f'%{midphaseP}  {st2}' if self.timeindex[0] > -1 else st2),
                                        color=self.palette['text'],ha='center',
                                    fontsize='medium'
                                    )
                            else:
                                text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticsupper,
                                        (f'{st2}  {midphaseP}%' if self.timeindex[0] > -1 else st2),
                                        color=self.palette['text'],ha='center',
                                    fontsize='medium'
                                    )
                            try:
                                text.set_in_layout(False)
                            except Exception: # pylint: disable=broad-except
                                pass
                        if right_to_left(self.locale_str):
                            text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticsupper,
                                        (f'%{finishphaseP}  {st3}' if self.timeindex[0] > -1 else st3),
                                        color=self.palette['text'],ha='center',
                                fontsize='medium'
                                )
                        else:
                            text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticsupper,
                                        (f'{st3}  {finishphaseP}%' if self.timeindex[0] > -1 else st3),
                                        color=self.palette['text'],ha='center',
                                fontsize='medium'
                                )
                        try:
                            text.set_in_layout(False)
                        except Exception:  # pylint: disable=broad-except
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+self.statisticstimes[4]/2.,statisticsupper,st4,color=self.palette['text'],ha='center',
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass

                st1 = st2 = st3 = st4 = ''

                if self.statisticsflags[4] or self.statisticsflags[6]:
                    rates_of_changes = self.aw.RoR(TP_index,dryEndIndex)
                    d = str(self.LCDdecimalplaces)
                    if right_to_left(self.locale_str):
                        if self.statisticsflags[6]:
                            fmtstr = '{1}{0:.' + d + 'f}'
                            if self.statisticsflags[4]:
                                fmtstr += '  {3}{2:.' + d + 'f}'
                        else:
                            fmtstr = '{3}{2:.' + d + 'f}'
                    elif self.statisticsflags[6]:
                        fmtstr = '{0:.' + d + 'f}{1}'
                        if self.statisticsflags[4]:
                            fmtstr += '  {2:.' + d + 'f}{3}'
                    else:
                        fmtstr = '{2:.' + d + 'f}{3}'

                    unit = self.aw.arabicReshape(self.mode + '/min')
                    if rates_of_changes[3] != -1:
                        st1 = st1 + fmtstr.format(rates_of_changes[3], self.mode, rates_of_changes[0], unit)
                    if rates_of_changes[4] != -1:
                        st2 = st2 + fmtstr.format(rates_of_changes[4], self.mode, rates_of_changes[1], unit)
                    if rates_of_changes[5] != -1:
                        st3 = st3 + fmtstr.format(rates_of_changes[5], self.mode, rates_of_changes[2], unit)


                    if self.timeindex[0] > -1:
                        text = self.ax.text(starttime + self.statisticstimes[1]/2.,statisticslower,st1,
                            color=self.palette['text'],
                            ha='center',
                            fontsize='medium')
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                    if self.timeindex[2]: # only if FCs exists
                        if self.statisticstimes[2]*100./self.statisticstimes[0]>1: # annotate only if mid phase is at least 1% of the total
                            text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticslower,st2,color=self.palette['text'],ha='center',
                                #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                                fontsize='medium'
                                )
                            try:
                                text.set_in_layout(False)
                            except Exception: # pylint: disable=broad-except
                                pass
                        text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticslower,st3,color=self.palette['text'],ha='center',
                            #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(starttime + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+max(self.statisticstimes[4]/2.,self.statisticstimes[4]/3.),statisticslower,st4,color=self.palette['text'],ha='center',
                            #fontproperties=statsprop # fails be rendered in PDF exports on MPL v3.4.x
                            fontsize='medium'
                            )
                        try:
                            text.set_in_layout(False)
                        except Exception: # pylint: disable=broad-except
                            pass
            self.writecharacteristics(TP_index,LP)
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' writestatistics() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))

    def cacheforBbp(self) -> None:
        try:
            # mode
            self.bbpCache['mode'] = self.mode
            # drop temps
            self.bbpCache['drop_bt'] = self.temp2[self.timeindex[6]]
            self.bbpCache['drop_et'] = self.temp1[self.timeindex[6]]
            # ending time epoch in mSec
            self.bbpCache['end_roastepoch_msec'] = QDateTime.currentDateTime().toMSecsSinceEpoch()
            # get the special events values at OFF and time of previous change relative to end
            self.bbpCache['end_events'] = self.get_specialevents_at_timeindex(len(self.timex)-1)
            # get the special events values at DROP and time of previous change relative to end
            self.bbpCache['drop_events'] = self.get_specialevents_at_timeindex(self.timeindex[6])
            self.bbpCache['drop_to_end'] = self.timex[-1] - self.timex[self.timeindex[6]]
        except Exception: # pylint: disable=broad-except
            self.bbpCache = {}

    def get_specialevents_at_timeindex(self, timeindex:int) -> List[List[Optional[float]]]:
        # note: event values are returned as actual_value+1
        # values_at_timeindex -> specialeventvalue, time_relative_to_end of last change after DROP else None
        values_at_timeindex: List[List[Optional[float]]] = [[None, None] for _ in range(4)]
        try:
            for event_type in range(4):
                for i in range(len(self.specialevents)-1, -1, -1):
                    if self.specialeventstype[i] == event_type and self.specialevents[i] <= timeindex:
                        last_change_after_drop = None
                        if self.specialevents[i] > self.timeindex[6]:
                            last_change_after_drop = float2float(self.timex[self.specialevents[i]] - self.timex[-1],2)
                        values_at_timeindex[event_type] = [self.specialeventsvalue[i], last_change_after_drop]
                        break
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' get_specialevents_at_timeindex() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return values_at_timeindex

    @staticmethod
    def convertHeat(value:float, fromUnit:str, toUnit:str='BTU') -> float:
        if value in [-1,None]:
            return value
        conversion = { #        BTU                kJ                kCal                kWh                hph               thm
                       'bt': {'bt':1.,          'kj':1.0551E+00,  'kc':2.5200E-01,  'kw':2.9307E-04,  'hp':3.9301E-04, 'th':1.0000E-05 }, # = 1 btu
                       'kj': {'bt':9.4782E-01,  'kj':1.,          'kc':2.3885E-01,  'kw':2.7778E-04,  'hp':3.7251E-04, 'th':9.4782E-06 }, # = 1 kj
                       'kc': {'bt':3.9683E+00,  'kj':4.1868E+00,  'kc':1.,          'kw':1.1630E-03,  'hp':1.5596E-03, 'th':3.9683E-05 }, # = 1 kcal
                       'kw': {'bt':3.4121E+03,  'kj':3.6000E+03,  'kc':8.5985E+02,  'kw':1.,          'hp':1.3410E+00, 'th':3.4121E-02 }, # = 1 kwh
                       'hp': {'bt':2.5444E+03,  'kj':2.6845E+03,  'kc':6.4119E+02,  'kw':7.4570E-01,  'hp':1.        , 'th':2.5444E-02 }, # = 1 hph
                       'th': {'bt':1.0000E+05,  'kj':1.0551E+05,  'kc':2.5200E+04,  'kw':2.9307E+01,  'hp':3.9301E+01, 'th':1.         }} # = 1 thm

        try:
            return value * conversion[fromUnit.lower()[0:2]][toUnit.lower()[0:2]]
        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            return 0

    # Calculate CO2 mass from energy consumption
    def calcCO2g(self, btus:float, energysource:int) -> float:
        co2g = btus * self.CO2kg_per_BTU[energysource] * 1000
        if energysource == 1:  # NG
            co2g = co2g - (co2g * (1 - self.Biogas_CO2_Reduction) * self.gasMix/100)
        elif energysource == 2:  # Electric
            co2g = co2g * (1 - self.electricEnergyMix/100)
        return co2g

    # Sum up the energy use from a variety of inputs
    def calcEnergyuse(self, beanweightstr:str = '') -> Tuple['EnergyMetrics', List['BTU']]:
        energymetrics:EnergyMetrics = {}
        btu_list:List[BTU] = []
        try:
            if len(self.timex) == 0:
                #self.aw.sendmessage(QApplication.translate("Message","No profile data"),append=False)
                return energymetrics, btu_list

            # helping function
            def formatLoadLabel(i:int) -> str:
                if len(self.loadlabels[i]) > 0:
                    return  self.loadlabels[i]
                return chr(ord('A')+i)

            # get the valid green weight
            if beanweightstr != '':
                w = toFloat(beanweightstr)
            else:
                w = self.weight[0]
            bean_weight = convertWeight(w, weight_units.index(self.weight[2]),1) # to kg

            eTypes = [''] + self.etypes[:][:4]

            # init the prev_loadtime to drop if it exists or to the end of profile time
            if self.timeindex[6] > 0:
                prev_loadtime = [self.timex[self.timeindex[6]]]*4
            else:
                prev_loadtime = [self.timex[-1]]*4
                #self.aw.sendmessage(QApplication.translate("Message","Profile has no DROP event"),append=False)

            for i in range(4):
                # iterate specialevents in reverse from DROP to the first event
                for j in range(len(self.specialevents) - 1, -1, -1):
                    if self.load_etypes[i] != 0 and self.specialeventstype[j] == self.load_etypes[i]-1:
                        # skip if loadrating is zero
                        if self.loadratings[i] == 0:
                            break
                        loadtime = self.timex[self.specialevents[j]]
                        # exclude heat before charge event
                        if self.timeindex[0] > -1 and loadtime <= self.timex[self.timeindex[0]]:
                            if prev_loadtime[i] <= self.timex[self.timeindex[0]]:
                                break
                            loadtime = self.timex[self.timeindex[0]]
                        duration = prev_loadtime[i] - loadtime

                        # exclude heat after drop event
                        if duration < 0:
                            continue
                        prev_loadtime[i] = loadtime
                        # scale the burner setting for 0-100%
                        val = (self.specialeventsvalue[j] - 1) * 10
                        emin = toInt(self.loadevent_zeropcts[i])
                        emax = toInt(self.loadevent_hundpcts[i])
                        scaled = (val - emin) / (emax - emin)  #emax > emin enforced by energy.py
                        load_pct = min(1,max(0, scaled)) * 100
                        if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = load_pct / 100

                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        if BTUs > 0:
                            loadlabel = f'{formatLoadLabel(i)}-{eTypes[self.load_etypes[i]]}'
                            kind = 7  #Roast Event
                            sortorder = (2000 * (i + 1)) + j
                            CO2g = self.calcCO2g(BTUs, self.sourcetypes[i])
                            btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})
                ### end of loop: for j in range(len(self.specialevents) - 1, -1, -1)

                # calculate Continuous event type
                if self.load_etypes[i] == 0:
                    if self.timeindex[0] > -1 and self.timeindex[6] > 0:
                        duration = self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]]
                    else:
                        duration = 0
                        #self.aw.sendmessage(QApplication.translate("Message","Missing CHARGE or DROP event"),append=False)
                    load_pct = toInt(self.loadevent_hundpcts[i])  #needed only for the btu_list and outmsg
                    if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                        # convert pressure to heat
                        factor = math.sqrt(load_pct / 100)
                    else:
                        factor = load_pct / 100

                    loadlabel = formatLoadLabel(i)
                    kind = 6  #Roast Continuous
                    fueltype = self.sourcetypes[i]
                    sortorder = 2000 - i
                    BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                    CO2g = self.calcCO2g(BTUs, self.sourcetypes[i])
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate preheat
                if self.preheatenergies[i] != 0 and self.roastbatchpos == 1:
                    if self.preheatenergies[i] < 0 < self.preheatDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.preheatenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = load_pct / 100
                        duration = self.preheatDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 1  #Preheat Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.preheatenergies[i] * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 0  #Preheat Measured

                    loadlabel = formatLoadLabel(i)
                    sortorder = 100 + i
                    CO2g = self.calcCO2g(BTUs, self.sourcetypes[i])
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate betweenbatch
                if self.betweenbatchenergies[i] != 0 and (self.roastbatchpos > 1 or self.betweenbatch_after_preheat or self.roastbatchpos==0):
                    if self.betweenbatchenergies[i] < 0 < self.betweenbatchDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.betweenbatchenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = load_pct / 100
                        duration = self.betweenbatchDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 3  #BBP Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.betweenbatchenergies[i] * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 2  #BBP Measured

                    loadlabel = formatLoadLabel(i)
                    sortorder = 400 + i
                    CO2g = self.calcCO2g(BTUs, self.sourcetypes[i])
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})

                # calculate cooling
                if self.coolingenergies[i] != 0 and self.roastbatchpos == 1:
                    if self.coolingenergies[i] < 0 < self.coolingDuration:
                        # percent load multiplied by duration
                        load_pct = abs(self.coolingenergies[i] * 1000./10)
                        if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                            # convert pressure to heat
                            factor = math.sqrt(load_pct / 100)
                        else:
                            factor = load_pct / 100
                        duration = self.coolingDuration
                        BTUs = self.loadratings[i] * factor * (duration / 3600) * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 5  #Cooling Percent
                    else:
                        # measured value
                        load_pct = 0
                        duration = 0
                        BTUs = self.coolingenergies[i] * self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                        kind = 4  #Cooling Measured
                    loadlabel = formatLoadLabel(i)
                    sortorder = 800 + i
                    CO2g = self.calcCO2g(BTUs, self.sourcetypes[i])
                    if BTUs > 0:
                        btu_list.append({'load_pct':load_pct,'duration':duration,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':self.sourcetypes[i],'SortOrder':sortorder})
            #### end of loop: for i in range(0,4)

            # Meter reads
            btu_meter_bbp:float = 0
            btu_meter_roast:float = 0
            co2_meter_bbp:float = 0
            co2_meter_roast:float = 0
            for j in range(2):
                # Get the batch, roast and bbp meter reads
                if self.meterreads[j][0] > 0:
                    BTUs = self.meterreads[j][0]
                    loadlabel = self.meterlabels[j]
                    sortorder = j  # meter reads at the top of the details table
                    fueltype = self.meterfuels[j]
                    CO2g = self.calcCO2g(BTUs, fueltype)
                    kind = 8 # Meter
                    btu_list.append({'load_pct':0,'duration':0,'BTUs':BTUs,'CO2g':CO2g,'LoadLabel':loadlabel,'Kind':kind,'SourceType':fueltype,'SortOrder':sortorder})
                    # Get the BBP and Roastreads
                    btu_meter_bbp += self.meterreads[j][1] # Charge
                    btu_meter_roast += self.meterreads[j][7] - self.meterreads[j][1] # Drop minus Charge
                    co2_meter_bbp += self.calcCO2g(btu_meter_bbp, fueltype)
                    co2_meter_roast += self.calcCO2g(btu_meter_roast, fueltype)

            # sort the entries in btu list per the sort order defined for each entry
            btu_list.sort(key=lambda k : k['SortOrder'] )

            # summarize the batch metrics
            btu_batch = btu_preheat = btu_bbp = btu_cooling = btu_roast = 0.
            co2_batch = co2_preheat = co2_bbp = co2_cooling = co2_roast = 0.
            btu_elec = btu_lpg = btu_ng = 0.
            for item in btu_list:
                btu_batch += item['BTUs']
                btu_preheat += item['BTUs'] if item['Kind'] in {0, 1} else 0
                btu_bbp += item['BTUs'] if item['Kind'] in {2, 3} else 0
                btu_cooling += item['BTUs'] if item['Kind'] in {4, 5} else 0
                btu_roast += item['BTUs'] if item['Kind'] in {6, 7} else 0
                co2_batch += item['CO2g']
                co2_preheat += item['CO2g'] if item['Kind'] in {0, 1} else 0
                co2_bbp += item['CO2g'] if item['Kind'] in {2, 3} else 0
                co2_cooling += item['CO2g'] if item['Kind'] in {4, 5} else 0
                co2_roast += item['CO2g'] if item['Kind'] in {6, 7} else 0
                btu_lpg += item['BTUs'] if item['SourceType'] == 0 else 0
                btu_ng += item['BTUs'] if item['SourceType'] == 1 else 0
                btu_elec += item['BTUs'] if item['SourceType'] == 2 else 0
            btu_bbp += btu_meter_bbp
            btu_roast += btu_meter_roast
            co2_bbp += co2_meter_bbp
            co2_roast += co2_meter_roast
            btu_batch = float2float(btu_batch,3)
            btu_preheat = float2float(btu_preheat,3)
            btu_bbp = float2float(btu_bbp,3)
            btu_cooling = float2float(btu_cooling,3)
            btu_roast = float2float(btu_roast,3)
            co2_batch = float2float(co2_batch,3)
            co2_preheat = float2float(co2_preheat,3)
            co2_bbp = float2float(co2_bbp,3)
            co2_cooling = float2float(co2_cooling,3)
            co2_roast = float2float(co2_roast,3)
            btu_lpg = float2float(btu_lpg,3)
            btu_ng = float2float(btu_ng,3)
            btu_elec = float2float(btu_elec,3)
            btu_meter1 = float2float(self.meterreads[0][0],3)
            btu_meter2 = float2float(self.meterreads[1][0],3)
            if bean_weight > 0:
                co2_batch_per_green_kg = co2_batch / bean_weight
                co2_roast_per_green_kg = co2_roast / bean_weight
                btu_batch_per_green_kg = btu_batch / bean_weight
                btu_roast_per_green_kg = btu_roast / bean_weight
            else:
                co2_batch_per_green_kg = 0
                co2_roast_per_green_kg = 0
                btu_batch_per_green_kg = 0
                btu_roast_per_green_kg = 0
            co2_batch_per_green_kg = float2float(co2_batch_per_green_kg,3)
            co2_roast_per_green_kg = float2float(co2_roast_per_green_kg,3)
            btu_batch_per_green_kg = float2float(btu_batch_per_green_kg,3)
            btu_roast_per_green_kg = float2float(btu_roast_per_green_kg,3)
            kwh_batch_per_green_kg = float2float(self.convertHeat(btu_batch_per_green_kg,'BTU','kWh'),3)
            kwh_roast_per_green_kg = float2float(self.convertHeat(btu_roast_per_green_kg,'BTU','kWh'),3)

            # energymetrics
            energymetrics['BTU_batch'] = btu_batch
            energymetrics['BTU_batch_per_green_kg'] = btu_batch_per_green_kg
            energymetrics['CO2_batch'] = co2_batch
            energymetrics['BTU_preheat'] = btu_preheat
            energymetrics['CO2_preheat'] = co2_preheat
            energymetrics['BTU_bbp'] = btu_bbp
            energymetrics['CO2_bbp'] = co2_bbp
            energymetrics['BTU_cooling'] = btu_cooling
            energymetrics['CO2_cooling'] = co2_cooling
            energymetrics['BTU_roast'] = btu_roast
            energymetrics['BTU_roast_per_green_kg'] = btu_roast_per_green_kg
            energymetrics['CO2_roast'] = co2_roast
            energymetrics['CO2_batch_per_green_kg'] = co2_batch_per_green_kg
            energymetrics['CO2_roast_per_green_kg'] = co2_roast_per_green_kg
            energymetrics['BTU_LPG'] = btu_lpg
            energymetrics['BTU_NG'] = btu_ng
            energymetrics['BTU_ELEC'] = btu_elec
            energymetrics['BTU_METER1'] = btu_meter1
            energymetrics['BTU_METER2'] = btu_meter2
            energymetrics['KWH_batch_per_green_kg'] = kwh_batch_per_green_kg
            energymetrics['KWH_roast_per_green_kg'] = kwh_roast_per_green_kg

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' calcEnergyuse() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return energymetrics,btu_list

    def measureFromprofile(self) -> Tuple[List[float],List[float],float,float]:
        coolEnergy = [0.]*4
        heatEnergy = [0.]*4
        heatDuration = 0.
        coolDuration = 0.
        try:
            if len(self.timex) == 0:
                #self.aw.sendmessage(QApplication.translate("Message","No profile data"),append=False)
                return [-1]*4, [-1]*4, 0, 0

            def getEnergy(i:int, j:int, duration:float) -> float:
                try:
                    # scale the burner setting for 0-100%
                    val = (self.specialeventsvalue[j] - 1) * 10
                    emin = toInt(self.loadevent_zeropcts[i])
                    emax = toInt(self.loadevent_hundpcts[i])
                    scaled = (val - emin) / (emax - emin)  #emax > emin enforced by energy.py
                    load_pct = min(1,max(0,scaled)) * 100
                    if self.presssure_percents[i] and self.sourcetypes[i] in {0, 1}:   # gas loads only
                        # convert pressure to heat
                        factor = math.sqrt(load_pct / 100)
                    else:
                        factor = load_pct / 100
                    return self.loadratings[i] * factor * (duration / 3600) #* self.convertHeat(1,self.powerunits[self.ratingunits[i]],'BTU')
                except Exception as ex: # pylint: disable=broad-except
                    _log.exception(ex)
                    _, _, exc_tb = sys.exc_info()
                    self.adderror((QApplication.translate('Error Message','Exception:') + ' measureFromprofile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
                return 0

            # if there is a DROP event use that for coolstart
            if self.timeindex[6] > 0:
                coolstart = self.timex[self.timeindex[6]]
            # else if there is a CHARGE event use that for coolstart
            elif self.timeindex[0] > -1:
                coolstart = self.timex[self.timeindex[0]]
            # else use the start of time for coolstart
            else:
                coolstart = self.timex[0]

            # if there is a CHARGE event use that for heatend
            if self.timeindex[0] > -1:
                heatend = self.timex[self.timeindex[0]]
            # else use the end of time for heatend
            else:
                heatend = self.timex[-1]

            prev_loadtime = [self.timex[-1]]*4

            for i in range(4):
                # iterate specialevents in reverse from end of profile to start
                if self.load_etypes[i] == 0:
                    heatEnergy[i] = -1
                    coolEnergy[i] = -1
                elif self.loadratings[i] > 0:
                    for j in range(len(self.specialevents) - 1, -1, -1):
                        if self.specialeventstype[j] == self.load_etypes[i]-1:
                            loadtime = self.timex[self.specialevents[j]]

                            if coolstart <= loadtime < prev_loadtime[i]:
                                duration = prev_loadtime[i] - loadtime
                                coolEnergy[i] += getEnergy(i,j,duration)
                            elif loadtime < coolstart <= prev_loadtime[i]:
                                duration = prev_loadtime[i] - coolstart
                                coolEnergy[i] += getEnergy(i,j,duration)

                            if loadtime < heatend <= prev_loadtime[i]:
                                duration = heatend - loadtime
                                heatEnergy[i] += getEnergy(i,j,duration)
                            elif loadtime < heatend and prev_loadtime[i] < heatend:
                                duration = prev_loadtime[i] - loadtime
                                heatEnergy[i] += getEnergy(i,j,duration)

                            prev_loadtime[i] = loadtime

                    ### end of loop: for j in range(len(self.specialevents) - 1, -1, -1)
            #### end of loop: for i in range(0,4)

            heatDuration = self.timex[self.timeindex[0]]
            coolDuration = self.timex[-1] - self.timex[self.timeindex[6]]

        except Exception as ex: # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' measureFromprofile() {0}').format(str(ex)),getattr(exc_tb, 'tb_lineno', '?'))
        return heatEnergy, coolEnergy, heatDuration, coolDuration

    #called from markdryend(), markcharge(), mark1Cstart(),  etc when using device 18 (manual mode)
    def drawmanual(self, et:float, bt:float, tx:float) -> None:
        self.timex.append(tx)
        self.temp1.append(et)
        if self.ETcurve and self.l_temp1 is not None:
            self.l_temp1.set_data(self.timex, self.temp1)
        self.temp2.append(bt)
        if self.BTcurve and self.l_temp2 is not None:
            self.l_temp2.set_data(self.timex, self.temp2)

    def movebackground(self, direction:str, step:int) -> None:
        lt = len(self.timeB)
        le = len(self.temp1B)
        lb = len(self.temp2B)
        #all background curves must have same dimension in order to plot. Check just in case.
        if lt > 1 and lt == le and lb == le:
            if  direction == 'up':
                for i in range(lt):
                    self.temp1B[i] += step
                    self.temp2B[i] += step
                    self.stemp1B[i] += step
                    self.stemp2B[i] += step
                for i,xtB in enumerate(self.extratimexB):
                    for j,_ in enumerate(xtB):
                        self.temp1BX[i][j] += step
                        self.temp2BX[i][j] += step
                        self.stemp1BX[i][j] += step
                        self.stemp2BX[i][j] += step
                self.backgroundprofile_moved_y += step
                self.moveBackgroundAnnoPositionsY(step)

            elif direction == 'left':
                for i in range(lt):
                    self.timeB[i] -= step
                for xtB in self.extratimexB:
                    for j,_ in enumerate(xtB):
                        xtB[j] -= step
                self.backgroundprofile_moved_x -= step
                self.moveBackgroundAnnoPositionsX(-step)

            elif direction == 'right':
                for i in range(lt):
                    self.timeB[i] += step
                for xtB in self.extratimexB:
                    for j,_ in enumerate(xtB):
                        xtB[j] += step
                self.backgroundprofile_moved_x += step
                self.moveBackgroundAnnoPositionsX(step)

            elif direction == 'down':
                for i in range(lt):
                    self.temp1B[i] -= step
                    self.temp2B[i] -= step
                    self.stemp1B[i] -= step
                    self.stemp2B[i] -= step

                for i,xtB in enumerate(self.extratimexB):
                    for j,_ in enumerate(xtB):
                        self.temp1BX[i][j] -= step
                        self.temp2BX[i][j] -= step
                        self.stemp1BX[i][j] -= step
                        self.stemp2BX[i][j] -= step
                self.backgroundprofile_moved_y -= step
                self.moveBackgroundAnnoPositionsY(-step)

            # ensure to deactivate passed background events to prevent their replay
            if self.backgroundPlaybackEvents and direction in {'left','right'}:
                # to ignore already passed events
                self.updateReplayedBackgroundEvents()
        else:
            self.aw.sendmessage(QApplication.translate('Message','Unable to move background'))

    #points are used to draw interpolation
    def findpoints(self) -> Tuple[List[float],List[float]]:
        #if profile found
        if self.timeindex[0] != -1:
            Xpoints = []                        #make temporary lists to hold the values to return
            Ypoints = []

            #start point from beginning of time
            Xpoints.append(self.timex[0])
            Ypoints.append(self.temp2[0])
            #input beans (CHARGE)
            Xpoints.append(self.timex[self.timeindex[0]])
            Ypoints.append(self.temp2[self.timeindex[0]])

            #find indexes of lowest point and dryend
            LPind = self.aw.findTP()
            DE = self.aw.findDryEnd()

            if LPind < DE:
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
            else:
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])

            if self.temp2[self.timeindex[1]] > self.timex[DE] and self.temp2[self.timeindex[1]] > self.timex[LPind]:
                Xpoints.append(self.timex[self.timeindex[1]])
                Ypoints.append(self.temp2[self.timeindex[1]])
            if self.timeindex[2]:
                Xpoints.append(self.timex[self.timeindex[2]])
                Ypoints.append(self.temp2[self.timeindex[2]])
            if self.timeindex[3]:
                Xpoints.append(self.timex[self.timeindex[3]])
                Ypoints.append(self.temp2[self.timeindex[3]])
            if self.timeindex[4]:
                Xpoints.append(self.timex[self.timeindex[4]])
                Ypoints.append(self.temp2[self.timeindex[4]])
            if self.timeindex[5]:
                Xpoints.append(self.timex[self.timeindex[5]])
                Ypoints.append(self.temp2[self.timeindex[5]])
            if self.timeindex[6]:
                Xpoints.append(self.timex[self.timeindex[6]])
                Ypoints.append(self.temp2[self.timeindex[6]])

            #end point
            if self.timex[self.timeindex[6]] != self.timex[-1]:
                Xpoints.append(self.timex[-1])
                Ypoints.append(self.temp2[-1])

            return Xpoints,Ypoints

        self.aw.sendmessage(QApplication.translate('Message','No finished profile found'))
        return [],[]

    #collects info about the univariate interpolation
    def univariateinfo(self) -> None:
        try:
            from scipy.interpolate import UnivariateSpline # type: ignore
            #pylint: disable=E0611
            Xpoints,Ypoints = self.findpoints()  #from lowest point to avoid many coefficients
            equ = UnivariateSpline(Xpoints, Ypoints)
            coeffs = equ.get_coeffs().tolist()
            knots = equ.get_knots().tolist()
            resid = equ.get_residual()
            roots = equ.roots().tolist()

            #interpretation of coefficients: http://www.sagenb.org/home/pub/1708/

            string = f"<b>{QApplication.translate('Message','Polynomial coefficients (Horner form):')}</b><br>"
            string += f'{coeffs}<br><br>'
            string += f"<b>{QApplication.translate('Message','Knots:')}</b><br>"
            string += f'{knots}<br><br>'
            string += f"<b>{QApplication.translate('Message','Residual:')}</b><br>"
            string += f'{resid}<br><br>'
            string += f"<b>{QApplication.translate('Message','Roots:')}</b><br>"
            string += str(roots)

            QMessageBox.information(self.aw, QApplication.translate('Message','Profile information'),string)

        except ValueError as e:
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Value Error:') + ' univariateinfo() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' univariateinfo() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

#    def test(self):
##        p = 120 # period in seconds
##        k = int(round(p / self.delay * 1000)) # number of past readings to consider
#        k = 70
#        if len(self.timex)>k:
#            try:
#                ET = numpy.array([numpy.nan if x == -1 else x for x in self.temp1[-k:]], dtype='float64')
#                BT = numpy.array([numpy.nan if x == -1 else x for x in self.temp2[-k:]], dtype='float64')
#                ET_BT = ET - BT
##                delta = numpy.array([numpy.nan if x == -1 else x for x in self.delta2[-k:]], dtype='float64')
#                delta = numpy.array([numpy.nan if x == -1 else x for x in self.unfiltereddelta2[-k:]], dtype='float64')
#                idx = numpy.isfinite(ET_BT) & numpy.isfinite(delta)
#                z, residuals, _, _, _ = numpy.polyfit(ET_BT[idx],delta[idx], 2, full=True)
#                print("z",z)
#                f = numpy.poly1d(z)
#                v = f(ET_BT[-1])
##                v = (f(ET_BT[-2]) + f(ET_BT[-1])) / 2 # this smoothing seems to delay too much
#                print("res",residuals, f(0), abs(delta[-1] - v))
#                if abs(delta[-1] - v) > 10:
#                    return -1, -1
#                else:
#                    return f(0), v
##                    return residuals, v
#
##                    if residuals > 280:
##                        return -1, -1
##                    elif residuals > 50:
##                        return v, -1
##                    else:
##                        return -1, v
#            except Exception as e: # pylint: disable=broad-except
#                print(e)
#                _log.exception(e)
#                return -1, -1
#        else:
#            return -1, -1

    def polyfit(self, xarray:Sequence[Optional[float]], yarray:Sequence[Optional[float]], deg:int, startindex:int, endindex:int, _:bool = False, onDeltaAxis:bool = False) -> Optional['npt.NDArray[numpy.double]']:
        xa = xarray[startindex:endindex]
        ya = yarray[startindex:endindex]
        if len(xa) > 0 and len(xa) == len(ya) and not all(x == 0 for x in xa) and not all(x == 0 for x in ya):
            try:
                # polyfit only over proper values (not -1, infinite or NaN)
                c1 = numpy.array([numpy.nan if x == -1 else x for x in xa], dtype='float64')
                c2 = numpy.array([numpy.nan if x == -1 else x for x in ya], dtype='float64')
                idx = numpy.isfinite(c1) & numpy.isfinite(c2)
                z:npt.NDArray[numpy.double] = numpy.polyfit(c1[idx],c2[idx],deg)
                p = numpy.poly1d(z)
                x = p(numpy.array(xarray[startindex:endindex], dtype='float64'))
                pad = max(0,len(self.timex) - startindex - len(x))
                xx = numpy.concatenate((numpy.full((max(0,startindex)), None),x, numpy.full((pad,), None)))
                trans = None
                if onDeltaAxis and self.delta_ax is not None:
                    trans = self.delta_ax.transData
                elif self.ax is not None:
                    trans = self.ax.transData
                if trans is not None and self.ax is not None:
                    self.ax.plot(self.timex, xx, linestyle = '--', linewidth=3, transform=trans)
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.fig.canvas.draw()
                    return z
                return None
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
                return None
        else:
            return None

    #ln() regression. ln() will be used when power does not equal 2 (quadratic) or 3 (cubic).
    def lnRegression(self,power:int=0, curvefit_starttime:float=0, curvefit_endtime:float=0, plot:bool=True) -> str:
        res:str = ''
        try:
            from scipy.optimize import curve_fit # type: ignore
            if self.timeindex[0] > -1 and self.timeindex[6] > -1:  #CHARGE and DROP events exist
                charge = self.timex[self.timeindex[0]]
                if curvefit_starttime is not None and curvefit_starttime > charge:
                    begin = self.time2index(curvefit_starttime)
                    time_l = []
                    temp_l = []
                else:
                    #a = [charge] # not used!?
                    # find the DRY END point
                    if self.timeindex[1]: # take DRY if available
                        begin = self.timeindex[1]
                    else: # take DRY as specified in phases
                        pi = self.aw.findDryEnd(phasesindex=1)
                        begin = self.time2index(self.timex[pi])
                    # initial bean temp set to greens_temp or ambient or a fixed temp
                    if self.greens_temp > 0:
                        time_l = [charge]
                        temp_l = [self.greens_temp]
                    elif self.ambientTemp is not None and self.ambientTemp > 0:
                        time_l = [charge]
                        temp_l = [self.ambientTemp]
                    else:
                        time_l = [charge]
                        roomTemp = 70.0 if self.mode == 'F' else 21.0
                        temp_l = [roomTemp]
                if curvefit_endtime > 0:
                    end = self.time2index(curvefit_endtime)
                else:
                    end = self.timeindex[6]
                time_l = time_l + self.timex[begin:end]
                temp_l = temp_l + self.temp2[begin:end]

                xa = numpy.array(time_l) - charge
                yn = numpy.array(temp_l)
                func:Union[Callable[[Any, Any, Any, Any], Any],Callable[[Any, Any, Any, Any, Any], Any]]
                if power == 2:
                    func = lambda x,a,b,c: a*x*x + b*x + c # noqa: E731 # pylint: disable=unnecessary-lambda-assignment
                elif power == 3:
                    func = lambda x,a,b,c,d: a*x*x*x + b*x*x + c*x + d # noqa: E731 # pylint: disable=unnecessary-lambda-assignment
                else:
                    func = lambda x,a,b,c: a * numpy.log(b*x+c) # noqa: E731 # pylint: disable=unnecessary-lambda-assignment
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    hint = [0.01,0.01,1]
                    if power == 2:
                        hint = [-0.001, 0.5, 10]
                    elif power == 3:
                        hint =     [-0.00001, -0.0001, 0.5, 10]
                    popt,_ = curve_fit(func, xa, yn, p0=hint, maxfev=3000) # pylint: disable=unbalanced-tuple-unpacking
                #perr = numpy.sqrt(numpy.diag(pcov))
                if plot and self.ax is not None:
                    xb = numpy.array(self.timex)
                    xxb = xb + charge
                    xxa = xa + charge
                    self.ax.plot(xxb, func(xb, *popt),  color='#000000', linestyle = '-.', linewidth=3)
                    self.ax.plot(xxa, yn, 'ro')
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.fig.canvas.draw()
                if len(popt)>2:
                    if power == 2:
                        res = f"{popt[0]:.8f} * t*t {('+' if popt[1] > 0 else '')} {popt[1]:.8f} * t {('+' if popt[2] > 0 else '')} {popt[2]:.8f}"
                    elif power ==3:
                        res = f"{popt[0]:.8f} * t*t*t {('+' if popt[1] > 0 else '')} {popt[1]:.8f} * t*t {('+' if popt[2] > 0 else '')} {popt[2]:.8f} * t {('+' if popt[3] > 0 else '')} {popt[3]:.8f}"
                    else:
                        res = f"{popt[0]:.8f} * log({popt[1]:.8f} * t {('+' if popt[2] > 0 else '')} {popt[2]:.8f}, e)"
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror(QApplication.translate('Error Message','Error in lnRegression:') + ' lnRegression() ' + str(e),getattr(exc_tb, 'tb_lineno', '?'))
            if power == 2:
                fit = 'x\u00b2'
            elif power == 3:
                fit = 'x\u00b3'
            else:
                fit = QApplication.translate('Label','ln()')
            msg = QApplication.translate('Message','Cannot fit this curve to ' + fit)
            QApplication.processEvents() #this is here to be sure the adderror gets written to the log before the sendmessage
            self.aw.sendmessage(msg)

        return res

    #interpolation type
    def univariate(self) -> None:
        try:
            if self.ax is not None:
                from scipy.interpolate import UnivariateSpline
                #pylint: disable=E0611
                Xpoints,Ypoints = self.findpoints()

                func = UnivariateSpline(Xpoints, Ypoints)

                xa = numpy.array(self.timex)
                newX = func(xa).tolist()

                self.ax.plot(self.timex, newX, color='#000000', linestyle = '-.', linewidth=3)
                self.ax.plot(Xpoints, Ypoints, 'ro')

                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()

        except ValueError:
            self.adderror(QApplication.translate('Error Message','Value Error:') + ' univariate()')

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror(QApplication.translate('Error Message','Exception:') + ' univariate() ' + str(e),getattr(exc_tb, 'tb_lineno', '?'))

    def drawinterp(self, mode:str) -> None:
        try:
            if self.ax is not None:
                #pylint: disable=E1101
                from scipy import interpolate as inter # type: ignore
                Xpoints,Ypoints = self.findpoints() #from 0 origin
                func = inter.interp1d(Xpoints, Ypoints, kind=mode)
                newY = func(self.timex)
                self.ax.plot(self.timex, newY, color='#000000', linestyle = '-.', linewidth=3)
                self.ax.plot(Xpoints, Ypoints, 'ro')

                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Value Error:') + ' drawinterp() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' drawinterp() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    # calculates the (interpolated) temperature from the given time/temp arrays at timepoint "seconds"
    @staticmethod
    def timetemparray2temp(timearray:Union['npt.NDArray[numpy.double]',Sequence[float]],
            temparray:Union['npt.NDArray[numpy.double]',Sequence[Optional[float]]], seconds:float) -> float:
        if timearray is not None and temparray is not None and len(timearray) and len(temparray) and len(timearray) == len(temparray):
            if seconds > timearray[-1] or seconds < timearray[0]:
                # requested timepoint out of bonds
                return -1
            # compute the closest index (left sided)
            i = int(numpy.searchsorted(timearray,seconds,side='left'))
            ti = timearray[i]
            tempi = temparray[i]
            if tempi is None or numpy.isnan(tempi):
                return -1
            if i < len(timearray) - 1:
                j = i - 1
                tj = timearray[j]
                tempj = temparray[j]
                if tempj is None or numpy.isnan(tempj):
                    return -1
                s = (tempi - tempj) / (ti - tj)
                return tempj + s*(seconds - tj)
            # should not be reached (guarded by the outer if)
            return tempi
        return -1

    # if smoothed=True, the smoothed data is taken if available
    # if relative=True, the given time in seconds is interpreted relative to CHARGE, otherwise absolute from the first mesasurement
    def BTat(self, seconds:float, smoothed:bool = True, relative:bool = False) -> float:
        if smoothed and self.stemp2 is not None and len(self.stemp2) != 0:
            temp = self.stemp2
        else:
            temp = self.temp2
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)

    def ETat(self, seconds:float, smoothed:bool = True, relative:bool = False) -> float:
        if smoothed and self.stemp1 is not None and len(self.stemp1) != 0:
            temp = self.stemp1
        else:
            temp = self.temp1
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)

    def backgroundBTat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp2B,seconds + offset)

    def backgroundSmoothedBTat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB, self.stemp2B, seconds + offset)

    def backgroundETat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp1B,seconds + offset)

    def backgroundSmoothedETat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.stemp1B,seconds + offset)

    # returns the background temperature of extra curve n
    # with n=0 => extra device 1, curve 1; n=1 => extra device 1, curve 2; n=2 => extra device 2, curve 1,....
    # if the selected extra curve does not exists, the error value -1 is returned
    # if smoothed is True, the value of the corresponding smoothed extra line is returned
    def backgroundXTat(self, n:int, seconds:float, relative:bool = False, smoothed:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        if n % 2 == 0:
            # even
            tempBX = self.stemp1BX if smoothed else self.temp1BX
        else:
            # odd
            tempBX = self.stemp2BX if smoothed else self.temp2BX
        c = n // 2
        if len(tempBX)>c:
            temp = tempBX[c]
        else:
            # no such extra device curve
            return -1
        return self.timetemparray2temp(self.timeB,temp,seconds + offset)

    def backgroundDBTat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta2B,seconds + offset)

    def backgroundDETat(self, seconds:float, relative:bool = False) -> float:
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta1B,seconds + offset)

    # fast variant based on binary search on lists using bisect (using numpy.searchsorted is slower)
    # side-condition: values in self.timex in linear order
    # time: time in seconds
    # nearest: if nearest is True the closest index is returned (slower), otherwise the previous (faster)
    # returns
    #   -1 on empty timex
    #    0 if time smaller than first entry of timex
    #  len(timex)-1 if time larger than last entry of timex (last index)
    @staticmethod
    def timearray2index(timearray:List[float], time:float, nearest:bool = True) -> int:
        i = bisect_right(timearray, time)
        if i:
            if nearest and i>0 and (i == len(timearray) or abs(time - timearray[i]) > abs(time - timearray[i-1])):
                return i-1
            return i
        return -1

    #selects closest time INDEX in self.timex from a given input float seconds
    def time2index(self, seconds:float, nearest:bool=True) -> int:
        #find where given seconds crosses self.timex
        return self.timearray2index(self.timex, seconds, nearest)

    #selects closest time INDEX in self.timeB from a given input float seconds
    def backgroundtime2index(self, seconds:float, nearest:bool=True) -> int:
        #find where given seconds crosses self.timeB
        return self.timearray2index(self.timeB, seconds, nearest)

    #updates list self.timeindex when found an _OLD_ profile without self.timeindex (new version)
    def timeindexupdate(self, times:List[float]) -> None:
##        #          START            DRYEND          FCs             FCe         SCs         SCe         DROP
##        times = [self.startend[0],self.dryend[0],self.varC[0],self.varC[2],self.varC[4],self.varC[6],self.startend[2]]
        for i,tms in enumerate(times):
            if tms:
                self.timeindex[i] = max(0,self.time2index(tms))
            else:
                self.timeindex[i] = 0

    #updates list self.timeindexB when found an _OLD_ profile without self.timeindexB
    def timebackgroundindexupdate(self, times:List[float]) -> None:
##        #          STARTB            DRYENDB          FCsB       FCeB         SCsB         SCeB               DROPB
##        times = [self.startendB[0],self.dryendB[0],self.varCB[0],self.varCB[2],self.varCB[4],self.varCB[6],self.startendB[2]]
        for i,tms in enumerate(times):
            if tms:
                self.timeindexB[i] = max(0,self.backgroundtime2index(tms))
            else:
                self.timeindexB[i] = 0


    #adds errors (can be called also outside the GUI thread, eg. from the sampling thread as actual message is written by updategraphics in the GUI thread)
    def adderror(self, error:str, line:Optional[Any]=None) -> None:
        try:
            #### lock shared resources #####
            self.errorsemaphore.acquire(1)
            _log.error(error)
            timez = str(QDateTime.currentDateTime().toString('hh:mm:ss.zzz'))    #zzz = milliseconds
            #keep a max of 500 errors
            if len(self.errorlog) > 499:
                self.errorlog = self.errorlog[1:]
            if line:
                error = error + '@line ' + str(line)
            self.errorlog.append(timez + ' ' + error)
            # truncate to first line for window message line
            try:
                # only show first line in
                error = error.splitlines()[0]
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            # update the error dlg
            if hasattr(self.aw, 'error_dlg') and self.aw.error_dlg:
                self.aw.updateErrorLogSignal.emit()
            self.aw.sendmessageSignal.emit(error,True,None)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
        finally:
            if self.errorsemaphore.available() < 1:
                self.errorsemaphore.release(1)

    ####################  PROFILE DESIGNER   ###################################################################################
    #launches designer
    def designer(self) -> None:
        #disconnect mouse cross if ON
        if self.crossmarker:
            self.togglecrosslines()
        #clear background if it came from analysis
        if len(self.analysisresultsstr) > 0:
            self.aw.deleteBackground()

        if self.timex:
            reply = QMessageBox.question(self.aw, QApplication.translate('Message','Designer Start'),
                                         QApplication.translate('Message','Importing a profile in to Designer will decimate all data except the main [points].\nContinue?'),
                                         QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Yes:
                res = self.initfromprofile()
                if res:
                    self.ax_lines_clear()
                    self.ax_annotations_clear() # remove background profiles annotations (has to be done before reset!)
                    # we also have to remove those extra event annotations if in combo mode
                    if self.eventsGraphflag == 4:
                        self.ax_combo_text_annotations_clear()
                    self.connect_designer()
                    self.aw.disableEditMenus(designer=True)
                    self.redraw()
                else:
                    self.aw.designerAction.setChecked(False)
            elif reply == QMessageBox.StandardButton.Cancel:
                self.aw.designerAction.setChecked(False)
        else:
            #if no profile found
            #
            # reset also the special event copy held for the designer
            self.eventtimecopy = []
            self.eventtimecopy = []
            self.specialeventsStringscopy = []
            self.specialeventsvaluecopy = []
            self.specialeventstypecopy = []
            self.etypescopy = self.etypes[:]
            #
            #pylint: disable=E0611
            #reset (clear) plot
            self.ax_lines_clear()
            self.ax_annotations_clear() # remove background profiles annotations (has to be done before reset!)
            # we also have to remove those extra event annotations if in combo mode
            if self.eventsGraphflag == 4:
                self.ax_combo_text_annotations_clear()
            self.reset(redraw=False,soundOn=False)
            self.connect_designer()
            self.aw.disableEditMenus(designer=True)
            self.designerinit()

    @pyqtSlot()
    @pyqtSlot(bool)
    def savepoints(self, _:bool = False) -> None:
        try:
            filename = self.aw.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Points'),ext='*.adsg')
            if filename:
                obj:Dict[str, Union[List[float],List[int]]] = {}
                obj['timex'] = [float2float(float(tx), 10) for tx in self.timex] # List[float]
                obj['temp1'] = [float2float(float(t1), 8) for t1 in self.temp1] # List[float]
                obj['temp2'] = [float2float(float(t2), 8) for t2 in self.temp2] # List[float]
                obj['timeindex'] = self.timeindex # List[int]
                import codecs # @Reimport
                with codecs.open(filename, 'w+', encoding='utf-8') as f:
                    f.write(repr(obj))
                self.aw.sendmessage(QApplication.translate('Message','Points saved'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _a, _b, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' savepoints() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def loadpoints(self, _:bool = False) -> None:
        try:
            filename = self.aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Load Points'),ext='*.adsg')
            obj = None
            if os.path.exists(filename):
                import codecs # @Reimport
                with codecs.open(filename, 'rb', encoding='utf-8') as f:
                    obj=ast.literal_eval(f.read())
            if obj and 'timex' in obj and 'temp1' in obj and 'temp2' in obj:
                self.timex = obj['timex']
                self.temp1 = obj['temp1']
                self.temp2 = obj['temp2']
                self.timeindex = obj['timeindex']
                self.xaxistosm(redraw=False)
                self.redrawdesigner(force=True)
                self.aw.sendmessage(QApplication.translate('Message','Points loaded'))
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _a, _b, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message','Exception:') + ' loadpoints() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))


    #used to start designer from scratch (not from a loaded profile)
    def designerinit(self) -> None:
        #init start vars        #CH, DE,      FCs,      FCe,       SCs,         SCe,         Drop,      COOL
        self.designertimeinit = [0,(4*60),(9*60),(11*60),(12*60),(12.5*60),(13*60),(17*60)]
        if self.mode == 'C':
            self.designertemp1init = [230.,230.,230.,230.,225.,220.,215.,150.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP,COOL
            self.designertemp2init = [210.,150.,198.,207.,212.,213.,215.,150.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP,COOL
        elif self.mode == 'F':
            self.designertemp1init = [446.,446.,446.,446.,437.,428.,419.,302.]
            self.designertemp2init = [410.,300.,388.,404.,413.,415.5,419.,302.]

        idx = 0
        self.timex,self.temp1,self.temp2 = [],[],[]
        for i,_ in enumerate(self.timeindex):
            # add SCe and COOL END only if corresponding button is enabled
            if (i != 5 or self.buttonvisibility[5]) and (i != 7 or self.buttonvisibility[7]):
                self.timex.append(self.designertimeinit[i])
                self.temp1.append(self.designertemp1init[i])
                self.temp2.append(self.designertemp2init[i])
                self.timeindex[i] = idx
                idx += 1
        # add TP
        if self.mode == 'C':
            self.timex.insert(1,1.5*60)
            self.temp1.insert(1,230)
            self.temp2.insert(1,110)
            # add one intermediate point between DRY and FCs
            self.timex.insert(3,6*60)
            self.temp1.insert(3,230)
            self.temp2.insert(3,174)
        elif self.mode == 'F':
            self.timex.insert(1,1.5*60)
            self.temp1.insert(1,446)
            self.temp2.insert(1,230)
            # add one intermediate point between DRY and FCs
            self.timex.insert(3,6*60)
            self.temp1.insert(3,446)
            self.temp2.insert(3,345)
        for x,_ in enumerate(self.timeindex):
            if self.timeindex[x] >= 2:
                self.timeindex[x] += 2
            elif self.timeindex[x] >= 1:
                self.timeindex[x] += 1

        self.timealign(redraw=False)

        if not self.locktimex:
            self.startofx = self.timex[0] -60
            self.endofx = self.timex[-1] + 60
            self.xaxistosm(redraw=False)

#        # import UnivariateSpline needed to draw the curve in designer
#        from scipy.interpolate import UnivariateSpline # @UnusedImport # pylint: disable=import-error
#        global UnivariateSpline # pylint: disable=global-statement
        # init designer timez
        self.designer_timez = list(numpy.arange(self.timex[0],self.timex[-1],self.time_step_size))
        # set initial RoR z-axis limits
        self.setDesignerDeltaAxisLimits(self.DeltaETflag, self.DeltaBTflag)
        self.redrawdesigner(force=True)

    #loads main points from a profile so that they can be edited
    def initfromprofile(self) -> bool:
        if self.timeindex[0] == -1 or self.timeindex[6] == 0:
            QMessageBox.information(self.aw, QApplication.translate('Message','Designer Init'),
                                    QApplication.translate('Message','Unable to start designer.\nProfile missing [CHARGE] or [DROP]'))
            self.disconnect_designer()
            return False

        #save events. They will be deleted on qmc.reset()
        self.specialeventsStringscopy = self.specialeventsStrings[:]
        self.specialeventsvaluecopy = self.specialeventsvalue[:]
        self.specialeventstypecopy = self.specialeventstype[:]
        self.eventtimecopy = []
        for spe in self.specialevents:
            #save relative time of events
            self.eventtimecopy.append(self.timex[spe]-self.timex[self.timeindex[0]])
        self.etypescopy = self.etypes[:]

        #find lowest point from profile to be converted
        lpindex = self.aw.findTP()
        if lpindex != -1 and lpindex not in self.timeindex:
            lptime = self.timex[lpindex]
            lptemp2 = self.temp2[lpindex]
            # we only consider TP if its BT is at least 20 degrees lower than the CHARGE temperature
            if self.temp2[self.timeindex[0]] < (lptemp2 + 20):
                lpindex = -1
        else:
            lpindex = -1
            lptime = -1
            lptemp2 = -1

        timeindexhold = [self.timex[self.timeindex[0]],0,0,0,0,0,0,0]
        timez,t1,t2 = [self.timex[self.timeindex[0]]],[self.temp1[self.timeindex[0]]],[self.temp2[self.timeindex[0]]]    #first CHARGE point
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:                           # fill up empty lists with main points (FCs, etc). match from timeindex
                timez.append(self.timex[self.timeindex[i]])  #add time
                t1.append(self.temp1[self.timeindex[i]])    #add temp1
                t2.append(self.temp2[self.timeindex[i]])    #add temp2
                timeindexhold[i] =  self.timex[self.timeindex[i]]

        # we remember time axis limits to reconstruct after reset (which might alter them such that they do not fit to the profile data any longer!)
        startofx = self.startofx
        endofx = self.endofx

        res = self.reset()  #erase screen
        if not res:
            return False

        # reconstruct timeaxis limits
        self.startofx = startofx
        self.endofx = endofx

        self.timex,self.temp1,self.temp2 = timez[:],t1[:],t2[:]  #copy lists back after reset() with the main points

        self.timeindexupdate(timeindexhold) #create new timeindex[]

        #add lowest point as extra point
        if lpindex != -1:
            self.currentx = lptime
            self.currenty = lptemp2
            self.addpoint(manual=False)
            # reset cursor coordinates
            self.currentx = 0
            self.currenty = 0

        self.timealign(redraw=False)

        self.xaxistosm(redraw=False)
#        # import UnivariateSpline needed to draw the curve in designer
#        from scipy.interpolate import UnivariateSpline # @UnusedImport # pylint: disable=import-error
#        global UnivariateSpline # pylint: disable=global-statement
        # init designer timez
        self.designer_timez = list(numpy.arange(self.timex[0],self.timex[-1],self.time_step_size))
        # set initial RoR z-axis limits
        self.setDesignerDeltaAxisLimits(self.DeltaETflag, self.DeltaBTflag)

        self.redrawdesigner(force=True)                                   #redraw the designer screen

        return True

    def setDesignerDeltaAxisLimits(self, setET:bool, setBT:bool) -> None:
        if setET or setBT:
            from scipy.interpolate import UnivariateSpline
            delta1_max = 0
            delta2_max = 0
            # we have first to calculate the delta data
            # returns the max ET/BT RoR between CHARGE and DROP
            if setET:
                try:
                    func1 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
                    funcDelta1 = func1.derivative()
                    delta1_max = max(funcDelta1(self.designer_timez) * 60)
                except Exception: # pylint: disable=broad-except
                    # scipy interpolate might fail for certain k
                    pass
            if setBT:
                try:
                    func2 = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
                    funcDelta2 = func2.derivative()
                    delta2_max = max(funcDelta2(self.designer_timez) * 60)
                except Exception: # pylint: disable=broad-except
                    # scipy interpolate might fail for certain k
                    pass
            dmax = max(delta1_max, delta2_max)
            # we only adjust the upper limit automatically
            assert self.aw is not None
            zlimit_org = self.zlimit
            if dmax > self.zlimit_min:
                self.zlimit = int(dmax) + 1
            else:
                self.zlimit = self.zlimit_min + 1
            if self.delta_ax is not None:
                if zlimit_org != self.zlimit:
                    self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                if self.zgrid != 0:
                    d = self.zlimit - self.zlimit_min
                    steps = int(round(d/5))
                    if steps > 50:
                        steps = int(round(steps/10))*10
                    elif steps > 10:
                        steps = int(round(steps/5))*5
                    elif steps > 5:
                        steps = 5
                    else:
                        steps = int(round(steps/2))*2
                    auto_grid = max(2,steps)
                    if auto_grid != self.zgrid:
                        self.zgrid = auto_grid
                        if self.zgrid > 0:
                            self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                            self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            for i in self.delta_ax.get_yticklines():
                                i.set_markersize(10)
                            for i in self.delta_ax.yaxis.get_minorticklines():
                                i.set_markersize(5)
                            for label in self.delta_ax.get_yticklabels() :
                                label.set_fontsize('small')
                            if not self.LCDdecimalplaces:
                                self.delta_ax.minorticks_off()

    #redraws designer
    def redrawdesigner(self, force:bool=False) -> None: #if force is set the bitblit cache is ignored and a full redraw is triggered
        from scipy.interpolate import UnivariateSpline
        if self.designerflag and self.ax is not None:

            if self.ax_background_designer is None or force:
                # we first initialize the background canvas and the bitblit cache
                self.designer_timez = list(numpy.arange(self.timex[0],self.timex[-1],self.time_step_size))

                #pylint: disable=E0611
                #reset (clear) plot
                self.ax_lines_clear()
                self.ax_annotations_clear() # remove background profiles annotations (has to be done before reset!)

                # remove logo image while in Designer
                if self.ai is not None:
                    try:
                        self.ai.remove()
                    except Exception: # pylint: disable=broad-except
                        pass
                fontprop_medium = self.aw.mpl_fontproperties.copy()
                fontprop_medium.set_size('medium')
                self.set_xlabel(self.aw.arabicReshape(QApplication.translate('Label', 'Designer')))

                # update z-axis limits if autoDelta is enabled
                self.setDesignerDeltaAxisLimits(self.DeltaETflag and self.autodeltaxET, self.DeltaBTflag and self.autodeltaxBT)

                # init artists
                rcParams['path.sketch'] = (0,0,0)


                #draw background
                if self.background:
                    if self.backgroundShowFullflag:
                        btime = self.timeB
                        b1temp = self.stemp1B
                        b2temp = self.stemp2B
                    else:
                        bcharge_idx = 0
                        if self.timeindexB[0] > -1:
                            bcharge_idx = self.timeindexB[0]
                        bdrop_idx = len(self.timeB)-1
                        if self.timeindexB[6] > 0:
                            bdrop_idx = self.timeindexB[6]
                        btime = self.timeB[bcharge_idx:bdrop_idx]
                        b1temp = self.stemp1B[bcharge_idx:bdrop_idx]
                        b2temp = self.stemp2B[bcharge_idx:bdrop_idx]

                    self.ax.plot(btime,b1temp,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                    sketch_params=None,path_effects=[],
                                                    linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                    alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundET')))
                    self.ax.plot(btime,b2temp,markersize=self.BTbackmarkersize,marker=self.BTbackmarker,
                                                    linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                    sketch_params=None,path_effects=[],
                                                    alpha=self.backgroundalpha,label=self.aw.arabicReshape(QApplication.translate('Label', 'BackgroundBT')))

                self.l_stat1, = self.ax.plot([],[],color = self.palette['rect1'],alpha=.5,linewidth=5)
                self.l_stat2, = self.ax.plot([],[],color = self.palette['rect2'],alpha=.5,linewidth=5)
                self.l_stat3, = self.ax.plot([],[],color = self.palette['rect3'],alpha=.5,linewidth=5)

                self.l_div1, = self.ax.plot([],[],color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
                self.l_div2, = self.ax.plot([],[],color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
                self.l_div3, = self.ax.plot([],[],color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')
                self.l_div4, = self.ax.plot([],[],color = self.palette['grid'],alpha=.3,linewidth=3,linestyle='--')

                if (self.DeltaBTflag or self.DeltaETflag) and self.delta_ax is not None:
                    trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)

                    self.l_delta1, = self.ax.plot([],[],transform=trans,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+self.patheffects,foreground=self.palette['background'])],
                        linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette['deltaet'],
                        label=self.aw.arabicReshape(deltaLabelPrefix + QApplication.translate('Label', 'ET')))
                    self.l_delta2, = self.ax.plot([],[],transform=trans,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+self.patheffects,foreground=self.palette['background'])],
                        linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette['deltabt'],
                        label=self.aw.arabicReshape(deltaLabelPrefix + QApplication.translate('Label', 'BT')))
                else:
                    self.l_delta1 = None
                    self.l_delta2 = None

                self.l_temp1, = self.ax.plot([], [],markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,
                    linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette['et'],
                        label=QApplication.translate('Label', 'ET'))
                self.l_temp2, = self.ax.plot([], [], markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,
                    linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette['bt'],
                        label=QApplication.translate('Label', 'BT'))

                self.l_temp1_markers, = self.ax.plot([],[],color = self.palette['et'],marker = 'o',picker=True, pickradius=10,linestyle='',markersize=8)
                self.l_temp2_markers, = self.ax.plot([],[],color = self.palette['bt'],marker = 'o',picker=True, pickradius=10,linestyle='',markersize=8)

                self._designer_orange_mark, = self.ax.plot([],[],color = 'orange',marker = 'o',alpha = .3,markersize=30)
                self._designer_blue_mark, = self.ax.plot([],[],color = 'blue',marker = 'o',alpha = .3,markersize=30)

                #plot
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw() # NOTE: this needs to be done NOW and not via draw_idle() at any time later, to avoid ghost lines

                # initialize bitblit background
                axfig = self.ax.get_figure()
                if axfig is not None and hasattr(self.fig.canvas,'copy_from_bbox'):
                    self.ax_background_designer = self.fig.canvas.copy_from_bbox(axfig.bbox)  # pyright: ignore[reportAttributeAccessIssue]

            # restore background
            if hasattr(self.fig.canvas,'restore_region'):
                self.fig.canvas.restore_region(self.ax_background_designer) # pyright: ignore[reportAttributeAccessIssue]


            #create statistics bar
            #calculate the positions for the statistics elements
            ydist = self.ylimit - self.ylimit_min
            statisticsheight = self.ylimit - (0.13 * ydist)
            stats_ys = [statisticsheight,statisticsheight]

            #add statistics bar

            if self.l_stat1 is not None:
                self.l_stat1.set_data([self.timex[self.timeindex[0]],self.timex[self.timeindex[1]]],stats_ys)
                self.ax.draw_artist(self.l_stat1)
            if self.l_stat2 is not None:
                self.l_stat2.set_data([self.timex[self.timeindex[1]],self.timex[self.timeindex[2]]],stats_ys)
                self.ax.draw_artist(self.l_stat2)
            if self.l_stat3 is not None:
                self.l_stat3.set_data([self.timex[self.timeindex[2]],self.timex[self.timeindex[6]]],stats_ys)
                self.ax.draw_artist(self.l_stat3)

            #add phase division lines

            ylist = [self.ylimit,0]
            if self.l_div1 is not None:
                self.l_div1.set_data([self.timex[self.timeindex[0]],self.timex[self.timeindex[0]]],ylist)
                self.ax.draw_artist(self.l_div1)
            if self.l_div2 is not None:
                self.l_div2.set_data([self.timex[self.timeindex[1]],self.timex[self.timeindex[1]]],ylist)
                self.ax.draw_artist(self.l_div2)
            if self.l_div3 is not None:
                self.l_div3.set_data([self.timex[self.timeindex[2]],self.timex[self.timeindex[2]]],ylist)
                self.ax.draw_artist(self.l_div3)
            if self.l_div4 is not None:
                self.l_div4.set_data([self.timex[self.timeindex[6]],self.timex[self.timeindex[6]]],ylist)
                self.ax.draw_artist(self.l_div4)

            if self.BTsplinedegree >= len(self.timex):  #max 5 or less. Cannot be bigger than points
                self.BTsplinedegree = len(self.timex)-1

            if self.ETsplinedegree >= len(self.timex):  #max 5 or less. Cannot be bigger than points
                self.ETsplinedegree = len(self.timex)-1

            try:
                func2 = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
                btvals = func2(self.designer_timez)
                func1 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
                etvals = func1(self.designer_timez)
            except Exception: # pylint: disable=broad-except
                self.adderror(QApplication.translate('Error Message', 'Exception: redrawdesigner() Roast events may be out of order. Resetting Designer.'))
                self.reset_designer()
                return

            #convert all time values to temperature

            if self.DeltaBTflag and self.l_delta2 is not None:
                funcDelta2 = func2.derivative()
                deltabtvals = funcDelta2(self.designer_timez) * 60
                self.l_delta2.set_data(numpy.array(self.designer_timez), deltabtvals)
                self.ax.draw_artist(self.l_delta2)

            if self.DeltaETflag and self.l_delta1 is not None:
                funcDelta1 = func1.derivative()
                deltaetvals = funcDelta1(self.designer_timez) * 60
                self.l_delta1.set_data(numpy.array(self.designer_timez), deltaetvals)
                self.ax.draw_artist(self.l_delta1)

            #add curves
            if self.ETcurve and self.l_temp1 is not None:
                self.l_temp1.set_data(numpy.array(self.designer_timez), etvals)
                self.ax.draw_artist(self.l_temp1)
            if self.BTcurve and self.l_temp2 is not None:
                self.l_temp2.set_data(numpy.array(self.designer_timez), btvals)
                self.ax.draw_artist(self.l_temp2)

            #add markers (big circles) '0'
            if self.ETcurve and self.l_temp1_markers is not None:
                self.l_temp1_markers.set_data(self.timex,self.temp1)
                self.ax.draw_artist(self.l_temp1_markers)
            if self.BTcurve and self.l_temp2_markers is not None:
                self.l_temp2_markers.set_data(self.timex,self.temp2)
                self.ax.draw_artist(self.l_temp2_markers)

            if self._designer_orange_mark_shown and self._designer_orange_mark is not None:
                self.ax.draw_artist(self._designer_orange_mark)
            if self._designer_blue_mark_shown and self._designer_blue_mark is not None:
                self.ax.draw_artist(self._designer_blue_mark)

            afig = self.ax.get_figure()
            if afig is not None:
                self.fig.canvas.blit(afig.bbox)
            self.fig.canvas.flush_events()

    #CONTEXT MENU  = Right click
    def on_press(self, event:'MouseEvent') -> None:
        try:
            if event.inaxes != self.ax or event.button != 3:
                return #select right click only

            self.releaseMouse()
            self.mousepress = False
            # reset the zoom rectangles
            self.aw.ntb.release_pan(event)
            self.aw.ntb.release_zoom(event)
            # set cursor
            self.setCursor(Qt.CursorShape.PointingHandCursor)

            event_xdata = event.xdata
            event_ydata = event.ydata
            if event_xdata is None or event_ydata is None:
                return
            self.currentx = event_xdata
            self.currenty = event_ydata

            designermenu = QMenu(self.aw)  # if we bind this to self, we inherit the background-color: transparent from self.fig

            designermenu.addSeparator()

            addpointAction = QAction(QApplication.translate('Contextual Menu', 'Add point'),self)
            addpointAction.triggered.connect(self.addpoint_action)
            designermenu.addAction(addpointAction)

            removepointAction = QAction(QApplication.translate('Contextual Menu', 'Remove point'),self)
            removepointAction.triggered.connect(self.removepoint)
            designermenu.addAction(removepointAction)

            designermenu.addSeparator()

            loadpointsAction = QAction(QApplication.translate('Contextual Menu', 'Load points'),self)
            loadpointsAction.triggered.connect(self.loadpoints)
            designermenu.addAction(loadpointsAction)

            savepointsAction = QAction(QApplication.translate('Contextual Menu', 'Save points'),self)
            savepointsAction.triggered.connect(self.savepoints)
            designermenu.addAction(savepointsAction)

            designermenu.addSeparator()

            resetAction = QAction(QApplication.translate('Contextual Menu', 'Reset Designer'),self)
            resetAction.triggered.connect(self.reset_designer)
            designermenu.addAction(resetAction)

            configAction = QAction(QApplication.translate('Contextual Menu', 'Config...'),self)
            configAction.triggered.connect(self.desconfig)
            designermenu.addAction(configAction)

            designermenu.exec(QCursor.pos())
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)

    def on_pick(self, event:'PickEvent') -> None:
        if self.currentx or self.currenty:
            self.currentx = 0
            self.currenty = 0
            return

        self.setCursor(Qt.CursorShape.ClosedHandCursor)

        if hasattr(event, 'ind'):
            event_ind = event.ind # pyright:ignore
            if event_ind is not None:
                if isinstance(event_ind, (int)):
                    self.indexpoint = event_ind
                else:
                    N = len(event_ind)
                    if not N:
                        return
                    self.indexpoint = event_ind[0]
        else:
            return

        self.mousepress = True

        line = event.artist

        if isinstance(line, Line2D):
            #identify which line is being edited
            ydata = line.get_ydata()
            if len(ydata)>1 and ydata[1] == self.temp1[1]:
                self.workingline = 1
            else:
                self.workingline = 2

    #handles when releasing mouse
    def on_release(self,_:'Event') -> None:
        self.mousepress = False
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        self.redrawdesigner(force=True)

    def phases_to_messageline(self) -> None:
        totaltime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]]
        dryphasetime = self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]]
        midphasetime = self.timex[self.timeindex[2]] - self.timex[self.timeindex[1]]
        finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]]

        if totaltime:
            dryphaseP = int(round(dryphasetime*100./totaltime))
            midphaseP = int(round(midphasetime*100./totaltime))
            finishphaseP = int(round(finishphasetime*100./totaltime))
        else:
            return

        midramp = self.temp2[self.timeindex[2]] - self.temp2[self.timeindex[1]]
        finishramp = self.temp2[self.timeindex[6]] - self.temp2[self.timeindex[2]]

        min_bt,time_min_bt = self.findTPdes()
        if min_bt is not None and time_min_bt is not None:
            dryrampTP = self.temp2[self.timeindex[1]] - min_bt
            dryphasetimeTP = self.timex[self.timeindex[1]] - time_min_bt

            if dryphasetimeTP:
                dryroc = f' {((dryrampTP/dryphasetimeTP)*60.):.1f} {self.mode}/min'
            else:
                dryroc = f' 0 {self.mode}/min'

            if midphasetime:
                midroc = f' {((midramp/midphasetime)*60.):.1f} {self.mode}/min'
            else:
                midroc = '/min' f' 0 {self.mode}/min'

            if finishphasetime:
                finishroc = f' {((finishramp/finishphasetime)*60.):.1f} {self.mode}/min'
            else:
                finishroc = f'/min' f' 0 {self.mode}/min'

            margin = '&nbsp;&nbsp;&nbsp;'
            text_color_rect1 = '#ffffff' if self.aw.QColorBrightness(QColor(self.palette['rect1'])) < 128 else '#000000'
            string1 = f" <font color = \"{text_color_rect1[:7]}\" style=\"BACKGROUND-COLOR: {self.palette['rect1'][:7]}\">{margin}{stringfromseconds(dryphasetime)}{margin}{dryphaseP}%{margin}{dryroc}{margin}</font>"
            text_color_rect2 = '#ffffff' if self.aw.QColorBrightness(QColor(self.palette['rect2'])) < 128 else '#000000'
            string2 = f" <font color = \"{text_color_rect2[:7]}\" style=\"BACKGROUND-COLOR: {self.palette['rect2'][:7]}\">{margin} {stringfromseconds(midphasetime)} {margin} {midphaseP}% {margin} {midroc} {margin}</font>"
            text_color_rect3 = '#ffffff' if self.aw.QColorBrightness(QColor(self.palette['rect3'])) < 128 else '#000000'
            string3 = f" <font color = \"{text_color_rect3[:7]}\" style=\"BACKGROUND-COLOR: {self.palette['rect3'][:7]}\">{margin} {stringfromseconds(finishphasetime)} {margin} {finishphaseP}% {margin} {finishroc} {margin}</font>"
            self.aw.sendmessage(f'<PRE>{string1}{string2}{string3}</PRE>',append=False)

    #handler for moving point
    def on_motion(self, event:'MouseEvent') -> None:
        if not event.inaxes:
            return

        xdata = event.xdata
        ydata = event.ydata

        try:
            if ydata is not None and xdata is not None and self.mousepress:                                 #if mouse clicked

                self.timex[self.indexpoint] = xdata
                if self.workingline == 1:
                    self.temp1[self.indexpoint] = ydata
                else:
                    self.temp2[self.indexpoint] = ydata

                if self._designer_orange_mark_shown and self._designer_orange_mark is not None:
                    self._designer_orange_mark.set_data([xdata], [ydata])
                elif self._designer_blue_mark_shown and self._designer_blue_mark is not None:
                    self._designer_blue_mark.set_data([xdata], [ydata])

                #check point going over point
                #check to the left
                if self.indexpoint > 0 and abs(self.timex[self.indexpoint] - self.timex[self.indexpoint - 1]) < 10.:
                    self.unrarefy_designer()
                    return
                #check to the right
                if self.indexpoint <= len(self.timex)-2 and abs(self.timex[self.indexpoint] - self.timex[self.indexpoint + 1]) < 10.:
                    self.unrarefy_designer()
                    return

                #check for possible CHARGE time moving
                if self.indexpoint == self.timeindex[0]:
                    self.designer_timez = numpy.arange(self.timex[0],self.timex[-1]+1,1).tolist()
                    self.xaxistosm(redraw=False)

                #check for possible DROP/COOL time moving
                if (self.timeindex[7] and self.indexpoint == self.timeindex[7]) or (not self.timeindex[7] and self.indexpoint == self.timeindex[6]):
                    self.designer_timez = list(numpy.arange(self.timex[0],self.timex[-1],self.time_step_size))

                #redraw
                self.redrawdesigner()

                if self.indexpoint in self.timeindex:
                    #report phases to messageline on moving event points
                    self.phases_to_messageline()
                else:
                    #report time of the additional point in blue
                    timez = stringfromseconds(self.timex[self.indexpoint] - self.timex[self.timeindex[0]])
                    self.aw.sendmessage(timez,style="background-color:'lightblue';",append=False)
                return

            orange_hit = False
            blue_hit = False
            if self.ax is not None and xdata is not None and ydata is not None:                       #outside graph type is None
                for i,_ in enumerate(self.timex):
                    if abs(xdata - self.timex[i]) < 7.:
                        if i in self.timeindex:
                            if self.BTcurve and abs(self.temp2[i] - ydata) < 10:
                                orange_hit = True
                                if not self._designer_orange_mark_shown and self._designer_orange_mark is not None:
                                    self._designer_orange_mark_shown = True
                                    self._designer_orange_mark.set_data([self.timex[i]],[self.temp2[i]])
                                    self.ax.draw_artist(self._designer_orange_mark)
                                    afig = self.ax.get_figure()
                                    if afig is not None:
                                        self.fig.canvas.blit(afig.bbox)
                                    self.fig.canvas.flush_events()
                            elif self.ETcurve and abs(self.temp1[i] - ydata) < 10:
                                orange_hit = True
                                if not self._designer_orange_mark_shown and self._designer_orange_mark is not None:
                                    self._designer_orange_mark_shown = True
                                    self._designer_orange_mark.set_data([self.timex[i]],[self.temp1[i]])
                                    self.ax.draw_artist(self._designer_orange_mark)
                                    afig = self.ax.get_figure()
                                    if afig is not None:
                                        self.fig.canvas.blit(afig.bbox)
                                    self.fig.canvas.flush_events()
                            index = self.timeindex.index(i)
                            if index == 0:
                                timez = stringfromseconds(0)
                                self.aw.sendmessage(QApplication.translate('Message', '[ CHARGE ]') + ' ' + timez, style="background-color:'#f07800';",append=False)
                            elif index == 1:
                                timez = stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ DRY END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 2:
                                timez = stringfromseconds(self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ FC START ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 3:
                                timez = stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ FC END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 4:
                                timez = stringfromseconds(self.timex[self.timeindex[4]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ SC START ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 5:
                                timez = stringfromseconds(self.timex[self.timeindex[5]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ SC END ]') + ' ' + timez, style="background-color:'orange';",append=False)
                            elif index == 6:
                                timez = stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ DROP ]') + ' ' + timez, style="background-color:'#f07800';",append=False)
                            elif index == 7:
                                timez = stringfromseconds(self.timex[self.timeindex[7]] - self.timex[self.timeindex[0]])
                                self.aw.sendmessage(QApplication.translate('Message', '[ COOL ]') + ' ' + timez, style="background-color:'#6FB5D1';",append=False)
                            break
                        axfig = self.ax.get_figure()
                        if self.BTcurve and abs(self.temp2[i] - ydata) < 10:
                            blue_hit = True
                            if not self._designer_blue_mark_shown and self._designer_blue_mark is not None:
                                self._designer_blue_mark_shown = True
                                self._designer_blue_mark.set_data([self.timex[i]],[self.temp2[i]])
                                self.ax.draw_artist(self._designer_blue_mark)

                                if axfig is not None:
                                    self.fig.canvas.blit(axfig.bbox)
                                self.fig.canvas.flush_events()
                        elif self.ETcurve and abs(self.temp1[i] - ydata) < 10:
                            blue_hit = True
                            if not self._designer_blue_mark_shown and self._designer_blue_mark is not None:
                                self._designer_blue_mark_shown = True
                                self._designer_blue_mark.set_data([self.timex[i]],[self.temp1[i]])
                                self.ax.draw_artist(self._designer_blue_mark)
                                if axfig is not None:
                                    self.fig.canvas.blit(axfig.bbox)
                                self.fig.canvas.flush_events()
                        timez = stringfromseconds(self.timex[i] - self.timex[self.timeindex[0]])
                        self.aw.sendmessage(timez,style="background-color:'lightblue';",append=False)
                        break
                draw_idle = False
                if not orange_hit and self._designer_orange_mark_shown and self._designer_orange_mark is not None:
                    # clear mark
                    self._designer_orange_mark_shown = False
                    self._designer_orange_mark.set_data([], [])
                    draw_idle = True
                if not blue_hit and self._designer_blue_mark_shown and self._designer_blue_mark is not None:
                    # clear mark
                    self._designer_blue_mark_shown = False
                    self._designer_blue_mark.set_data([], [])
                    draw_idle = True
                if draw_idle:
                    self.redrawdesigner(force=True)

                if orange_hit or blue_hit:
                    self.setCursor(Qt.CursorShape.OpenHandCursor)
                else:
                    self.setCursor(Qt.CursorShape.PointingHandCursor) # Qt.CursorShape.PointingHandCursor or Qt.CursorShape.ArrowCursor
                    self.phases_to_messageline()


        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' on_motion() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            self.unrarefy_designer()
            return

    def findTPdes(self) -> Tuple[Optional[float],Optional[float]]:
        try:
            from scipy.interpolate import UnivariateSpline
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            timez = numpy.arange(self.timex[0],self.timex[-1]+1,1).tolist()
            btvals = funcBT(timez).tolist()
            min_bt = min(btvals)
            idx_min_bt = btvals.index(min_bt)
            time_min_bt = timez[idx_min_bt]
            return min_bt, time_min_bt

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' findTPdes() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return None, None

    #this is used in on_motion() to try to prevent points crossing over points
    def unrarefy_designer(self) -> None:
        for i in range(len(self.timex)-1):
            if abs(self.timex[i]-self.timex[i+1]) < 20:
                self.timex[i+1] = self.timex[i] + 20
            self.disconnect_designer()
            self.connect_designer()

    @pyqtSlot()
    @pyqtSlot(bool)
    def addpoint_action(self, _:bool = False) -> None:
        self.addpoint()

    def addpoint(self, manual:bool = True) -> Optional[int]:
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            if manual:
                # open a dialog to let the user correct the input
                offset:float = 0.
                if self.timeindex[0] > -1:
                    offset = self.timex[self.timeindex[0]]
                values = [self.currentx-offset, self.currenty]
                from artisanlib.designer import pointDlg
                dlg = pointDlg(parent=self.aw, aw=self.aw, values=values)
                if dlg.exec():
                    self.currentx = values[0] + offset
                    self.currenty = values[1]
                else:
                    return None


            if self.currentx > self.timex[-1]:       #if point is beyond max timex (all the way to the right)

                #find closest line
                d1 = abs(self.temp1[-1] - self.currenty)
                d2 = abs(self.temp2[-1] - self.currenty)
                if d2 < d1:
                    self.temp2.append(self.currenty)
                    self.temp1.append(self.temp1[-1])
                else:
                    self.temp2.append(self.temp2[-1])
                    self.temp1.append(self.currenty)

                self.timex.append(self.currentx)
                #no need to update time index

                self.redrawdesigner(force=True)
                return 0

            if self.currentx < self.timex[0]:         #if point is below min timex (all the way to the left)
                #find closest line
                d1 = abs(self.temp1[0] - self.currenty)
                d2 = abs(self.temp2[0] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(0,self.currenty)
                    self.temp1.insert(0,self.temp1[0])
                else:
                    self.temp2.insert(0,self.temp2[0])
                    self.temp1.insert(0,self.currenty)

                self.timex.insert(0,self.currentx)

                #update timeindex
                if self.timeindex[0] != -1:   #we update timeindex[0] different
                    self.timeindex[0] += 1
                for u in range(1,len(self.timeindex)):
                    if self.timeindex[u]:
                        self.timeindex[u] += 1

                self.redrawdesigner(force=True)
                return len(self.timex)-1   #return index received from Designer Dialog Config to assign index to timeindex)

            #mid range
            #find index
            i = next((x for x, val in enumerate(self.timex) if val > self.currentx), None) # returns None if no index exists with "self.timex[i] > self.currentx"

            if i is None:
                return None

            #find closest line
            d1 = abs(self.temp1[i] - self.currenty)
            d2 = abs(self.temp2[i] - self.currenty)
            if (d2 < d1 or self.temp1[i] == -1) and self.temp2[i] != -1:
                self.temp2.insert(i,self.currenty)
                self.temp1.insert(i,self.temp1[i])
            elif self.temp1[i] != -1:
                self.temp2.insert(i,self.temp2[i])
                self.temp1.insert(i,self.currenty)
            if not (self.temp1[i] == -1 and self.temp2[i] == -1):
                self.timex.insert(i,self.currentx)

                #update timeindex
                for x,_ in enumerate(self.timeindex):
                    if self.timeindex[x] >= i:
                        self.timeindex[x] += 1

            self.redrawdesigner(force=True)
            return i

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' addpoint() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return None

    #removes point
    @pyqtSlot()
    @pyqtSlot(bool)
    def removepoint(self, _:bool = False) -> None:
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            #find index

            i = next((x for x, val in enumerate(self.timex) if val > self.currentx), None) # returns None if no index exists with "self.timex[i] > self.currentx"

            if i is None:
                return

            #find closest point
            if abs(self.timex[i]- self.currentx) < abs(self.timex[i-1] - self.currentx):
                index = i
            else:
                index = i-1

            #check if if it is a landmark point
            if index in self.timeindex:
                whichone = self.timeindex.index(index)
                if whichone in {0, 6}:  #if charge or drop
                    return
                self.timeindex[whichone] = 0

            self.timex.pop(index)
            self.temp1.pop(index)
            self.temp2.pop(index)

            for x,__ in enumerate(self.timeindex):
                if self.timeindex[x] > index: #decrease time index by one when above the index taken out
                    self.timeindex[x] = max(0,self.timeindex[x] - 1)

            self.redrawdesigner(force=True)

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _x, _s, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' removepoint() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))

    def clear_designer(self) -> None:
        # removes all generated artists and cleans the bitblit cache
        self.ax_background_designer = None
        self.ax_lines_clear()
        # clear references
        self._designer_orange_mark = None
        self._designer_orange_mark_shown = False
        self._designer_blue_mark = None
        self._designer_blue_mark_shown = False
        self.l_temp1_markers = None
        self.l_temp2_markers = None
        self.l_stat1 = None
        self.l_stat2 = None
        self.l_stat3 = None
        self.l_div1 = None
        self.l_div2 = None
        self.l_div3 = None
        self.l_div4 = None


    #converts from a designer profile to a normal profile
    def convert_designer(self) -> None:
        try:
            self.disconnect_designer()

            from scipy.interpolate import UnivariateSpline
            #pylint: disable=E0611
            #prevents accidentally deleting a modified profile.
            self.fileDirtySignal.emit()
            #create functions
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            funcET = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)

            #create longer list of time values
            timez = numpy.arange(self.timex[0],self.timex[-1]+1,1).tolist()

            #convert all time values to temperature
            btvals = funcBT(timez).tolist()
            etvals = funcET(timez).tolist()

            #find new indexes for events
            for i,_ in enumerate(self.specialevents):
                for p, tp in enumerate(timez):
                    if tp > self.timex[self.specialevents[i]]:
                        self.specialevents[i] = p
                        break

            #save landmarks
            maintimes = []
            for txi in self.timeindex:
                maintimes.append(self.timex[txi])

            self.timex = timez[:]
            self.temp1 = etvals[:]
            self.temp2 = btvals[:]

            self.timeindexupdate(maintimes)

            #check and restore carried over events
            if self.eventtimecopy:
                self.clearEvents() # first clear previous special event lists
                for i, etc in enumerate(self.eventtimecopy):
                    tx_idx:int = self.time2index(etc + self.timex[self.timeindex[0]])
                    if tx_idx > -1:
                        # only if event time is between CHARGE and DROP we reconstruct the event
                        self.addEvent(tx_idx,
                            self.specialeventstypecopy[i],
                            self.specialeventsStringscopy[i],
                            self.specialeventsvaluecopy[i])
            self.etypes = self.etypescopy[:]

            #check for extra devices
            num = len(self.timex)
            for i in range(len(self.extradevices)):
                self.extratemp1[i] = [-1.]*num
                self.extratemp2[i] = [-1.]*num
                self.extratimex[i] = self.timex[:]

            if self.profile_sampling_interval is None:
                self.profile_sampling_interval = self.delay / 1000.

            #create playback events
            if self.reproducedesigner == 1:
                self.designer_create_BT_rateofchange()
            elif self.reproducedesigner == 2:
                self.designer_create_ET_rateofchange()
            elif self.reproducedesigner == 3:
                self.designer_create_sv_command()
            elif self.reproducedesigner == 4:
                self.designer_create_ramp_command()

            self.redraw()
            self.aw.sendmessage(QApplication.translate('Message', 'New profile created'))

        except ValueError:
            _, _, exc_tb = sys.exc_info()
            self.adderror(QApplication.translate('Error Message', 'Value Error:') + ' createFromDesigner()',getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' createFromDesigner() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    #activates mouse events
    def connect_designer(self) -> None:
        if not self.designerflag:
            self.designerflag = True
            self.aw.designerAction.setChecked(True)
            self.setCursor(Qt.CursorShape.PointingHandCursor)
            self.mousepress = False
            #create mouse events. Note: keeping the ids inside a list helps protect against extrange python behaviour.
            self.designerconnections = [None,None,None,None]
            self.designerconnections[0] = self.fig.canvas.mpl_connect('pick_event',  cast('Callable[[Event],None]', self.on_pick))
            self.designerconnections[1] = self.fig.canvas.mpl_connect('button_release_event', self.on_release)
            self.designerconnections[2] = self.fig.canvas.mpl_connect('motion_notify_event', cast('Callable[[Event],None]', self.on_motion))
            self.designerconnections[3] = self.fig.canvas.mpl_connect('button_press_event', cast('Callable[[Event],None]',self.on_press)) #right click
            #this is needed to prevent complaints from UnivariateSpline() -used in redraw()- in extreme cases of difficulty
            warnings.simplefilter('ignore', UserWarning)

    #deactivates mouse events
    def disconnect_designer(self) -> None:
        self.designerflag = False
        self.aw.designerAction.setChecked(False)
        for dc in self.designerconnections:
            if dc is not None:
                self.fig.canvas.mpl_disconnect(dc)
        self.setCursor(Qt.CursorShape.ArrowCursor)
        warnings.simplefilter('default', UserWarning)

    #launches designer config Window
    @pyqtSlot()
    @pyqtSlot(bool)
    def desconfig(self, _:bool = False) -> None: # pylint: disable=no-self-use # used as slot
        from artisanlib.designer import designerconfigDlg
        dialog = designerconfigDlg(self.aw, self.aw)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def reset_designer(self, _:bool = False) -> None:
        #self.disconnect_designer() # done in reset() !
        self.reset()
        self.connect_designer()
        self.designerinit()

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_BT_rateofchange(self) -> None:
        self.clearEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp2[self.timeindex[i]] - self.temp2[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = QApplication.translate('Label', 'BT {0} {1}/min for {2}').format(f'{difftemp/difftime:.1f}',self.mode,stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])) # pylint: disable=consider-using-f-string
                    self.addEvent(self.timeindex[lastindexused],0,string,0)
                    lastindexused = i

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_ET_rateofchange(self) -> None:
        self.clearEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp1[self.timeindex[i]] - self.temp1[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = QApplication.translate('Label', 'ET {0} {1}/min for {2}').format(f'{difftemp/difftime:.1f}',self.mode,stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])) # pylint: disable=consider-using-f-string
                    self.addEvent(self.timeindex[lastindexused],0,string,0)
                    lastindexused = i

## Special Event API

    def clearEvents(self) -> None:
        self.specialevents = []
        self.specialeventstype = []
        self.specialeventsStrings = []
        self.specialeventsvalue = []

    def addEvent(self, event_time_idx:int, event_type:int, event_description:str, event_value:float) -> None:
        self.specialevents.append(event_time_idx)
        self.specialeventstype.append(event_type)
        self.specialeventsStrings.append(event_description)
        self.specialeventsvalue.append(event_value)

    def deleteEvent(self, event_time_idx:int) -> None:
        del self.specialevents[event_time_idx]
        del self.specialeventstype[event_time_idx]
        del self.specialeventsStrings[event_time_idx]
        del self.specialeventsvalue[event_time_idx]

    def setEvent(self, idx:int, event_time_idx:int, event_type:int, event_description:str, event_value:float) -> None:
        if -1 < idx < len(self.specialevents):
            self.specialevents[idx] = event_time_idx
            self.specialeventstype[idx] = event_type
            self.specialeventsStrings[idx] = event_description
            self.specialeventsvalue[idx] = event_value

    def popEvent(self, idx:int = -1) -> None:
        if len(self.specialevents) > (abs(idx)-1 if idx < 0 else idx):
            self.specialevents.pop(idx)
            self.specialeventstype.pop(idx)
            self.specialeventsStrings.pop(idx)
            self.specialeventsvalue.pop(idx)

    # delete the events at the given positions
    def deleteEvents(self, positions:List[int]) -> None:
        for idx in sorted(positions, reverse=True):
            self.popEvent(idx)

##

    #this is used to create a string in pid language to reproduce the profile from Designer
    #NOTE: pid runs ET (temp1)
    def designer_create_ramp_command(self) -> None:
        tempinits = []
        minutes_segments = []

        #ramp times in minutes
        minsDryPhase = str(int(abs(self.timex[self.timeindex[0]] - self.timex[self.timeindex[1]])/60))
        minsMidPhase = str(int(abs(self.timex[self.timeindex[1]] - self.timex[self.timeindex[2]])/60))
        minsFinishPhase = str(int(abs(self.timex[self.timeindex[2]] - self.timex[self.timeindex[6]])/60))

        #target temps for ET
        tempinits.append(f'{self.temp1[self.timeindex[1]]:.1f}')
        tempinits.append(f'{self.temp1[self.timeindex[2]]:.1f}')
        tempinits.append(f'{self.temp1[self.timeindex[6]]:.1f}')

        minutes_segments.append(minsDryPhase)
        minutes_segments.append(minsMidPhase)
        minutes_segments.append(minsFinishPhase)

        command = ''
        for i in range(3):
            command += 'SETRS::' + tempinits[i] + '::' + minutes_segments[i] + '::0::'
        command += 'SETRS::' + tempinits[-1] + '::0::0'

        self.clean_old_pid_commands()

        #do only one event but with all segments
        self.addEvent(0,0,command,0)

    #this is used to create a string in ET temp language to reproduce the profile from Designer
    def designer_create_sv_command(self) -> None:
        self.clean_old_pid_commands()
        for i in range(len(self.timeindex)-1):
            command = 'SETSV::{self.temp1[self.timeindex[i+1]]:.1f}'
            if i > 0 and self.timeindex[i]:
                self.addEvent(
                    self.timeindex[i],
                    0,
                    command,
                    0)

    #verifies there are no previous machine commands on events
    def clean_old_pid_commands(self) -> None:
        #check for possible preloaded machine commands
        target = 0
        if self.specialevents:
            for i in reversed(range(len(self.specialevents))):
                if '::' in self.specialeventsStrings[i]:
                    self.popEvent(i)
                    target = 1
                    break     #break or the index i can become larger than the new shorted length of specialevents
        if target:
            self.clean_old_pid_commands()

    ###################################      WHEEL GRAPH  ####################################################

    @staticmethod
    def findCenterWheelTextAngle(t:float) -> float:
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if t in {0., 360.}:
            return 270.
        #check cuadrants
        if 0. < t < 90 or t > 360:        #quadrant 1
            return 270.+t
        if 90 <= t <= 180:                #quadrant 2
            return t - 90.
        if 180 < t < 270:                 #quadrant 3
            return t + 90
        return t - 270                    #quadrant 4

    @staticmethod
    def findRadialWheelTextAngle(t:float) -> float:
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if 0 < t <= 90 or t > 270:
            return t
        return 180 + t

    def loadselectorwheel(self, path:str) -> None:
        s = 'Wheels' + '\\' + path
        direct = QDir()
        pathDir = direct.toNativeSeparators(s)
        filename = self.aw.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Open Wheel Graph'),path=pathDir,ext='*.wg')
        if filename:
            self.connectWheel()
            self.aw.loadWheel(filename)
            self.drawWheel()

    @pyqtSlot()
    @pyqtSlot(bool)
    def addTocuppingnotes(self, _:bool = False) -> None:
        descriptor = str(self.wheelnames[self.wheelx][self.wheelz])
        if self.cuppingnotes == '':
            self.cuppingnotes = descriptor
        else:
            self.cuppingnotes += '\n' + descriptor
        s = QApplication.translate('Message', ' added to cupping notes')
        self.aw.sendmessage(descriptor + s)

    @pyqtSlot()
    @pyqtSlot(bool)
    def addToroastingnotes(self, _:bool = False) -> None:
        descriptor =  str(self.wheelnames[self.wheelx][self.wheelz]) + ' '
        if self.roastingnotes == '':
            self.roastingnotes = descriptor
        else:
            self.roastingnotes +=  '\n' + descriptor
        string = QApplication.translate('Message', ' added to roasting notes')
        self.aw.sendmessage(descriptor + string)

    def wheel_pick(self, event:'PickEvent') -> None:
        rect =  event.artist
        url = rect.get_url()
        if url is not None:
            loc = url.split('-')
            x = int(loc[0])
            z = int(loc[1])
            self.aw.sendmessage(self.wheelnames[x][z])
            self.wheelx = x
            self.wheelz = z

    def wheel_release(self, event:'MouseEvent') -> None:
        newlocz = event.xdata
        if newlocz and newlocz != self.wheellocationz:
            diff = math.degrees(self.wheellocationx - newlocz)
            for i,_ in enumerate(self.startangle):
                self.startangle[i] -= diff
            self.drawWheel()

    def wheel_menu(self, event:'MouseEvent') -> None:
        if str(event.inaxes) != str(self.ax2):
            return
        if event.button == 1:
            xdata = event.xdata
            ydata = event.ydata
            if xdata is not None and ydata is not None:
                self.wheellocationx = xdata
                self.wheellocationz = ydata

        elif event.button == 3:
            designermenu = QMenu(self.aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
            cuppingAction = QAction(QApplication.translate('Contextual Menu', 'Add to Cupping Notes'),self)
            cuppingAction.triggered.connect(self.addTocuppingnotes)
            designermenu.addAction(cuppingAction)

            roastingAction = QAction(QApplication.translate('Contextual Menu', 'Add to Roasting Notes'),self)
            roastingAction.triggered.connect(self.addToroastingnotes)
            designermenu.addAction(roastingAction)

            designermenu.addSeparator()

            editAction = QAction(QApplication.translate('Contextual Menu', 'Edit'),self)
            editAction.triggered.connect(self.editmode)
            designermenu.addAction(editAction)

            designermenu.exec(QCursor.pos())

    @pyqtSlot()
    @pyqtSlot(bool)
    def editmode(self, _:bool = False) -> None:
        self.disconnectWheel()
        if self.aw.wheeldialog is not None:
            self.aw.wheeldialog.show()

    def exitviewmode(self) -> None:
        self.disconnectWheel()
        if self.ax2 is not None:
            try:
                self.fig.delaxes(self.ax2)
            except Exception: # pylint: disable=broad-except
                pass
        self.redraw(recomputeAllDeltas=False,forceRenewAxis=True)

    def connectWheel(self) -> None:
        self.wheelflag = True
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.wheelconnections[0] = self.fig.canvas.mpl_connect('pick_event', cast('Callable[[Event],None]', self.wheel_pick))
        self.wheelconnections[1] = self.fig.canvas.mpl_connect('button_press_event', cast('Callable[[Event],None]', self.wheel_menu))           #right click menu context
        self.wheelconnections[2] = self.fig.canvas.mpl_connect('button_release_event', cast('Callable[[Event],None]', self.wheel_release))

    def disconnectWheel(self) -> None:
        self.wheelflag = False
        self.setCursor(Qt.CursorShape.ArrowCursor)
        self.fig.canvas.mpl_disconnect(self.wheelconnections[0])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[1])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[2])

    def drawWheel(self) -> None:
        try:
            ### var constants  #####
            pi = numpy.pi
            threesixty = 2.*pi
            div = threesixty/100.
            rad = 360./threesixty
            ########################
            # same as redraw but using different axes
            self.fig.clf()
            #create a new name ax1 instead of ax
            if self.ax2 is not None:
                try:
                    self.fig.delaxes(self.ax2)
                except Exception: # pylint: disable=broad-except
                    pass
            self.ax2 = self.fig.add_subplot(111, projection='polar',facecolor='None')


            if self.ax2 is not None:

                # fixing yticks with matplotlib.ticker "FixedLocator"
                try:
                    ticks_loc = [float(tick) for tick in self.ax2.get_yticks()]
                    self.ax2.yaxis.set_major_locator(ticker.FixedLocator(ticks_loc))
                except Exception: # pylint: disable=broad-except
                    pass

                if isinstance(self.ax2, PolarAxes):
                    self.ax2.set_rmax(1.)
                self.ax2.set_aspect(self.wheelaspect)
                self.ax2.grid(False)

                #delete degrees ticks
                for tick in self.ax2.xaxis.get_major_ticks():
                    #tick.label1On = False
                    tick.label1.set_visible(False)
                #delete yaxis
                locs = self.ax2.get_yticks()
                labels = ['']*len(locs)
                self.ax2.set_yticklabels(labels)

                names = self.wheelnames[:]
                Wradii = self.wradii[:]
                startangle = self.startangle[:]
                projection = self.projection[:]

                #calculate text orientation
                wheels = len(names)

                if not wheels:
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.fig.canvas.draw()
                    return

                n,textangles,textloc = [],[],[] # nr of names, text angles, text locations
                for i in range(wheels):
                    l:List[float] = []
                    tloc:List[float] = []
                    countf:float = self.startangle[i]
                    #calculate text orientation
                    for p in range(len(names[i])):
                        if projection[i] == 0:
                            l.append(0)
                        elif projection[i] == 1:
                            l.append(self.findCenterWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + countf))
                        elif projection[i] == 2:
                            l.append(self.findRadialWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + countf))
                        tloc.append((3.6*self.segmentlengths[i][p]/2. + countf)/rad)
                        countf += self.segmentlengths[i][p]*3.6

                    textloc.append(tloc)
                    textangles.append(l)
                    Wradii[i] = float(Wradii[i])/100.                   #convert radii to float between 0-1 range
                    startangle[i] = startangle[i]/rad                   #convert angles to radians
                    n.append(len(names[i]))                             #store the number of names for each wheel

                #store the absolute len-radius origin of each circle
                lbottom = [0.]
                countf = 0.
                for i in range(wheels-1):
                    countf += Wradii[i]
                    lbottom.append(countf)

                Wradiitext = [Wradii[0]/2.]
                for i in range(wheels-1):
                    Wradiitext.append(lbottom[i+1] + Wradii[i+1]/2.)     #store absolute len-radius for text in each circle
                    Wradii[i] += self.wheeledge                          #create extra color edge between wheels by overlapping wheels
                #Generate Wheel graph
                barwheel = []                                                 #holds bar-graphs (wheels)

                for z, nz in enumerate(n):
                    #create wheel
                    theta,segmentwidth,radii = [],[],[]
                    fcount = startangle[z]
                    for i in range(nz):
                        #negative number affect eventpicker
                        if fcount > threesixty:
                            fcount %= threesixty
                        elif fcount < 0.:
                            fcount += threesixty
                        theta.append(fcount + div*self.segmentlengths[z][i] / 2.)
                        fcount += div*self.segmentlengths[z][i]
                        segmentwidth.append(div*self.segmentlengths[z][i])
                        radii.append(Wradii[z])

                    barwheel.append(self.ax2.bar(theta, radii, width=segmentwidth, bottom=lbottom[z],edgecolor=self.wheellinecolor,
                                            linewidth=self.wheellinewidth,picker=3))
                    #set color, alpha, and text
                    for count, (_, barwheel[z]) in enumerate(zip(radii, barwheel[z])): # noqa: B020 # type:ignore # pyright: error: "object*" is not iterable
                        barwheel_z = barwheel[z]
                        if isinstance(barwheel_z, Rectangle):
                            barwheel_z.set_facecolor(self.wheelcolor[z][count])
                            barwheel_z.set_alpha(max(min(self.segmentsalpha[z][count],1),0))
                            barwheel_z.set_url(str(z) + '-' + str(count))
                        fontprop = self.aw.mpl_fontproperties.copy()
                        fontprop.set_size(self.wheeltextsize[z])
                        anno = self.ax2.annotate(names[z][count],xy=(textloc[z][count],Wradiitext[z]),xytext=(textloc[z][count],Wradiitext[z]),
                            rotation=textangles[z][count],
                            horizontalalignment='center',
                            verticalalignment='center',
                            color=self.wheeltextcolor,
                            fontproperties=fontprop)
                        try:
                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                        except Exception: # pylint: disable=broad-except # mpl before v3.0 do not have this set_in_layout() function
                            pass
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Value Error:') + ' drawWheel() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.adderror((QApplication.translate('Error Message', 'Exception:') + ' drawWheel() {0}').format(str(e)),getattr(exc_tb, 'tb_lineno', '?'))
            return

    def makewheelcolorpattern(self) -> None:
        for wc in self.wheelcolor:
            wlen = len(wc)
            for i in range(wlen):
                color = QColor()
                color.setHsv(int(round((360/wlen)*i*self.wheelcolorpattern)),255,255,255)
                wc[i] = str(color.name())

    # sets parent and corrects segment lengths so that child fits inside parent (multiple children can be set to same parent)
    # input: z = index of parent in previous wheel    # wn = wheel number    # idx = index of element in wheel x
    def setwheelchild(self, z:int, wn:int, idx:int) -> None:
        #set same start angle
        self.startangle[wn] = self.startangle[wn-1]
        self.wheellabelparent[wn][idx] = z

        #adjust lengths
        for x in range(1,len(self.segmentlengths)):
            nsegments = len(self.segmentlengths[x])
            parentanglecount:float = 0
            for i in range(nsegments):
                if self.wheellabelparent[x][i]:                                                   #if parent selected (otherwise 0)
                    parentindex = self.wheellabelparent[x][i]                                     #parent index
                    if self.wheellabelparent[x][i] == parentindex:                                #if match
                        parentangle = self.segmentlengths[x-1][self.wheellabelparent[x][i]-1]     #find parent angle (in %)
                        #find number of labels with same parent
                        count = self.wheellabelparent[x].count(parentindex)                       #count number of labels with same parent
                        self.segmentlengths[x][i] = parentangle/count                             #divide parent angle between children

                        #calculate last total angle
                        if i < nsegments-1:
                            parentanglecount += self.segmentlengths[x][i]

                        #adjust rest of angles to get 100 % coverage
                        for a in range(i+1,nsegments):
                            self.segmentlengths[x][a] = (100-parentanglecount)/(nsegments-(i+1))

#############################     MOUSE CROSS     #############################

    def togglecrosslines(self) -> None:
        if not self.crossmarker and not self.designerflag and not self.flagstart:  #if not projection flag
            #turn ON
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None
            self.updateBackground() # update bitlblit backgrounds
            self.crossmarker = True
            message = QApplication.translate('Message', 'Mouse Cross ON: move mouse around')
            self.aw.sendmessage(message)
            self.crossmouseid = self.fig.canvas.mpl_connect('motion_notify_event', cast('Callable[[Event],None]', self.drawcross))
            self.onreleaseid = self.fig.canvas.mpl_connect('button_release_event', self.onrelease)  #mouse cross lines measurement
        else:
            #turn OFF
            i:int
            self.crossmarker = False
            if self.crossmouseid is not None:
                try:
                    self.fig.canvas.mpl_disconnect(self.crossmouseid)
                except Exception: # pylint: disable=broad-except
                    pass
            if self.onreleaseid is not None:
                try:
                    self.fig.canvas.mpl_disconnect(self.onreleaseid)  #mouse cross lines measurement
                except Exception: # pylint: disable=broad-except
                    pass
            try:
                if self.ax is not None:
                    i = self.ax.lines.index(self.base_horizontalcrossline)
                    self.ax.lines[i].remove()
#                    self.ax.lines.remove(self.l_horizontalcrossline)
            except Exception: # pylint: disable=broad-except
                pass
            self.l_horizontalcrossline = None
            try:
                if self.ax is not None:
                    i = self.ax.lines.index(self.base_verticalcrossline)
                    self.ax.lines[i].remove()
#                    self.ax.lines.remove(self.l_verticalcrossline)
            except Exception: # pylint: disable=broad-except
                pass
            self.l_verticalcrossline = None
            self.resetlines()
            message = QApplication.translate('Message', 'Mouse cross OFF')
            self.aw.sendmessage(message)
            self.updateBackground() # update bitlblit backgrounds

    def drawcross(self, event:'MouseEvent') -> None:
        # do not interleave with redraw()
        gotlock = self.profileDataSemaphore.tryAcquire(1,0)
        if not gotlock:
            _log.info('drawcross(): failed to get profileDataSemaphore lock')
        else:
            try:
                if self.ax is not None and event.inaxes == self.ax:
                    x = event.xdata
                    y = event.ydata
                    if self.delta_ax is not None and x is not None and y is not None and self.baseX and self.baseY:
                        deltaX = stringfromseconds(x - self.baseX)
                        deltaY = str(float2float(y - self.baseY,1))
                        RoR = str(float2float(60 * (y - self.baseY) / (x - self.baseX),1))
                        deltaRoR:float = (float(self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,y))[1]))[1])
                                    - float(self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,self.baseY))[1]))[1]))
                        #RoRoR is always in C/min/min
                        if self.mode == 'F':
                            deltaRoR = RoRfromFtoCstrict(deltaRoR)
                        RoRoR = str(float2float(60 * (deltaRoR)/(x - self.baseX),1))
                        message = f'delta Time= {deltaX},    delta Temp= {deltaY} {self.mode},    RoR= {RoR} {self.mode}/min,    RoRoR= {RoRoR} C/min/min'
                        self.aw.sendmessage(message)
                        self.base_messagevisible = True
                    elif self.base_messagevisible:
                        self.aw.clearMessageLine()
                        self.base_messagevisible = False
                    if x is not None and y is not None:
                        if self.l_horizontalcrossline is None:
                            self.l_horizontalcrossline = self.ax.axhline(y,color = self.palette['text'], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_horizontalcrossline.set_ydata([y])
                        if self.l_verticalcrossline is None:
                            self.l_verticalcrossline = self.ax.axvline(x,color = self.palette['text'], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_verticalcrossline.set_xdata([x])
                        if self.ax_background:
                            self.fig.canvas.restore_region(self.ax_background) # type: ignore
                            self.ax.draw_artist(self.l_horizontalcrossline)
                            self.ax.draw_artist(self.l_verticalcrossline)
                            if self.base_horizontalcrossline and self.base_verticalcrossline:
                                self.ax.draw_artist(self.base_horizontalcrossline)
                                self.ax.draw_artist(self.base_verticalcrossline)
                            try:
                                #figure.canvas.get_renderer()
                                self.fig.canvas.blit(self.ax.get_tightbbox(self.fig.canvas.get_renderer())) # type: ignore
                            except Exception: # pylint: disable=broad-except
                                pass
                        else:
                            self.updateBackground()
            finally:
                if self.profileDataSemaphore.available() < 1:
                    self.profileDataSemaphore.release(1)

    def __to_ascii(self, s:str) -> str:
        utf8_string = str(s)
        for k, uml in self.umlaute_dict.items():
            utf8_string = utf8_string.replace(k, uml)
        from unidecode import unidecode
        return unidecode(utf8_string)

    # convert German Umlauts if Dijkstra font is selected
    def __dijkstra_to_ascii(self, s:str) -> str:
        if self.graphfont in {1,9,10}: # font Humor, Dijkstra, or Xkcd selected
            return self.__to_ascii(s)
        return s

    # this method may be called from outside tpgraphcanvas
    # convert German Umlauts if Dijkstra font is selected
    def dijkstra_to_ascii(self, s:str) -> str:
        return self.__dijkstra_to_ascii(s)


########################################################################################
###     Sample thread
########################################################################################

class SampleThread(QThread): # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class
    sample_processingSignal = pyqtSignal(bool,list,list,list)
    terminatingSignal = pyqtSignal()

    def __init__(self, aw:'ApplicationWindow') -> None:
        super().__init__()

        self.aw = aw

        if str(platform.system()).startswith('Windows'):
            self.accurate_delay_cutoff = 10e-3
        else:
            self.accurate_delay_cutoff = 5e-3

    def sample_main_device(self) -> Tuple[float,float,float]:
        #read time, ET (t1) and BT (t2) TEMPERATURE
        try:
            if self.aw.simulator is None:
                tx,t1,t2 = self.aw.ser.devicefunctionlist[self.aw.qmc.device]()
                if self.aw.qmc.swapETBT:
                    return tx,float(t2),float(t1)
                return tx,float(t1),float(t2)
            tx = self.aw.qmc.timeclock.elapsedMilli()
            t1,t2 = self.aw.simulator.read(tx if self.aw.qmc.flagstart else 0)
            return tx,float(t1),float(t2)
        except Exception as e: # pylint: disable=broad-except
            _log.exception(e)
            tx = self.aw.qmc.timeclock.elapsedMilli()
            return tx,-1.0,-1.0

    def sample_extra_device(self, i:int) -> Tuple[float,float,float]:
        try:
            if self.aw.simulator is None or self.aw.qmc.extradevices[i] == 22: # the PID SV/DUTY we show from the computed readings
                tx,t1,t2 = self.aw.extraser[i].devicefunctionlist[self.aw.qmc.extradevices[i]]()
            else:
                tx = self.aw.qmc.timeclock.elapsedMilli()
                t1,t2 = self.aw.simulator.readextra(i,(tx if self.aw.qmc.flagstart else 0))
            return tx,float(t1),float(t2)
        except Exception: # pylint: disable=broad-except
#            _log.exception(e)
            tx = self.aw.qmc.timeclock.elapsedMilli()
            return tx,-1.0,-1.0

    # fetch the raw samples from the main and all extra devices once per interval
    def sample(self) -> None:
        gotlock = self.aw.qmc.samplingSemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        if not gotlock:
            _log.info('sample(): failed to get samplingSemaphore lock')
        else:
            temp1_readings = []
            temp2_readings = []
            timex_readings = []
            try:
                if self.aw.qmc.device != 18 or self.aw.simulator is not None: # not NONE device
                    ##### send sampling action if any interval is set to "sync" (extra_event_sampling_delay = 0)
                    try:
                        if self.aw.qmc.extra_event_sampling_delay == 0 and self.aw.qmc.extrabuttonactions[2]:
                            _log.debug('sync samplingAction()')
                            self.aw.eventactionx(self.aw.qmc.extrabuttonactions[2],self.aw.qmc.extrabuttonactionstrings[2])
                    except Exception as e: # pylint: disable=broad-except
                        _log.exception(e)

                    #### first retrieve readings from the main device
#                    timeBeforeETBT = libtime.perf_counter() # the time before sending the request to the main device
#                    #read time, ET (t1) and BT (t2) TEMPERATURE
#                    tx_org,t1,t2 = self.sample_main_device()
#                    etbt_time = libtime.perf_counter() - timeBeforeETBT
#                    tx = tx_org + (etbt_time / 2.0) # we take the average between before and after
# instead of estimating the real time of the sample, let the device implementation decide (mostly, the time the request was send should be accurate enough)
                    tx,t1,t2 = self.sample_main_device()
                    #etbt_time = libtime.perf_counter() - timeBeforeETBT
                    temp1_readings.append(t1)
                    temp2_readings.append(t2)
                    timex_readings.append(tx)

                    ##############  if using Extra devices
                    for i in range(len(self.aw.qmc.extradevices)):
                        extratx, extrat2, extrat1 = self.sample_extra_device(i)
                        temp1_readings.append(extrat1)
                        temp2_readings.append(extrat2)
                        timex_readings.append(extratx)
#                    total_time = libtime.perf_counter() - timeBeforeETBT

#                    _log.debug("sample(): ET/BT time => %.4f", etbt_time)
#                    _log.debug("sample(): total time => %.4f", total_time)
            except Exception as e: # pylint: disable=broad-except
                _log.exception(e)
            finally:
                local_flagstart = self.aw.qmc.flagstart # this need to be caught within the samplingSemaphore and forwarded to the sample_processing()
                if self.aw.qmc.samplingSemaphore.available() < 1:
                    self.aw.qmc.samplingSemaphore.release(1)
                self.sample_processingSignal.emit(local_flagstart, temp1_readings, temp2_readings, timex_readings)


    # libtime.sleep is accurate only up to 0-5ms
    # using a hyprid approach using sleep() and busy-wait based on the time.perf_counter()
    def accurate_delay(self, delay:float) -> None:
        """Function to provide accurate time delay in seconds
        """
        _ = libtime.perf_counter() + delay
        # use the standard sleep until one 5ms before the timeout (Windows <10 might need a limit of 5.5ms)
        if delay > self.accurate_delay_cutoff:
            half_delay = (delay - self.accurate_delay_cutoff) / 2.0
            libtime.sleep(half_delay)
            if not self.aw.qmc.flagon:
                return # we leave this sleep earlier as sampling was terminated
            libtime.sleep(half_delay)
        # continuous with a busy sleep
        while libtime.perf_counter() < _:
            pass # this raises CPU to 100%
#            libtime.sleep(1/100000) # this is a compromise with increased accuracy vs time.sleep() avoiding a 100% CPU load

    def run(self) -> None:
        pool = None
        try:
            self.aw.qmc.flagsamplingthreadrunning = True
            if sys.platform.startswith('darwin'):
                from Foundation import NSAutoreleasePool # type: ignore # @UnresolvedImport  # pylint: disable=import-error,no-name-in-module
                pool = NSAutoreleasePool.alloc().init()  # @UndefinedVariable # pylint: disable=maybe-no-member # noqa: F841
            self.aw.qmc.afterTP = False
            if not self.aw.qmc.flagon:
                return

            # initialize digitizer
            self.aw.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
            self.aw.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier

            interval = self.aw.qmc.delay/self.aw.qmc.timeclock.getBase()
            next_time:Optional[float] = None
            while True:
                if self.aw.qmc.flagon:
                    if next_time is None:
                        next_time = libtime.perf_counter() + interval
                    else:
                        #libtime.sleep(max(0, next_time - libtime.time())) # sleep is not very accurate
                        self.accurate_delay(max(0, next_time - libtime.perf_counter())) # more accurate, but keeps the CPU busy

                    #_log.info(datetime.datetime.now()) # use this to check for drifts

                    #collect information
                    if self.aw.sample_loop_running and self.aw.qmc.flagon:
                        try:
                            self.aw.qmc.flagsampling = True # we signal that we are sampling
                            self.sample()
                        finally:
                            self.aw.qmc.flagsampling = False # we signal that we are done with sampling
                    # else: we don't self.quit() and break to end the thread as the simulator (paused) might still be running
                else:
                    self.aw.qmc.flagsampling = False # type: ignore # mypy: Statement is unreachable  [unreachable] # we signal that we are done with sampling
                    # port is disconnected in OFFmonitor by calling disconnectProbes() => disconnectProbesFromSerialDevice()
#                    try:
#                        if self.aw.ser.SP.is_open:
#                            self.aw.ser.closeport()
##                        QApplication.processEvents()
#                    except Exception: # pylint: disable=broad-except
#                        pass
                    self.quit()
                    break  #thread ends
                if next_time is not None:
                    # skip tasks if we are behind schedule:
                    next_time += (libtime.perf_counter() - next_time) // interval * interval + interval
        finally:
            self.terminatingSignal.emit()
            self.aw.qmc.flagsampling = False # we signal that we are done with sampling
            self.aw.qmc.flagsamplingthreadrunning = False
            if sys.platform.startswith('darwin'):
                # disable undefined variable warning:
                del pool # pylint: disable=E0602


#########################################################################################################
###     Artisan thread Server
#########################################################################################################

class Athreadserver(QWidget): # pylint: disable=too-few-public-methods # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class
    terminatingSignal = pyqtSignal()

    def __init__(self, aw:'ApplicationWindow') -> None:
        super().__init__()
        self.aw = aw

    def createSampleThread(self) -> None:
        if self.aw is not None and not self.aw.qmc.flagsamplingthreadrunning: # we only start a new sampling thread if none is running yet
            sthread = SampleThread(self.aw)

            #connect graphics to GUI thread
            sthread.sample_processingSignal.connect(self.aw.qmc.sample_processing)
            sthread.terminatingSignal.connect(self.terminating)
            sthread.start(QThread.Priority.TimeCriticalPriority) # TimeCriticalPriority > HighestPriority > HighPriority > NormalPriority > LowPriority
            sthread.wait(300)    #needed in some Win OS

    @pyqtSlot()
    def terminating(self) -> None:
        self.terminatingSignal.emit()
