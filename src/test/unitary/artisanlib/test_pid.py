"""
Unit tests for artisanlib.pid module.

This module tests PID controller implementation including:
- PID initialization and configuration
- PID control loop calculations (P, I, D terms)
- Input/output smoothing and filtering
- Thread safety with semaphores
- Edge cases and boundary conditions

Tests focus on discovering potential bugs in numerical calculations,
thread safety, and control system stability.
"""

import math
from typing import List
from unittest.mock import MagicMock, patch

import pytest

from artisanlib.pid import PID


class TestPIDInitialization:
    """Test PID controller initialization and basic properties."""

    def test_init_default_parameters(self) -> None:
        """Test PID initialization with default parameters."""
        pid = PID()

        assert pid.Kp == 2.0
        assert pid.Ki == 0.03
        assert pid.Kd == 0.0
        assert pid.outMin == 0
        assert pid.outMax == 100
        assert pid.dutySteps == 1
        assert pid.dutyMin == 0
        assert pid.dutyMax == 100
        assert pid.target == 0.0
        assert pid.active is False

    def test_init_custom_parameters(self) -> None:
        """Test PID initialization with custom parameters."""
        control_func = MagicMock()
        pid = PID(control=control_func, p=5.0, i=0.1, d=2.0)

        assert pid.control == control_func
        assert pid.Kp == 5.0
        assert pid.Ki == 0.1
        assert pid.Kd == 2.0

    def test_init_internal_state(self) -> None:
        """Test that internal state is properly initialized."""
        pid = PID()

        assert pid.Pterm == 0.0
        assert pid.errSum == 0.0
        assert pid.Iterm == 0.0
        assert pid.lastError is None
        assert pid.lastInput is None
        assert pid.lastOutput is None
        assert pid.lastTime is None
        assert pid.lastDerr == 0.0
        assert not pid.derivative_on_error

    def test_init_smoothing_parameters(self) -> None:
        """Test that smoothing parameters are properly initialized."""
        pid = PID()

        assert pid.output_smoothing_factor == 0
        assert pid.output_decay_weights is None
        assert pid.previous_outputs == []
        assert pid.input_smoothing_factor == 0
        assert pid.input_decay_weights is None
        assert pid.previous_inputs == []
        assert pid.force_duty == 3
        assert pid.iterations_since_duty == 0

    def test_init_derivative_filter(self) -> None:
        """Test that derivative filter is properly initialized."""
        pid = PID()

        assert pid.derivative_filter_level == 0
        assert pid.derivative_filter is not None
        # Should be a LiveSosFilter instance
        assert hasattr(pid.derivative_filter, 'process')

    def test_init_semaphore(self) -> None:
        """Test that semaphore is properly initialized."""
        pid = PID()

        assert pid.pidSemaphore is not None
        assert pid.pidSemaphore.available() == 1


class TestPIDActivationControl:
    """Test PID activation and deactivation functionality."""

    def test_on_activates_pid(self) -> None:
        """Test that on() activates the PID controller."""
        pid = PID()
        assert pid.active is False

        pid.on()
        assert pid.active is True

    def test_off_deactivates_pid(self) -> None:
        """Test that off() deactivates the PID controller."""
        pid = PID()
        pid.on()
        assert pid.active is True

        pid.off()
        assert pid.active is False

    def test_isActive_returns_correct_state(self) -> None:
        """Test that isActive() returns correct activation state."""
        pid = PID()

        assert pid.isActive() is False

        pid.on()
        assert pid.isActive() is True

        pid.off()
        assert pid.isActive() is False

    def test_on_resets_lastOutput(self) -> None:
        """Test that on() resets lastOutput to ensure control output."""
        pid = PID()
        pid.lastOutput = 50.0

        pid.on()
        assert pid.lastOutput is None

    def test_isActive_handles_exceptions(self) -> None:
        """Test that isActive() handles exceptions gracefully."""
        pid = PID()

        # Mock semaphore to raise exception
        with patch.object(pid.pidSemaphore, 'acquire', side_effect=Exception('Test exception')):
            result = pid.isActive()
            assert result is False


class TestPIDParameterSetters:
    """Test PID parameter setter methods."""

    def test_setPID_updates_parameters(self) -> None:
        """Test that setPID updates PID parameters correctly."""
        pid = PID()

        pid.setPID(10.0, 0.5, 3.0)

        assert pid.Kp == 10.0
        assert pid.Ki == 0.5
        assert pid.Kd == 3.0

    def test_setPID_enforces_non_negative_values(self) -> None:
        """Test that setPID enforces non-negative parameter values."""
        pid = PID()

        pid.setPID(-5.0, -0.1, -2.0)

        assert pid.Kp == 0.0
        assert pid.Ki == 0.0
        assert pid.Kd == 0.0

    def test_setTarget_updates_target(self) -> None:
        """Test that setTarget updates the target value."""
        pid = PID()

        pid.setTarget(100.0)
        assert pid.target == 100.0

    def test_getTarget_returns_target(self) -> None:
        """Test that getTarget returns the current target."""
        pid = PID()
        pid.target = 75.0

        assert pid.getTarget() == 75.0

    def test_getTarget_handles_exceptions(self) -> None:
        """Test that getTarget handles exceptions gracefully."""
        pid = PID()

        with patch.object(pid.pidSemaphore, 'acquire', side_effect=Exception('Test exception')):
            result = pid.getTarget()
            assert result == 0.0

    def test_setLimits_updates_output_limits(self) -> None:
        """Test that setLimits updates output limits."""
        pid = PID()

        pid.setLimits(-50, 150)

        assert pid.outMin == -50
        assert pid.outMax == 150

    def test_setDutySteps_updates_duty_steps(self) -> None:
        """Test that setDutySteps updates duty steps."""
        pid = PID()

        pid.setDutySteps(5)
        assert pid.dutySteps == 5

    def test_setDutyMin_updates_duty_min(self) -> None:
        """Test that setDutyMin updates minimum duty."""
        pid = PID()

        pid.setDutyMin(10)
        assert pid.dutyMin == 10

    def test_setDutyMax_updates_duty_max(self) -> None:
        """Test that setDutyMax updates maximum duty."""
        pid = PID()

        pid.setDutyMax(90)
        assert pid.dutyMax == 90

    def test_setControl_updates_control_function(self) -> None:
        """Test that setControl updates the control function."""
        pid = PID()
        new_control = MagicMock()

        pid.setControl(new_control)
        assert pid.control == new_control

    def test_setDerivativeFilterLevel_updates_filter_level(self) -> None:
        """Test that setDerivativeFilterLevel updates filter level."""
        pid = PID()

        pid.setDerivativeFilterLevel(2)
        assert pid.derivative_filter_level == 2

    def test_setDerivativeLimit_updates_derivative_limit(self) -> None:
        """Test that setDerivativeLimit updates derivative limit."""
        pid = PID()

        pid.setDerivativeLimit(50)
        assert pid.derivative_limit == 50

    def test_setIntegralWindupPrevention_updates_integral_windup_prevention(self) -> None:
        """Test that setIntegralWindupPrevention updates integral windup prevention."""
        pid = PID()

        pid.setIntegralWindupPrevention(False)
        assert not pid.integral_windup_prevention

        pid.setIntegralWindupPrevention(True)
        assert pid.integral_windup_prevention

    def test_setDerivativeOnError_updates_derivative_on_error(self) -> None:
        """Test that setDerivativeOnError updates derivative on error."""
        pid = PID()

        pid.setDerivativeOnError(False)
        assert not pid.derivative_on_error

        pid.setDerivativeOnError(True)
        assert pid.derivative_on_error

    def test_setIntegralResetOnSP_updates_integral_reset_on_setpoint_change(self) -> None:
        """Test that setIntegralResetOnSP updates integral reset on setpoint change."""
        pid = PID()

        pid.setIntegralResetOnSP(False)
        assert not pid.integral_reset_on_setpoint_change

        pid.setIntegralResetOnSP(True)
        assert pid.integral_reset_on_setpoint_change

    def test_setIntegralLimitFactor_updates_integral_limit_factor(self) -> None:
        """Test that setIntegralLimitFactor updates integral limit factor."""
        pid = PID()

        pid.setIntegralLimitFactor(0.3)
        assert pid.integral_limit_factor == 0.3

    def test_setSetpointChangeThreshold_updates_setpoint_change_threshold(self) -> None:
        """Test that setSetpointChangeThreshold updates integral limit factor."""
        pid = PID()

        pid.setSetpointChangeThreshold(55)
        assert pid.setpoint_change_threshold == 55


class TestPIDSmoothingFunctions:
    """Test PID input and output smoothing functionality."""

    def test_smooth_output_no_smoothing(self) -> None:
        """Test output smoothing when smoothing factor is 0."""
        pid = PID()
        pid.output_smoothing_factor = 0

        result = pid._smooth_output(10.0)
        assert result == 10.0

    def test_smooth_output_with_smoothing(self) -> None:
        """Test output smoothing with smoothing factor > 0."""
        pid = PID()
        pid.output_smoothing_factor = 3

        # First value
        result1 = pid._smooth_output(10.0)
        assert result1 == 10.0

        # Second value
        result2 = pid._smooth_output(20.0)
        assert result2 == 20.0

        # Third value - now we have 3 values, so smoothing is applied
        result3 = pid._smooth_output(30.0)
        # Weighted average: (10*1 + 20*2 + 30*3) / (1+2+3) = 140/6 â‰ˆ 23.33
        assert result3 == pytest.approx(23.333333333333332, abs=1e-10)

        # Fourth value - sliding window
        result4 = pid._smooth_output(40.0)
        # Weighted average: (20*1 + 30*2 + 40*3) / (1+2+3) = 200/6 â‰ˆ 33.33
        assert result4 == pytest.approx(33.333333333333336, abs=1e-10)

    def test_smooth_input_no_smoothing(self) -> None:
        """Test input smoothing when smoothing factor is 0."""
        pid = PID()
        pid.input_smoothing_factor = 0

        result = pid._smooth_input(15.0)
        assert result == 15.0

    def test_smooth_input_with_smoothing(self) -> None:
        """Test input smoothing with smoothing factor > 0."""
        pid = PID()
        pid.input_smoothing_factor = 2

        result1 = pid._smooth_input(10.0)
        assert result1 == 10.0

        result2 = pid._smooth_input(20.0)
        # Weighted average: (10*1 + 20*2) / (1+2) = 50/3 â‰ˆ 16.67
        assert result2 == pytest.approx(16.666666666666668, abs=1e-10)

    def test_smooth_output_buffer_management(self) -> None:
        """Test that output smoothing buffer is properly managed."""
        pid = PID()
        pid.output_smoothing_factor = 2

        # Fill buffer beyond capacity
        pid._smooth_output(10.0)
        pid._smooth_output(20.0)
        pid._smooth_output(30.0)

        # Buffer should only contain last 2 values
        assert len(pid.previous_outputs) == 2
        assert pid.previous_outputs == [20.0, 30.0]

    def test_smooth_input_buffer_management(self) -> None:
        """Test that input smoothing buffer is properly managed."""
        pid = PID()
        pid.input_smoothing_factor = 2

        # Fill buffer beyond capacity
        pid._smooth_input(5.0)
        pid._smooth_input(15.0)
        pid._smooth_input(25.0)

        # Buffer should only contain last 2 values
        assert len(pid.previous_inputs) == 2
        assert pid.previous_inputs == [15.0, 25.0]

    def test_smoothing_weight_recalculation(self) -> None:
        """Test that smoothing weights are recalculated when factor changes."""
        pid = PID()

        # Set initial smoothing factor
        pid.output_smoothing_factor = 2
        pid._smooth_output(10.0)
        assert pid.output_decay_weights == [1.0, 2.0]

        # Change smoothing factor
        pid.output_smoothing_factor = 3
        pid._smooth_output(20.0)
        assert pid.output_decay_weights == [1.0, 2.0, 3.0]


class TestPIDControlLoop:
    """Test PID control loop calculations and behavior."""

    def test_update_rejects_invalid_input(self) -> None:
        """Test that update rejects invalid input values."""
        control_mock = MagicMock()
        pid = PID(control=control_mock)
        pid.on()

        # Test with -1 (error value)
        pid.update(-1)
        control_mock.assert_not_called()

        # Test with None
        pid.update(None)
        control_mock.assert_not_called()

    def test_update_first_call_initialization(self) -> None:
        """Test that first update call properly initializes state."""
        pid = PID()
        pid.target = 100.0

        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        assert pid.lastTime == 1000.0
        assert pid.lastError == 50.0  # target - input = 100 - 50
        assert pid.lastInput == 50.0

    def test_update_proportional_term_calculation(self) -> None:
        """Test proportional term calculation."""
        pid = PID(p=2.0)
        pid.target = 100.0

        # Initialize with first call
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Second call to calculate P term
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Error = 100 - 60 = 40, P = Kp * error = 2.0 * 40 = 80
        assert pid.Pterm == pytest.approx(80.0, abs=1e-10)

    def test_update_integral_term_calculation(self) -> None:
        """Test integral term calculation."""
        pid = PID(i=0.1)
        pid.setTarget(100.0)  # Use setTarget instead of direct assignment

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Second call
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Error = 40, dt = 1.0, I += Ki * error * dt = 0.1 * 40 * 1.0 = 4.0
        assert pid.Iterm == pytest.approx(4.0, abs=1e-10)

    def test_update_derivative_on_error_calculation(self) -> None:
        """Test derivative term calculation in derivative-on-error mode."""
        pid = PID(d=0.5)
        pid.derivative_on_error = True
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)  # error = 50

        # Second call
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)  # error = 40

        # derr = (40 - 50) / 1.0 = -10, D = Kd * derr = 0.5 * (-10) = -5
        # Note: The actual D term is calculated but we need to check the update logic
        # The derivative calculation happens inside update()

    def test_update_derivative_on_measurement_calculation(self) -> None:
        """Test derivative term calculation in derivative-on-measurement mode."""
        pid = PID(d=0.5)
        pid.derivative_on_error = False  # Default
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Second call
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # dinput = 60 - 50 = 10, dtinput = 10 / 1.0 = 10
        # D = -Kd * dtinput = -0.5 * 10 = -5

    @pytest.mark.parametrize(
        'kp,ki,kd,target,inputs,expected_trend',
        [
            (1.0, 0.0, 0.0, 100.0, [50.0, 60.0, 70.0], 'decreasing'),  # P-only
            (0.0, 0.1, 0.0, 100.0, [50.0, 50.0, 50.0], 'increasing'),  # I-only
            (1.0, 0.1, 0.1, 100.0, [50.0, 60.0, 70.0], 'positive'),  # PID
        ],
    )
    def test_update_control_behavior_patterns(
        self,
        kp: float,
        ki: float,
        kd: float,
        target: float,
        inputs: List[float],
        expected_trend: str,
    ) -> None:
        """Test PID control behavior patterns with different parameter combinations."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=kp, i=ki, d=kd)
        pid.target = target
        pid.on()

        outputs = []
        for i, inp in enumerate(inputs):
            with patch('time.time', return_value=1000.0 + i):
                pid.update(inp)
                if control_mock.call_args:
                    outputs.append(control_mock.call_args[0][0])

        if expected_trend == 'increasing' and len(outputs) > 1:
            assert outputs[-1] > outputs[0]
        elif expected_trend == 'positive' and outputs:
            assert all(out >= 0 for out in outputs)

    def test_update_output_clamping(self) -> None:
        """Test that output is properly clamped to limits."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=10.0)  # High gain
        pid.setLimits(0, 100)
        pid.target = 1000.0  # Very high target
        pid.on()

        with patch('time.time', return_value=1000.0):
            pid.update(0.0)

        with patch('time.time', return_value=1001.0):
            pid.update(0.0)

        # Output should be clamped to outMax
        if control_mock.called:
            called_value = control_mock.call_args[0][0]
            assert called_value <= 100

    def test_update_integral_windup_prevention(self) -> None:
        """Test that integral windup is prevented."""
        pid = PID(i=1.0)  # High integral gain
        pid.setLimits(0, 100)
        pid.target = 1000.0  # Very high target

        # Run many updates to accumulate integral term
        for i in range(100):
            with patch('time.time', return_value=1000.0 + i):
                pid.update(0.0)

        # Integral term should be clamped
        assert pid.Iterm <= 100.0
        assert pid.Iterm >= 0.0


class TestPIDDutyControl:
    """Test PID duty cycle control and output management."""

    def test_getDuty_returns_none_when_no_output(self) -> None:
        """Test that getDuty returns None when no output has been calculated."""
        pid = PID()

        result = pid.getDuty()
        assert result is None

    def test_getDuty_returns_clamped_output(self) -> None:
        """Test that getDuty returns output clamped to duty limits."""
        pid = PID()
        pid.setDutyMin(10)
        pid.setDutyMax(90)
        pid.lastOutput = 150.0  # Above max

        result = pid.getDuty()
        assert result == 90.0

    def test_getDuty_clamps_below_minimum(self) -> None:
        """Test that getDuty clamps output below minimum."""
        pid = PID()
        pid.setDutyMin(20)
        pid.setDutyMax(80)
        pid.lastOutput = 5.0  # Below min

        result = pid.getDuty()
        assert result == 20.0

    def test_update_duty_steps_threshold(self) -> None:
        """Test that control is only called when duty steps threshold is exceeded."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=1.0)
        pid.setDutySteps(5)  # Require 5-step change
        pid.target = 100.0
        pid.on()

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Small change (less than duty steps)
        with patch('time.time', return_value=1001.0):
            pid.update(52.0)  # Small error change

        # Control should not be called for small changes
        # (This depends on the actual PID calculation)

    def test_update_force_duty_mechanism(self) -> None:
        """Test that force_duty mechanism works correctly."""
        control_mock = MagicMock()
        pid = PID(control=control_mock)
        pid.force_duty = 2  # Force output every 2 iterations
        pid.target = 100.0
        pid.on()

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # First update after initialization
        with patch('time.time', return_value=1001.0):
            pid.update(50.0)

        # Second update - should force duty
        with patch('time.time', return_value=1002.0):
            pid.update(50.0)

        # Check that iterations_since_duty is managed correctly
        assert pid.iterations_since_duty >= 0

    def test_update_inactive_pid_no_control_call(self) -> None:
        """Test that inactive PID doesn't call control function."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=1.0)
        pid.target = 100.0
        # Don't activate PID

        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Control should not be called when PID is inactive
        control_mock.assert_not_called()

    def test_update_time_threshold(self) -> None:
        """Test that update requires minimum time difference."""
        control_mock = MagicMock()
        pid = PID(control=control_mock)
        pid.target = 100.0
        pid.on()

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with insufficient time difference (< 0.2s)
        with patch('time.time', return_value=1000.1):
            pid.update(60.0)

        # PID calculation should not proceed
        # (lastTime should still be 1000.0)


class TestPIDResetAndInitialization:
    """Test PID reset and initialization functionality."""

    def test_reset_calls_init(self) -> None:
        """Test that reset() calls init()."""
        pid = PID()

        # Set some state
        pid.Pterm = 10.0
        pid.Iterm = 20.0
        pid.lastError = 5.0

        pid.reset()

        # State should be reset
        assert pid.Pterm == 0.0
        assert pid.Iterm == 0.0
        assert pid.lastError == 0.0

    def test_init_resets_all_state(self) -> None:
        """Test that init() resets all internal state."""
        pid = PID()

        # Set various state values
        pid.errSum = 15.0
        pid.lastError = 10.0
        pid.lastInput = 25.0
        pid.lastTime = 1000.0
        pid.lastDerr = 5.0
        pid.Pterm = 30.0
        pid.Iterm = 40.0
        pid.lastOutput = 50.0
        pid.previous_inputs = [1.0, 2.0, 3.0]
        pid.previous_outputs = [4.0, 5.0, 6.0]

        pid.init()

        # All state should be reset
        assert pid.errSum == 0.0
        assert pid.lastError == 0.0
        assert pid.lastInput is None
        assert pid.lastTime is None  # type: ignore[unreachable]
        assert pid.lastDerr == 0.0
        assert pid.Pterm == 0.0
        assert pid.Iterm == 0.0
        assert pid.lastOutput is None
        assert pid.previous_inputs == []
        assert pid.previous_outputs == []
        assert pid.input_decay_weights is None
        assert pid.output_decay_weights is None

    def test_init_resets_derivative_filter(self) -> None:
        """Test that init() resets the derivative filter."""
        pid = PID()
        original_filter = pid.derivative_filter

        pid.init()

        # Filter should be reset (new instance)
        assert pid.derivative_filter is not original_filter

    def test_setTarget_with_init(self) -> None:
        """Test setTarget with initialization."""
        pid = PID()
        pid.Iterm = 50.0  # Set some state

        pid.setTarget(200.0, init=True)

        assert pid.target == 200.0
        assert pid.Iterm == 0.0  # Should be reset

    def test_setTarget_without_init(self) -> None:
        """Test setTarget without initialization."""
        pid = PID()
        pid.Iterm = 50.0  # Set some state

        pid.setTarget(200.0, init=False)

        assert pid.target == 200.0
        assert pid.Iterm == 50.0  # Should not be reset


class TestPIDEdgeCasesAndBoundaryConditions:
    """Test edge cases and boundary conditions."""

    def test_update_with_zero_time_difference(self) -> None:
        """Test update behavior with zero time difference."""
        pid = PID()
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with same time (zero dt)
        with patch('time.time', return_value=1000.0):
            pid.update(60.0)

        # Should not crash and should handle gracefully

    def test_update_with_very_small_time_difference(self) -> None:
        """Test update behavior with very small time difference."""
        pid = PID()
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with very small time difference
        with patch('time.time', return_value=1000.0001):
            pid.update(60.0)

        # Should handle small dt without numerical issues

    def test_update_with_very_large_time_difference(self) -> None:
        """Test update behavior with very large time difference."""
        pid = PID()
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with very large time difference
        with patch('time.time', return_value=2000.0):  # 1000 seconds later
            pid.update(60.0)

        # Should handle large dt without overflow

    @pytest.mark.parametrize(
        'extreme_value',
        [
            float('inf'),
            float('-inf'),
            1e10,
            -1e10,
            1e-10,
            -1e-10,
        ],
    )
    def test_update_with_extreme_input_values(self, extreme_value: float) -> None:
        """Test update behavior with extreme input values."""
        pid = PID()
        pid.target = 100.0

        with patch('time.time', return_value=1000.0):
            pid.update(50.0)  # Initialize normally

        with patch('time.time', return_value=1001.0):
            if math.isfinite(extreme_value):
                pid.update(extreme_value)
                # Should handle without crashing
            else:
                # Infinite values might cause issues
                pid.update(extreme_value)

    @pytest.mark.parametrize(
        'extreme_target',
        [
            1e10,
            -1e10,
            0.0,
            float('inf'),
            float('-inf'),
        ],
    )
    def test_update_with_extreme_target_values(self, extreme_target: float) -> None:
        """Test update behavior with extreme target values."""
        pid = PID()
        pid.target = extreme_target

        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Should handle extreme targets without crashing

    def test_update_with_nan_input(self) -> None:
        """Test update behavior with NaN input."""
        pid = PID()
        pid.target = 100.0

        # NaN should be handled gracefully (though not explicitly in current code)
        with patch('time.time', return_value=1000.0):
            pid.update(float('nan'))

    def test_setPID_with_extreme_parameters(self) -> None:
        """Test setPID with extreme parameter values."""
        pid = PID()

        # Very large parameters
        pid.setPID(1e10, 1e10, 1e10)
        assert pid.Kp == 1e10
        assert pid.Ki == 1e10
        assert pid.Kd == 1e10

        # Very small parameters
        pid.setPID(1e-10, 1e-10, 1e-10)
        assert pid.Kp == 1e-10
        assert pid.Ki == 1e-10
        assert pid.Kd == 1e-10

    def test_setLimits_with_inverted_limits(self) -> None:
        """Test setLimits with inverted min/max values."""
        pid = PID()

        # Set inverted limits (max < min)
        pid.setLimits(100, 0)

        assert pid.outMin == 100
        assert pid.outMax == 0

        # This might cause issues in clamping logic

    def test_setLimits_with_equal_limits(self) -> None:
        """Test setLimits with equal min and max values."""
        pid = PID()

        pid.setLimits(50, 50)

        assert pid.outMin == 50
        assert pid.outMax == 50

    def test_derivative_filter_level_changes(self) -> None:
        """Test changing derivative filter level."""
        pid = PID()
        original_filter = pid.derivative_filter

        pid.setDerivativeFilterLevel(5)

        assert pid.derivative_filter_level == 5
        # Filter should be reset
        assert pid.derivative_filter is not original_filter

    def test_smoothing_factor_edge_cases(self) -> None:
        """Test smoothing factors with edge case values."""
        pid = PID()

        # Test with smoothing factor of 1
        pid.output_smoothing_factor = 1
        result = pid._smooth_output(10.0)
        assert result == 10.0

        # Test with very large smoothing factor
        pid.output_smoothing_factor = 1000
        for i in range(10):
            pid._smooth_output(float(i))

        # Should handle large smoothing factors

    def test_concurrent_access_simulation(self) -> None:
        """Test simulation of concurrent access to PID methods."""
        pid = PID()

        # Simulate concurrent calls (though actual threading would be needed for real test)
        pid.on()
        pid.setPID(1.0, 0.1, 0.01)
        pid.setTarget(100.0)
        pid.update(50.0)
        pid.off()

        # Should handle sequential calls without issues

    def test_exception_handling_in_update(self) -> None:
        """Test exception handling in update method."""
        control_mock = MagicMock(side_effect=Exception('Control error'))
        pid = PID(control=control_mock)
        pid.target = 100.0
        pid.on()

        # Should not crash even if control function raises exception
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        with patch('time.time', return_value=1001.0):
            pid.update(60.0)


class TestPIDDerivativeFilter:
    """Test PID derivative filter functionality."""

    def test_derivativeFilter_returns_filter(self) -> None:
        """Test that derivativeFilter returns a LiveSosFilter."""
        filter_instance = PID.derivativeFilter()

        assert hasattr(filter_instance, 'process')
        # Should be able to process values
        result = filter_instance.process(1.0)
        assert isinstance(result, (int, float))

    def test_derivative_filter_integration(self) -> None:
        """Test derivative filter integration in PID loop."""
        pid = PID(d=1.0)
        pid.setDerivativeFilterLevel(1)  # Enable filtering
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with derivative component
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Should use filtered derivative

    def test_derivative_filter_disabled(self) -> None:
        """Test derivative filter when disabled."""
        pid = PID(d=1.0)
        pid.setDerivativeFilterLevel(0)  # Disable filtering
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Update with derivative component
        with patch('time.time', return_value=1001.0):
            pid.update(60.0)

        # Should use unfiltered derivative


class TestPIDNumericalStability:
    """Test PID numerical stability and precision."""

    def test_long_running_stability(self) -> None:
        """Test PID stability over many iterations."""
        pid = PID(p=1.0, i=0.1, d=0.01)
        pid.target = 100.0

        # Run many iterations
        for i in range(1000):
            with patch('time.time', return_value=1000.0 + i * 0.1):
                # Simulate noisy input around target
                noise = (i % 10 - 5) * 0.1
                pid.update(100.0 + noise)

        # PID should remain stable
        assert math.isfinite(pid.Pterm)
        assert math.isfinite(pid.Iterm)
        assert math.isfinite(pid.lastOutput or 0.0)

    def test_precision_with_small_values(self) -> None:
        """Test PID precision with very small values."""
        pid = PID(p=1e-6, i=1e-8, d=1e-10)
        pid.target = 1e-5

        with patch('time.time', return_value=1000.0):
            pid.update(1e-6)

        with patch('time.time', return_value=1001.0):
            pid.update(2e-6)

        # Should handle small values without underflow
        assert pid.Pterm != 0.0 or pid.target == 0.0

    def test_precision_with_large_values(self) -> None:
        """Test PID precision with very large values."""
        pid = PID(p=1e6, i=1e4, d=1e8)
        pid.target = 1e9

        with patch('time.time', return_value=1000.0):
            pid.update(1e8)

        with patch('time.time', return_value=1001.0):
            pid.update(2e8)

        # Should handle large values without overflow
        assert math.isfinite(pid.Pterm)
        assert math.isfinite(pid.Iterm)


class TestPIDDerivativeKickImprovements:
    """Test improved derivative kick prevention features."""

    def test_derivative_limit_initialization(self) -> None:
        """Test that derivative limit is properly initialized."""
        pid = PID()

        assert pid.derivative_limit == 80.0
        assert pid.lastTarget == 0.0
        assert pid.measurement_history == []
        assert pid.setpoint_changed is False

    def test_setDerivativeLimit_updates_limit(self) -> None:
        """Test that setDerivativeLimit updates the derivative limit."""
        pid = PID()

        pid.setDerivativeLimit(50.0)
        assert pid.getDerivativeLimit() == 50.0

    def test_setDerivativeLimit_enforces_non_negative(self) -> None:
        """Test that setDerivativeLimit enforces non-negative values."""
        pid = PID()

        pid.setDerivativeLimit(-10.0)
        assert pid.getDerivativeLimit() == 0.0

    def test_getDerivativeLimit_handles_exceptions(self) -> None:
        """Test that getDerivativeLimit handles exceptions gracefully."""
        pid = PID()

        with patch.object(pid.pidSemaphore, 'acquire', side_effect=Exception('Test exception')):
            result = pid.getDerivativeLimit()
            assert result == 80.0  # Default value

    def test_measurement_history_tracking(self) -> None:
        """Test that measurement history is properly tracked."""
        pid = PID()
        pid.target = 100.0

        # Simulate several measurements
        measurements = [50.0, 52.0, 54.0, 56.0, 58.0, 60.0]

        for i, measurement in enumerate(measurements):
            with patch('time.time', return_value=1000.0 + i):
                pid.update(measurement)

        # History should contain last 5 measurements
        assert len(pid.measurement_history) == 5
        assert pid.measurement_history == measurements[1:]  # Last 5

    def test_setpoint_change_detection(self) -> None:
        """Test that setpoint changes are properly detected."""
        pid = PID()

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Change setpoint
        pid.setTarget(100.0, init=False)

        # Next update should detect setpoint change
        with patch('time.time', return_value=1001.0):
            pid.update(52.0)

        assert pid.setpoint_changed is True
        assert pid.lastTarget == 100.0

    def test_setpoint_change_flag_clearing(self) -> None:
        """Test that setpoint change flag is cleared after some time."""
        pid = PID()

        # Initialize and change setpoint
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        pid.setTarget(100.0, init=False)

        # First update after setpoint change
        with patch('time.time', return_value=1001.0):
            pid.update(52.0)

        assert pid.setpoint_changed is True

        # Subsequent updates without setpoint change should clear flag
        with patch('time.time', return_value=1002.0):
            pid.update(54.0)

        assert pid.setpoint_changed is False

    def test_measurement_discontinuity_detection(self) -> None:
        """Test measurement discontinuity detection."""
        pid = PID()

        # Build up normal measurement history
        normal_measurements = [50.0, 51.0, 52.0, 53.0]
        for measurement in normal_measurements:
            pid._update_measurement_history(measurement)

        # Test normal change (should not be detected as discontinuity)
        assert not pid._detect_measurement_discontinuity(54.0)

        # Test large discontinuity (should be detected)
        assert pid._detect_measurement_discontinuity(70.0)  # Large jump

    def test_derivative_calculation_with_setpoint_change(self) -> None:
        """Test that derivative calculation is reduced after setpoint changes."""
        pid = PID(d=1.0)
        pid.setpoint_changed = True
        pid.lastInput = 0.0

        # Calculate derivative with setpoint change flag set
        derivative = pid._calculate_derivative_on_measurement(60.0, 1.0)

        # Should be reduced compared to normal calculation
        # Normal would be: -1.0 * (60.0 - 0.0) / 1.0 = -60.0
        # With setpoint change: -60.0 * 0.5 = -30.0
        assert derivative == pytest.approx(-30.0, abs=1e-10)

    def test_derivative_calculation_with_discontinuity(self) -> None:
        """Test that derivative calculation is reduced with measurement discontinuities."""
        pid = PID(d=1.0)
        pid.lastInput = 50.0

        # Set up measurement history to trigger discontinuity detection
        pid.measurement_history = [50.0, 51.0, 52.0, 53.0]

        # Large jump should trigger discontinuity reduction
        derivative = pid._calculate_derivative_on_measurement(80.0, 1.0)

        # Normal would be: -1.0 * (80.0 - 50.0) / 1.0 = -30.0
        # With discontinuity: -30.0 * 0.3 = -9.0
        assert derivative == pytest.approx(-9.0, abs=1e-10)

    def test_derivative_limiting(self) -> None:
        """Test that derivative contribution is limited."""
        pid = PID(d=1.0)
        pid.derivative_limit = 20.0
        pid.lastInput = 0.0

        # Large input change that would exceed derivative limit
        derivative = pid._calculate_derivative_on_measurement(100.0, 1.0)

        # Should be limited to derivative_limit
        assert derivative == pytest.approx(-20.0, abs=1e-10)

    def test_enhanced_derivative_on_error_limiting(self) -> None:
        """Test that derivative-on-error mode also applies limiting."""
        pid = PID(d=2.0)
        pid.derivative_on_error = True
        pid.derivative_limit = 30.0
        pid.target = 100.0

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Large error change that would exceed derivative limit
        with patch('time.time', return_value=1001.0):
            pid.update(10.0)  # Large change in error

        # The derivative term calculation happens inside update()
        # We can't directly test the D value, but we can verify the system doesn't crash
        # and that the derivative limit attribute is being used

    def test_init_resets_enhanced_attributes(self) -> None:
        """Test that init() resets enhanced derivative kick prevention attributes."""
        pid = PID()

        # Set some state
        pid.lastTarget = 50.0
        pid.measurement_history = [1.0, 2.0, 3.0]
        pid.setpoint_changed = True

        pid.init()

        # Should be reset
        assert pid.lastTarget == pid.target
        assert pid.measurement_history == []
        assert pid.setpoint_changed is False

    def test_integration_with_existing_functionality(self) -> None:
        """Test that enhanced features integrate well with existing PID functionality."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=1.0, i=0.1, d=0.5)
        pid.setDerivativeLimit(25.0)
        pid.target = 100.0
        pid.on()

        # Simulate a sequence with setpoint changes and measurements
        measurements = [20.0, 25.0, 30.0, 35.0, 40.0]

        for i, measurement in enumerate(measurements):
            if i == 2:  # Change setpoint mid-sequence
                pid.setTarget(150.0, init=False)

            with patch('time.time', return_value=1000.0 + i):
                pid.update(measurement)

        # Should have called control function
        assert control_mock.called

        # Should have proper state
        assert len(pid.measurement_history) <= 5
        assert pid.lastTarget == 150.0


class TestPIDIntegralWindupImprovements:
    """Test improved integral windup prevention features."""

    def test_integral_windup_prevention_initialization(self) -> None:
        """Test that integral windup prevention attributes are properly initialized."""
        pid = PID()

        assert pid.integral_windup_prevention is True
        assert pid.integral_limit_factor == 1.0
        assert pid.setpoint_change_threshold == 25.0
        assert pid.integral_reset_on_setpoint_change is True
        assert pid.back_calculation_factor == 0.5

    def test_setIntegralWindupPrevention_updates_setting(self) -> None:
        """Test that setIntegralWindupPrevention updates the setting."""
        pid = PID()

        pid.setIntegralWindupPrevention(False)
        assert pid.getIntegralWindupPrevention() is False

        pid.setIntegralWindupPrevention(True)
        assert pid.getIntegralWindupPrevention() is True

    def test_getIntegralWindupPrevention_handles_exceptions(self) -> None:
        """Test that getIntegralWindupPrevention handles exceptions gracefully."""
        pid = PID()

        with patch.object(pid.pidSemaphore, 'acquire', side_effect=Exception('Test exception')):
            result = pid.getIntegralWindupPrevention()
            assert result is True  # Default value

    def test_setIntegralLimitFactor_updates_factor(self) -> None:
        """Test that setIntegralLimitFactor updates the factor."""
        pid = PID()

        pid.setIntegralLimitFactor(0.6)
        assert pid.getIntegralLimitFactor() == 0.6

    def test_setIntegralLimitFactor_clamps_to_valid_range(self) -> None:
        """Test that setIntegralLimitFactor clamps values to [0.0, 1.0]."""
        pid = PID()

        pid.setIntegralLimitFactor(-0.5)
        assert pid.getIntegralLimitFactor() == 0.0

        pid.setIntegralLimitFactor(1.5)
        assert pid.getIntegralLimitFactor() == 1.0

    def test_setSetpointChangeThreshold_updates_threshold(self) -> None:
        """Test that setSetpointChangeThreshold updates the threshold."""
        pid = PID()

        pid.setSetpointChangeThreshold(10.0)
        assert pid.getSetpointChangeThreshold() == 10.0

    def test_setSetpointChangeThreshold_enforces_non_negative(self) -> None:
        """Test that setSetpointChangeThreshold enforces non-negative values."""
        pid = PID()

        pid.setSetpointChangeThreshold(-5.0)
        assert pid.getSetpointChangeThreshold() == 0.0

    def test_should_integrate_prevents_windup(self) -> None:
        """Test that _should_integrate prevents integration during saturation."""
        pid = PID()
        pid.setLimits(0, 100)

        # Should not integrate when output is saturated and error would make it worse
        assert not pid._should_integrate(10.0, 150.0)  # Positive error, output above max
        assert not pid._should_integrate(-10.0, -50.0)  # Negative error, output below min

        # Should integrate when error would help reduce saturation
        assert pid._should_integrate(-10.0, 150.0)  # Negative error, output above max
        assert pid._should_integrate(10.0, -50.0)  # Positive error, output below min

        # Should integrate when output is not saturated
        assert pid._should_integrate(10.0, 50.0)  # Normal operation

    def test_should_integrate_disabled_windup_prevention(self) -> None:
        """Test that _should_integrate always returns True when windup prevention is disabled."""
        pid = PID()
        pid.integral_windup_prevention = False

        # Should always integrate when windup prevention is disabled
        assert pid._should_integrate(10.0, 150.0)
        assert pid._should_integrate(-10.0, -50.0)

    def test_calculate_integral_limits_positive_range(self) -> None:
        """Test integral limits calculation for positive output range."""
        pid = PID()
        pid.setLimits(0, 100)
        pid.integral_limit_factor = 1.0

        integral_min, integral_max = pid._calculate_integral_limits()

        assert integral_min == 0.0
        assert integral_max == 100.0  # 100 * 1.0

    def test_calculate_integral_limits_negative_range(self) -> None:
        """Test integral limits calculation for negative output range."""
        pid = PID()
        pid.setLimits(-100, 0)
        pid.integral_limit_factor = 0.6

        integral_min, integral_max = pid._calculate_integral_limits()

        assert integral_min == -60.0  # -100 * 0.6
        assert integral_max == 0.0

    def test_calculate_integral_limits_symmetric_range(self) -> None:
        """Test integral limits calculation for symmetric output range."""
        pid = PID()
        pid.setLimits(-50, 50)
        pid.integral_limit_factor = 1.0

        integral_min, integral_max = pid._calculate_integral_limits()

        assert integral_min == -50.0  # -(100 * 1.0) / 2
        assert integral_max == 50.0  # (100 * 1.0) / 2

    def test_handle_setpoint_change_integral_large_change(self) -> None:
        """Test integral handling for large setpoint changes."""
        pid = PID()
        pid.Iterm = 50.0
        pid.setpoint_change_threshold = 10.0

        # Large setpoint change should reset integral
        pid._handle_setpoint_change_integral(15.0)
        assert pid.Iterm == 0.0

    def test_handle_setpoint_change_integral_moderate_change(self) -> None:
        """Test integral handling for moderate setpoint changes."""
        pid = PID()
        pid.Iterm = 50.0
        pid.setpoint_change_threshold = 10.0

        # Moderate setpoint change should reduce integral
        pid._handle_setpoint_change_integral(7.0)  # Between threshold/2 and threshold
        assert pid.Iterm == 25.0  # 50.0 * 0.5

    def test_handle_setpoint_change_integral_small_change(self) -> None:
        """Test integral handling for small setpoint changes."""
        pid = PID()
        pid.Iterm = 50.0
        pid.setpoint_change_threshold = 10.0

        # Small setpoint change should not affect integral
        pid._handle_setpoint_change_integral(2.0)
        assert pid.Iterm == 50.0

    def test_handle_setpoint_change_integral_disabled(self) -> None:
        """Test integral handling when setpoint change handling is disabled."""
        pid = PID()
        pid.Iterm = 50.0
        pid.integral_reset_on_setpoint_change = False

        # Should not change integral even for large setpoint changes
        pid._handle_setpoint_change_integral(20.0)
        assert pid.Iterm == 50.0

    def test_back_calculate_integral_with_clamping(self) -> None:
        """Test back-calculation when output is clamped."""
        pid = PID(i=1.0)
        pid.Iterm = 50.0
        pid.back_calculation_factor = 0.5

        # Simulate output clamping
        output_before = 120.0
        output_after = 100.0  # Clamped

        pid._back_calculate_integral(output_before, output_after)

        # Integral should be reduced: 50.0 - (120.0 - 100.0) * 0.5 = 40.0
        assert pid.Iterm == pytest.approx(40.0, abs=1e-10)

    def test_back_calculate_integral_no_clamping(self) -> None:
        """Test back-calculation when output is not clamped."""
        pid = PID(i=1.0)
        pid.Iterm = 50.0

        # No clamping occurred
        pid._back_calculate_integral(80.0, 80.0)

        # Integral should remain unchanged
        assert pid.Iterm == 50.0

    def test_back_calculate_integral_disabled(self) -> None:
        """Test back-calculation when windup prevention is disabled."""
        pid = PID(i=1.0)
        pid.Iterm = 50.0
        pid.integral_windup_prevention = False

        # Should not adjust integral even when output is clamped
        pid._back_calculate_integral(120.0, 100.0)
        assert pid.Iterm == 50.0

    def test_back_calculate_integral_zero_ki(self) -> None:
        """Test back-calculation when Ki is zero."""
        pid = PID(i=0.0)
        pid.Iterm = 50.0

        # Should not adjust integral when Ki is zero
        pid._back_calculate_integral(120.0, 100.0)
        assert pid.Iterm == 50.0

    def test_integration_with_setpoint_changes(self) -> None:
        """Test integration of improved windup prevention with setpoint changes."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=1.0, i=0.5, d=0.1)
        pid.setLimits(0, 100)
        pid.setSetpointChangeThreshold(10.0)
        pid.setTarget(50.0)  # Initialize with setTarget to set lastTarget properly
        pid.on()

        # Initialize and build up some integral term
        with patch('time.time', return_value=1000.0):
            pid.update(30.0)

        # Let integral build up
        with patch('time.time', return_value=1001.0):
            pid.update(30.0)

        # Verify integral has built up
        assert pid.Iterm > 0.0

        # Large setpoint change
        pid.setTarget(80.0, init=False)  # 30 unit change > threshold

        # Need to call update() to trigger setpoint change detection
        with patch('time.time', return_value=1002.0):
            pid.update(32.0)

        # Integral should be reset due to large setpoint change
        assert pid.Iterm == pytest.approx(0.0, abs=1e-10)

    def test_integration_with_output_saturation(self) -> None:
        """Test integration behavior during output saturation."""
        control_mock = MagicMock()
        pid = PID(control=control_mock, p=2.0, i=1.0, d=0.0)
        pid.setLimits(0, 100)
        pid.target = 200.0  # High target to cause saturation
        pid.on()

        # Initialize
        with patch('time.time', return_value=1000.0):
            pid.update(50.0)

        # Multiple updates that would normally cause windup
        for i in range(5):
            with patch('time.time', return_value=1001.0 + i):
                pid.update(50.0)  # Constant error

        # Integral should be limited and not cause excessive windup
        integral_min, integral_max = pid._calculate_integral_limits()
        assert integral_min <= pid.Iterm <= integral_max
